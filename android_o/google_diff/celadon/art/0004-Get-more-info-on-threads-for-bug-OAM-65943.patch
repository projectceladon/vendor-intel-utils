From 520b06fb45ed072dc04ee2e817a86808f0e96ddd Mon Sep 17 00:00:00 2001
From: lab_aqa <lab_aqa@intel.com>
Date: Mon, 2 Jul 2018 09:52:39 +0530
Subject: [PATCH 4/4] Get more info on threads for bug OAM-65943

Change-Id: Id8c631181f262469a5ba5accf5321f774c4af08b
Tracked-On:https://jira01.devtools.intel.com/browse/OAM-65943
Category: device enablement
Domain: AOSP.ART-Other
Origin: internal
Upstream-Candidate: no, proprietary
Signed-off-by: lab_aqa <lab_aqa@intel.com>
---
 runtime/art_method.cc                      | 11 ++++++++---
 runtime/art_method.h                       |  2 +-
 runtime/entrypoints/entrypoint_utils-inl.h |  1 +
 runtime/fault_handler.cc                   |  7 ++++++-
 runtime/stack.cc                           |  2 +-
 5 files changed, 17 insertions(+), 6 deletions(-)

diff --git a/runtime/art_method.cc b/runtime/art_method.cc
index d8984e8..3f876ea 100644
--- a/runtime/art_method.cc
+++ b/runtime/art_method.cc
@@ -601,7 +601,7 @@ const uint8_t* ArtMethod::GetQuickenedInfo(PointerSize pointer_size) {
   }
 }
 
-const OatQuickMethodHeader* ArtMethod::GetOatQuickMethodHeader(uintptr_t pc) {
+const OatQuickMethodHeader* ArtMethod::GetOatQuickMethodHeader(uintptr_t pc, bool safe) {
   // Our callers should make sure they don't pass the instrumentation exit pc,
   // as this method does not look at the side instrumentation stack.
   DCHECK_NE(pc, reinterpret_cast<uintptr_t>(GetQuickInstrumentationExitPc()));
@@ -681,7 +681,7 @@ const OatQuickMethodHeader* ArtMethod::GetOatQuickMethodHeader(uintptr_t pc) {
   }
   const void* oat_entry_point = oat_method.GetQuickCode();
   if (oat_entry_point == nullptr || class_linker->IsQuickGenericJniStub(oat_entry_point)) {
-    DCHECK(IsNative()) << PrettyMethod();
+    DCHECK(safe || IsNative()) << PrettyMethod();
     return nullptr;
   }
 
@@ -692,7 +692,12 @@ const OatQuickMethodHeader* ArtMethod::GetOatQuickMethodHeader(uintptr_t pc) {
     return method_header;
   }
 
-  DCHECK(method_header->Contains(pc))
+  bool contains_pc = method_header->Contains(pc);
+  if (safe) {
+    return contains_pc ? method_header : nullptr;
+  }
+
+  DCHECK(contains_pc)
       << PrettyMethod()
       << " " << std::hex << pc << " " << oat_entry_point
       << " " << (uintptr_t)(method_header->GetCode() + method_header->GetCodeSize());
diff --git a/runtime/art_method.h b/runtime/art_method.h
index 0de4efd..5db557f 100644
--- a/runtime/art_method.h
+++ b/runtime/art_method.h
@@ -650,7 +650,7 @@ class ArtMethod FINAL {
 
   // Returns the method header for the compiled code containing 'pc'. Note that runtime
   // methods will return null for this method, as they are not oat based.
-  const OatQuickMethodHeader* GetOatQuickMethodHeader(uintptr_t pc)
+  const OatQuickMethodHeader* GetOatQuickMethodHeader(uintptr_t pc, bool safe = false)
       REQUIRES_SHARED(Locks::mutator_lock_);
 
   // Get compiled code for the method, return null if no code exists.
diff --git a/runtime/entrypoints/entrypoint_utils-inl.h b/runtime/entrypoints/entrypoint_utils-inl.h
index be3e4f8..499cb4e 100644
--- a/runtime/entrypoints/entrypoint_utils-inl.h
+++ b/runtime/entrypoints/entrypoint_utils-inl.h
@@ -477,6 +477,7 @@ inline ArtMethod* FindMethodFromCode(uint32_t method_idx,
       return resolved_method;
     case kVirtual: {
       ObjPtr<mirror::Class> klass = (*this_object)->GetClass();
+      DCHECK(klass);
       uint16_t vtable_index = resolved_method->GetMethodIndex();
       if (access_check &&
           (!klass->HasVTable() ||
diff --git a/runtime/fault_handler.cc b/runtime/fault_handler.cc
index fd0cd5f..e7de210 100644
--- a/runtime/fault_handler.cc
+++ b/runtime/fault_handler.cc
@@ -300,7 +300,12 @@ bool FaultManager::IsInGeneratedCode(siginfo_t* siginfo, void* context, bool che
     return false;
   }
 
-  const OatQuickMethodHeader* method_header = method_obj->GetOatQuickMethodHeader(return_pc);
+  const OatQuickMethodHeader* method_header = method_obj->GetOatQuickMethodHeader(return_pc, true);
+
+  if (method_header == nullptr) {
+    VLOG(signals) << "no oat header";
+    return false;
+  }
 
   // We can be certain that this is a method now.  Check if we have a GC map
   // at the return PC address.
diff --git a/runtime/stack.cc b/runtime/stack.cc
index 2e06536..a99a2d1 100644
--- a/runtime/stack.cc
+++ b/runtime/stack.cc
@@ -776,7 +776,7 @@ void StackVisitor::WalkStack(bool include_transitions) {
       DCHECK(current_fragment->GetTopShadowFrame() == nullptr);
       ArtMethod* method = *cur_quick_frame_;
       while (method != nullptr) {
-        cur_oat_quick_method_header_ = method->GetOatQuickMethodHeader(cur_quick_frame_pc_);
+        cur_oat_quick_method_header_ = method->GetOatQuickMethodHeader(cur_quick_frame_pc_, true);
         SanityCheckFrame();
 
         if ((walk_kind_ == StackWalkKind::kIncludeInlinedFrames)
-- 
1.9.1

