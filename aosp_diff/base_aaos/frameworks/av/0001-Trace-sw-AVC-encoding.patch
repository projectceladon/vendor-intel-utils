From 2368b38bc2b7a59dc96c3087d1b26ed187e8bb1e Mon Sep 17 00:00:00 2001
From: "Tang, Shaofeng" <shaofeng.tang@intel.com>
Date: Fri, 21 Mar 2025 16:33:34 +0000
Subject: [PATCH] Trace sw AVC encoding

Signed-off-by: Tang, Shaofeng <shaofeng.tang@intel.com>
---
 media/codec2/components/avc/C2SoftAvcEnc.cpp | 47 ++++++++++++++++++--
 1 file changed, 43 insertions(+), 4 deletions(-)

diff --git a/media/codec2/components/avc/C2SoftAvcEnc.cpp b/media/codec2/components/avc/C2SoftAvcEnc.cpp
index 80a5e67f42..d226e6efe2 100644
--- a/media/codec2/components/avc/C2SoftAvcEnc.cpp
+++ b/media/codec2/components/avc/C2SoftAvcEnc.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #define LOG_TAG "C2SoftAvcEnc"
 #include <log/log.h>
 #include <utils/misc.h>
@@ -1482,10 +1482,13 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
         uint8_t *base,
         uint32_t capacity,
         uint64_t workIndex) {
+    ALOGE("##### stang23 ##### setEncodeArgs +");
     iv_raw_buf_t *ps_inp_raw_buf;
     memset(ps_encode_ip, 0, sizeof(*ps_encode_ip));
     memset(ps_encode_op, 0, sizeof(*ps_encode_op));
 
+    ALOGE("##### stang23 ##### setEncodeArgs line :%d", __LINE__);
+
     ps_inp_raw_buf = &ps_encode_ip->s_inp_buf;
     ps_encode_ip->s_out_buf.pv_buf = base;
     ps_encode_ip->s_out_buf.u4_bytes = 0;
@@ -1493,6 +1496,7 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
     ps_encode_ip->u4_size = sizeof(ive_video_encode_ip_t);
     ps_encode_op->u4_size = sizeof(ive_video_encode_op_t);
 
+    ALOGE("##### stang23 ##### setEncodeArgs line :%d", __LINE__);
     ps_encode_ip->e_cmd = IVE_CMD_VIDEO_ENCODE;
     ps_encode_ip->pv_bufs = nullptr;
     ps_encode_ip->pv_mb_info = nullptr;
@@ -1504,6 +1508,7 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
     ps_encode_ip->u4_timestamp_low = workIndex & 0xFFFFFFFF;
     ps_encode_op->s_out_buf.pv_buf = nullptr;
 
+    ALOGE("##### stang23 ##### setEncodeArgs line :%d", __LINE__);
     /* Initialize color formats */
     memset(ps_inp_raw_buf, 0, sizeof(iv_raw_buf_t));
     ps_inp_raw_buf->u4_size = sizeof(iv_raw_buf_t);
@@ -1514,6 +1519,7 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
         }
         return C2_OK;
     }
+    ALOGE("##### stang23 ##### setEncodeArgs line :%d", __LINE__);
 
     if (input->width() < mSize->width ||
         input->height() < mSize->height) {
@@ -1538,20 +1544,26 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
     CHECK_EQ((height & 1u), 0u);
     size_t yPlaneSize = width * height;
 
+    ALOGE("##### stang23 ##### setEncodeArgs line :%d", __LINE__);
     switch (layout.type) {
         case C2PlanarLayout::TYPE_RGB:
             [[fallthrough]];
         case C2PlanarLayout::TYPE_RGBA: {
             ALOGV("yPlaneSize = %zu", yPlaneSize);
+	    ALOGE("##### stang23 ##### setEncodeArgs TYPE_RGBA + line :%d", __LINE__);
             MemoryBlock conversionBuffer = mConversionBuffers.fetch(yPlaneSize * 3 / 2);
+	    ALOGE("##### stang23 ##### setEncodeArgs TYPE_RGBA + line :%d", __LINE__);
             mConversionBuffersInUse.emplace(conversionBuffer.data(), conversionBuffer);
+	    ALOGE("##### stang23 ##### setEncodeArgs TYPE_RGBA + line :%d", __LINE__);
             yPlane = conversionBuffer.data();
             uPlane = yPlane + yPlaneSize;
             vPlane = uPlane + yPlaneSize / 4;
             yStride = width;
             uStride = vStride = yStride / 2;
+	    ALOGE("##### stang23 ##### setEncodeArgs TYPE_RGBA + line :%d", __LINE__);
             ConvertRGBToPlanarYUV(yPlane, yStride, height, conversionBuffer.size(), *input,
                                   mColorAspects->matrix, mColorAspects->range);
+	    ALOGE("##### stang23 ##### setEncodeArgs TYPE_RGBA + line :%d", __LINE__);
             break;
         }
         case C2PlanarLayout::TYPE_YUV: {
@@ -1570,6 +1582,7 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
             }
 
             // copy to I420
+	    ALOGE("##### stang23 ##### setEncodeArgs copy to I420 + line :%d", __LINE__);
             yStride = width;
             uStride = vStride = yStride / 2;
             MemoryBlock conversionBuffer = mConversionBuffers.fetch(yPlaneSize * 3 / 2);
@@ -1583,6 +1596,8 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
             yPlane = conversionBuffer.data();
             uPlane = yPlane + yPlaneSize;
             vPlane = uPlane + yPlaneSize / 4;
+
+	    ALOGE("##### stang23 ##### setEncodeArgs copy to I420 - line :%d", __LINE__);
             break;
 
         }
@@ -1596,6 +1611,8 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
             return C2_BAD_VALUE;
     }
 
+    ALOGE("##### stang23 ##### setEncodeArgs line :%d", __LINE__);
+
     switch (mIvVideoColorFormat) {
         case IV_YUV_420P:
         {
@@ -1646,6 +1663,7 @@ c2_status_t C2SoftAvcEnc::setEncodeArgs(
             break;
         }
     }
+    ALOGE("##### stang23 ##### setEncodeArgs line :%d", __LINE__);
     return C2_OK;
 }
 
@@ -1680,6 +1698,7 @@ void C2SoftAvcEnc::finishWork(uint64_t workIndex, const std::unique_ptr<C2Work>
 void C2SoftAvcEnc::process(
         const std::unique_ptr<C2Work> &work,
         const std::shared_ptr<C2BlockPool> &pool) {
+    ALOGE("##### stang23 ##### C2SoftAvcEnc::process +");
     // Initialize output work
     work->result = C2_OK;
     work->workletsProcessed = 0u;
@@ -1692,14 +1711,19 @@ void C2SoftAvcEnc::process(
     // Initialize encoder if not already initialized
     if (mCodecCtx == nullptr) {
         if (C2_OK != initEncoder()) {
-            ALOGE("Failed to initialize encoder");
+            ALOGE("##### stang23 ##### Failed to initialize encoder");
             mSignalledError = true;
             work->result = C2_CORRUPTED;
             work->workletsProcessed = 1u;
             return;
         }
+	ALOGE("##### stang23 ##### initEncoder is done!");
     }
+
+    ALOGE("##### stang23 ##### Encoder is initialized!");
+
     if (mSignalledError) {
+	    ALOGE("##### stang23 ##### mSignalledError return!");
         return;
     }
     // while (!mSawOutputEOS && !outQueue.empty()) {
@@ -1711,6 +1735,7 @@ void C2SoftAvcEnc::process(
     memset(ps_encode_op, 0, sizeof(*ps_encode_op));
 
     if (!mSpsPpsHeaderReceived) {
+	ALOGE("##### stang23 ##### decoding HEADER");
         constexpr uint32_t kHeaderLength = MIN_STREAM_SIZE;
         uint8_t header[kHeaderLength];
         error = setEncodeArgs(
@@ -1749,15 +1774,17 @@ void C2SoftAvcEnc::process(
         work->worklets.front()->output.configUpdate.push_back(std::move(csd));
 
         DUMP_TO_FILE(
-                mOutFile, csd->m.value, csd->flexCount());
+                mOutFile, csd->m.value, (int)csd->flexCount());
         if (work->input.buffers.empty()) {
             work->workletsProcessed = 1u;
+	    ALOGE("##### stang23 ##### decoding HEADER return! line :%d", __LINE__);
             return;
         }
     }
 
     // handle dynamic config parameters
     {
+	ALOGE("##### stang23 ##### handle dynamic config parameters. line :%d", __LINE__);
         IntfImpl::Lock lock = mIntf->lock();
         std::shared_ptr<C2StreamIntraRefreshTuning::output> intraRefresh = mIntf->getIntraRefresh_l();
         std::shared_ptr<C2StreamBitrateInfo::output> bitrate = mIntf->getBitrate_l();
@@ -1819,13 +1846,17 @@ void C2SoftAvcEnc::process(
     }
 
     do {
+	ALOGE("##### stang23 ##### encode frame in loops. line :%d", __LINE__);
         if (mSawInputEOS && work->input.buffers.empty()) break;
         if (!mOutBlock) {
             C2MemoryUsage usage = {C2MemoryUsage::CPU_READ,
                                    C2MemoryUsage::CPU_WRITE};
             // TODO: error handling, proper usage, etc.
+	    ALOGE("##### stang23 ##### before fetchLinearBlock. line :%d", __LINE__);
             c2_status_t err =
                 pool->fetchLinearBlock(mOutBufferSize, usage, &mOutBlock);
+
+	    ALOGE("##### stang23 ##### fetchLinearBlock done. line :%d", __LINE__);
             if (err != C2_OK) {
                 ALOGE("fetch linear block err = %d", err);
                 work->result = err;
@@ -1833,7 +1864,9 @@ void C2SoftAvcEnc::process(
                 return;
             }
         }
+	ALOGE("##### stang23 ##### before mOutBlock->map().get(). line :%d", __LINE__);
         C2WriteView wView = mOutBlock->map().get();
+	ALOGE("##### stang23 ##### mOutBlock->map().get() done. line :%d", __LINE__);
         if (wView.error() != C2_OK) {
             ALOGE("write view map err = %d", wView.error());
             work->result = wView.error();
@@ -1841,8 +1874,10 @@ void C2SoftAvcEnc::process(
             return;
         }
 
+	ALOGE("##### stang23 ##### before setEncodeArgs. line :%d", __LINE__);
         error = setEncodeArgs(
                 ps_encode_ip, ps_encode_op, view.get(), wView.base(), wView.capacity(), workIndex);
+	ALOGE("##### stang23 ##### setEncodeArgs done. line :%d", __LINE__);
         if (error != C2_OK) {
             ALOGE("setEncodeArgs failed : %d", error);
             mSignalledError = true;
@@ -1859,7 +1894,9 @@ void C2SoftAvcEnc::process(
          * to start of current decode() */
         mTimeStart = systemTime();
         timeDelay = mTimeStart - mTimeEnd;
+	ALOGE("##### stang23 ##### before ive_api_function. line :%d", __LINE__);
         status = ive_api_function(mCodecCtx, &s_video_encode_ip, &s_video_encode_op);
+	ALOGE("##### stang23 ##### ive_api_function end. line :%d", __LINE__);
 
         if (IV_SUCCESS != status) {
             if ((ps_encode_op->u4_error_code & 0xFF) == IH264E_BITSTREAM_BUFFER_OVERFLOW) {
@@ -1874,9 +1911,11 @@ void C2SoftAvcEnc::process(
             work->result = C2_CORRUPTED;
             work->workletsProcessed = 1u;
             return;
-        }
+	}
     } while (IV_SUCCESS != status);
 
+    ALOGE("##### stang23 ##### encoded done successfully.");
+
     // Hold input buffer reference
     if (inputBuffer) {
         mBuffers[ps_encode_ip->s_inp_buf.apv_bufs[0]] = inputBuffer;
-- 
2.34.1

