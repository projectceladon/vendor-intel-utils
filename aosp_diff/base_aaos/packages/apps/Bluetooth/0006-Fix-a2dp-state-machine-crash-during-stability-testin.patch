From 595b2f1f52651b4bb11c175c411047818607fc2b Mon Sep 17 00:00:00 2001
From: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
Date: Mon, 18 Dec 2023 11:36:38 +0530
Subject: [PATCH] Fix a2dp state machine crash during stability testing

Gracefully close the state machines which are not started.
So that events will go only to active state machines.

Cherry-picked from AOSP.
https://android-review.googlesource.com/c/platform/packages/modules/Bluetooth/+/2684452
commit-id: 782ba8463c24517701df2f5f5265248eefa48ffe

Tracked-On: OAM-112969
Signed-off-by: Sal Savage <salsavage@google.com>
Signed-off-by: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
---
 .../bluetooth/a2dpsink/A2dpSinkService.java   | 21 ++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java b/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java
index c70ed469b..b5d3ab2cd 100644
--- a/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java
+++ b/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java
@@ -365,7 +365,11 @@ public class A2dpSinkService extends ProfileService {
     }
 
     void removeStateMachine(A2dpSinkStateMachine stateMachine) {
+	if (stateMachine == null) {
+            return;
+        }
         mDeviceStateMap.remove(stateMachine.getDevice());
+	stateMachine.quitNow();
     }
 
     public List<BluetoothDevice> getConnectedDevices() {
@@ -377,14 +381,25 @@ public class A2dpSinkService extends ProfileService {
         A2dpSinkStateMachine existingStateMachine =
                 mDeviceStateMap.putIfAbsent(device, newStateMachine);
         // Given null is not a valid value in our map, ConcurrentHashMap will return null if the
-        // key was absent and our new value was added. We should then start and return it.
+        // key was absent and our new value was added. We should then start and return it. Else
+        // we quit the new one so we don't leak a thread
         if (existingStateMachine == null) {
             newStateMachine.start();
             return newStateMachine;
-        }
+        } else {
+            // If you try to quit a StateMachine that hasn't been constructed yet, the StateMachine
+            // spits out an NPE trying to read a state stack array that only gets made on start().
+            // We can just quit the thread made explicitly
+            newStateMachine.getHandler().getLooper().quit();
+	}
         return existingStateMachine;
     }
 
+    @VisibleForTesting
+    protected A2dpSinkStateMachine getStateMachineForDevice(BluetoothDevice device) {
+        return mDeviceStateMap.get(device);
+    }
+
     List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
         if (DBG) Log.d(TAG, "getDevicesMatchingConnectionStates" + Arrays.toString(states));
         List<BluetoothDevice> deviceList = new ArrayList<>();
@@ -555,7 +570,7 @@ public class A2dpSinkService extends ProfileService {
     private void onAudioConfigChanged(byte[] address, int sampleRate, int channelCount) {
         StackEvent event = StackEvent.audioConfigChanged(getAnonymousDevice(address), sampleRate,
                 channelCount);
-        A2dpSinkStateMachine stateMachine = getOrCreateStateMachine(event.mDevice);
+	A2dpSinkStateMachine stateMachine = getStateMachineForDevice(event.mDevice);
         stateMachine.sendMessage(A2dpSinkStateMachine.STACK_EVENT, event);
     }
 }
-- 
2.17.1

