From 3d34a88fb2728b7af8a46b6639637846595f5e72 Mon Sep 17 00:00:00 2001
From: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
Date: Wed, 15 May 2024 19:16:23 +0530
Subject: [PATCH] Add logs in A2dpSinkStateMachine for debug

Signed-off-by: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
---
 .../bluetooth/a2dpsink/A2dpSinkService.java    | 18 +++++++++++++++++-
 .../a2dpsink/A2dpSinkStateMachine.java         |  4 +++-
 2 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java b/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java
index b5d3ab2cd..4917b97a9 100644
--- a/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java
+++ b/src/com/android/bluetooth/a2dpsink/A2dpSinkService.java
@@ -45,7 +45,7 @@ import java.util.concurrent.ConcurrentHashMap;
  */
 public class A2dpSinkService extends ProfileService {
     private static final String TAG = "A2dpSinkService";
-    private static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG);
+    private static final boolean DBG = true;//Log.isLoggable(TAG, Log.DEBUG);
     private int mMaxConnectedAudioDevices;
 
     private AdapterService mAdapterService;
@@ -83,6 +83,7 @@ public class A2dpSinkService extends ProfileService {
 
     @Override
     protected boolean stop() {
+        Log.d(TAG, "stop()");
         setA2dpSinkService(null);
         cleanupNative();
         for (A2dpSinkStateMachine stateMachine : mDeviceStateMap.values()) {
@@ -306,6 +307,7 @@ public class A2dpSinkService extends ProfileService {
      */
     @RequiresPermission(android.Manifest.permission.BLUETOOTH_PRIVILEGED)
     public boolean connect(BluetoothDevice device) {
+        Log.d(TAG, "connect 1");
         enforceCallingOrSelfPermission(BLUETOOTH_PRIVILEGED,
                 "Need BLUETOOTH_PRIVILEGED permission");
         if (device == null) {
@@ -323,8 +325,10 @@ public class A2dpSinkService extends ProfileService {
             return false;
         }
 
+        Log.d(TAG, "connect 2");
         A2dpSinkStateMachine stateMachine = getOrCreateStateMachine(device);
         if (stateMachine != null) {
+            Log.d(TAG, "connect 3");
             stateMachine.connect();
             return true;
         } else {
@@ -348,6 +352,7 @@ public class A2dpSinkService extends ProfileService {
                     + ", InstanceMap start state: " + sb.toString());
         }
 
+        Log.d(TAG, "disconnect");
         A2dpSinkStateMachine stateMachine = mDeviceStateMap.get(device);
         // a state machine instance doesn't exist. maybe it is already gone?
         if (stateMachine == null) {
@@ -368,6 +373,7 @@ public class A2dpSinkService extends ProfileService {
 	if (stateMachine == null) {
             return;
         }
+        Log.d(TAG, "removeStateMachine");
         mDeviceStateMap.remove(stateMachine.getDevice());
 	stateMachine.quitNow();
     }
@@ -380,23 +386,29 @@ public class A2dpSinkService extends ProfileService {
         A2dpSinkStateMachine newStateMachine = new A2dpSinkStateMachine(device, this);
         A2dpSinkStateMachine existingStateMachine =
                 mDeviceStateMap.putIfAbsent(device, newStateMachine);
+        Log.d(TAG, "getOrCreateStateMachine 1");
         // Given null is not a valid value in our map, ConcurrentHashMap will return null if the
         // key was absent and our new value was added. We should then start and return it. Else
         // we quit the new one so we don't leak a thread
         if (existingStateMachine == null) {
+            Log.d(TAG, "getOrCreateStateMachine 2");
             newStateMachine.start();
+            Log.d(TAG, "getOrCreateStateMachine 3");
             return newStateMachine;
         } else {
             // If you try to quit a StateMachine that hasn't been constructed yet, the StateMachine
             // spits out an NPE trying to read a state stack array that only gets made on start().
             // We can just quit the thread made explicitly
+            Log.d(TAG, "getOrCreateStateMachine 4");
             newStateMachine.getHandler().getLooper().quit();
 	}
+        Log.d(TAG, "getOrCreateStateMachine 5");
         return existingStateMachine;
     }
 
     @VisibleForTesting
     protected A2dpSinkStateMachine getStateMachineForDevice(BluetoothDevice device) {
+        Log.d(TAG, "getStateMachineForDevice");
         return mDeviceStateMap.get(device);
     }
 
@@ -429,7 +441,9 @@ public class A2dpSinkService extends ProfileService {
      * {@link BluetoothProfile#STATE_DISCONNECTING} if this profile is being disconnected
      */
     public int getConnectionState(BluetoothDevice device) {
+        Log.d(TAG, "getConnectionState 1");
         A2dpSinkStateMachine stateMachine = mDeviceStateMap.get(device);
+        Log.d(TAG, "getConnectionState 2");
         return (stateMachine == null) ? BluetoothProfile.STATE_DISCONNECTED
                 : stateMachine.getState();
     }
@@ -498,11 +512,13 @@ public class A2dpSinkService extends ProfileService {
     }
 
     BluetoothAudioConfig getAudioConfig(BluetoothDevice device) {
+        Log.d(TAG, "getAudioConfig 1");
         A2dpSinkStateMachine stateMachine = mDeviceStateMap.get(device);
         // a state machine instance doesn't exist. maybe it is already gone?
         if (stateMachine == null) {
             return null;
         }
+        Log.d(TAG, "getAudioConfig 2");
         return stateMachine.getAudioConfig();
     }
 
diff --git a/src/com/android/bluetooth/a2dpsink/A2dpSinkStateMachine.java b/src/com/android/bluetooth/a2dpsink/A2dpSinkStateMachine.java
index cfc4bfc0f..4725d3f6a 100644
--- a/src/com/android/bluetooth/a2dpsink/A2dpSinkStateMachine.java
+++ b/src/com/android/bluetooth/a2dpsink/A2dpSinkStateMachine.java
@@ -37,7 +37,7 @@ import com.android.bluetooth.statemachine.StateMachine;
 
 public class A2dpSinkStateMachine extends StateMachine {
     static final String TAG = "A2DPSinkStateMachine";
-    static final boolean DBG = Log.isLoggable(TAG, Log.DEBUG);
+    static final boolean DBG = true;//Log.isLoggable(TAG, Log.DEBUG);
 
     //0->99 Events from Outside
     public static final int CONNECT = 1;
@@ -65,6 +65,7 @@ public class A2dpSinkStateMachine extends StateMachine {
 
     A2dpSinkStateMachine(BluetoothDevice device, A2dpSinkService service) {
         super(TAG);
+	setDbg(DBG);
         mDevice = device;
         mDeviceAddress = Utils.getByteAddress(mDevice);
         mService = service;
@@ -116,6 +117,7 @@ public class A2dpSinkStateMachine extends StateMachine {
      * send the Connect command asynchronously
      */
     public final void connect() {
+        Log.d(TAG, "connect");
         sendMessage(CONNECT);
     }
 
-- 
2.17.1

