From cb449a2de298943de8cc8fb784497d9fe0e7c9df Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mat=C3=ADas=20Hern=C3=A1ndez?= <matiashe@google.com>
Date: Mon, 5 Jun 2023 18:24:04 +0200
Subject: [PATCH] Don't hide approved NLSes in Settings

Note that an NLS that shouldn't be approvable (because its name is too long) but was already approved (either before the max length check was introduced, or through other means) will disappear from the list if the user revokes its access. This might be somewhat confusing, but since this is a very-edge case already it's fine.

Bug: 282932362
Test: manual
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ff255c6eda1528f01a167a9a65b7f8e414d28584)
Merged-In: I4c9faea68e6d16b1a4ec7f472b5433cac1704c06
Change-Id: I4c9faea68e6d16b1a4ec7f472b5433cac1704c06
---
 .../NotificationAccessSettings.java           |  25 +--
 .../notification/NotificationBackend.java     |   3 +
 .../NotificationAccessSettingsTest.java       | 144 ++++++++++++++++++
 3 files changed, 160 insertions(+), 12 deletions(-)
 create mode 100644 tests/robotests/src/com/android/settings/notification/NotificationAccessSettingsTest.java

diff --git a/src/com/android/settings/notification/NotificationAccessSettings.java b/src/com/android/settings/notification/NotificationAccessSettings.java
index d94498e68f..ab2a177bcf 100644
--- a/src/com/android/settings/notification/NotificationAccessSettings.java
+++ b/src/com/android/settings/notification/NotificationAccessSettings.java
@@ -40,6 +40,7 @@ import android.widget.Toast;
 import androidx.preference.PreferenceCategory;
 import androidx.preference.PreferenceScreen;
 
+import com.android.internal.annotations.VisibleForTesting;
 import com.android.settings.R;
 import com.android.settings.Utils;
 import com.android.settings.applications.AppInfoBase;
@@ -60,8 +61,8 @@ import java.util.List;
 @SearchIndexable
 public class NotificationAccessSettings extends EmptyTextSettings {
     private static final String TAG = "NotifAccessSettings";
-    private static final String ALLOWED_KEY = "allowed";
-    private static final String NOT_ALLOWED_KEY = "not_allowed";
+    static final String ALLOWED_KEY = "allowed";
+    static final String NOT_ALLOWED_KEY = "not_allowed";
     private static final int MAX_CN_LENGTH = 500;
 
     private static final ManagedServiceSettings.Config CONFIG =
@@ -77,9 +78,9 @@ public class NotificationAccessSettings extends EmptyTextSettings {
                     .setEmptyText(R.string.no_notification_listeners)
                     .build();
 
-    private NotificationManager mNm;
+    @VisibleForTesting NotificationManager mNm;
     protected Context mContext;
-    private PackageManager mPm;
+    @VisibleForTesting PackageManager mPm;
     private DevicePolicyManager mDpm;
     private ServiceListing mServiceListing;
     private IconDrawableFactory mIconDrawableFactory;
@@ -99,12 +100,6 @@ public class NotificationAccessSettings extends EmptyTextSettings {
                 .setNoun(CONFIG.noun)
                 .setSetting(CONFIG.setting)
                 .setTag(CONFIG.tag)
-                .setValidator(info -> {
-                    if (info.getComponentName().flattenToString().length() > MAX_CN_LENGTH) {
-                        return false;
-                    }
-                    return true;
-                })
                 .build();
         mServiceListing.addCallback(this::updateList);
 
@@ -135,7 +130,8 @@ public class NotificationAccessSettings extends EmptyTextSettings {
         mServiceListing.setListening(false);
     }
 
-    private void updateList(List<ServiceInfo> services) {
+    @VisibleForTesting
+    void updateList(List<ServiceInfo> services) {
         final UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE);
         final int managedProfileId = Utils.getManagedProfileId(um, UserHandle.myUserId());
 
@@ -148,6 +144,11 @@ public class NotificationAccessSettings extends EmptyTextSettings {
         services.sort(new PackageItemInfo.DisplayNameComparator(mPm));
         for (ServiceInfo service : services) {
             final ComponentName cn = new ComponentName(service.packageName, service.name);
+            boolean isAllowed = mNm.isNotificationListenerAccessGranted(cn);
+            if (!isAllowed && cn.flattenToString().length() > MAX_CN_LENGTH) {
+                continue;
+            }
+
             CharSequence title = null;
             try {
                 title = mPm.getApplicationInfoAsUser(
@@ -192,7 +193,7 @@ public class NotificationAccessSettings extends EmptyTextSettings {
                         return true;
                     });
             pref.setKey(cn.flattenToString());
-            if (mNm.isNotificationListenerAccessGranted(cn)) {
+            if (isAllowed) {
                 allowedCategory.addPreference(pref);
             } else {
                 notAllowedCategory.addPreference(pref);
diff --git a/src/com/android/settings/notification/NotificationBackend.java b/src/com/android/settings/notification/NotificationBackend.java
index e448dda20a..d95b48f393 100644
--- a/src/com/android/settings/notification/NotificationBackend.java
+++ b/src/com/android/settings/notification/NotificationBackend.java
@@ -143,6 +143,9 @@ public class NotificationBackend {
 
     static public CharSequence getDeviceList(ICompanionDeviceManager cdm, LocalBluetoothManager lbm,
             String pkg, int userId) {
+        if (cdm == null) {
+            return "";
+        }
         boolean multiple = false;
         StringBuilder sb = new StringBuilder();
 
diff --git a/tests/robotests/src/com/android/settings/notification/NotificationAccessSettingsTest.java b/tests/robotests/src/com/android/settings/notification/NotificationAccessSettingsTest.java
new file mode 100644
index 0000000000..e644c2975b
--- /dev/null
+++ b/tests/robotests/src/com/android/settings/notification/NotificationAccessSettingsTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.notification;
+
+import static com.android.settings.notification.NotificationAccessSettings.ALLOWED_KEY;
+import static com.android.settings.notification.NotificationAccessSettings.NOT_ALLOWED_KEY;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.truth.Truth.assertThat;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import android.app.NotificationManager;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.ServiceInfo;
+
+import androidx.fragment.app.FragmentActivity;
+import androidx.preference.PreferenceCategory;
+import androidx.preference.PreferenceScreen;
+
+import com.android.settings.testutils.shadow.ShadowBluetoothUtils;
+import com.android.settingslib.bluetooth.LocalBluetoothManager;
+
+import com.google.common.base.Strings;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+import org.mockito.stubbing.Answer;
+import org.robolectric.Robolectric;
+import org.robolectric.RobolectricTestRunner;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowApplication;
+
+import java.util.ArrayList;
+
+@RunWith(RobolectricTestRunner.class)
+@Config(shadows = {ShadowBluetoothUtils.class})
+public class NotificationAccessSettingsTest {
+
+    private Context mContext;
+    private NotificationAccessSettings mAccessSettings;
+    @Mock
+    private NotificationManager mNotificationManager;
+    @Mock
+    private PackageManager mPackageManager;
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+
+        mContext = RuntimeEnvironment.application;
+        ShadowApplication shadowApp = ShadowApplication.getInstance();
+        shadowApp.setSystemService(Context.NOTIFICATION_SERVICE, mNotificationManager);
+
+        mAccessSettings = new NotificationAccessSettings();
+        FragmentActivity activity = Robolectric.buildActivity(FragmentActivity.class).setup().get();
+        activity.getSupportFragmentManager().beginTransaction().add(mAccessSettings, null).commit();
+
+        when(mPackageManager.getApplicationInfoAsUser(any(), anyInt(), anyInt())).then(
+                (Answer<ApplicationInfo>) invocation -> {
+                    ApplicationInfo appInfo = mock(ApplicationInfo.class);
+                    when(appInfo.loadLabel(any())).thenReturn(invocation.getArgument(0));
+                    return appInfo;
+                });
+
+        mAccessSettings.mNm = mNotificationManager;
+        mAccessSettings.mPm = mPackageManager;
+        ShadowBluetoothUtils.sLocalBluetoothManager = mock(LocalBluetoothManager.class);
+    }
+
+    @Test
+    public void updateList_enabledLongName_shown() {
+        ComponentName longCn = new ComponentName("test.pkg1",
+                Strings.repeat("Blah", 200) + "Service");
+        ComponentName shortCn = new ComponentName("test.pkg2", "ReasonableService");
+        ArrayList<ServiceInfo> services = new ArrayList<>();
+        services.add(newServiceInfo(longCn.getPackageName(), longCn.getClassName(), 1));
+        services.add(newServiceInfo(shortCn.getPackageName(), shortCn.getClassName(), 2));
+        when(mNotificationManager.isNotificationListenerAccessGranted(any())).thenReturn(true);
+
+        mAccessSettings.updateList(services);
+
+        PreferenceScreen screen = mAccessSettings.getPreferenceScreen();
+        PreferenceCategory allowed = checkNotNull(screen.findPreference(ALLOWED_KEY));
+        PreferenceCategory notAllowed = checkNotNull(screen.findPreference(NOT_ALLOWED_KEY));
+        assertThat(allowed.getPreferenceCount()).isEqualTo(2);
+        assertThat(allowed.getPreference(0).getKey()).isEqualTo(longCn.flattenToString());
+        assertThat(allowed.getPreference(1).getKey()).isEqualTo(shortCn.flattenToString());
+        assertThat(notAllowed.getPreferenceCount()).isEqualTo(0);
+    }
+
+    @Test
+    public void updateList_disabledLongName_notShown() {
+        ComponentName longCn = new ComponentName("test.pkg1",
+                Strings.repeat("Blah", 200) + "Service");
+        ComponentName shortCn = new ComponentName("test.pkg2", "ReasonableService");
+        ArrayList<ServiceInfo> services = new ArrayList<>();
+        services.add(newServiceInfo(longCn.getPackageName(), longCn.getClassName(), 1));
+        services.add(newServiceInfo(shortCn.getPackageName(), shortCn.getClassName(), 2));
+        when(mNotificationManager.isNotificationListenerAccessGranted(any())).thenReturn(false);
+
+        mAccessSettings.updateList(services);
+
+        PreferenceScreen screen = mAccessSettings.getPreferenceScreen();
+        PreferenceCategory allowed = checkNotNull(screen.findPreference(ALLOWED_KEY));
+        PreferenceCategory notAllowed = checkNotNull(screen.findPreference(NOT_ALLOWED_KEY));
+        assertThat(allowed.getPreferenceCount()).isEqualTo(0);
+        assertThat(notAllowed.getPreferenceCount()).isEqualTo(1);
+        assertThat(notAllowed.getPreference(0).getKey()).isEqualTo(shortCn.flattenToString());
+    }
+
+    private static ServiceInfo newServiceInfo(String packageName, String serviceName, int uid) {
+        ServiceInfo serviceInfo = new ServiceInfo();
+        serviceInfo.packageName = packageName;
+        serviceInfo.name = serviceName;
+        serviceInfo.applicationInfo = new ApplicationInfo();
+        serviceInfo.applicationInfo.uid = uid;
+        return serviceInfo;
+    }
+}
-- 
2.41.0.585.gd2178a4bd4-goog

