From 258c862961982490e1d2f1c5e3df853cd5bec38a Mon Sep 17 00:00:00 2001
From: Ankit Agrawal <ankit.agarwal@intel.com>
Date: Tue, 4 Jul 2023 11:31:17 +0530
Subject: [PATCH] Multi-Passenger Feature Support in IVI AOSP.

Implemented feature to support all passengers in IVI,
So all passengers can use apps concurrently on their
own display connected with same device.

Tested this feature with 1 driver & 2 passengers.

Tracked-On: OAM-108948
Signed-off-by: Ankit Agrawal <ankit.agarwal@intel.com>
---
 .../android/car/CarOccupantZoneService.java   |  24 +++-
 .../com/android/car/user/CarUserService.java  | 112 ++++++++++++------
 .../launcher/LauncherActivity.java            |  22 +++-
 3 files changed, 119 insertions(+), 39 deletions(-)

diff --git a/service/src/com/android/car/CarOccupantZoneService.java b/service/src/com/android/car/CarOccupantZoneService.java
index 4f82157e0..f2cd798b2 100644
--- a/service/src/com/android/car/CarOccupantZoneService.java
+++ b/service/src/com/android/car/CarOccupantZoneService.java
@@ -335,6 +335,21 @@ public final class CarOccupantZoneService extends ICarOccupantZone.Stub
                 }
                 return false;
             }
+
+            @Override
+            public int getAvailablePassengerDisplay() {
+                Slogf.w(TAG, "getAvailablePassengerDisplay");
+                int count = 0;
+                for (OccupantZoneInfo ozi : getAllOccupantZones()) {
+                    if (getDisplayForOccupant(ozi.zoneId,
+                            CarOccupantZoneManager.DISPLAY_TYPE_MAIN) != Display.INVALID_DISPLAY
+                            && ozi.occupantType != CarOccupantZoneManager.OCCUPANT_TYPE_DRIVER) {
+                        Slogf.w(TAG, "getAvailablePassengerDisplay count is (%d)", count);
+                        count++;
+                    }
+                }
+                return count;
+            }
         };
         userService.setZoneUserBindingHelper(helper);
     }
@@ -544,6 +559,7 @@ public final class CarOccupantZoneService extends ICarOccupantZone.Stub
         for (int index = 0; index < mAudioZoneIdToOccupantZoneIdMapping.size(); index++) {
             int audioZoneId = mAudioZoneIdToOccupantZoneIdMapping.keyAt(index);
             if (occupantZoneId == mAudioZoneIdToOccupantZoneIdMapping.get(audioZoneId)) {
+                    Slogf.w(TAG, "getAudioZoneIdForOccupantLocked (%d) occupantZoneId (%d)", audioZoneId,occupantZoneId );
                 return audioZoneId;
             }
         }
@@ -557,6 +573,7 @@ public final class CarOccupantZoneService extends ICarOccupantZone.Stub
             int occupantZoneId = mAudioZoneIdToOccupantZoneIdMapping.get(audioZoneId,
                     OccupantZoneInfo.INVALID_ZONE_ID);
             if (occupantZoneId == OccupantZoneInfo.INVALID_ZONE_ID) {
+                    Slogf.w(TAG, "invalid case");
                 return null;
             }
             // To support headless zones return the occupant configuration.
@@ -1147,13 +1164,18 @@ public final class CarOccupantZoneService extends ICarOccupantZone.Stub
 
         for (int i = 0; i < mActiveOccupantConfigs.size(); ++i) {
             int zoneId = mActiveOccupantConfigs.keyAt(i);
+	    OccupantZoneInfo zConfig = mOccupantsConfig.get(zoneId);
             OccupantConfig config = mActiveOccupantConfigs.valueAt(i);
             // mProfileUsers empty if not supported
             if (mProfileUsers.contains(config.userId)) {
                 Slogf.i(TAG, "Profile user:%d already assigned for occupant zone:%d",
                         config.userId, zoneId);
             } else {
-                config.userId = driverUserId;
+                /*The below assignment would default the other users to driver user, hence the line is commented*/
+                //config.userId = driverUserId;
+                if(zConfig.occupantType == CarOccupantZoneManager.OCCUPANT_TYPE_DRIVER) {
+                    config.userId = driverUserId;
+                }
             }
         }
     }
diff --git a/service/src/com/android/car/user/CarUserService.java b/service/src/com/android/car/user/CarUserService.java
index e5bf033ef..8958df7f5 100644
--- a/service/src/com/android/car/user/CarUserService.java
+++ b/service/src/com/android/car/user/CarUserService.java
@@ -182,9 +182,9 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
     private boolean mUser0Unlocked;
     @GuardedBy("mLockUser")
     private final ArrayList<Runnable> mUser0UnlockTasks = new ArrayList<>();
-    // Only one passenger is supported.
+    // Supporting multiple passengers.
     @GuardedBy("mLockUser")
-    private @UserIdInt int mLastPassengerId;
+    private ArrayList<Integer> mRunningPassengersId = new ArrayList<>();
     /**
      * Background users that will be restarted in garage mode. This list can include the
      * current foreground user but the current foreground user should not be restarted.
@@ -314,6 +314,8 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
         boolean unassignUserFromOccupantZone(@UserIdInt int userId);
         /** Returns whether there is a passenger display. */
         boolean isPassengerDisplayAvailable();
+        /** Returns number of passenger display available. */
+        int getAvailablePassengerDisplay();
     }
 
     private final Object mLockHelper = new Object();
@@ -350,7 +352,6 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
         mMaxRunningUsers = maxRunningUsers;
         mUserManager = userManager;
         mDpm = dpm;
-        mLastPassengerId = UserHandle.USER_NULL;
         mHandler = handler == null ? new Handler(mHandlerThread.getLooper()) : handler;
         mInitialUserSetter =
                 initialUserSetter == null ? new InitialUserSetter(context, this,
@@ -665,7 +666,7 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
                 Slog.w(TAG, "could not assign passenger to zone");
                 return false;
             }
-            mLastPassengerId = passengerId;
+            mRunningPassengersId.add(passengerId);
         }
         for (PassengerCallback callback : mPassengerCallbacks) {
             callback.onPassengerStarted(passengerId, zoneId);
@@ -673,6 +674,15 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
         return true;
     }
 
+    private void stopAllPassenger() {
+        if (!mRunningPassengersId.isEmpty()) {
+            for (int i = 0; i < mRunningPassengersId.size(); i++) {
+                stopPassengerInternal(mRunningPassengersId.get(i), true);
+            }
+            mRunningPassengersId.clear();
+        }
+    }
+
     /**
      * @see CarUserManager.stopPassenger
      */
@@ -689,7 +699,7 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
                 Slog.w(TAG, "passenger " + passengerId + " doesn't exist");
                 return false;
             }
-            if (mLastPassengerId != passengerId) {
+            if (!mRunningPassengersId.contains(passengerId)) {
                 Slog.w(TAG, "passenger " + passengerId + " hasn't been started");
                 return true;
             }
@@ -709,7 +719,6 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
                 Slog.w(TAG, "could not unassign user from occupant zone");
                 return false;
             }
-            mLastPassengerId = UserHandle.USER_NULL;
         }
         for (PassengerCallback callback : mPassengerCallbacks) {
             callback.onPassengerStopped(passengerId);
@@ -2259,10 +2268,20 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
         } else if (eventType == CarUserManager.USER_LIFECYCLE_EVENT_TYPE_UNLOCKED) {
             onUserUnlocked(userId);
 	    if(userId == ActivityManager.getCurrentUser() && userId != UserHandle.USER_SYSTEM) {
-		if (mLastPassengerId != UserHandle.USER_NULL && !mUserManager.isUserUnlocked(UserHandle.of(mLastPassengerId))) {
-                    stopPassengerInternal(mLastPassengerId, false);
-		    startFirstPassenger(userId);
-                 }
+                if (!mRunningPassengersId.isEmpty()) {
+                    boolean passengerUserLocked = false;
+                    for (int i = 0; i < mRunningPassengersId.size(); i++) {
+                        int runningPassengerId = mRunningPassengersId.get(i);
+                        if(!mUserManager.isUserUnlocked(UserHandle.of(runningPassengerId))) {
+                            passengerUserLocked = true;
+                            break;
+                        }
+                    }
+                    if(passengerUserLocked) {
+                        stopAllPassenger();
+                        startAllPassenger(userId);
+                    }
+                }
             }
         }
 
@@ -2366,12 +2385,26 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
 
         mInitialUserSetter.setLastActiveUser(toUserId);
 
-        if (mLastPassengerId != UserHandle.USER_NULL) {
-            stopPassengerInternal(mLastPassengerId, false);
+        if (!mRunningPassengersId.isEmpty()) {
+            for (int i = 0; i < mRunningPassengersId.size(); i++) {
+                stopPassengerInternal(mRunningPassengersId.get(i), false);
+            }
+            mRunningPassengersId.clear();
         }
-        if (mEnablePassengerSupport && isPassengerDisplayAvailable()) {
-            setupPassengerUser();
-            startFirstPassenger(toUserId);
+
+        if (mEnablePassengerSupport) {
+            int availablePassengerDisplays = getAvailablePassengerDisplay();
+            int existingProfile = getNumberOfManagedProfiles(toUserId);
+            for (int i = 1; i <=  (availablePassengerDisplays - existingProfile); i++) {
+                if (1 == (existingProfile + i)) {
+                    setupPassengerUser("Front_Passenger");
+                } else if (2 == (existingProfile + i)) {
+                    setupPassengerUser("Rear_Passenger_Left");
+                } else if (3 == (existingProfile + i)) {
+                    setupPassengerUser("Rear_Passenger_Right");
+                }
+            }
+            startAllPassenger(toUserId);
         }
         t.traceEnd();
     }
@@ -2510,15 +2543,15 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
     }
 
     /**
-     * Starts the first passenger of the given driver and assigns the passenger to the front
+     * Start all available passengers of the given driver and assigns the passenger to
      * passenger zone.
      *
      * @param driverId User id of the driver.
      * @return whether it succeeds.
      */
-    private boolean startFirstPassenger(@UserIdInt int driverId) {
-        int zoneId = getAvailablePassengerZone();
-        if (zoneId == OccupantZoneInfo.INVALID_ZONE_ID) {
+    private boolean startAllPassenger(@UserIdInt int driverId) {
+        List<Integer> zoneIds = getAvailablePassengerZone();
+        if (zoneIds.isEmpty()) {
             Slog.w(TAG, "passenger occupant zone is not found");
             return false;
         }
@@ -2527,41 +2560,42 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
             Slog.w(TAG, "passenger is not found");
             return false;
         }
-        // Only one passenger is supported. If there are two or more passengers, the first passenger
-        // is chosen.
-        int passengerId = passengers.get(0).id;
-        if (!startPassenger(passengerId, zoneId)) {
-            Slog.w(TAG, "cannot start passenger " + passengerId);
-            return false;
+        for (int i = 0; i < zoneIds.size(); i++) {
+            int passengerId = passengers.get(i).id;
+            if (!startPassenger(passengerId, zoneIds.get(i))) {
+                Slog.w(TAG, "cannot start passenger " + passengerId);
+                return false;
+            }
         }
         return true;
     }
 
-    private int getAvailablePassengerZone() {
+    private List<Integer> getAvailablePassengerZone() {
         int[] occupantTypes = new int[] {CarOccupantZoneManager.OCCUPANT_TYPE_FRONT_PASSENGER,
                 CarOccupantZoneManager.OCCUPANT_TYPE_REAR_PASSENGER};
+        ArrayList<Integer> passengerZones = new ArrayList<>();
         for (int occupantType : occupantTypes) {
-            int zoneId = getZoneId(occupantType);
-            if (zoneId != OccupantZoneInfo.INVALID_ZONE_ID) {
-                return zoneId;
+            List<OccupantZoneInfo> zoneInfos = getOccupantZones(occupantType);
+            for (int i = 0; i < zoneInfos.size(); i++) {
+                passengerZones.add(zoneInfos.get(i).zoneId);
             }
         }
-        return OccupantZoneInfo.INVALID_ZONE_ID;
+        return passengerZones;
     }
 
     /**
      * Creates a new passenger user when there is no passenger user.
      */
-    private void setupPassengerUser() {
+    private void setupPassengerUser(String passengerName) {
         int currentUser = ActivityManager.getCurrentUser();
         int profileCount = getNumberOfManagedProfiles(currentUser);
-        if (profileCount > 0) {
+        if (profileCount > 2) {
             Slog.w(TAG, "max profile of user" + currentUser
                     + " is exceeded: current profile count is " + profileCount);
             return;
         }
         // TODO(b/140311342): Use resource string for the default passenger name.
-        UserInfo passenger = createPassenger("Passenger", currentUser);
+        UserInfo passenger = createPassenger(passengerName, currentUser);
         if (passenger == null) {
             // Couldn't create user, most likely because there are too many.
             Slog.w(TAG, "cannot create a passenger user");
@@ -2569,6 +2603,18 @@ public final class CarUserService extends ICarUserService.Stub implements CarSer
         }
     }
 
+    private int getAvailablePassengerDisplay() {
+        ZoneUserBindingHelper helper = null;
+        synchronized (mLockHelper) {
+            if (mZoneUserBindingHelper == null) {
+                Slog.w(TAG, "implementation is not delegated");
+                return 0;
+            }
+            helper = mZoneUserBindingHelper;
+        }
+        return helper.getAvailablePassengerDisplay();
+    }
+
     @NonNull
     private List<OccupantZoneInfo> getOccupantZones(@OccupantTypeEnum int occupantType) {
         ZoneUserBindingHelper helper = null;
diff --git a/tests/MultiDisplaySecondaryHomeTestLauncher/src/com/android/car/multidisplay/launcher/LauncherActivity.java b/tests/MultiDisplaySecondaryHomeTestLauncher/src/com/android/car/multidisplay/launcher/LauncherActivity.java
index bcd900497..04a5e40ee 100644
--- a/tests/MultiDisplaySecondaryHomeTestLauncher/src/com/android/car/multidisplay/launcher/LauncherActivity.java
+++ b/tests/MultiDisplaySecondaryHomeTestLauncher/src/com/android/car/multidisplay/launcher/LauncherActivity.java
@@ -20,6 +20,7 @@ import static com.android.car.multidisplay.launcher.PinnedAppListViewModel.PINNE
 
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
+import android.app.ActivityManager;
 import android.app.ActivityOptions;
 import android.app.AlertDialog;
 import android.app.Application;
@@ -229,7 +230,7 @@ public class LauncherActivity extends FragmentActivity implements AppPickedCallb
         mBackKey.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                injectInputEvent(KeyEvent.KEYCODE_BACK);
+                injectInputEvent(v, KeyEvent.KEYCODE_BACK);
             }
         });
 
@@ -237,16 +238,27 @@ public class LauncherActivity extends FragmentActivity implements AppPickedCallb
             @Override
              public void onClick(View v) {
                  Intent appIntent = new Intent();
-                 appIntent.setComponent(new ComponentName("com.android.car.multidisplay", "com.android.car.multidisplay.launcher.LauncherActivity"));
+                 appIntent.setComponent(new ComponentName("com.android.car.multidisplay",
+                         "com.android.car.multidisplay.launcher.LauncherActivity"));
                  appIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-                 getApplicationContext().startActivityAsUser(appIntent, android.os.Process.myUserHandle());
+                 if (android.os.Process.myUserHandle().getIdentifier() != ActivityManager.getCurrentUser()) {
+                     getApplicationContext().startActivityAsUser(appIntent, android.os.Process.myUserHandle());
+                 } else {
+                     final ActivityOptions options = ActivityOptions.makeBasic();
+                     options.setLaunchDisplayId(v.getDisplay().getDisplayId());
+                     try {
+                         getApplicationContext().startActivity(appIntent, options.toBundle());
+                     } catch (Exception e) {
+                         // Exception
+                     }
+                 }
              }
         });
 
     }
 
-    void injectInputEvent(int keycode) {
-        mDisplayId = getLauncherDisplayId();
+    void injectInputEvent(View view, int keycode) {
+        mDisplayId = view.getDisplay().getDisplayId();
         long downTime = SystemClock.uptimeMillis();
         KeyEvent keyEvent_down = new KeyEvent(downTime, downTime, KeyEvent.ACTION_DOWN, keycode, 0);
         keyEvent_down.setDisplayId(mDisplayId);
-- 
2.17.1

