From 525f6f76bf4835381dea3af99304806d8f651e0e Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Wed, 28 Aug 2024 12:50:32 +0530
Subject: [PATCH] enable virtio camera evs in A15

---
 cpp/evs/apps/default/evs_app.rc               |   1 -
 cpp/evs/apps/default/res/config.json          |  10 +-
 cpp/evs/apps/default/src/EvsStateControl.cpp  |   2 +-
 cpp/evs/apps/default/src/RenderDirectView.cpp |   5 +
 cpp/evs/manager/aidl/evsmanagerd.rc           |   1 -
 .../sampleDriver/aidl/include/EvsEnumerator.h |   2 +
 .../sampleDriver/aidl/include/MediaControl.h  | 244 ++++++
 cpp/evs/sampleDriver/aidl/include/NodeInfo.h  |  51 ++
 cpp/evs/sampleDriver/aidl/include/SysCall.h   |  81 ++
 .../sampleDriver/aidl/include/VideoCapture.h  |   8 +
 .../sampleDriver/aidl/include/bufferCopy.h    |   3 +
 .../sampleDriver/aidl/include/v4l2-subdev.h   | 171 ++++
 ...ndroid.hardware.automotive.evs-default.xml |   1 +
 .../sampleDriver/aidl/src/EvsEnumerator.cpp   |  23 +-
 .../sampleDriver/aidl/src/EvsV4lCamera.cpp    |   5 +-
 .../sampleDriver/aidl/src/MediaControl.cpp    | 799 ++++++++++++++++++
 cpp/evs/sampleDriver/aidl/src/NodeInfo.cpp    |  57 ++
 cpp/evs/sampleDriver/aidl/src/SysCall.cpp     | 171 ++++
 .../sampleDriver/aidl/src/VideoCapture.cpp    | 212 +++--
 cpp/evs/sampleDriver/aidl/src/bufferCopy.cpp  |  27 +
 20 files changed, 1810 insertions(+), 64 deletions(-)
 create mode 100644 cpp/evs/sampleDriver/aidl/include/MediaControl.h
 create mode 100644 cpp/evs/sampleDriver/aidl/include/NodeInfo.h
 create mode 100644 cpp/evs/sampleDriver/aidl/include/SysCall.h
 create mode 100644 cpp/evs/sampleDriver/aidl/include/v4l2-subdev.h
 create mode 100644 cpp/evs/sampleDriver/aidl/src/MediaControl.cpp
 create mode 100644 cpp/evs/sampleDriver/aidl/src/NodeInfo.cpp
 create mode 100644 cpp/evs/sampleDriver/aidl/src/SysCall.cpp

diff --git a/cpp/evs/apps/default/evs_app.rc b/cpp/evs/apps/default/evs_app.rc
index 35cb73045..4ce1bce31 100644
--- a/cpp/evs/apps/default/evs_app.rc
+++ b/cpp/evs/apps/default/evs_app.rc
@@ -3,7 +3,6 @@ service evs_app /system/bin/evs_app
     priority -20
     user automotive_evs
     group automotive_evs
-    disabled # will not automatically start with its class; must be explictly started.
 
 on late-init
     start evs_app
diff --git a/cpp/evs/apps/default/res/config.json b/cpp/evs/apps/default/res/config.json
index a6ab7484b..333afd8c7 100644
--- a/cpp/evs/apps/default/res/config.json
+++ b/cpp/evs/apps/default/res/config.json
@@ -9,7 +9,7 @@
   "displays" : [
     {
       "_comment": "Seahawk",
-      "displayPort" : 129,
+      "displayPort" : 0,
       "frontRange" : 100,
       "rearRange" : 100
     },
@@ -26,7 +26,7 @@
   },
   "cameras" : [
     {
-      "cameraId" : "/dev/video10",
+      "cameraId" : "/dev/video0",
       "function" : "reverse,park",
       "x" : 0.0,
       "y" : 20.0,
@@ -40,7 +40,7 @@
       "vflip" : false
     },
     {
-      "cameraId" : "/dev/video11",
+      "cameraId" : "/dev/video1",
       "function" : "front,park",
       "x" : 0.0,
       "y" : 100.0,
@@ -54,7 +54,7 @@
       "vflip" : false
     },
     {
-      "cameraId" : "/dev/video12",
+      "cameraId" : "/dev/video2",
       "function" : "right,park",
       "x" : -25.0,
       "y" : 60.0,
@@ -68,7 +68,7 @@
       "vflip" : false
     },
     {
-      "cameraId" : "/dev/video13",
+      "cameraId" : "/dev/video3",
       "function" : "left, park",
       "x" : 20.0,
       "y" : 60.0,
diff --git a/cpp/evs/apps/default/src/EvsStateControl.cpp b/cpp/evs/apps/default/src/EvsStateControl.cpp
index 0192563ac..91dd7abda 100644
--- a/cpp/evs/apps/default/src/EvsStateControl.cpp
+++ b/cpp/evs/apps/default/src/EvsStateControl.cpp
@@ -323,7 +323,7 @@ bool EvsStateControl::configureEvsPipeline(State desiredState) {
     // Used by CarStats to accurately compute stats, it needs to be close to the beginning.
     auto desiredStateTimeMillis = android::uptimeMillis();
 
-    LOG(DEBUG) << "Switching to state " << desiredState;
+    LOG(INFO) << "Switching to state " << desiredState;
     LOG(DEBUG) << "  Current state " << mCurrentState << " has "
                << mCameraList[mCurrentState].size() << " cameras";
     LOG(DEBUG) << "  Desired state " << desiredState << " has " << mCameraList[desiredState].size()
diff --git a/cpp/evs/apps/default/src/RenderDirectView.cpp b/cpp/evs/apps/default/src/RenderDirectView.cpp
index e31957a10..dd8e29f27 100644
--- a/cpp/evs/apps/default/src/RenderDirectView.cpp
+++ b/cpp/evs/apps/default/src/RenderDirectView.cpp
@@ -122,7 +122,12 @@ bool RenderDirectView::activate() {
         LOG(WARNING) << "No stream configuration data is found; "
                      << "default parameters will be used.";
     }
+    // This client always wants below input data format
+    targetCfg->format = aidl::android::hardware::graphics::common::PixelFormat::RGBA_8888;
+    foundCfg = true;
 
+    targetCfg->width = 1920;
+    targetCfg->height = 1080;
     // Construct our video texture
     mTexture.reset(createVideoTexture(mEnumerator, mCameraDesc.id.c_str(), std::move(targetCfg),
                                       sDisplay, mConfig.getUseExternalMemory(),
diff --git a/cpp/evs/manager/aidl/evsmanagerd.rc b/cpp/evs/manager/aidl/evsmanagerd.rc
index b2af31f54..f6c773a70 100644
--- a/cpp/evs/manager/aidl/evsmanagerd.rc
+++ b/cpp/evs/manager/aidl/evsmanagerd.rc
@@ -3,4 +3,3 @@ service evsmanagerd /system/bin/evsmanagerd
     priority -20
     user automotive_evs
     group automotive_evs system
-    disabled # will not automatically start with its class; must be explicitly started.
diff --git a/cpp/evs/sampleDriver/aidl/include/EvsEnumerator.h b/cpp/evs/sampleDriver/aidl/include/EvsEnumerator.h
index 313ecb7e5..84f24ec3d 100644
--- a/cpp/evs/sampleDriver/aidl/include/EvsEnumerator.h
+++ b/cpp/evs/sampleDriver/aidl/include/EvsEnumerator.h
@@ -20,6 +20,7 @@
 #include "ConfigManager.h"
 #include "EvsGlDisplay.h"
 #include "EvsV4lCamera.h"
+#include "MediaControl.h"
 
 #include <aidl/android/frameworks/automotive/display/ICarDisplayProxy.h>
 #include <aidl/android/hardware/automotive/evs/BnEvsEnumerator.h>
@@ -74,6 +75,7 @@ public:
     EvsEnumerator(const std::shared_ptr<
                   ::aidl::android::frameworks::automotive::display::ICarDisplayProxy>&
                           proxyService);
+    virtual ~EvsEnumerator();
 
     void notifyDeviceStatusChange(const std::string_view& deviceName,
                                   aidlevs::DeviceStatusType type);
diff --git a/cpp/evs/sampleDriver/aidl/include/MediaControl.h b/cpp/evs/sampleDriver/aidl/include/MediaControl.h
new file mode 100644
index 000000000..3383deec3
--- /dev/null
+++ b/cpp/evs/sampleDriver/aidl/include/MediaControl.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2015-2021 Intel Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/media.h>
+#include <v4l2-subdev.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <string>
+#include <vector>
+#include <mutex>
+#include <map>
+#include <utils/Log.h>
+#include "NodeInfo.h"
+
+struct MediaEntity;
+struct MediaPad;
+struct MediaLink;
+
+#define MEDIA_CTL_DEV_NAME "/dev/media"
+#define MEDIA_DRIVER_NAME "intel-ipu"
+#define MEDIA_DEVICE_MAX_NUM 256
+
+enum {
+    FC_FORMAT = 0,
+    FC_SELECTION = 1,
+};
+
+enum ResolutionType {
+    RESOLUTION_MAX = 0,
+    RESOLUTION_COMPOSE,
+    RESOLUTION_CROP,
+    RESOLUTION_TARGET,
+
+};
+
+struct McFormat {
+    int entity;
+    int pad;
+    int stream;
+    int formatType;
+    int selCmd;
+    int top;
+    int left;
+    int width;
+    int height;
+    enum ResolutionType type;
+    std::string entityName;
+    unsigned int pixelCode;
+};
+
+struct McOutput {
+    int port;
+    unsigned int v4l2Format;
+    int width;
+    int height;
+    McOutput() {
+        port = -1;
+        v4l2Format = 0;
+        width = 0;
+        height = 0;
+    }
+};
+
+struct McCtl {
+    int entity;
+    int ctlCmd;
+    int ctlValue;
+    std::string ctlName;
+    std::string entityName;
+    McCtl() {
+        entity = 0;
+        ctlCmd = 0;
+        ctlValue = 0;
+    }
+};
+
+struct McLink {
+    int srcEntity;
+    int srcPad;
+    int sinkEntity;
+    int sinkPad;
+    bool enable;
+    std::string srcEntityName;
+    std::string sinkEntityName;
+};
+
+struct McRoute {
+    int entity;
+    uint32_t sinkPad;
+    uint32_t sinkStream;
+    uint32_t srcPad;
+    uint32_t srcStream;
+    uint32_t flag;
+    std::string entityName;
+    McRoute() {
+        entity = 0;
+        sinkPad = 0;
+        srcPad = 0;
+        sinkStream = 0;
+        srcStream = 0;
+        flag = 0;
+        entityName.clear();
+    }
+};
+
+struct McVideoNode {
+    std::string name;
+    VideoNodeType videoNodeType;
+    McVideoNode() { videoNodeType = VIDEO_GENERIC; }
+};
+
+struct MediaCtlConf {
+    std::vector<McCtl> ctls;
+    std::vector<McLink> links;
+    std::vector<McRoute> routes;
+    std::vector<McFormat> formats;
+    std::vector<McOutput> outputs;
+    std::vector<McVideoNode> videoNodes;
+    int mcId;
+    int outputWidth;
+    int outputHeight;
+    int format;
+    /*
+     * The outputWidth or outputHeight is 0 if there isn't this setting
+     * in MediaCtlConf. It means the isys output size is dynamic, and
+     * we don't use stream size to select MC.
+     */
+    MediaCtlConf() {
+        mcId = -1;
+        outputWidth = 0;
+        outputHeight = 0;
+        format = -1;
+    }
+};
+
+/**
+ * \class MediaController
+ *
+ * This class is used for discovering and configuring the internal topology
+ * of a media device. Devices are modelled as an oriented graph of building
+ * blocks called media entities. The media entities are connected to each other
+ * through pads.
+ *
+ * Each media entity corresponds to a V4L2 subdevice. This class is also used
+ * for configuring the V4L2 subdevices.
+ */
+
+class MediaControl {
+ public:
+    /**
+     * \brief Get the singleton instance of MediaControl
+     */
+    static MediaControl* getInstance();
+
+    /**
+     * \brief Release the singleton instance of MediaControl.
+     */
+    static void releaseInstance();
+
+    /**
+     * \brief Enum entities and link, and reset all links
+     *
+     * \return 0 if succeed, other value indicates failed
+     */
+    int initEntities();
+
+    /**
+     * \brief Free all entities and links memory
+     */
+    void clearEntities();
+
+    /**
+     * \brief Get the entity by name
+     *
+     * \return entity id if succeed or -1 if error
+     */
+    int getEntityIdByName(const char* name);
+
+    int resetAllLinks();
+    // VIRTUAL_CHANNEL_S
+    int resetAllRoutes();
+    // VIRTUAL_CHANNEL_E
+    int createLink();
+
+ private:
+    MediaControl& operator=(const MediaControl&);
+    MediaControl(const char* devName);
+    ~MediaControl();
+
+    static MediaControl* getMediaControlInstance();
+    int openDevice();
+    void closeDevice(int fd);
+    void getDeviceName(const char* entityName, std::string& deviceNodeName, bool isSubDev);
+    int SetRouting(int fd, v4l2_subdev_route* routes, uint32_t numRoutes);
+    int GetRouting(int fd, v4l2_subdev_route* routes, uint32_t* numRoutes);
+
+    // enum MediaControl info.
+    int enumInfo();
+    int enumLinks(int fd);
+    int enumEntities(int fd);
+
+    // get entity info.
+    int getDevnameFromSysfs(MediaEntity* entity);
+    MediaEntity* getEntityById(uint32_t id);
+    MediaEntity* getEntityByName(const char* name);
+
+    // set up entity link.
+
+    MediaLink* entityAddLink(MediaEntity* entity);
+    int setupLink(uint32_t srcEntity, uint32_t srcPad, uint32_t sinkEntity, uint32_t sinkPad,
+                  bool enable);
+    int setupLink(MediaPad* source, MediaPad* sink, uint32_t flags);
+
+    int SetFormat(int fd, const struct v4l2_subdev_format& format);
+    int setSelection(int cameraId, const McFormat* format, int targetWidth, int targetHeight);
+
+    std::string mDevName;
+    std::vector<MediaEntity> mEntities;
+
+    static MediaControl* sInstance;
+    static std::mutex sLock;
+};
diff --git a/cpp/evs/sampleDriver/aidl/include/NodeInfo.h b/cpp/evs/sampleDriver/aidl/include/NodeInfo.h
new file mode 100644
index 000000000..8e8401266
--- /dev/null
+++ b/cpp/evs/sampleDriver/aidl/include/NodeInfo.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2020 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+enum VideoNodeType {
+    // video node device
+    VIDEO_GENERIC,
+    VIDEO_GENERIC_MEDIUM_EXPO,
+    VIDEO_GENERIC_SHORT_EXPO,
+    // CSI_META_S
+    VIDEO_CSI_META,
+    // CSI_META_E
+
+    // sensor subdevice
+    VIDEO_PIXEL_ARRAY,
+    VIDEO_PIXEL_BINNER,
+    VIDEO_PIXEL_SCALER,
+
+    // ISP subdevice
+    VIDEO_ISYS_RECEIVER,
+    VIDEO_ISYS_RECEIVER_BACKEND,
+};
+
+struct VideoNodeInfo {
+    VideoNodeType type;
+    const char* fullName;
+    const char* shortName;
+};
+
+enum EncodeBufferType {
+    ENCODE_ISA_CONFIG = 0,
+    ENCODE_STATS = 1,
+};
+
+extern const VideoNodeInfo gVideoNodeInfos[];
+extern const char* GetNodeName(VideoNodeType nodeType);
+extern VideoNodeType GetNodeType(const char* nodeName);
diff --git a/cpp/evs/sampleDriver/aidl/include/SysCall.h b/cpp/evs/sampleDriver/aidl/include/SysCall.h
new file mode 100644
index 000000000..116a635fa
--- /dev/null
+++ b/cpp/evs/sampleDriver/aidl/include/SysCall.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2015-2021 Intel Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <errno.h>
+#include <fcntl.h>
+#include <linux/media.h>
+#include <linux/v4l2-subdev.h>
+#include <linux/videodev2.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <mutex>
+
+class SysCall {
+ protected:
+    SysCall();
+    virtual ~SysCall();
+
+ public:
+    virtual int open(const char* pathname, int flags);
+    virtual int close(int fd);
+    virtual void* mmap(void* addr, size_t len, int prot, int flag, int filedes, off_t off);
+    virtual int munmap(void* addr, size_t len);
+
+    virtual int ioctl(int fd, int request, struct media_device_info* arg);
+    virtual int ioctl(int fd, int request, struct media_link_desc* arg);
+    virtual int ioctl(int fd, int request, struct media_links_enum* arg);
+    virtual int ioctl(int fd, int request, struct media_links_desc* arg);
+    virtual int ioctl(int fd, int request, struct media_entity_desc* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_capability* arg);
+    virtual int ioctl(int fd, int request, v4l2_fmtdesc* arg);
+    virtual int ioctl(int fd, int request, enum v4l2_buf_type* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_format* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_requestbuffers* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_buffers* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_buffer* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_subdev_format* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_subdev_stream* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_streamon_info* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_ext_controls* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_control* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_queryctrl* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_subdev_selection* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_subdev_routing* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_querymenu* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_event_subscription* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_event* arg);
+    virtual int ioctl(int fd, int request, struct v4l2_exportbuffer* arg);
+
+    virtual int poll(struct pollfd* pfd, nfds_t nfds, int timeout);
+
+    static SysCall* getInstance();
+    static void updateInstance(SysCall* newSysCall);
+
+ private:
+    int ioctl(int fd, int request, void* arg);
+
+    SysCall& operator=(const SysCall&);  // Don't call me
+
+    static bool sIsInitialized;
+    static SysCall* sInstance;
+    static std::mutex sLock;
+};
diff --git a/cpp/evs/sampleDriver/aidl/include/VideoCapture.h b/cpp/evs/sampleDriver/aidl/include/VideoCapture.h
index 18537ad15..92ec2c5ab 100644
--- a/cpp/evs/sampleDriver/aidl/include/VideoCapture.h
+++ b/cpp/evs/sampleDriver/aidl/include/VideoCapture.h
@@ -25,6 +25,11 @@
 
 typedef v4l2_buffer imageBuffer;
 
+#define VIDEO_PLANES 1
+#define BUFFER_COUNT 6
+#define WIDTH 1920
+#define HEIGHT 1080
+
 class VideoCapture final {
 public:
     bool open(const char* deviceName, const int32_t width = 0, const int32_t height = 0);
@@ -65,8 +70,11 @@ private:
     bool returnFrame(int id);
 
     int mDeviceFd = -1;
+    uint32_t mBufferType = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
 
     int mNumBuffers = 0;
+    uint32_t mBufferSize;
+
     std::unique_ptr<v4l2_buffer[]> mBufferInfos = nullptr;
     std::unique_ptr<void*[]> mPixelBuffers = nullptr;
 
diff --git a/cpp/evs/sampleDriver/aidl/include/bufferCopy.h b/cpp/evs/sampleDriver/aidl/include/bufferCopy.h
index 21484cc88..eeabc5c41 100644
--- a/cpp/evs/sampleDriver/aidl/include/bufferCopy.h
+++ b/cpp/evs/sampleDriver/aidl/include/bufferCopy.h
@@ -31,6 +31,9 @@ void fillNV21FromYUYV(const ::aidl::android::hardware::automotive::evs::BufferDe
 void fillRGBAFromYUYV(const ::aidl::android::hardware::automotive::evs::BufferDesc& tgtBuff,
                       uint8_t* tgt, void* imgData, unsigned imgStride);
 
+void fillRGBAFromUYVY(const BufferDesc& tgtBuff, uint8_t* tgt,
+                      void* imgData, unsigned imgStride);
+
 void fillYUYVFromYUYV(const ::aidl::android::hardware::automotive::evs::BufferDesc& tgtBuff,
                       uint8_t* tgt, void* imgData, unsigned imgStride);
 
diff --git a/cpp/evs/sampleDriver/aidl/include/v4l2-subdev.h b/cpp/evs/sampleDriver/aidl/include/v4l2-subdev.h
new file mode 100644
index 000000000..94a89b636
--- /dev/null
+++ b/cpp/evs/sampleDriver/aidl/include/v4l2-subdev.h
@@ -0,0 +1,171 @@
+/****************************************************************************
+ ****************************************************************************
+ ***
+ ***   This header was automatically generated from a Linux kernel header
+ ***   of the same name, to make information necessary for userspace to
+ ***   call into the kernel available to libc.  It contains only constants,
+ ***   structures, and macros generated from the original header, and thus,
+ ***   contains no copyrightable information.
+ ***
+ ***   To edit the content of this header, modify the corresponding
+ ***   source file (e.g. under external/kernel-headers/original/) then
+ ***   run bionic/libc/kernel/tools/update_all.py
+ ***
+ ***   Any manual change here will be lost the next time this script will
+ ***   be run. You've been warned!
+ ***
+ ****************************************************************************
+ ****************************************************************************/
+#ifndef __LINUX_V4L2_SUBDEV_H
+#define __LINUX_V4L2_SUBDEV_H
+#include <linux/ioctl.h>
+#include <linux/types.h>
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#include <linux/v4l2-common.h>
+#include <linux/v4l2-mediabus.h>
+enum v4l2_subdev_format_whence {
+  V4L2_SUBDEV_FORMAT_TRY = 0,
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  V4L2_SUBDEV_FORMAT_ACTIVE = 1,
+};
+struct v4l2_subdev_format {
+  __u32 which;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 pad;
+  struct v4l2_mbus_framefmt format;
+   __u32 stream;
+  __u32 reserved[7];
+};
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+struct v4l2_subdev_crop {
+  __u32 which;
+  __u32 pad;
+  struct v4l2_rect rect;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 reserved[8];
+};
+struct v4l2_subdev_mbus_code_enum {
+  __u32 pad;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 index;
+  __u32 code;
+  __u32 which;
+  __u32 reserved[8];
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+};
+struct v4l2_subdev_frame_size_enum {
+  __u32 index;
+  __u32 pad;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 code;
+  __u32 min_width;
+  __u32 max_width;
+  __u32 min_height;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 max_height;
+  __u32 which;
+  __u32 reserved[8];
+};
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+struct v4l2_subdev_frame_interval {
+  __u32 pad;
+  struct v4l2_fract interval;
+  __u32 reserved[9];
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+};
+struct v4l2_subdev_frame_interval_enum {
+  __u32 index;
+  __u32 pad;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 code;
+  __u32 width;
+  __u32 height;
+  struct v4l2_fract interval;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 which;
+  __u32 reserved[8];
+};
+struct v4l2_subdev_selection {
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  __u32 which;
+  __u32 pad;
+  __u32 target;
+  __u32 flags;
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+  struct v4l2_rect r;
+  __u32 reserved[8];
+};
+#define v4l2_subdev_edid v4l2_edid
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define VIDIOC_SUBDEV_G_FMT _IOWR('V', 4, struct v4l2_subdev_format)
+#define VIDIOC_SUBDEV_S_FMT _IOWR('V', 5, struct v4l2_subdev_format)
+#define VIDIOC_SUBDEV_G_FRAME_INTERVAL _IOWR('V', 21, struct v4l2_subdev_frame_interval)
+#define VIDIOC_SUBDEV_S_FRAME_INTERVAL _IOWR('V', 22, struct v4l2_subdev_frame_interval)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define VIDIOC_SUBDEV_ENUM_MBUS_CODE _IOWR('V', 2, struct v4l2_subdev_mbus_code_enum)
+#define VIDIOC_SUBDEV_ENUM_FRAME_SIZE _IOWR('V', 74, struct v4l2_subdev_frame_size_enum)
+#define VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL _IOWR('V', 75, struct v4l2_subdev_frame_interval_enum)
+#define VIDIOC_SUBDEV_G_CROP _IOWR('V', 59, struct v4l2_subdev_crop)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define VIDIOC_SUBDEV_S_CROP _IOWR('V', 60, struct v4l2_subdev_crop)
+#define VIDIOC_SUBDEV_G_SELECTION _IOWR('V', 61, struct v4l2_subdev_selection)
+#define VIDIOC_SUBDEV_S_SELECTION _IOWR('V', 62, struct v4l2_subdev_selection)
+#define VIDIOC_SUBDEV_G_STD _IOR('V', 23, v4l2_std_id)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define VIDIOC_SUBDEV_S_STD _IOW('V', 24, v4l2_std_id)
+#define VIDIOC_SUBDEV_ENUMSTD _IOWR('V', 25, struct v4l2_standard)
+#define VIDIOC_SUBDEV_G_EDID _IOWR('V', 40, struct v4l2_edid)
+#define VIDIOC_SUBDEV_S_EDID _IOWR('V', 41, struct v4l2_edid)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define VIDIOC_SUBDEV_QUERYSTD _IOR('V', 63, v4l2_std_id)
+#define VIDIOC_SUBDEV_S_DV_TIMINGS _IOWR('V', 87, struct v4l2_dv_timings)
+#define VIDIOC_SUBDEV_G_DV_TIMINGS _IOWR('V', 88, struct v4l2_dv_timings)
+#define VIDIOC_SUBDEV_ENUM_DV_TIMINGS _IOWR('V', 98, struct v4l2_enum_dv_timings)
+/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */
+#define VIDIOC_SUBDEV_QUERY_DV_TIMINGS _IOR('V', 99, struct v4l2_dv_timings)
+#define VIDIOC_SUBDEV_DV_TIMINGS_CAP _IOWR('V', 100, struct v4l2_dv_timings_cap)
+#define VIDIOC_SUBDEV_S_ROUTING _IOWR('V', 39, struct v4l2_subdev_routing)
+#define VIDIOC_SUBDEV_G_ROUTING _IOWR('V', 38, struct v4l2_subdev_routing)
+#define V4L2_SUBDEV_ROUTE_FL_ACTIVE (1 << 0)
+#define V4L2_SUBDEV_ROUTE_FL_IMMUTABLE (1 << 1)
+#define V4L2_SUBDEV_ROUTE_FL_SOURCE (1 << 2)
+/**
+ * struct v4l2_subdev_route - A signal route inside a subdev
+ * @sink_pad: the sink pad
+ * @sink_stream: the sink stream
+ * @source_pad: the source pad
+ * @source_stream: the source stream
+ * @flags: route flags:
+ *
+ * V4L2_SUBDEV_ROUTE_FL_ACTIVE: Is the stream in use or not? An
+ * active stream will start when streaming is enabled on a video
+ * node. Set by the user.
+ *
+ * V4L2_SUBDEV_ROUTE_FL_SOURCE: Is the sub-device the source of a
+ * stream? In this case the sink information is unused (and
+ * zero). Set by the driver.
+ *
+ * V4L2_SUBDEV_ROUTE_FL_IMMUTABLE: Is the stream immutable, i.e.
+ * can it be activated and inactivated? Set by the driver.
+ */
+struct v4l2_subdev_route {
+ __u32 sink_pad;
+ __u32 sink_stream;
+ __u32 source_pad;
+ __u32 source_stream;
+ __u32 flags;
+ __u32 reserved[5];
+};
+
+/**
+ * struct v4l2_subdev_routing - Routing information
+ * @routes: the routes array
+ * @num_routes: the total number of routes in the routes array
+ */
+struct v4l2_subdev_routing {
+ struct v4l2_subdev_route *routes;
+ __u32 num_routes;
+ __u32 reserved[5];
+};
+
+#endif
diff --git a/cpp/evs/sampleDriver/aidl/manifest_android.hardware.automotive.evs-default.xml b/cpp/evs/sampleDriver/aidl/manifest_android.hardware.automotive.evs-default.xml
index ae37ad3f6..78a32a627 100644
--- a/cpp/evs/sampleDriver/aidl/manifest_android.hardware.automotive.evs-default.xml
+++ b/cpp/evs/sampleDriver/aidl/manifest_android.hardware.automotive.evs-default.xml
@@ -1,6 +1,7 @@
 <manifest version="1.0" type="device">
     <hal format="aidl">
         <name>android.hardware.automotive.evs</name>
+        <version>2</version>
         <fqname>IEvsEnumerator/hw/1</fqname>
     </hal>
 </manifest>
diff --git a/cpp/evs/sampleDriver/aidl/src/EvsEnumerator.cpp b/cpp/evs/sampleDriver/aidl/src/EvsEnumerator.cpp
index b79ed101a..7924ff43c 100644
--- a/cpp/evs/sampleDriver/aidl/src/EvsEnumerator.cpp
+++ b/cpp/evs/sampleDriver/aidl/src/EvsEnumerator.cpp
@@ -146,11 +146,26 @@ EvsEnumerator::EvsEnumerator(const std::shared_ptr<ICarDisplayProxy>& proxyServi
         sDisplayProxy = proxyService;
     }
 
+    MediaControl* mc = MediaControl::getInstance();
+    if (mc) {
+        mc->initEntities();
+        mc->resetAllRoutes();
+        mc->createLink();
+    }
+
     // Enumerate existing devices
     enumerateCameras();
     mInternalDisplayId = enumerateDisplays();
 }
 
+EvsEnumerator::~EvsEnumerator() {
+    MediaControl* mc = MediaControl::getInstance();
+    if (mc) {
+        mc->clearEntities();
+        MediaControl::releaseInstance();
+    }
+}
+
 bool EvsEnumerator::checkPermission() {
     const auto uid = AIBinder_getCallingUid();
     if (kAllowedUids.find(uid) == kAllowedUids.end()) {
@@ -613,14 +628,15 @@ bool EvsEnumerator::qualifyCaptureDevice(const char* deviceName) {
     if (result < 0) {
         return false;
     }
-    if (((caps.capabilities & V4L2_CAP_VIDEO_CAPTURE) == 0) ||
+    if (((caps.capabilities & (V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_CAPTURE_MPLANE)) == 0) ||
         ((caps.capabilities & V4L2_CAP_STREAMING) == 0)) {
         return false;
     }
 
     // Enumerate the available capture formats (if any)
     v4l2_fmtdesc formatDescription;
-    formatDescription.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    formatDescription.type = (caps.capabilities & V4L2_CAP_VIDEO_CAPTURE) ? V4L2_BUF_TYPE_VIDEO_CAPTURE : V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+
     bool found = false;
     for (int i = 0; !found; ++i) {
         formatDescription.index = i;
@@ -631,6 +647,7 @@ bool EvsEnumerator::qualifyCaptureDevice(const char* deviceName) {
                        << formatDescription.flags;
             switch (formatDescription.pixelformat) {
                 case V4L2_PIX_FMT_YUYV:
+                case V4L2_PIX_FMT_UYVY:
                     found = true;
                     break;
                 case V4L2_PIX_FMT_NV21:
@@ -654,7 +671,7 @@ bool EvsEnumerator::qualifyCaptureDevice(const char* deviceName) {
                     break;
 #endif  // V4L2_PIX_FMT_ARGB32
                 default:
-                    LOG(WARNING) << "Unsupported, " << std::hex << formatDescription.pixelformat;
+                    LOG(WARNING) << "Shiva Unsupported, " << std::hex << formatDescription.pixelformat;
                     break;
             }
         } else {
diff --git a/cpp/evs/sampleDriver/aidl/src/EvsV4lCamera.cpp b/cpp/evs/sampleDriver/aidl/src/EvsV4lCamera.cpp
index f9338c641..1a6816d34 100644
--- a/cpp/evs/sampleDriver/aidl/src/EvsV4lCamera.cpp
+++ b/cpp/evs/sampleDriver/aidl/src/EvsV4lCamera.cpp
@@ -39,7 +39,7 @@ using ::android::base::Result;
 using ::ndk::ScopedAStatus;
 
 // Default camera output image resolution
-constexpr std::array<int32_t, 2> kDefaultResolution = {640, 480};
+const std::array<int32_t, 2> kDefaultResolution = {WIDTH, HEIGHT};
 
 // Arbitrary limit on number of graphics buffers allowed to be allocated
 // Safeguards against unreasonable resource consumption and provides a testable limit
@@ -185,6 +185,9 @@ ScopedAStatus EvsV4lCamera::startVideoStream(const std::shared_ptr<IEvsCameraStr
                 case V4L2_PIX_FMT_YUYV:
                     mFillBufferFromVideo = fillRGBAFromYUYV;
                     break;
+                case V4L2_PIX_FMT_UYVY:
+                    mFillBufferFromVideo = fillRGBAFromUYVY;
+                    break;
                 default:
                     LOG(ERROR) << "Unhandled camera source format " << (char*)&videoSrcFormat;
             }
diff --git a/cpp/evs/sampleDriver/aidl/src/MediaControl.cpp b/cpp/evs/sampleDriver/aidl/src/MediaControl.cpp
new file mode 100644
index 000000000..1a50a79db
--- /dev/null
+++ b/cpp/evs/sampleDriver/aidl/src/MediaControl.cpp
@@ -0,0 +1,799 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (C) 2015-2021 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "MediaControl.h"
+#include "VideoCapture.h"
+
+#include <linux/v4l2-mediabus.h>
+#include <linux/videodev2.h>
+
+#include <stack>
+#include <string>
+#include <dirent.h>
+#include <dlfcn.h>
+#include "SysCall.h"
+
+using std::string;
+using std::vector;
+
+#define MAX_SYS_NAME 64
+#define MAX_TARGET_NAME 256
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+
+struct MediaLink {
+    MediaPad* source;
+    MediaPad* sink;
+    MediaLink* twin;
+    uint32_t flags;
+    uint32_t padding[3];
+};
+
+struct MediaPad {
+    MediaEntity* entity;
+    uint32_t index;
+    uint32_t flags;
+    uint32_t padding[3];
+};
+
+struct MediaEntity {
+    media_entity_desc info;
+    MediaPad* pads;
+    MediaLink* links;
+    unsigned int maxLinks;
+    unsigned int numLinks;
+
+    char devname[32];
+};
+
+MediaControl* MediaControl::sInstance = nullptr;
+std::mutex MediaControl::sLock;
+
+int MediaControl::createLink() {
+    int ret = 0;
+    McFormat formats[] = {
+        {.entityName = "Intel IPU6 CSI-2 1",
+         .pad = 0,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "Intel IPU6 CSI-2 1",
+         .pad = 1,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "isx031 a",
+         .pad = 0,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "isx031 b",
+         .pad = 0,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "isx031 c",
+         .pad = 0,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "isx031 d",
+         .pad = 0,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "TI960 a",
+         .pad = 0,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "TI960 a",
+         .pad = 1,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "TI960 a",
+         .pad = 2,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "TI960 a",
+         .pad = 3,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "TI960 a",
+         .pad = 4,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "Intel IPU6 CSI2 BE SOC 0",
+         .pad = 0,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "Intel IPU6 CSI2 BE SOC 0",
+         .pad = 1,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "Intel IPU6 CSI2 BE SOC 0",
+         .pad = 2,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "Intel IPU6 CSI2 BE SOC 0",
+         .pad = 3,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+        {.entityName = "Intel IPU6 CSI2 BE SOC 0",
+         .pad = 4,
+         .pixelCode = V4L2_MBUS_FMT_UYVY8_1X16,
+         .width = WIDTH,
+         .height = HEIGHT},
+    };
+
+    McLink links[] = {
+        {.srcEntityName = "isx031 a", .srcPad = 0, .sinkEntityName = "TI960 a", .sinkPad = 0},
+        {.srcEntityName = "isx031 b", .srcPad = 0, .sinkEntityName = "TI960 a", .sinkPad = 1},
+        {.srcEntityName = "isx031 c", .srcPad = 0, .sinkEntityName = "TI960 a", .sinkPad = 2},
+        {.srcEntityName = "isx031 d", .srcPad = 0, .sinkEntityName = "TI960 a", .sinkPad = 3},
+        {.srcEntityName = "TI960 a",
+         .srcPad = 4,
+         .sinkEntityName = "Intel IPU6 CSI-2 1",
+         .sinkPad = 0},
+        {.srcEntityName = "Intel IPU6 CSI-2 1",
+         .srcPad = 1,
+         .sinkEntityName = "Intel IPU6 CSI2 BE SOC 0",
+         .sinkPad = 0},
+        {.srcEntityName = "Intel IPU6 CSI2 BE SOC 0",
+         .srcPad = 1,
+         .sinkEntityName = "Intel IPU6 BE SOC capture 0",
+         .sinkPad = 0},
+        {.srcEntityName = "Intel IPU6 CSI2 BE SOC 0",
+         .srcPad = 2,
+         .sinkEntityName = "Intel IPU6 BE SOC capture 1",
+         .sinkPad = 0},
+        {.srcEntityName = "Intel IPU6 CSI2 BE SOC 0",
+         .srcPad = 3,
+         .sinkEntityName = "Intel IPU6 BE SOC capture 2",
+         .sinkPad = 0},
+        {.srcEntityName = "Intel IPU6 CSI2 BE SOC 0",
+         .srcPad = 4,
+         .sinkEntityName = "Intel IPU6 BE SOC capture 3",
+         .sinkPad = 0},
+    };
+
+    for (McFormat& format : formats) {
+        MediaEntity* entity = getEntityByName(format.entityName.c_str());
+        int fd = -1;
+        if (entity) fd = ::open(entity->devname, O_RDWR);
+
+        ALOGD("@%s, set format for %s  pad: %d", __func__, format.entityName.c_str(), format.pad);
+        if (fd >= 0) {
+            v4l2_mbus_framefmt mbusfmt;
+            memset(&mbusfmt, 0, sizeof(mbusfmt));
+            mbusfmt.width = format.width;
+            mbusfmt.height = format.height;
+            mbusfmt.code = format.pixelCode;
+
+            struct v4l2_subdev_format fmt = {};
+            fmt.pad = format.pad;
+            fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+            fmt.format = mbusfmt;
+            fmt.stream = format.stream;
+            ret = ::ioctl(fd, VIDIOC_SUBDEV_S_FMT, &fmt);
+            close(fd);
+            if (ret < 0) {
+                ALOGE("@%s, Fail set format for %s  pad: %d", __func__, format.entityName.c_str(),
+                      format.pad);
+            }
+        } else {
+            // continue link others when fails
+            ALOGE("@%s, Fail set open device %s", __func__, format.entityName.c_str());
+        }
+    }
+
+    for (McLink& link : links) {
+        ALOGD("@%s, set link : %s --> %s", __func__, link.srcEntityName.c_str(),
+              link.sinkEntityName.c_str());
+        ret = -1;
+        int srcEntity = getEntityIdByName(link.srcEntityName.c_str());
+        int sinkEntity = getEntityIdByName(link.sinkEntityName.c_str());
+        if (srcEntity >= 0 && sinkEntity >= 0) {
+            ret = setupLink(srcEntity, link.srcPad, sinkEntity, link.sinkPad, true);
+        }
+        if (ret < 0) {
+            ALOGE("@%s, Fail set link : %s --> %s", __func__, link.srcEntityName.c_str(),
+                  link.sinkEntityName.c_str());
+        }
+    }
+    return ret;
+}
+
+void MediaControl::getDeviceName(const char* entityName, string& deviceNodeName, bool isSubDev) {
+    const char* filePrefix = "video";
+    const char* dirPath = "/sys/class/video4linux/";
+    if (isSubDev) filePrefix = "v4l-subdev";
+
+    DIR* dp = opendir(dirPath);
+    if (dp == nullptr) {
+        ALOGE("@%s, Fail open : %s", __func__, dirPath);
+    }
+
+    struct dirent* dirp = nullptr;
+    while ((dirp = readdir(dp)) != nullptr) {
+        if ((dirp->d_type == DT_LNK) &&
+            (strncmp(dirp->d_name, filePrefix, strlen(filePrefix)) == 0)) {
+            string subDeviceName = dirPath;
+            subDeviceName += dirp->d_name;
+            subDeviceName += "/name";
+            int fd = open(subDeviceName.c_str(), O_RDONLY);
+            if (fd < 0) {
+                ALOGE("@%s, Fail open : %s", __func__, subDeviceName.c_str());
+            }
+
+            char buf[128] = {'\0'};
+            int len = read(fd, buf, sizeof(buf));
+            close(fd);
+            len--;  // remove "\n"
+            if (len == (int)strlen(entityName) && memcmp(buf, entityName, len) == 0) {
+                deviceNodeName = "/dev/";
+                deviceNodeName += dirp->d_name;
+                break;
+            }
+        }
+    }
+    closedir(dp);
+}
+
+MediaControl* MediaControl::getMediaControlInstance() {
+    MediaControl* mediaControlInstance = nullptr;
+
+    for (int i = 0; i < MEDIA_DEVICE_MAX_NUM; i++) {
+        std::string fileName = MEDIA_CTL_DEV_NAME;
+        fileName.append(std::to_string(i));
+
+        struct stat fileStat = {};
+        int ret = stat(fileName.c_str(), &fileStat);
+        if (ret != 0) {
+            ALOGE("%s: There is no file %s", __func__, fileName.c_str());
+            continue;
+        }
+
+        SysCall* sc = SysCall::getInstance();
+        int fd = sc->open(fileName.c_str(), O_RDWR);
+        if (fd < 0) {
+            ALOGE("%s, Open media device(%s) failed: %s", __func__, fileName.c_str(),
+                  strerror(errno));
+            break;
+        }
+
+        media_device_info info;
+        ret = sc->ioctl(fd, MEDIA_IOC_DEVICE_INFO, &info);
+        if ((ret != -1) &&
+            (0 == strncmp(info.driver, MEDIA_DRIVER_NAME, strlen(MEDIA_DRIVER_NAME)))) {
+            mediaControlInstance = new MediaControl(fileName.c_str());
+        }
+
+        if (sc->close(fd) < 0) {
+            ALOGE("Failed to close media device %s:%s", fileName.c_str(), strerror(errno));
+        }
+
+        if (mediaControlInstance) {
+            ALOGE("%s: media device name:%s", __func__, fileName.c_str());
+            break;
+        }
+    }
+
+    return mediaControlInstance;
+}
+
+MediaControl* MediaControl::getInstance() {
+    std::unique_lock<std::mutex> lock(sLock);
+    if (!sInstance) {
+        sInstance = getMediaControlInstance();
+    }
+    return sInstance;
+}
+
+void MediaControl::releaseInstance() {
+    std::unique_lock<std::mutex> lock(sLock);
+
+    if (sInstance) {
+        delete sInstance;
+        sInstance = nullptr;
+    }
+}
+
+MediaControl::MediaControl(const char* devName) : mDevName(devName) {}
+
+MediaControl::~MediaControl() {}
+
+int MediaControl::initEntities() {
+    mEntities.reserve(100);
+
+    int ret = enumInfo();
+    if (ret != 0) {
+        ALOGE("Enum Info failed.\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+void MediaControl::clearEntities() {
+    auto entity = mEntities.begin();
+    while (entity != mEntities.end()) {
+        delete[] entity->pads;
+        entity->pads = nullptr;
+        delete[] entity->links;
+        entity->links = nullptr;
+        entity = mEntities.erase(entity);
+    }
+}
+
+MediaEntity* MediaControl::getEntityByName(const char* name) {
+    for (auto& entity : mEntities) {
+        if (strcmp(name, entity.info.name) == 0) {
+            return &entity;
+        }
+    }
+
+    return nullptr;
+}
+
+int MediaControl::getEntityIdByName(const char* name) {
+    MediaEntity* entity = getEntityByName(name);
+    if (!entity) {
+        return -1;
+    }
+
+    return entity->info.id;
+}
+
+int MediaControl::resetAllLinks() {
+    for (auto& entity : mEntities) {
+        for (uint32_t j = 0; j < entity.numLinks; j++) {
+            MediaLink* link = &entity.links[j];
+
+            if (link->flags & MEDIA_LNK_FL_IMMUTABLE ||
+                link->source->entity->info.id != entity.info.id) {
+                continue;
+            }
+            int ret = setupLink(link->source, link->sink, link->flags & ~MEDIA_LNK_FL_ENABLED);
+
+            if (ret < 0) return ret;
+        }
+    }
+
+    return 0;
+}
+
+int MediaControl::SetRouting(int fd, v4l2_subdev_route* routes, uint32_t numRoutes) {
+    if (!routes) {
+        ALOGE("%s: Device node %d routes is nullptr", __func__, fd);
+        return -EINVAL;
+    }
+
+    v4l2_subdev_routing r = {routes, numRoutes, {0}};
+
+    int ret = ::ioctl(fd, VIDIOC_SUBDEV_S_ROUTING, &r);
+    if (ret < 0) {
+        ALOGE("%s: Device node %d IOCTL VIDIOC_SUBDEV_S_ROUTING error: %s", __func__, fd,
+              strerror(errno));
+        return ret;
+    }
+
+    return ret;
+}
+
+int MediaControl::GetRouting(int fd, v4l2_subdev_route* routes, uint32_t* numRoutes) {
+    if (!routes || !numRoutes) {
+        ALOGE("%s: Device node %d routes or numRoutes is nullptr", __func__, fd);
+        return -EINVAL;
+    }
+
+    v4l2_subdev_routing r = {routes, *numRoutes, {0}};
+
+    int ret = ::ioctl(fd, VIDIOC_SUBDEV_G_ROUTING, &r);
+    if (ret < 0) {
+        ALOGE("%s: Device node %d IOCTL VIDIOC_SUBDEV_G_ROUTING error: %s", __func__, fd,
+              strerror(errno));
+        return ret;
+    }
+
+    *numRoutes = r.num_routes;
+
+    return ret;
+}
+
+int MediaControl::resetAllRoutes() {
+    for (MediaEntity& entity : mEntities) {
+        struct v4l2_subdev_route routes[entity.info.pads];
+        uint32_t numRoutes = entity.info.pads;
+
+        string subDeviceNodeName;
+        subDeviceNodeName.clear();
+        getDeviceName(entity.info.name, subDeviceNodeName, true);
+        if (subDeviceNodeName.find("/dev/") == std::string::npos) {
+            continue;
+        }
+
+        int fd = ::open(subDeviceNodeName.c_str(), O_RDWR);
+        int ret = GetRouting(fd, routes, &numRoutes);
+        if (ret != 0) {
+            close(fd);
+            continue;
+        }
+
+        for (uint32_t j = 0; j < numRoutes; j++) {
+            routes[j].flags &= ~V4L2_SUBDEV_ROUTE_FL_ACTIVE;
+        }
+
+        ret = SetRouting(fd, routes, numRoutes);
+        if (ret < 0) {
+            ALOGW("@%s, setRouting ret:%d", __func__, ret);
+        }
+        close(fd);
+    }
+
+    return 0;
+}
+
+int MediaControl::setupLink(MediaPad* source, MediaPad* sink, uint32_t flags) {
+    MediaLink* link = nullptr;
+    media_link_desc ulink;
+    uint32_t i;
+    int ret = 0;
+
+    SysCall* sc = SysCall::getInstance();
+
+    int fd = openDevice();
+    if (fd < 0) goto done;
+
+    for (i = 0; i < source->entity->numLinks; i++) {
+        link = &source->entity->links[i];
+
+        if (link->source->entity == source->entity && link->source->index == source->index &&
+            link->sink->entity == sink->entity && link->sink->index == sink->index)
+            break;
+    }
+
+    if (i == source->entity->numLinks) {
+        ALOGE("%s: Link not found", __func__);
+        ret = -ENOENT;
+        goto done;
+    }
+
+    /* source pad */
+    memset(&ulink, 0, sizeof(media_link_desc));
+    ulink.source.entity = source->entity->info.id;
+    ulink.source.index = source->index;
+    ulink.source.flags = MEDIA_PAD_FL_SOURCE;
+
+    /* sink pad */
+    ulink.sink.entity = sink->entity->info.id;
+    ulink.sink.index = sink->index;
+    ulink.sink.flags = MEDIA_PAD_FL_SINK;
+
+    if (link) ulink.flags = flags | (link->flags & MEDIA_LNK_FL_IMMUTABLE);
+
+    ret = sc->ioctl(fd, MEDIA_IOC_SETUP_LINK, &ulink);
+    if (ret == -1) {
+        ret = -errno;
+        ALOGE("Unable to setup link (%s)", strerror(errno));
+        goto done;
+    }
+
+    if (link) {
+        link->flags = ulink.flags;
+        link->twin->flags = ulink.flags;
+    }
+
+    ret = 0;
+
+done:
+    closeDevice(fd);
+    return ret;
+}
+
+int MediaControl::setupLink(uint32_t srcEntity, uint32_t srcPad, uint32_t sinkEntity,
+                            uint32_t sinkPad, bool enable) {
+    ALOGD("@%s srcEntity %d srcPad %d sinkEntity %d sinkPad %d enable %d", __func__, srcEntity,
+          srcPad, sinkEntity, sinkPad, enable);
+
+    for (auto& entity : mEntities) {
+        for (uint32_t j = 0; j < entity.numLinks; j++) {
+            MediaLink* link = &entity.links[j];
+
+            if ((link->source->entity->info.id == srcEntity) && (link->source->index == srcPad) &&
+                (link->sink->entity->info.id == sinkEntity) && (link->sink->index == sinkPad)) {
+                if (enable)
+                    link->flags |= MEDIA_LNK_FL_ENABLED;
+                else
+                    link->flags &= ~MEDIA_LNK_FL_ENABLED;
+
+                return setupLink(link->source, link->sink, link->flags);
+            }
+        }
+    }
+
+    return -1;
+}
+
+int MediaControl::openDevice() {
+    int fd;
+    SysCall* sc = SysCall::getInstance();
+
+    fd = sc->open(mDevName.c_str(), O_RDWR);
+    if (fd < 0) {
+        ALOGE("Failed to open media device %s: %s", mDevName.c_str(), strerror(errno));
+        return -1;
+    }
+
+    return fd;
+}
+
+void MediaControl::closeDevice(int fd) {
+    if (fd < 0) return;
+
+    SysCall* sc = SysCall::getInstance();
+
+    if (sc->close(fd) < 0) {
+        ALOGE("Failed to close media device %s: %s", mDevName.c_str(), strerror(errno));
+    }
+}
+
+int MediaControl::enumInfo() {
+    SysCall* sc = SysCall::getInstance();
+
+    if (mEntities.size() > 0) return 0;
+
+    int fd = openDevice();
+    if (fd < 0) {
+        ALOGE("Open device failed.");
+        return fd;
+    }
+
+    media_device_info info;
+    int ret = sc->ioctl(fd, MEDIA_IOC_DEVICE_INFO, &info);
+    if (ret < 0) {
+        ALOGE("Unable to retrieve media device information for device %s (%s)", mDevName.c_str(),
+              strerror(errno));
+        goto done;
+    }
+
+    ret = enumEntities(fd);
+    if (ret < 0) {
+        ALOGE("Unable to enumerate entities for device %s", mDevName.c_str());
+        goto done;
+    }
+
+    ALOGD("Found %lu entities, enumerating pads and links", mEntities.size());
+
+    ret = enumLinks(fd);
+    if (ret < 0) {
+        ALOGE("Unable to enumerate pads and linksfor device %s", mDevName.c_str());
+        goto done;
+    }
+
+    ret = 0;
+
+done:
+    closeDevice(fd);
+    return ret;
+}
+
+int MediaControl::enumEntities(int fd) {
+    MediaEntity entity;
+    uint32_t id;
+    int ret;
+
+    SysCall* sc = SysCall::getInstance();
+
+    for (id = 0, ret = 0;; id = entity.info.id) {
+        memset(&entity, 0, sizeof(MediaEntity));
+        entity.info.id = id | MEDIA_ENT_ID_FLAG_NEXT;
+
+        ret = sc->ioctl(fd, MEDIA_IOC_ENUM_ENTITIES, &entity.info);
+        if (ret < 0) {
+            ret = errno != EINVAL ? -errno : 0;
+            break;
+        }
+
+        /* Number of links (for outbound links) plus number of pads (for
+         * inbound links) is a good safe initial estimate of the total
+         * number of links.
+         */
+        entity.maxLinks = entity.info.pads + entity.info.links;
+
+        entity.pads = new MediaPad[entity.info.pads];
+        entity.links = new MediaLink[entity.maxLinks];
+        getDevnameFromSysfs(&entity);
+        mEntities.push_back(entity);
+
+        /* Note: carefully to move the follow setting. It must be behind of
+         * push_back to mEntities:
+         * 1. if entity is not pushed back to mEntities, getEntityById will
+         * return NULL.
+         * 2. we can't set entity.pads[i].entity to &entity direct. Because,
+         * entity is stack variable, its scope is just this function.
+         */
+        for (uint32_t i = 0; i < entity.info.pads; ++i) {
+            entity.pads[i].entity = getEntityById(entity.info.id);
+        }
+    }
+
+    return ret;
+}
+
+int MediaControl::getDevnameFromSysfs(MediaEntity* entity) {
+    char sysName[MAX_SYS_NAME] = {'\0'};
+    char target[MAX_TARGET_NAME] = {'\0'};
+    int ret;
+
+    if (!entity) {
+        ALOGE("entity is null.");
+        return -EINVAL;
+    }
+
+    ret = snprintf(sysName, MAX_SYS_NAME, "/sys/dev/char/%u:%u", entity->info.v4l.major,
+                   entity->info.v4l.minor);
+    if (ret <= 0) {
+        ALOGE("create sysName failed ret %d.", ret);
+        return -EINVAL;
+    }
+
+    ret = readlink(sysName, target, MAX_TARGET_NAME);
+    if (ret <= 0) {
+        ALOGE("readlink sysName %s failed ret %d.", sysName, ret);
+        return -EINVAL;
+    }
+
+    char* d = strrchr(target, '/');
+    if (!d) {
+        ALOGE("target is invalid %s.", target);
+        return -EINVAL;
+    }
+    d++; /* skip '/' */
+
+    char* t = strstr(d, "dvb");
+    if (t && t == d) {
+        t = strchr(t, '.');
+        if (!t) {
+            ALOGE("target is invalid %s.", target);
+            return -EINVAL;
+        }
+        *t = '/';
+        d += 3; /* skip "dvb" */
+        snprintf(entity->devname, sizeof(entity->devname), "/dev/dvb/adapter%s", d);
+    } else {
+        snprintf(entity->devname, sizeof(entity->devname), "/dev/%s", d);
+    }
+
+    return 0;
+}
+
+int MediaControl::enumLinks(int fd) {
+    int ret = 0;
+
+    SysCall* sc = SysCall::getInstance();
+
+    for (auto& entity : mEntities) {
+        media_links_enum links;
+        uint32_t i;
+
+        links.entity = entity.info.id;
+        links.pads = new media_pad_desc[entity.info.pads];
+        links.links = new media_link_desc[entity.info.links];
+
+        if (sc->ioctl(fd, MEDIA_IOC_ENUM_LINKS, &links) < 0) {
+            ret = -errno;
+            ALOGE("Unable to enumerate pads and links (%s).", strerror(errno));
+            delete[] links.pads;
+            delete[] links.links;
+            return ret;
+        }
+
+        for (i = 0; i < entity.info.pads; ++i) {
+            entity.pads[i].entity = getEntityById(entity.info.id);
+            entity.pads[i].index = links.pads[i].index;
+            entity.pads[i].flags = links.pads[i].flags;
+        }
+
+        for (i = 0; i < entity.info.links; ++i) {
+            media_link_desc* link = &links.links[i];
+            MediaLink* fwdlink;
+            MediaLink* backlink;
+            MediaEntity* source;
+            MediaEntity* sink;
+
+            source = getEntityById(link->source.entity);
+            sink = getEntityById(link->sink.entity);
+
+            if (source == nullptr || sink == nullptr) {
+                ALOGE("WARNING entity %u link %u src %u/%u to %u/%u is invalid!", entity.info.id, i,
+                      link->source.entity, link->source.index, link->sink.entity, link->sink.index);
+                ret = -EINVAL;
+            } else if (link->source.index < 0 || link->source.index >= source->info.pads) {
+                ALOGE("WARNING entity %u link %u src %u/%u index out of range!", entity.info.id, i,
+                      link->source.entity, link->source.index);
+                ret = -EINVAL;
+            } else if (link->sink.index < 0 || link->sink.index >= sink->info.pads) {
+                ALOGE("WARNING entity %u link %u to %u/%u index out of range!", entity.info.id, i,
+                      link->sink.entity, link->sink.index);
+                ret = -EINVAL;
+            } else {
+                fwdlink = entityAddLink(source);
+                if (fwdlink) {
+                    fwdlink->source = &source->pads[link->source.index];
+                    fwdlink->sink = &sink->pads[link->sink.index];
+                    fwdlink->flags = link->flags;
+                }
+
+                backlink = entityAddLink(sink);
+                if (backlink) {
+                    backlink->source = &source->pads[link->source.index];
+                    backlink->sink = &sink->pads[link->sink.index];
+                    backlink->flags = link->flags;
+                }
+
+                if (fwdlink) fwdlink->twin = backlink;
+                if (backlink) backlink->twin = fwdlink;
+            }
+        }
+
+        delete[] links.pads;
+        delete[] links.links;
+    }
+
+    return ret;
+}
+
+MediaLink* MediaControl::entityAddLink(MediaEntity* entity) {
+    if (entity->numLinks >= entity->maxLinks) {
+        uint32_t maxLinks = entity->maxLinks * 2;
+        MediaLink* links = new MediaLink[maxLinks];
+
+        memcpy(links, entity->links, sizeof(MediaLink) * entity->maxLinks);
+        delete[] entity->links;
+
+        for (uint32_t i = 0; i < entity->numLinks; ++i) {
+            links[i].twin->twin = &links[i];
+        }
+
+        entity->maxLinks = maxLinks;
+        entity->links = links;
+    }
+
+    return &entity->links[entity->numLinks++];
+}
+
+MediaEntity* MediaControl::getEntityById(uint32_t id) {
+    bool next = id & MEDIA_ENT_ID_FLAG_NEXT;
+
+    id &= ~MEDIA_ENT_ID_FLAG_NEXT;
+
+    for (uint32_t i = 0; i < mEntities.size(); i++) {
+        if ((mEntities[i].info.id == id && !next) || (mEntities[0].info.id > id && next)) {
+            return &mEntities[i];
+        }
+    }
+
+    return nullptr;
+}
diff --git a/cpp/evs/sampleDriver/aidl/src/NodeInfo.cpp b/cpp/evs/sampleDriver/aidl/src/NodeInfo.cpp
new file mode 100644
index 000000000..bc5a61842
--- /dev/null
+++ b/cpp/evs/sampleDriver/aidl/src/NodeInfo.cpp
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2020 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "NodeInfo.h"
+#include <string.h>
+
+#define ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))
+
+const VideoNodeInfo gVideoNodeInfos[] = {
+    {VIDEO_GENERIC, "VIDEO_GENERIC", "Generic"},
+    {VIDEO_GENERIC_MEDIUM_EXPO, "VIDEO_GENERIC_MEDIUM_EXPO", "GenericMediumExpo"},
+    {VIDEO_GENERIC_SHORT_EXPO, "VIDEO_GENERIC_SHORT_EXPO", "GenericShortExpo"},
+    // CSI_META_S
+    {VIDEO_CSI_META, "VIDEO_CSI_META", "CsiMeta"},
+    // CSI_META_E
+
+    {VIDEO_PIXEL_ARRAY, "VIDEO_PIXEL_ARRAY", "PixelArray"},
+    {VIDEO_PIXEL_BINNER, "VIDEO_PIXEL_BINNER", "PixelBinner"},
+    {VIDEO_PIXEL_SCALER, "VIDEO_PIXEL_SCALER", "PixelScaler"},
+
+    {VIDEO_ISYS_RECEIVER, "VIDEO_ISYS_RECEIVER", "ISysReceiver"},
+    {VIDEO_ISYS_RECEIVER_BACKEND, "VIDEO_ISYS_RECEIVER_BACKEND", "CsiBE"},
+};
+
+const char* GetNodeName(VideoNodeType nodeType) {
+    int size = ARRAY_SIZE(gVideoNodeInfos);
+    for (int i = 0; i < size; i++) {
+        if (gVideoNodeInfos[i].type == nodeType) {
+            return gVideoNodeInfos[i].shortName;
+        }
+    }
+    return "InvalidNode";
+}
+
+VideoNodeType GetNodeType(const char* nodeName) {
+    int size = ARRAY_SIZE(gVideoNodeInfos);
+    for (int i = 0; i < size; i++) {
+        if (strcmp(gVideoNodeInfos[i].fullName, nodeName) == 0) {
+            return gVideoNodeInfos[i].type;
+        }
+    }
+
+    return VIDEO_GENERIC;
+}
diff --git a/cpp/evs/sampleDriver/aidl/src/SysCall.cpp b/cpp/evs/sampleDriver/aidl/src/SysCall.cpp
new file mode 100644
index 000000000..b66e0e60b
--- /dev/null
+++ b/cpp/evs/sampleDriver/aidl/src/SysCall.cpp
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2015-2021 Intel Corporation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "SysCall.h"
+#include <stdio.h>
+#include <utils/Log.h>
+
+static int sCreatedCount = 0;
+bool SysCall::sIsInitialized = false;
+SysCall* SysCall::sInstance = nullptr;
+// Guard for singleton instance creation
+std::mutex SysCall::sLock;
+
+/*static*/ SysCall* SysCall::getInstance() {
+    std::unique_lock<std::mutex> lock(sLock);
+    if (!sIsInitialized) {
+        // Use real sys call as default
+        sInstance = new SysCall();
+        sIsInitialized = true;
+    }
+    return sInstance;
+}
+
+void SysCall::updateInstance(SysCall* newSysCall) {
+    ALOGI("%s", __func__);
+    std::unique_lock<std::mutex> lock(sLock);
+    if (sIsInitialized) {
+        sIsInitialized = false;
+    }
+    sInstance = newSysCall;
+    if (newSysCall != nullptr) sIsInitialized = true;
+}
+
+SysCall::SysCall() {
+    sCreatedCount++;
+    ALOGI("Syscall was created %d time", sCreatedCount);
+}
+
+SysCall::~SysCall() {
+    sCreatedCount--;
+    ALOGI("Syscall was destructed %d time", sCreatedCount);
+}
+
+int SysCall::open(const char* pathname, int flags) {
+    return ::open(pathname, flags);
+}
+
+int SysCall::close(int fd) {
+    return ::close(fd);
+}
+
+void* SysCall::mmap(void* addr, size_t len, int prot, int flag, int filedes, off_t off) {
+    return ::mmap(addr, len, prot, flag, filedes, off);
+}
+
+int SysCall::munmap(void* addr, size_t len) {
+    return ::munmap(addr, len);
+}
+
+int SysCall::ioctl(int fd, int request, struct media_device_info* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct media_link_desc* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct media_links_enum* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct media_links_desc* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct media_entity_desc* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_capability* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, v4l2_fmtdesc* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, enum v4l2_buf_type* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_format* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_requestbuffers* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_buffers* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_buffer* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_subdev_format* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_subdev_stream* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+int SysCall::ioctl(int fd, int request, struct v4l2_streamon_info* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_ext_controls* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_control* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_queryctrl* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_subdev_selection* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_subdev_routing* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_querymenu* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_event_subscription* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_event* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, struct v4l2_exportbuffer* arg) {
+    return ioctl(fd, request, reinterpret_cast<void*>(arg));
+}
+
+int SysCall::ioctl(int fd, int request, void* arg) {
+    int ret = 0;
+    do {
+        ret = ::ioctl(fd, request, arg);
+    } while (-1 == ret && EINTR == errno);
+
+    return ret;
+}
+
+int SysCall::poll(struct pollfd* pfd, nfds_t nfds, int timeout) {
+    int ret = 0;
+    do {
+        ret = ::poll(pfd, nfds, timeout);
+    } while (-1 == ret && EINTR == errno);
+
+    return ret;
+}
diff --git a/cpp/evs/sampleDriver/aidl/src/VideoCapture.cpp b/cpp/evs/sampleDriver/aidl/src/VideoCapture.cpp
index d0e9009be..b2c869428 100644
--- a/cpp/evs/sampleDriver/aidl/src/VideoCapture.cpp
+++ b/cpp/evs/sampleDriver/aidl/src/VideoCapture.cpp
@@ -15,6 +15,8 @@
  */
 
 #include "VideoCapture.h"
+#include <vector>
+#include <string.h>
 
 #include <android-base/logging.h>
 
@@ -37,8 +39,10 @@
 //        the file descriptor.  This must be fixed before using this code for anything but
 //        experimentation.
 bool VideoCapture::open(const char* deviceName, const int32_t width, const int32_t height) {
+
+    LOG(INFO) <<"App requested resolution "<<width <<" "<<height;
     // If we want a polling interface for getting frames, we would use O_NONBLOCK
-    mDeviceFd = ::open(deviceName, O_RDWR, 0);
+    mDeviceFd = ::open(deviceName, O_RDWR| O_NONBLOCK, 0);
     if (mDeviceFd < 0) {
         PLOG(ERROR) << "failed to open device " << deviceName;
         return false;
@@ -53,6 +57,19 @@ bool VideoCapture::open(const char* deviceName, const int32_t width, const int32
         }
     }
 
+    // Verify we can use this device for video capture
+    if (!(caps.capabilities & (V4L2_CAP_VIDEO_CAPTURE_MPLANE | V4L2_CAP_VIDEO_CAPTURE)) ||
+        !(caps.capabilities & V4L2_CAP_STREAMING)) {
+        // Can't do streaming capture.
+        LOG(ERROR) << "Streaming capture not supported by " << deviceName;
+        return false;
+    }
+//TODO : now fixed for 720p as acrn is supported only this resolution
+    uint32_t requestWidth = 1280;
+    uint32_t requestHeight = 720;
+    mBufferType = (caps.capabilities & V4L2_CAP_VIDEO_CAPTURE) ? V4L2_BUF_TYPE_VIDEO_CAPTURE :
+                                                                 V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+
     // Report device properties
     LOG(INFO) << "Open Device: " << deviceName << " (fd = " << mDeviceFd << ")";
     LOG(DEBUG) << "  Driver: " << caps.driver;
@@ -65,53 +82,100 @@ bool VideoCapture::open(const char* deviceName, const int32_t width, const int32
     // Enumerate the available capture formats (if any)
     LOG(DEBUG) << "Supported capture formats:";
     v4l2_fmtdesc formatDescriptions;
-    formatDescriptions.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    formatDescriptions.type = mBufferType;
+//TODO : Enumerate all formats which valid fps will be handled after IPU driver support
     for (int i = 0; true; i++) {
         formatDescriptions.index = i;
         if (ioctl(mDeviceFd, VIDIOC_ENUM_FMT, &formatDescriptions) == 0) {
             LOG(DEBUG) << "  " << std::setw(2) << i << ": " << formatDescriptions.description << " "
                        << std::hex << std::setw(8) << formatDescriptions.pixelformat << " "
                        << std::hex << formatDescriptions.flags;
+            // auto detect USB camera resolution
+            struct v4l2_frmsizeenum frmsize;
+            frmsize.pixel_format = formatDescriptions.pixelformat;
+            frmsize.index = 0;
+            while (ioctl(mDeviceFd, VIDIOC_ENUM_FRAMESIZES, &frmsize) >= 0) {
+                struct v4l2_frmivalenum frmival;
+                memset(&frmival, 0, sizeof(frmival));
+                frmival.pixel_format = formatDescriptions.pixelformat;
+                if (frmsize.type == V4L2_FRMSIZE_TYPE_DISCRETE) {
+                    frmival.width = frmsize.discrete.width;
+                    frmival.height = frmsize.discrete.height;
+                    while (ioctl(mDeviceFd, VIDIOC_ENUM_FRAMEINTERVALS, &frmival) == 0) {
+                        if ((frmival.type == V4L2_FRMIVAL_TYPE_DISCRETE) &&
+                            (1.0 * frmival.discrete.denominator / frmival.discrete.numerator >
+                             29.0) &&
+                            (requestWidth * requestHeight) <
+                                frmsize.discrete.width * frmsize.discrete.height) {
+                            if(frmsize.discrete.width == (uint32_t)width && frmsize.discrete.height == (uint32_t)height) {
+                                LOG(INFO) <<"Driver support this resolution ";
+                                requestWidth = frmsize.discrete.width;
+                                requestHeight = frmsize.discrete.height;
+                                break;
+                            }
+                        }
+                        frmival.index++;
+                    }
+               } else {
+                   LOG(INFO) << "Stepwise: step_width=" << frmsize.stepwise.step_width<< " step_height=" << frmsize.stepwise.step_height;
+                   LOG(INFO) << "min_width = " << frmsize.stepwise.min_width << " min_height=" << frmsize.stepwise.min_height;
+                   LOG(INFO) << "max_width = " << frmsize.stepwise.max_width << " max_height=" << frmsize.stepwise.max_height;
+                   requestWidth = frmsize.stepwise.min_width;
+                   requestHeight = frmsize.stepwise.min_height;
+
+                }
+                frmsize.index++;
+            }
         } else {
             // No more formats available
             break;
         }
     }
-
-    // Verify we can use this device for video capture
-    if (!(caps.capabilities & V4L2_CAP_VIDEO_CAPTURE) ||
-        !(caps.capabilities & V4L2_CAP_STREAMING)) {
-        // Can't do streaming capture.
-        LOG(ERROR) << "Streaming capture not supported by " << deviceName;
-        return false;
-    }
-
     // Set our desired output format
     v4l2_format format;
-    format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    format.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
-    format.fmt.pix.width = width;
-    format.fmt.pix.height = height;
-    LOG(INFO) << "Requesting format: " << ((char*)&format.fmt.pix.pixelformat)[0]
-              << ((char*)&format.fmt.pix.pixelformat)[1] << ((char*)&format.fmt.pix.pixelformat)[2]
-              << ((char*)&format.fmt.pix.pixelformat)[3] << "(" << std::hex << std::setw(8)
-              << format.fmt.pix.pixelformat << ")";
+    format.type = mBufferType;
+    if (format.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+        format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+        format.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_UYVY;
+        format.fmt.pix_mp.width = width;
+        format.fmt.pix_mp.height = height;
+        format.fmt.pix_mp.num_planes = 1;
+        format.fmt.pix_mp.plane_fmt[0].bytesperline = width * 2;
+        format.fmt.pix_mp.plane_fmt[0].sizeimage = width * height * 2;
+    } else if (strcmp((char*)caps.driver, "virtio-camera") == 0) {
+            LOG(INFO) << "Virtio-camera"<<requestWidth <<" "<<requestHeight;
+            format.type = V4L2_CAP_VIDEO_CAPTURE;
+            format.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
+            format.fmt.pix.width = requestWidth > 0 ? requestWidth : 1280;
+            format.fmt.pix.height = requestHeight > 0 ? requestHeight : 960;
+    } else {
+        format.type = V4L2_CAP_VIDEO_CAPTURE;
+        format.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
+        format.fmt.pix.width = requestWidth > 0 ? requestWidth : width;
+        format.fmt.pix.height = requestHeight > 0 ? requestHeight : height;
+    }
 
     if (ioctl(mDeviceFd, VIDIOC_S_FMT, &format) < 0) {
         PLOG(ERROR) << "VIDIOC_S_FMT failed";
     }
 
     // Report the current output format
-    format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
     if (ioctl(mDeviceFd, VIDIOC_G_FMT, &format) == 0) {
-        mFormat = format.fmt.pix.pixelformat;
-        mWidth = format.fmt.pix.width;
-        mHeight = format.fmt.pix.height;
-        mStride = format.fmt.pix.bytesperline;
-
-        LOG(INFO) << "Current output format:  " << "fmt=0x" << std::hex
-                  << format.fmt.pix.pixelformat << ", " << std::dec << format.fmt.pix.width << " x "
-                  << format.fmt.pix.height << ", pitch=" << format.fmt.pix.bytesperline;
+        if (format.type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+            mFormat = format.fmt.pix_mp.pixelformat;
+            mWidth = format.fmt.pix_mp.width;
+            mHeight = format.fmt.pix_mp.height;
+            mStride = format.fmt.pix_mp.plane_fmt[0].bytesperline;
+        } else {
+            mFormat = format.fmt.pix.pixelformat;
+            mWidth = format.fmt.pix.width;
+            mHeight = format.fmt.pix.height;
+            mStride = format.fmt.pix.bytesperline;
+        }
+
+        LOG(INFO) << "Current output format:  "
+                  << "fmt=0x" << std::hex << mFormat << ", " << std::dec << mWidth << " x "
+                  << mHeight << ", pitch=" << mStride;
     } else {
         PLOG(ERROR) << "VIDIOC_G_FMT failed";
         return false;
@@ -148,45 +212,64 @@ bool VideoCapture::startStream(std::function<void(VideoCapture*, imageBuffer*, v
 
     // Tell the L4V2 driver to prepare our streaming buffers
     v4l2_requestbuffers bufrequest;
-    bufrequest.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    bufrequest.type = mBufferType;
     bufrequest.memory = V4L2_MEMORY_MMAP;
-    bufrequest.count = 1;
+    bufrequest.count = BUFFER_COUNT;
     if (ioctl(mDeviceFd, VIDIOC_REQBUFS, &bufrequest) < 0) {
         PLOG(ERROR) << "VIDIOC_REQBUFS failed";
         return false;
     }
 
-    mNumBuffers = bufrequest.count;
+    mNumBuffers = BUFFER_COUNT;
     mBufferInfos = std::make_unique<v4l2_buffer[]>(mNumBuffers);
     mPixelBuffers = std::make_unique<void*[]>(mNumBuffers);
 
     for (int i = 0; i < mNumBuffers; ++i) {
         // Get the information on the buffer that was created for us
         memset(&mBufferInfos[i], 0, sizeof(v4l2_buffer));
-        mBufferInfos[i].type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        mBufferInfos[i].type = mBufferType;
         mBufferInfos[i].memory = V4L2_MEMORY_MMAP;
         mBufferInfos[i].index = i;
 
+        if (mBufferInfos[i].type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+            std::vector<struct v4l2_plane> planes;
+            planes.resize(VIDEO_PLANES);
+            mBufferInfos[i].m.planes = planes.data();
+            mBufferInfos[i].length = planes.size();
+        }
+
         if (ioctl(mDeviceFd, VIDIOC_QUERYBUF, &mBufferInfos[i]) < 0) {
             PLOG(ERROR) << "VIDIOC_QUERYBUF failed";
             return false;
         }
 
+        uint32_t memOffset = mBufferInfos[i].type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE ?
+                                 mBufferInfos[i].m.planes[0].m.mem_offset :
+                                 mBufferInfos[i].m.offset;
         LOG(DEBUG) << "Buffer description:";
-        LOG(DEBUG) << "  offset: " << mBufferInfos[i].m.offset;
+        LOG(INFO) << "  offset: " << memOffset;
         LOG(DEBUG) << "  length: " << mBufferInfos[i].length;
         LOG(DEBUG) << "  flags : " << std::hex << mBufferInfos[i].flags;
-
-        // Get a pointer to the buffer contents by mapping into our address space
-        mPixelBuffers[i] = mmap(NULL, mBufferInfos[i].length, PROT_READ | PROT_WRITE, MAP_SHARED,
-                                mDeviceFd, mBufferInfos[i].m.offset);
-
-        if (mPixelBuffers[i] == MAP_FAILED) {
-            PLOG(ERROR) << "mmap() failed";
-            return false;
+        if (mBufferInfos[i].type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+            LOG(INFO) << "  size : " << std::hex << mBufferInfos[i].m.planes[0].length;
+
+        mBufferSize = (mBufferInfos[i].type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) ?
+                          mBufferInfos[i].m.planes[0].length :
+                          mBufferInfos[i].length;
+        std::vector<void*> mappedBuffer;
+        mappedBuffer.resize(VIDEO_PLANES);
+        for (uint32_t plane = 0; plane < VIDEO_PLANES; plane++) {
+            mappedBuffer[plane] =
+                mmap(NULL, mBufferSize, PROT_READ | PROT_WRITE, MAP_SHARED, mDeviceFd, memOffset);
+
+            if (mappedBuffer[plane] == MAP_FAILED) {
+                PLOG(ERROR) << "mmap() failed";
+                return false;
+            }
+
+            memset(mappedBuffer[plane], 0, mBufferSize);
         }
-
-        memset(mPixelBuffers[i], 0, mBufferInfos[i].length);
+        mPixelBuffers[i] = mappedBuffer[0];
         LOG(INFO) << "Buffer mapped at " << mPixelBuffers[i];
 
         // Queue the first capture buffer
@@ -197,10 +280,10 @@ bool VideoCapture::startStream(std::function<void(VideoCapture*, imageBuffer*, v
     }
 
     // Start the video stream
-    const int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    const int type = mBufferType;
     if (ioctl(mDeviceFd, VIDIOC_STREAMON, &type) < 0) {
         PLOG(ERROR) << "VIDIOC_STREAMON failed";
-        return false;
+       // return false;
     }
 
     // Remember who to tell about new frames as they arrive
@@ -230,7 +313,7 @@ void VideoCapture::stopStream() {
         }
 
         // Stop the underlying video stream (automatically empties the buffer queue)
-        const int type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        const int type = mBufferType;
         if (ioctl(mDeviceFd, VIDIOC_STREAMOFF, &type) < 0) {
             PLOG(ERROR) << "VIDIOC_STREAMOFF failed";
         }
@@ -240,12 +323,12 @@ void VideoCapture::stopStream() {
 
     for (int i = 0; i < mNumBuffers; ++i) {
         // Unmap the buffers we allocated
-        munmap(mPixelBuffers[i], mBufferInfos[i].length);
+        munmap(mPixelBuffers[i], mBufferSize);
     }
 
     // Tell the L4V2 driver to release our streaming buffers
     v4l2_requestbuffers bufrequest;
-    bufrequest.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    bufrequest.type = mBufferType;
     bufrequest.memory = V4L2_MEMORY_MMAP;
     bufrequest.count = 0;
     ioctl(mDeviceFd, VIDIOC_REQBUFS, &bufrequest);
@@ -280,8 +363,32 @@ bool VideoCapture::returnFrame(int id) {
 // This runs on a background thread to receive and dispatch video frames
 void VideoCapture::collectFrames() {
     // Run until our atomic signal is cleared
+    fd_set fds;
+    FD_ZERO(&fds);
+    FD_SET(mDeviceFd, &fds);
+
     while (mRunMode == RUN) {
-        struct v4l2_buffer buf = {.type = V4L2_BUF_TYPE_VIDEO_CAPTURE, .memory = V4L2_MEMORY_MMAP};
+        struct v4l2_plane mplanes[VIDEO_PLANES];
+         struct v4l2_buffer buf = {
+                        .type = mBufferType, .memory = V4L2_MEMORY_MMAP};
+
+        if (mBufferType == V4L2_CAP_VIDEO_CAPTURE_MPLANE) {
+            LOG(INFO) << "MPLANE setting to dqbuf";
+            buf.length = VIDEO_PLANES;
+            buf.m.planes = mplanes;
+        }
+
+        timeval tv;
+        tv.tv_sec = 1;
+        tv.tv_usec = 0;  // 10ms
+        int ret = select(mDeviceFd + 1, &fds, nullptr, nullptr, &tv);
+        if (ret == -1) {
+            LOG(INFO) << "Fatal error: selection failure ";
+            break;
+        } else if (ret == 0) {
+            LOG(INFO) << "Warning: timeout of device ";
+            continue;
+        }
 
         // Wait for a buffer to be ready
         if (ioctl(mDeviceFd, VIDIOC_DQBUF, &buf) < 0) {
@@ -308,7 +415,8 @@ void VideoCapture::collectFrames() {
 int VideoCapture::setParameter(v4l2_control& control) {
     int status = ioctl(mDeviceFd, VIDIOC_S_CTRL, &control);
     if (status < 0) {
-        PLOG(ERROR) << "Failed to program a parameter value " << "id = " << std::hex << control.id;
+        PLOG(ERROR) << "Failed to program a parameter value "
+                    << "id = " << std::hex << control.id;
     }
 
     return status;
@@ -317,8 +425,8 @@ int VideoCapture::setParameter(v4l2_control& control) {
 int VideoCapture::getParameter(v4l2_control& control) {
     int status = ioctl(mDeviceFd, VIDIOC_G_CTRL, &control);
     if (status < 0) {
-        PLOG(ERROR) << "Failed to read a parameter value" << " fd = " << std::hex << mDeviceFd
-                    << " id = " << control.id;
+        PLOG(ERROR) << "Failed to read a parameter value"
+                    << " fd = " << std::hex << mDeviceFd << " id = " << control.id;
     }
 
     return status;
diff --git a/cpp/evs/sampleDriver/aidl/src/bufferCopy.cpp b/cpp/evs/sampleDriver/aidl/src/bufferCopy.cpp
index 8d70d6afd..9f89c103e 100644
--- a/cpp/evs/sampleDriver/aidl/src/bufferCopy.cpp
+++ b/cpp/evs/sampleDriver/aidl/src/bufferCopy.cpp
@@ -136,6 +136,33 @@ void fillRGBAFromYUYV(const BufferDesc& tgtBuff, uint8_t* tgt, void* imgData, un
     }
 }
 
+void fillRGBAFromUYVY(const BufferDesc& tgtBuff, uint8_t* tgt, void* imgData, unsigned imgStride) {
+    const AHardwareBuffer_Desc* pDesc =
+        reinterpret_cast<const AHardwareBuffer_Desc*>(&tgtBuff.buffer.description);
+    // Converts YUY2ToARGB (little endian).  Please note that libyuv uses the
+    // little endian while we're using the big endian in RGB format names.
+    const auto dstStrideInBytes = pDesc->stride * 4;  // 4-byte per pixel
+    auto result = libyuv::UYVYToARGB((const uint8_t*)imgData,
+                                     imgStride,             // input stride in bytes
+                                     tgt,
+                                     dstStrideInBytes,      // output stride in bytes
+                                     pDesc->width,
+                                     pDesc->height);
+    if (result) {
+        LOG(ERROR) << "Failed to convert YUYV to BGRA.";
+        return;
+    }
+
+    // Swaps R and B pixels to convert BGRA to RGBA in place.
+    // TODO(b/190783702): Consider allocating an extra space to store ARGB data
+    //                    temporarily if below operation is too slow.
+    result = libyuv::ABGRToARGB(tgt, dstStrideInBytes, tgt, dstStrideInBytes,
+                                pDesc->width, pDesc->height);
+    if (result) {
+        LOG(ERROR) << "Failed to convert BGRA to RGBA.";
+    }
+}
+
 void fillYUYVFromYUYV(const BufferDesc& tgtBuff, uint8_t* tgt, void* imgData, unsigned imgStride) {
     const AHardwareBuffer_Desc* pDesc =
             reinterpret_cast<const AHardwareBuffer_Desc*>(&tgtBuff.buffer.description);
-- 
2.17.1

