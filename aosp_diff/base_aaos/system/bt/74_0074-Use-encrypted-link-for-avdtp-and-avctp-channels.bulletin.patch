From 8e8d34836cb27e70ea0cfa227a6d31b7bbcd9a1b Mon Sep 17 00:00:00 2001
From: Brian Delwiche <delwiche@google.com>
Date: Mon, 23 Sep 2024 21:39:40 +0000
Subject: [PATCH] Use encrypted link for avdtp and avctp channels

This is a backport of the AOSP changes for b/345258562.

Test: mmm packages/modules/Bluetooth
Bug: 345258562
Ignore-AOSP-First: security
Tag: #security
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:0850bdb96f9af6aed32bd3cf96c6f93eb4e4ccb5)
Merged-In: Ie5fe394f5c710690b8fc6e90cdd6c2b4cac9c7ca
Change-Id: Ie5fe394f5c710690b8fc6e90cdd6c2b4cac9c7ca
---
 stack/avct/avct_api.cc     | 7 ++++---
 stack/avct/avct_bcb_act.cc | 5 +++--
 stack/avct/avct_lcb_act.cc | 4 ++--
 stack/avdt/avdt_ad.cc      | 4 ++--
 stack/avdt/avdt_api.cc     | 3 ++-
 5 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/stack/avct/avct_api.cc b/stack/avct/avct_api.cc
index da4c90427..281ba8887 100644
--- a/stack/avct/avct_api.cc
+++ b/stack/avct/avct_api.cc
@@ -59,17 +59,18 @@ void AVCT_Register() {
   /* initialize AVCTP data structures */
   memset(&avct_cb, 0, sizeof(tAVCT_CB));
 
+  uint16_t sec = BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT;
+
   /* register PSM with L2CAP */
   L2CA_Register2(AVCT_PSM, avct_l2c_appl, true /* enable_snoop */, nullptr,
-                 kAvrcMtu, 0, BTA_SEC_AUTHENTICATE);
+                 kAvrcMtu, 0, sec);
 
   /* Include the browsing channel which uses eFCR */
   tL2CAP_ERTM_INFO ertm_info;
   ertm_info.preferred_mode = L2CAP_FCR_ERTM_MODE;
 
   L2CA_Register2(AVCT_BR_PSM, avct_l2c_br_appl, true /*enable_snoop*/,
-                 &ertm_info, kAvrcBrMtu, AVCT_MIN_BROWSE_MTU,
-                 BTA_SEC_AUTHENTICATE);
+                 &ertm_info, kAvrcBrMtu, AVCT_MIN_BROWSE_MTU, sec);
 
 #if defined(AVCT_INITIAL_TRACE_LEVEL)
   avct_cb.trace_level = AVCT_INITIAL_TRACE_LEVEL;
diff --git a/stack/avct/avct_bcb_act.cc b/stack/avct/avct_bcb_act.cc
index ebb92e381..02d3c4277 100644
--- a/stack/avct/avct_bcb_act.cc
+++ b/stack/avct/avct_bcb_act.cc
@@ -112,8 +112,9 @@ void avct_bcb_chnl_open(tAVCT_BCB* p_bcb, UNUSED_ATTR tAVCT_LCB_EVT* p_data) {
 
   /* call l2cap connect req */
   p_bcb->ch_state = AVCT_CH_CONN;
-  p_bcb->ch_lcid =
-      L2CA_ConnectReq2(AVCT_BR_PSM, p_lcb->peer_addr, BTA_SEC_AUTHENTICATE);
+  p_bcb->ch_lcid = L2CA_ConnectReq2(AVCT_BR_PSM, p_lcb->peer_addr,
+                                    BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT);
+
   if (p_bcb->ch_lcid == 0) {
     /* if connect req failed, send ourselves close event */
     tAVCT_LCB_EVT avct_lcb_evt;
diff --git a/stack/avct/avct_lcb_act.cc b/stack/avct/avct_lcb_act.cc
index 1b4197861..e4e042e48 100644
--- a/stack/avct/avct_lcb_act.cc
+++ b/stack/avct/avct_lcb_act.cc
@@ -188,8 +188,8 @@ void avct_lcb_chnl_open(tAVCT_LCB* p_lcb, UNUSED_ATTR tAVCT_LCB_EVT* p_data) {
   uint16_t result = AVCT_RESULT_FAIL;
 
   p_lcb->ch_state = AVCT_CH_CONN;
-  p_lcb->ch_lcid =
-      L2CA_ConnectReq2(AVCT_PSM, p_lcb->peer_addr, BTA_SEC_AUTHENTICATE);
+  p_lcb->ch_lcid = L2CA_ConnectReq2(AVCT_PSM, p_lcb->peer_addr,
+                                    BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT);
   if (p_lcb->ch_lcid == 0) {
     /* if connect req failed, send ourselves close event */
     tAVCT_LCB_EVT avct_lcb_evt;
diff --git a/stack/avdt/avdt_ad.cc b/stack/avdt/avdt_ad.cc
index ff102548f..6a077ae20 100644
--- a/stack/avdt/avdt_ad.cc
+++ b/stack/avdt/avdt_ad.cc
@@ -546,8 +546,8 @@ void avdt_ad_open_req(uint8_t type, AvdtpCcb* p_ccb, AvdtpScb* p_scb,
     p_tbl->state = AVDT_AD_ST_CONN;
 
     /* call l2cap connect req */
-    lcid =
-        L2CA_ConnectReq2(AVDT_PSM, p_ccb->peer_addr, BTM_SEC_OUT_AUTHENTICATE);
+    lcid = L2CA_ConnectReq2(AVDT_PSM, p_ccb->peer_addr,
+                            BTM_SEC_OUT_AUTHENTICATE | BTM_SEC_OUT_ENCRYPT);
     if (lcid != 0) {
       /* if connect req ok, store tcid in lcid table  */
       avdtp_cb.ad.lcid_tbl[lcid] = avdt_ad_tc_tbl_to_idx(p_tbl);
diff --git a/stack/avdt/avdt_api.cc b/stack/avdt/avdt_api.cc
index 9bc6f5a16..02912ad02 100644
--- a/stack/avdt/avdt_api.cc
+++ b/stack/avdt/avdt_api.cc
@@ -93,9 +93,10 @@ void avdt_scb_transport_channel_timer_timeout(void* data) {
  *
  ******************************************************************************/
 void AVDT_Register(AvdtpRcb* p_reg, tAVDT_CTRL_CBACK* p_cback) {
+  uint16_t sec = BTA_SEC_AUTHENTICATE | BTA_SEC_ENCRYPT;
   /* register PSM with L2CAP */
   L2CA_Register2(AVDT_PSM, avdt_l2c_appl, true /* enable_snoop */, nullptr,
-                 kAvdtpMtu, 0, BTA_SEC_AUTHENTICATE);
+                 kAvdtpMtu, 0, sec);
 
   /* initialize AVDTP data structures */
   avdt_scb_init();
-- 
2.48.1.262.g85cc9f2d1e-goog

