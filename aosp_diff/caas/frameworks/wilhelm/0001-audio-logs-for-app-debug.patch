From e05081f813d6d71eb7e9b7b1a3c281fc59be303b Mon Sep 17 00:00:00 2001
From: gkdeepa <g.k.deepa@intel.com>
Date: Thu, 13 Jan 2022 13:57:59 +0530
Subject: [PATCH] audio logs for app debug

Tracked-On:
---
 src/android/AudioPlayer_to_android.cpp | 28 ++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/src/android/AudioPlayer_to_android.cpp b/src/android/AudioPlayer_to_android.cpp
index a324b4a..ae5bb46 100644
--- a/src/android/AudioPlayer_to_android.cpp
+++ b/src/android/AudioPlayer_to_android.cpp
@@ -1235,9 +1235,15 @@ SLresult android_audioPlayer_checkSourceSink(CAudioPlayer *pAudioPlayer)
 // from a buffer queue. This will not be called once the AudioTrack has been destroyed.
 static void audioTrack_callBack_pullFromBuffQueue(int event, void* user, void *info) {
     CAudioPlayer *ap = (CAudioPlayer *)user;
-
+    
+    SL_LOGE("Deepa :setting GenericPlayer to SL_PLAYSTATE_PLAYING");
+    if(ap == NULL)
+       SL_LOGE("Deepa :ap is NULL");
+      
     if (!android::CallbackProtector::enterCbIfOk(ap->mCallbackProtector)) {
         // it is not safe to enter the callback (the track is about to go away)
+        
+        SL_LOGE("Deepa :it is not safe to enter the callback");
         return;
     }
 
@@ -1248,12 +1254,13 @@ static void audioTrack_callBack_pullFromBuffQueue(int event, void* user, void *i
         //SL_LOGV("received event EVENT_MORE_DATA from AudioTrack TID=%d", gettid());
         slPrefetchCallback prefetchCallback = NULL;
         void *prefetchContext = NULL;
+        SL_LOGE("Deepa : before prefetchEvents ");
         SLuint32 prefetchEvents = SL_PREFETCHEVENT_NONE;
         android::AudioTrack::Buffer* pBuff = (android::AudioTrack::Buffer*)info;
-
+        if(pBuff == NULL)
+        SL_LOGE("Deepa :pBuff is NULL");
         // retrieve data from the buffer queue
         interface_lock_exclusive(&ap->mBufferQueue);
-
         if (ap->mBufferQueue.mCallbackPending) {
             // call callback with lock not held
             slBufferQueueCallback callback = ap->mBufferQueue.mCallback;
@@ -1267,7 +1274,7 @@ static void audioTrack_callBack_pullFromBuffQueue(int event, void* user, void *i
         }
 
         if (ap->mBufferQueue.mState.count != 0) {
-            //SL_LOGV("nbBuffers in queue = %u",ap->mBufferQueue.mState.count);
+            SL_LOGV("nbBuffers in queue = %u",ap->mBufferQueue.mState.count);
             assert(ap->mBufferQueue.mFront != ap->mBufferQueue.mRear);
 
             BufferHeader *oldFront = ap->mBufferQueue.mFront;
@@ -1277,13 +1284,16 @@ static void audioTrack_callBack_pullFromBuffQueue(int event, void* user, void *i
             size_t availSink = pBuff->size;
             size_t bytesToCopy = availSource < availSink ? availSource : availSink;
             void *pSrc = (char *)oldFront->mBuffer + ap->mBufferQueue.mSizeConsumed;
+            SL_LOGV("Deepa memcpy ");
             memcpy(pBuff->raw, pSrc, bytesToCopy);
 
             if (bytesToCopy < availSource) {
+            SL_LOGV("Deepa bytesToCopy < availSource ");
                 ap->mBufferQueue.mSizeConsumed += bytesToCopy;
                 // pBuff->size is already equal to bytesToCopy in this case
             } else {
                 // consumed an entire buffer, dequeue
+            SL_LOGV("Deepa bytesToCopy < availSource else");
                 pBuff->size = bytesToCopy;
                 ap->mBufferQueue.mSizeConsumed = 0;
                 if (newFront ==
@@ -1302,6 +1312,7 @@ static void audioTrack_callBack_pullFromBuffQueue(int event, void* user, void *i
             // signal no data available
             pBuff->size = 0;
 
+            ALOGE("Deep empty queue");    
             // signal we're at the end of the content, but don't pause (see note in function)
             audioPlayer_dispatch_headAtEnd_lockPlay(ap, false /*set state to paused?*/, false);
 
@@ -1340,17 +1351,17 @@ static void audioTrack_callBack_pullFromBuffQueue(int event, void* user, void *i
     break;
 
     case android::AudioTrack::EVENT_MARKER:
-        //SL_LOGI("received event EVENT_MARKER from AudioTrack");
+        SL_LOGE("Deepa received event EVENT_MARKER from AudioTrack");
         audioTrack_handleMarker_lockPlay(ap);
         break;
 
     case android::AudioTrack::EVENT_NEW_POS:
-        //SL_LOGI("received event EVENT_NEW_POS from AudioTrack");
+        SL_LOGE("Deepa received event EVENT_NEW_POS from AudioTrack");
         audioTrack_handleNewPos_lockPlay(ap);
         break;
 
     case android::AudioTrack::EVENT_UNDERRUN:
-        //SL_LOGI("received event EVENT_UNDERRUN from AudioTrack");
+        SL_LOGE("Deepa received event EVENT_UNDERRUN from AudioTrack");
         audioTrack_handleUnderrun_lockPlay(ap);
         break;
 
@@ -1369,7 +1380,8 @@ static void audioTrack_callBack_pullFromBuffQueue(int event, void* user, void *i
                 (CAudioPlayer *)user);
         break;
     }
-
+    
+   SL_LOGV("Deepa mCallbackProtector-exit ");
     ap->mCallbackProtector->exitCb();
 }
 
-- 
2.17.1

