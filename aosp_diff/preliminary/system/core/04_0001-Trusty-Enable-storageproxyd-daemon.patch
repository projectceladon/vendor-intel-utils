From ede133678d6ac3c74854bcd73301cce3a20f6c34 Mon Sep 17 00:00:00 2001
From: sheng wei <w.sheng@intel.com>
Date: Tue, 23 Jul 2019 10:45:55 +0800
Subject: [PATCH 1/3] Trusty: Enable storageproxyd daemon

add support for RPMB devices
add support for simulation RPMB device
    It is used only when real RPMB key is not programmed.

Change-Id: I6df9507542b7212273a72b26bc350e8dc9b945b1
Tracked-On:
Signed-off-by: Huang, Yang <yang.huang@intel.com>
Signed-off-by: sheng wei <w.sheng@intel.com>
---
 trusty/storage/lib/Android.bp     |   6 +
 trusty/storage/proxy/Android.bp   |  13 +-
 trusty/storage/proxy/ipc.h        |   1 +
 trusty/storage/proxy/linux/rpmb.h | 134 ++++++
 trusty/storage/proxy/proxy.c      |  81 ++--
 trusty/storage/proxy/rpmb-dev.c   | 182 +++++++++
 trusty/storage/proxy/rpmb-dev.h   |  23 ++
 trusty/storage/proxy/rpmb-sim.c   | 659 ++++++++++++++++++++++++++++++
 trusty/storage/proxy/rpmb-sim.h   |  25 ++
 trusty/storage/proxy/storage.c    |  12 +-
 trusty/storage/proxy/storage.h    |   4 +
 trusty/storage/tests/Android.bp   |   1 +
 trusty/trusty-base.mk             |  28 --
 trusty/trusty-storage.mk          |  18 -
 14 files changed, 1089 insertions(+), 98 deletions(-)
 create mode 100644 trusty/storage/proxy/linux/rpmb.h
 create mode 100644 trusty/storage/proxy/rpmb-dev.c
 create mode 100644 trusty/storage/proxy/rpmb-dev.h
 create mode 100644 trusty/storage/proxy/rpmb-sim.c
 create mode 100644 trusty/storage/proxy/rpmb-sim.h
 delete mode 100644 trusty/trusty-base.mk
 delete mode 100644 trusty/trusty-storage.mk

diff --git a/trusty/storage/lib/Android.bp b/trusty/storage/lib/Android.bp
index 2fba17edd..22ceab411 100644
--- a/trusty/storage/lib/Android.bp
+++ b/trusty/storage/lib/Android.bp
@@ -26,10 +26,16 @@ cc_library_static {
         "libtrusty",
         "libtrustystorageinterface",
     ],
+
     shared_libs: [
         "liblog",
     ],
 
+    header_libs: [
+        "liblog_headers",
+        "libcutils_headers",
+    ],
+
     cflags: [
         "-fvisibility=hidden",
         "-Wall",
diff --git a/trusty/storage/proxy/Android.bp b/trusty/storage/proxy/Android.bp
index b93facbbc..01371f966 100644
--- a/trusty/storage/proxy/Android.bp
+++ b/trusty/storage/proxy/Android.bp
@@ -21,18 +21,27 @@ cc_binary {
     srcs: [
         "ipc.c",
         "rpmb.c",
+        "rpmb-dev.c",
         "storage.c",
         "proxy.c",
+        "rpmb-sim.c",
     ],
 
-    shared_libs: ["liblog"],
-    header_libs: ["libcutils_headers"],
+    shared_libs: [
+        "liblog",
+        "libcrypto",
+    ],
 
     static_libs: [
         "libtrustystorageinterface",
         "libtrusty",
     ],
 
+    header_libs: [
+        "liblog_headers",
+        "libcutils_headers",
+    ],
+
     cflags: [
         "-Wall",
         "-Werror",
diff --git a/trusty/storage/proxy/ipc.h b/trusty/storage/proxy/ipc.h
index 2e366bbb9..994aa6a6c 100644
--- a/trusty/storage/proxy/ipc.h
+++ b/trusty/storage/proxy/ipc.h
@@ -17,6 +17,7 @@
 
 #include <stdint.h>
 #include <trusty/interface/storage.h>
+#include <unistd.h>
 
 int ipc_connect(const char *device, const char *service_name);
 void ipc_disconnect(void);
diff --git a/trusty/storage/proxy/linux/rpmb.h b/trusty/storage/proxy/linux/rpmb.h
new file mode 100644
index 000000000..98bf68cb9
--- /dev/null
+++ b/trusty/storage/proxy/linux/rpmb.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015-2016, Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_LINUX_RPMB_H_
+#define _UAPI_LINUX_RPMB_H_
+
+#include <linux/types.h>
+
+/**
+ * struct rpmb_frame - rpmb frame as defined by specs
+ *
+ * @stuff        : stuff bytes
+ * @key_mac      : The authentication key or the message authentication
+ *                 code (MAC) depending on the request/response type.
+ *                 The MAC will be delivered in the last (or the only)
+ *                 block of data.
+ * @data         : Data to be written or read by signed access.
+ * @nonce        : Random number generated by the host for the requests
+ *                 and copied to the response by the RPMB engine.
+ * @write_counter: Counter value for the total amount of the successful
+ *                 authenticated data write requests made by the host.
+ * @addr         : Address of the data to be programmed to or read
+ *                 from the RPMB. Address is the serial number of
+ *                 the accessed block (half sector 256B).
+ * @block_count  : Number of blocks (half sectors, 256B) requested to be
+ *                 read/programmed.
+ * @result       : Includes information about the status of the write counter
+ *                 (valid, expired) and result of the access made to the RPMB.
+ * @req_resp     : Defines the type of request and response to/from the memory.
+ */
+struct rpmb_frame {
+	__u8   stuff[196];
+	__u8   key_mac[32];
+	__u8   data[256];
+	__u8   nonce[16];
+	__be32 write_counter;
+	__be16 addr;
+	__be16 block_count;
+	__be16 result;
+	__be16 req_resp;
+} __attribute__((packed));
+
+#define RPMB_PROGRAM_KEY       0x1    /* Program RPMB Authentication Key */
+#define RPMB_GET_WRITE_COUNTER 0x2    /* Read RPMB write counter */
+#define RPMB_WRITE_DATA        0x3    /* Write data to RPMB partition */
+#define RPMB_READ_DATA         0x4    /* Read data from RPMB partition */
+#define RPMB_RESULT_READ       0x5    /* Read result request  (Internal) */
+
+#define RPMB_REQ2RESP(_OP) ((_OP) << 8)
+#define RPMB_RESP2REQ(_OP) ((_OP) >> 8)
+
+/* length of the part of the frame used for HMAC computation */
+#define hmac_data_len \
+	(sizeof(struct rpmb_frame) - offsetof(struct rpmb_frame, data))
+
+/**
+ * enum rpmb_op_result - rpmb operation results
+ *
+ * @RPMB_ERR_OK:       operation successful
+ * @RPMB_ERR_GENERAL:  general failure
+ * @RPMB_ERR_AUTH:     mac doesn't match or ac calculation failure
+ * @RPMB_ERR_COUNTER:  counter doesn't match or counter increment failure
+ * @RPMB_ERR_ADDRESS:  address out of range or wrong address alignment
+ * @RPMB_ERR_WRITE:    data, counter, or result write failure
+ * @RPMB_ERR_READ:     data, counter, or result read failure
+ * @RPMB_ERR_NO_KEY:   authentication key not yet programmed
+ *
+ * @RPMB_ERR_COUNTER_EXPIRED:  counter expired
+ */
+enum rpmb_op_result {
+	RPMB_ERR_OK      = 0x0000,
+	RPMB_ERR_GENERAL = 0x0001,
+	RPMB_ERR_AUTH    = 0x0002,
+	RPMB_ERR_COUNTER = 0x0003,
+	RPMB_ERR_ADDRESS = 0x0004,
+	RPMB_ERR_WRITE   = 0x0005,
+	RPMB_ERR_READ    = 0x0006,
+	RPMB_ERR_NO_KEY  = 0x0007,
+
+	RPMB_ERR_COUNTER_EXPIRED = 0x0080
+};
+
+#define RPMB_F_WRITE     (1UL << 0)
+#define RPMB_F_REL_WRITE (1UL << 1)
+
+/**
+ * struct rpmb_cmd: rpmb access command
+ *
+ * @flags:   command flags
+ *      0 - read command
+ *      1 - write commnad RPMB_F_WRITE
+ *      2 -  reliable write RPMB_F_REL_WRITE
+ * @nframes: number of rpmb frames in the command
+ * @frames_ptr:  a pointer to the list of rpmb frames
+ */
+struct rpmb_ioc_cmd {
+	__u32 flags;
+	__u32 nframes;
+	__aligned_u64 frames_ptr;
+};
+
+#define rpmb_ioc_cmd_set_frames(_cmd, _ptr) \
+	(_cmd).frames_ptr = (__aligned_u64)(intptr_t)(_ptr)
+
+#define rpmb_ioc_cmd_set(_cmd, _flags, _ptr, _n) do {         \
+	(_cmd).flags = (_flags);                              \
+	(_cmd).nframes = (_n);                                \
+	(_cmd).frames_ptr = (__u64)(intptr_t)(_ptr);  \
+} while (0)
+
+/**
+ * struct rpmb_ioc_seq_cmd - rpmb command sequence
+ *
+ * @num_of_cmds: number of commands
+ * @cmds: list of rpmb commands
+ */
+struct rpmb_ioc_seq_cmd {
+	__u64 num_of_cmds;
+	struct rpmb_ioc_cmd cmds[0];
+};
+
+#define RPMB_IOC_SEQ_CMD _IOWR(0xB5, 82, struct rpmb_ioc_seq_cmd)
+
+#endif /* _UAPI_LINUX_RPMB_H_ */
diff --git a/trusty/storage/proxy/proxy.c b/trusty/storage/proxy/proxy.c
index c61f7d007..c34dcc145 100644
--- a/trusty/storage/proxy/proxy.c
+++ b/trusty/storage/proxy/proxy.c
@@ -20,20 +20,31 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/capability.h>
+#include <sys/sysmacros.h>
 #include <sys/prctl.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
+#include <linux/major.h>
+
 #include <cutils/android_filesystem_config.h>
 
 #include "ipc.h"
 #include "log.h"
 #include "rpmb.h"
+#include "rpmb-dev.h"
+#include "rpmb-sim.h"
 #include "storage.h"
 
 #define REQ_BUFFER_SIZE 4096
+/* /dev/block/mmcblk1p13 */
+#define RPMB_SIM_DEV_NAME       "/dev/block/by-name/teedata"
+
 static uint8_t req_buffer[REQ_BUFFER_SIZE + 1];
 
+static unsigned int rpmb_sim;
+
 static const char* ss_data_root;
 static const char* trusty_devname;
 static const char* rpmb_devname;
@@ -65,46 +76,6 @@ static void show_usage_and_exit(int code) {
     exit(code);
 }
 
-static int drop_privs(void) {
-    struct __user_cap_header_struct capheader;
-    struct __user_cap_data_struct capdata[2];
-
-    if (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0) {
-        return -1;
-    }
-
-    /*
-     * ensure we're running as the system user
-     */
-    if (setgid(AID_SYSTEM) != 0) {
-        return -1;
-    }
-
-    if (setuid(AID_SYSTEM) != 0) {
-        return -1;
-    }
-
-    /*
-     * drop all capabilities except SYS_RAWIO
-     */
-    memset(&capheader, 0, sizeof(capheader));
-    memset(&capdata, 0, sizeof(capdata));
-    capheader.version = _LINUX_CAPABILITY_VERSION_3;
-    capheader.pid = 0;
-
-    capdata[CAP_TO_INDEX(CAP_SYS_RAWIO)].permitted = CAP_TO_MASK(CAP_SYS_RAWIO);
-    capdata[CAP_TO_INDEX(CAP_SYS_RAWIO)].effective = CAP_TO_MASK(CAP_SYS_RAWIO);
-
-    if (capset(&capheader, &capdata[0]) < 0) {
-        return -1;
-    }
-
-    /* no-execute for user, no access for group and other */
-    umask(S_IXUSR | S_IRWXG | S_IRWXO);
-
-    return 0;
-}
-
 static int handle_req(struct storage_msg* msg, const void* req, size_t req_len) {
     int rc;
 
@@ -156,7 +127,10 @@ static int handle_req(struct storage_msg* msg, const void* req, size_t req_len)
             break;
 
         case STORAGE_RPMB_SEND:
-            rc = rpmb_send(msg, req, req_len);
+            if (rpmb_sim)
+                rc = rpmb_sim_send(msg, req, req_len);
+            else
+                rc = rpmb_dev_send(msg, req, req_len);
             break;
 
         default:
@@ -237,8 +211,16 @@ static void parse_args(int argc, char* argv[]) {
 int main(int argc, char* argv[]) {
     int rc;
 
-    /* drop privileges */
-    if (drop_privs() < 0) return EXIT_FAILURE;
+    rc = rpmb_sim_open(RPMB_SIM_DEV_NAME);
+    if (rc < 0)
+        rpmb_sim = 0;
+    else
+        rpmb_sim = is_use_sim_rpmb();
+
+    if (rpmb_sim)
+        ALOGI("storage use simulation rpmb.\n");
+    else
+        ALOGI("storage use physical rpmb.\n");
 
     /* parse arguments */
     parse_args(argc, argv);
@@ -247,8 +229,11 @@ int main(int argc, char* argv[]) {
     rc = storage_init(ss_data_root);
     if (rc < 0) return EXIT_FAILURE;
 
-    /* open rpmb device */
-    rc = rpmb_open(rpmb_devname, dev_type);
+    if (!rpmb_sim) {
+        rpmb_sim_close();
+        rc = rpmb_dev_open(rpmb_devname);
+    }
+
     if (rc < 0) return EXIT_FAILURE;
 
     /* connect to Trusty secure storage server */
@@ -260,7 +245,11 @@ int main(int argc, char* argv[]) {
     ALOGE("exiting proxy loop with status (%d)\n", rc);
 
     ipc_disconnect();
-    rpmb_close();
+
+    if (rpmb_sim)
+        rpmb_sim_close();
+    else
+        rpmb_dev_close();
 
     return (rc < 0) ? EXIT_FAILURE : EXIT_SUCCESS;
 }
diff --git a/trusty/storage/proxy/rpmb-dev.c b/trusty/storage/proxy/rpmb-dev.c
new file mode 100644
index 000000000..e116cac6e
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-dev.c
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+
+#include "linux/rpmb.h"
+
+#include "ipc.h"
+#include "log.h"
+#include "rpmb.h"
+#include "storage.h"
+
+#define RPMB_BLOCK_SIZE sizeof(struct rpmb_frame)
+
+static int rpmb_fd = -1;
+static uint8_t read_buf[4096];
+
+#ifdef RPMB_DEBUG
+
+static void print_buf(const char *prefix, const uint8_t *buf, size_t size)
+{
+    size_t i;
+
+    printf("%s @%p [%zu]", prefix, buf, size);
+    for (i = 0; i < size; i++) {
+        if (i && i % 32 == 0)
+            printf("\n%*s", (int) strlen(prefix), "");
+        printf(" %02x", buf[i]);
+    }
+    printf("\n");
+    fflush(stdout);
+}
+
+#endif /* RPMB_DEBUG */
+
+
+int rpmb_dev_send(struct storage_msg *msg, const void *r, size_t req_len)
+{
+    int rc;
+    uint32_t blocks;
+    struct {
+        struct rpmb_ioc_seq_cmd seq;
+        struct rpmb_ioc_cmd cmd[3];
+    } rpmb = {};
+    struct rpmb_ioc_cmd *cmd = rpmb.seq.cmds;
+    const struct storage_rpmb_send_req *req = r;
+
+    if (req_len < sizeof(*req)) {
+        ALOGW("malformed rpmb request: invalid length (%zu < %zu)\n",
+              req_len, sizeof(*req));
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    size_t expected_len = sizeof(*req) + req->reliable_write_size + req->write_size;
+    if (req_len != expected_len) {
+        ALOGW("malformed rpmb request: invalid length (%zu != %zu)\n",
+              req_len, expected_len);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    const uint8_t *write_buf = req->payload;
+    if (req->reliable_write_size) {
+        if ((req->reliable_write_size % RPMB_BLOCK_SIZE) != 0) {
+            ALOGW("invalid reliable write size %u\n", req->reliable_write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+
+        blocks = req->reliable_write_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, RPMB_F_WRITE | RPMB_F_REL_WRITE, write_buf, blocks);
+
+#ifdef RPMB_DEBUG
+        ALOGI("opcode: 0x%x, write_flag: 0x%x\n", cmd->opcode, cmd->write_flag);
+        //print_buf("request: ", write_buf, req->reliable_write_size);
+#endif
+        write_buf += req->reliable_write_size;
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    if (req->write_size) {
+        if ((req->write_size % RPMB_BLOCK_SIZE) != 0) {
+            ALOGW("invalid write size %u\n", req->write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+        blocks = req->write_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, RPMB_F_WRITE, write_buf, blocks);
+
+#ifdef RPMB_DEBUG
+        ALOGI("opcode: 0x%x, write_flag: 0x%x\n", cmd->opcode, cmd->write_flag);
+        print_buf("request: ", write_buf, req->write_size);
+#endif
+        write_buf += req->write_size;
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    if (req->read_size) {
+        if (req->read_size % RPMB_BLOCK_SIZE != 0 ||
+            req->read_size > sizeof(read_buf)) {
+            ALOGE("%s: invalid read size %u\n", __func__, req->read_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+        blocks = req->read_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, 0, read_buf, blocks);
+
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    rc = ioctl(rpmb_fd, RPMB_IOC_SEQ_CMD, &rpmb.seq);
+    if (rc < 0) {
+        ALOGE("%s: mmc ioctl failed: %d, %s\n", __func__, rc, strerror(errno));
+        msg->result = STORAGE_ERR_GENERIC;
+        goto err_response;
+    }
+#ifdef RPMB_DEBUG
+    if (req->read_size)
+        print_buf("response: ", read_buf, req->read_size);
+#endif
+
+    if (msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) {
+        /*
+         * Nothing todo for post msg commit request as RPMB_IOC_SEQ_CMD
+         * is fully synchronous in this implementation.
+         */
+    }
+
+    msg->result = STORAGE_NO_ERROR;
+    return ipc_respond(msg, read_buf, req->read_size);
+
+err_response:
+    return ipc_respond(msg, NULL, 0);
+}
+
+
+int rpmb_dev_open(const char *rpmb_devname)
+{
+    int rc;
+
+    rc = open(rpmb_devname, O_RDWR, 0);
+    if (rc < 0) {
+        ALOGE("unable (%d) to open rpmb device '%s': %s\n",
+              errno, rpmb_devname, strerror(errno));
+        return rc;
+    }
+    rpmb_fd = rc;
+    return 0;
+}
+
+void rpmb_dev_close(void)
+{
+    close(rpmb_fd);
+    rpmb_fd = -1;
+}
+
diff --git a/trusty/storage/proxy/rpmb-dev.h b/trusty/storage/proxy/rpmb-dev.h
new file mode 100644
index 000000000..449369517
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-dev.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <trusty/interface/storage.h>
+
+int rpmb_dev_open(const char *rpmb_devname);
+int rpmb_dev_send(struct storage_msg *msg, const void *r, size_t req_len);
+void rpmb_dev_close(void);
diff --git a/trusty/storage/proxy/rpmb-sim.c b/trusty/storage/proxy/rpmb-sim.c
new file mode 100644
index 000000000..eb2ce9f9c
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-sim.c
@@ -0,0 +1,659 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2017 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <inttypes.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <openssl/hmac.h>
+
+#include "ipc.h"
+#include "storage.h"
+#include "log.h"
+
+struct rpmb_packet {
+    uint8_t              pad[196];
+    uint8_t              key_mac[32];
+    uint8_t              data[256];
+    uint8_t              nonce[16];
+    uint32_t             write_counter;
+    uint16_t             address;
+    uint16_t             block_count;
+    uint16_t             result;
+    uint16_t             req_resp;
+};
+
+enum rpmb_request {
+    RPMB_REQ_PROGRAM_KEY                = 0x0001,
+    RPMB_REQ_GET_COUNTER                = 0x0002,
+    RPMB_REQ_DATA_WRITE                 = 0x0003,
+    RPMB_REQ_DATA_READ                  = 0x0004,
+    RPMB_REQ_RESULT_READ                = 0x0005,
+};
+
+enum rpmb_response {
+    RPMB_RESP_PROGRAM_KEY               = 0x0100,
+    RPMB_RESP_GET_COUNTER               = 0x0200,
+    RPMB_RESP_DATA_WRITE                = 0x0300,
+    RPMB_RESP_DATA_READ                 = 0x0400,
+};
+
+enum rpmb_result {
+    RPMB_RES_OK                         = 0x0000,
+    RPMB_RES_GENERAL_FAILURE            = 0x0001,
+    RPMB_RES_AUTH_FAILURE               = 0x0002,
+    RPMB_RES_COUNT_FAILURE              = 0x0003,
+    RPMB_RES_ADDR_FAILURE               = 0x0004,
+    RPMB_RES_WRITE_FAILURE              = 0x0005,
+    RPMB_RES_READ_FAILURE               = 0x0006,
+    RPMB_RES_NO_AUTH_KEY                = 0x0007,
+
+    RPMB_RES_WRITE_COUNTER_EXPIRED      = 0x0080,
+};
+
+
+#define RPMB_FRAME_SIZE  512
+
+static int rpmb_fd = -1;
+static uint8_t read_buf[4096];
+
+/*
+ * 0~6 is magic
+ * 7~38 is rpmb key
+ * 39~41 is write counter
+ */
+#define KEY_MAGIC		"key_sim"
+#define KEY_MAGIC_ADDR		0
+#define KEY_MAGIC_LENGTH	7
+
+#define KEY_ADDR		7
+#define KEY_LENGTH		32
+
+#define WRITER_COUNTER_ADDR	39
+
+/* teedata size is 32M. But here only 256K~4M are available to use. */
+#define TEEDATA_SIZE		(4*1024*1024) //4M
+#define TEEDATA_BLOCK_COUNT	(TEEDATA_SIZE/256)
+
+
+inline uint32_t swap32(uint32_t val)
+{
+	return ((val & (uint32_t)0x000000ffUL) << 24)
+		| ((val & (uint32_t)0x0000ff00UL) <<  8)
+		| ((val & (uint32_t)0x00ff0000UL) >>  8)
+		| ((val & (uint32_t)0xff000000UL) >> 24);
+}
+
+inline uint16_t swap16(uint16_t val)
+{
+	return ((val & (uint16_t)0x00ffU) << 8)
+		| ((val & (uint16_t)0xff00U) >> 8);
+}
+
+static int rpmb_sim_operations(const void *rel_write_data,
+                        size_t rel_write_size, const void *write_data,
+                        size_t write_size, void *read_buf, size_t read_size);
+
+/*
+ * Executes the RPMB request at @r, sends response to storage service.
+ *
+ * @msg:     address of storage message header
+ * @r:       address of storage message request
+ * @req_len: length of resp in bytes
+ */
+int rpmb_sim_send(struct storage_msg *msg, const void *r,
+                             size_t req_len)
+{
+    int rc;
+    size_t exp_len;
+    const void *write_data = NULL;
+    const void *rel_write_data = NULL;
+    const struct storage_rpmb_send_req *req = r;
+
+    if (req_len < sizeof(req)) {
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    exp_len = sizeof(*req) + req->reliable_write_size + req->write_size;
+    if (req_len != exp_len) {
+        ALOGE("%s: malformed rpmb request: invalid length (%zu != %zu)\n",
+                __func__, req_len, exp_len);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    if (req->reliable_write_size) {
+        if ((req->reliable_write_size % RPMB_FRAME_SIZE) != 0) {
+            ALOGE("%s: invalid reliable write size %u\n", __func__,
+                         req->reliable_write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+        rel_write_data = req->payload;
+    }
+
+    if (req->write_size) {
+        if ((req->write_size % RPMB_FRAME_SIZE) != 0) {
+            ALOGE("%s: invalid write size %u\n", __func__,
+                         req->write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+        write_data = req->payload + req->reliable_write_size;
+    }
+
+    if (req->read_size) {
+        if (req->read_size % RPMB_FRAME_SIZE != 0 ||
+            req->read_size > sizeof(read_buf)) {
+            ALOGE("%s: invalid read size %u\n", __func__,
+                         req->read_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+    }
+
+    /* execute rpmb command */
+    rc = rpmb_sim_operations(rel_write_data, req->reliable_write_size,
+                             write_data, req->write_size,
+                             read_buf, req->read_size);
+    if (rc) {
+        ALOGE("%s: rpmb_storage_send failed: %d\n", __func__, rc);
+        msg->result = STORAGE_ERR_GENERIC;
+        goto err_response;
+    }
+
+    if (msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) {
+        /*
+         * Nothing todo for post msg commit request as MMC_IOC_MULTI_CMD
+         * is fully synchronous in this implementation.
+         */
+    }
+
+    msg->result = STORAGE_NO_ERROR;
+    return ipc_respond(msg, read_buf, req->read_size);
+
+err_response:
+    return ipc_respond(msg, NULL, 0);
+}
+
+int rpmb_sim_open(const char *rpmb_devname)
+{
+    int rc;
+
+    rc = open(rpmb_devname, O_RDWR, 0);
+    if (rc < 0) {
+        ALOGE("%s: unable (%d) to open rpmb device '%s': %s\n",
+              __func__, errno, rpmb_devname, strerror(errno));
+        return rc;
+    }
+    rpmb_fd = rc;
+    return 0;
+}
+
+void rpmb_sim_close(void)
+{
+    close(rpmb_fd);
+    rpmb_fd = -1;
+}
+
+static int fwrite_with_retry(int fd, const void *buf, size_t size, off_t offset)
+{
+    int rc;
+
+    rc = write_with_retry(fd, buf, size, offset);
+    if (rc < 0) {
+       ALOGE("%s write with retry failed.\n", __func__);
+       return rc;
+    }
+
+    rc = fsync(fd);
+    if (rc < 0) {
+        ALOGE("fsync for fd=%d failed: %s\n", fd, strerror(errno));
+        return rc;
+    }
+    return 0;
+}
+
+static int get_counter(uint32_t *counter)
+{
+    int rc = 0;
+
+    rc = read_with_retry(rpmb_fd, counter, sizeof(*counter), WRITER_COUNTER_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed.\n", __func__);
+        return -1;
+    }
+
+    swap32(*counter);
+
+    return 0;
+}
+
+static int set_counter(const uint32_t *counter)
+{
+    int rc = 0;
+    uint32_t cnt = *counter;
+
+    swap32(cnt);
+    rc = fwrite_with_retry(rpmb_fd, &cnt, sizeof(cnt), WRITER_COUNTER_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed.\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int is_key_programmed(void)
+{
+    int rc = 0;
+    uint8_t magic[KEY_MAGIC_LENGTH] = {0};
+
+    rc = read_with_retry(rpmb_fd, magic, KEY_MAGIC_LENGTH, KEY_MAGIC_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s read magic failed.\n", __func__);
+        return 0;
+    }
+
+    if (memcmp(KEY_MAGIC, magic, KEY_MAGIC_LENGTH))
+        return 0;
+
+    return 1;
+}
+
+int is_use_sim_rpmb(void)
+{
+    return is_key_programmed();
+}
+
+static int get_key(uint8_t *key)
+{
+    int rc = 0;
+
+    rc = read_with_retry(rpmb_fd, key, 32, KEY_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed.\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int program_key(const uint8_t *key)
+{
+    int rc = 0;
+
+    rc = fwrite_with_retry(rpmb_fd, key, 32, KEY_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed at set key.\n", __func__);
+        return -1;
+    }
+
+    rc = fwrite_with_retry(rpmb_fd, KEY_MAGIC, KEY_MAGIC_LENGTH, KEY_MAGIC_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed at set magic.\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int rpmb_mac(uint8_t *key, const struct rpmb_packet *packet,
+                    int packet_count, uint8_t *mac)
+{
+    int i;
+    int hmac_ret;
+    unsigned int md_len;
+    HMAC_CTX hmac_ctx;
+
+    HMAC_CTX_init(&hmac_ctx);
+    hmac_ret = HMAC_Init_ex(&hmac_ctx, key, 32, EVP_sha256(), NULL);
+    if (!hmac_ret) {
+        ALOGE("HMAC_Init_ex failed\n");
+        goto err;
+    }
+
+    for (i = 0; i < packet_count; i++) {
+        hmac_ret = HMAC_Update(&hmac_ctx, packet[i].data, 284);
+        if (!hmac_ret) {
+            ALOGE("HMAC_Update failed\n");
+            goto err;
+        }
+    }
+
+    hmac_ret = HMAC_Final(&hmac_ctx, mac, &md_len);
+    if (md_len != 32) {
+        ALOGE("bad md_len %d != 32.\n", md_len);
+        exit(1);
+    }
+
+    if (!hmac_ret) {
+        ALOGE("HMAC_Final failed\n");
+        goto err;
+    }
+
+err:
+    HMAC_CTX_cleanup(&hmac_ctx);
+
+    return hmac_ret ? 0 : -1;
+}
+
+static int rpmb_program_key(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                            struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    int err = RPMB_RES_WRITE_FAILURE;
+    uint32_t counter = 0;
+
+    if (in_cnt == 0  || in_frame == NULL)
+        return -EINVAL;
+
+    if (is_key_programmed())
+        err = RPMB_RES_GENERAL_FAILURE;
+    else
+        ret = program_key(in_frame->key_mac);
+
+    if (ret)
+        goto out;
+
+    ret = set_counter(&counter);
+    if (ret)
+        goto out;
+
+    err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, out_cnt*sizeof(*out_frame));
+        out_frame->req_resp = swap16(RPMB_RESP_PROGRAM_KEY);
+        out_frame->result = swap16(err);
+    }
+
+    return ret;
+}
+
+static int rpmb_write(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                      struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    int err = RPMB_RES_WRITE_FAILURE;
+    uint32_t i;
+    uint8_t key[32];
+    uint8_t mac[32];
+    uint32_t counter;
+    uint16_t addr;
+    uint16_t block_count;
+    uint8_t data[256*in_cnt];
+
+    if (in_cnt == 0  || in_frame == NULL)
+        return -EINVAL;
+
+    if (in_frame[0].req_resp != swap16(RPMB_REQ_DATA_WRITE))
+        return -EINVAL;
+
+    if (in_cnt > 2) {
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    addr = swap16(in_frame[0].address);
+    block_count = swap16(in_frame[0].block_count);
+
+    if (addr >= TEEDATA_BLOCK_COUNT) {
+        err = RPMB_RES_ADDR_FAILURE;
+        goto out;
+    }
+
+    if (addr + block_count > TEEDATA_BLOCK_COUNT)
+        goto out;
+
+    if (block_count == 0 || block_count > in_cnt) {
+        ret = -EINVAL;
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    if (!is_key_programmed()) {
+        err = RPMB_RES_NO_AUTH_KEY;
+        goto out;
+    }
+
+    if (get_counter(&counter))
+        goto out;
+
+    if (counter == 0xFFFFFFFF) {
+        err = RPMB_RES_WRITE_COUNTER_EXPIRED;
+        goto out;
+    }
+
+    if (counter != swap32(in_frame[0].write_counter)) {
+        err = RPMB_RES_COUNT_FAILURE;
+        goto out;
+    }
+
+    if (get_key(key)) {
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    if (rpmb_mac(key, in_frame, in_cnt, mac)) {
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    if (memcmp(in_frame[in_cnt - 1].key_mac, mac, 32)) {
+        ALOGE("%s wrong mac.\n", __func__);
+        err = RPMB_RES_AUTH_FAILURE;
+        goto out;
+    }
+
+    for (i = 0; i < in_cnt; i++)
+        memcpy(data + i * 256, in_frame[i].data, 256);
+
+    if (fwrite_with_retry(rpmb_fd, data, sizeof(data), 256 * addr) < 0) {
+        ALOGE("%s fwrite_with_retry failed.\n", __func__);
+        goto out;
+    }
+
+    ++counter;
+    if (set_counter(&counter)) {
+        ALOGE("%s set_counter failed.\n", __func__);
+        goto out;
+    }
+
+    err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, out_cnt*sizeof(*out_frame));
+        out_frame->req_resp = swap16(RPMB_RESP_DATA_WRITE);
+        out_frame->result = swap16(err);
+        if (err == RPMB_RES_OK) {
+            out_frame->address = swap16(addr);
+            out_frame->write_counter = swap32(counter);
+            rpmb_mac(key, out_frame, 1, out_frame->key_mac);
+        }
+    }
+
+    return ret;
+}
+
+static int rpmb_read(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                     struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    uint32_t i;
+    int err = RPMB_RES_READ_FAILURE;
+    uint8_t key[32];
+    uint8_t mac[32];
+    uint16_t addr;
+    uint8_t data[256*out_cnt];
+
+    if (in_cnt != 1 || in_frame == NULL)
+        return -EINVAL;
+
+    if (in_frame->req_resp != swap16(RPMB_REQ_DATA_READ))
+        return -EINVAL;
+
+    addr = swap16(in_frame->address);
+
+    if (addr >= TEEDATA_BLOCK_COUNT) {
+        err = RPMB_RES_ADDR_FAILURE;
+        goto out;
+    }
+
+    if (addr + out_cnt > TEEDATA_BLOCK_COUNT)
+        goto out;
+
+    if (!is_key_programmed()) {
+        err = RPMB_RES_NO_AUTH_KEY;
+        goto out;
+    }
+
+    if (read_with_retry(rpmb_fd, data, sizeof(data), 256 * addr) < 0) {
+        ALOGE("%s read_with_retry failed.\n", __func__);
+        goto out;
+    }
+
+    err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, out_cnt*sizeof(*out_frame));
+        for (i = 0; i < out_cnt; i++) {
+            memcpy(out_frame[i].nonce, in_frame[0].nonce, sizeof(in_frame[0].nonce));
+            out_frame[i].req_resp = swap16(RPMB_RESP_DATA_READ);
+            out_frame[i].block_count = swap16(out_cnt);
+            out_frame[i].address = in_frame[0].address;
+            memcpy(out_frame[i].data, data+256*i, 256);
+        }
+        if (get_key(key))
+            ALOGE("%s, get_key failed.\n", __func__);
+
+        out_frame[out_cnt - 1].result = swap16(err);
+        rpmb_mac(key, out_frame, out_cnt, mac);
+        memcpy(out_frame[out_cnt - 1].key_mac, mac, sizeof(mac));
+    }
+
+    return ret;
+}
+
+static int rpmb_get_counter(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                            struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    int err = RPMB_RES_COUNT_FAILURE;
+    uint8_t key[32];
+    uint32_t counter;
+
+    if (in_cnt != 1 || in_frame == NULL)
+        return -EINVAL;
+
+    if (in_frame->req_resp != swap16(RPMB_REQ_GET_COUNTER))
+        return -EINVAL;
+
+    if (!is_key_programmed()) {
+        err = RPMB_RES_NO_AUTH_KEY;
+        goto out;
+    }
+
+    if (get_key(key))
+        goto out;
+
+    if (get_counter(&counter))
+        goto out;
+
+     err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, sizeof(*out_frame)*out_cnt);
+        out_frame->result = swap16(err);
+        out_frame->req_resp = swap16(RPMB_RESP_GET_COUNTER);
+        memcpy(out_frame->nonce, in_frame[0].nonce, sizeof(in_frame[0].nonce));
+
+        if (err == RPMB_RES_OK) {
+            out_frame->write_counter = swap32(counter);
+            rpmb_mac(key, out_frame, out_cnt, out_frame->key_mac);
+        }
+    }
+
+    return ret;
+}
+
+/*
+ *                rel_write       write      read
+ * RPMB_READ          0             1        1~N
+ * RPMB_WRITE        1~N            1         1
+ * GET_COUNTER        0             1         1
+ * PROGRAM_KEY        1             1         1
+ */
+static int rpmb_sim_operations(const void *rel_write_data, size_t rel_write_size,
+                        const void *write_data, size_t write_size,
+                        void *read_buf, size_t read_size)
+{
+    int ret = -1;
+
+    if (rel_write_size) {
+        int nframe = rel_write_size/RPMB_FRAME_SIZE;
+        struct rpmb_packet rel_write_frame[nframe];
+        memcpy(rel_write_frame, rel_write_data, sizeof(rel_write_frame));
+        if (rel_write_frame[0].req_resp == swap16(RPMB_REQ_DATA_WRITE))  {
+            if (write_size/RPMB_FRAME_SIZE &&
+                   ((struct rpmb_packet*)write_data)->req_resp == swap16(RPMB_REQ_RESULT_READ))
+                ret = rpmb_write(rel_write_frame, nframe, read_buf, read_size/RPMB_FRAME_SIZE);
+            else
+                ret = rpmb_write(rel_write_frame, nframe, NULL, 0);
+        }
+        else if (rel_write_frame[0].req_resp == swap16(RPMB_REQ_PROGRAM_KEY)) {
+            if (write_size/RPMB_FRAME_SIZE &&
+                   ((struct rpmb_packet*)write_data)->req_resp == swap16(RPMB_REQ_RESULT_READ))
+                ret = rpmb_program_key(rel_write_frame, 1, read_buf, read_size/RPMB_FRAME_SIZE);
+            else
+                ret = rpmb_program_key(rel_write_frame, 1, NULL, 0);
+        }
+    }
+    else if (write_size) {
+        struct rpmb_packet write_frame[write_size/RPMB_FRAME_SIZE];
+        memcpy(write_frame, write_data, sizeof(write_frame));
+        if (write_frame[0].req_resp == swap16(RPMB_REQ_DATA_READ)) {
+            ret = rpmb_read(write_frame, 1, read_buf, read_size/RPMB_FRAME_SIZE);
+        }
+        else if (write_frame[0].req_resp == swap16(RPMB_REQ_GET_COUNTER)) {
+            ret = rpmb_get_counter(write_frame, 1, read_buf, 1);
+        }
+    }
+
+    return ret;
+}
+
diff --git a/trusty/storage/proxy/rpmb-sim.h b/trusty/storage/proxy/rpmb-sim.h
new file mode 100644
index 000000000..68ac4cd99
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-sim.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2017 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <trusty/interface/storage.h>
+
+int rpmb_sim_open(const char *rpmb_devname);
+int rpmb_sim_send(struct storage_msg *msg, const void *r, size_t req_len);
+void rpmb_sim_close(void);
+int is_use_sim_rpmb(void);
diff --git a/trusty/storage/proxy/storage.c b/trusty/storage/proxy/storage.c
index 5b83e2141..4ba2ef77a 100644
--- a/trusty/storage/proxy/storage.c
+++ b/trusty/storage/proxy/storage.c
@@ -123,7 +123,7 @@ static enum storage_err translate_errno(int error)
     return result;
 }
 
-static ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t offset)
+ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t offset)
 {
     ssize_t rc;
     const uint8_t *buf = buf_;
@@ -136,10 +136,11 @@ static ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t off
         buf += rc;
         offset += rc;
     }
+
     return 0;
 }
 
-static ssize_t read_with_retry(int fd, void *buf_, size_t size, off_t offset)
+ssize_t read_with_retry(int fd, void *buf_, size_t size, off_t offset)
 {
     ssize_t rc;
     size_t  rcnt = 0;
@@ -469,7 +470,9 @@ int storage_init(const char *dirname)
 {
     fs_state = SS_CLEAN;
     dir_state = SS_CLEAN;
-    for (uint i = 0; i < FD_TBL_SIZE; i++) {
+    uint i = 0;
+
+    for (i = 0; i < FD_TBL_SIZE; i++) {
         fd_state[i] = SS_UNUSED;  /* uninstalled */
     }
 
@@ -486,9 +489,10 @@ int storage_init(const char *dirname)
 int storage_sync_checkpoint(void)
 {
     int rc;
+    uint fd = 0;
 
     /* sync fd table and reset it to clean state first */
-    for (uint fd = 0; fd < FD_TBL_SIZE; fd++) {
+    for (fd = 0; fd < FD_TBL_SIZE; fd++) {
          if (fd_state[fd] == SS_DIRTY) {
              if (fs_state == SS_CLEAN) {
                  /* need to sync individual fd */
diff --git a/trusty/storage/proxy/storage.h b/trusty/storage/proxy/storage.h
index 5a670d4b7..4d659b113 100644
--- a/trusty/storage/proxy/storage.h
+++ b/trusty/storage/proxy/storage.h
@@ -43,3 +43,7 @@ int storage_init(const char *dirname);
 
 int storage_sync_checkpoint(void);
 
+ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t offset);
+
+ssize_t read_with_retry(int fd, void *buf_, size_t size, off_t offset);
+
diff --git a/trusty/storage/tests/Android.bp b/trusty/storage/tests/Android.bp
index 536c3ca7a..f63170025 100644
--- a/trusty/storage/tests/Android.bp
+++ b/trusty/storage/tests/Android.bp
@@ -30,6 +30,7 @@ cc_test {
         "libtrustystorage",
         "libtrusty",
     ],
+
     shared_libs: [
         "liblog",
     ],
diff --git a/trusty/trusty-base.mk b/trusty/trusty-base.mk
deleted file mode 100644
index 0a0ecec02..000000000
--- a/trusty/trusty-base.mk
+++ /dev/null
@@ -1,28 +0,0 @@
-#
-# Copyright (C) 2016 The Android Open-Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-#
-# This makefile should be included by devices that use Trusty TEE
-# to pull in the baseline set of Trusty specific modules.
-#
-
-PRODUCT_PACKAGES += \
-	android.hardware.keymaster@3.0-service.trusty \
-	gatekeeper.trusty
-
-PRODUCT_PROPERTY_OVERRIDES += \
-	ro.hardware.keystore=trusty \
-	ro.hardware.gatekeeper=trusty
diff --git a/trusty/trusty-storage.mk b/trusty/trusty-storage.mk
deleted file mode 100644
index 3f263167c..000000000
--- a/trusty/trusty-storage.mk
+++ /dev/null
@@ -1,18 +0,0 @@
-#
-# Copyright (C) 2015 The Android Open-Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-PRODUCT_PACKAGES += \
-	storageproxyd \
-- 
2.22.0

