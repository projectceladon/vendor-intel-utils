From d5af6b0ea4a05cbc740c5ae31c43e1e07077e9e9 Mon Sep 17 00:00:00 2001
From: ahs <amrita.h.s@intel.com>
Date: Tue, 19 Jan 2021 21:02:20 +0530
Subject: [PATCH] avx2 for memcpy apis of libaudioutils

Tracked-On:
Signed-off-by: ahs <amrita.h.s@intel.com>
---
 audio_utils/Android.bp                     |   1 +
 audio_utils/primitives.c                   | 269 ++++++++++++++++++++-
 audio_utils/tests/primitives_benchmark.cpp | 128 +++++++++-
 3 files changed, 389 insertions(+), 9 deletions(-)

diff --git a/audio_utils/Android.bp b/audio_utils/Android.bp
index 5ffbb941..d9288f8f 100644
--- a/audio_utils/Android.bp
+++ b/audio_utils/Android.bp
@@ -80,6 +80,7 @@ cc_library {
             cflags: ["-D__unused=__attribute__((unused))"],
         },
     },
+    cflags: ["-mavx2"],
     min_sdk_version: "29",
 }
 
diff --git a/audio_utils/primitives.c b/audio_utils/primitives.c
index 06812f07..6b9e4393 100644
--- a/audio_utils/primitives.c
+++ b/audio_utils/primitives.c
@@ -17,6 +17,9 @@
 #include <cutils/bitops.h>  /* for popcount() */
 #include <audio_utils/primitives.h>
 #include "private/private.h"
+#include <immintrin.h>
+#include <xmmintrin.h>
+#include <stdio.h>
 
 void ditherAndClamp(int32_t *out, const int32_t *sums, size_t pairs)
 {
@@ -90,39 +93,166 @@ void memcpy_to_i16_from_i32(int16_t *dst, const int32_t *src, size_t count)
     }
 }
 
-void memcpy_to_i16_from_float(int16_t *dst, const float *src, size_t count)
+/*void memcpy_to_i16_from_float(int16_t *dst, const float *src, size_t count)
 {
     for (; count > 0; --count) {
         *dst++ = clamp16_from_float(*src++);
     }
+}*/
+
+inline void memcpy_to_i16_from_float_small(int16_t *dst, const float *src, size_t count)
+{
+   if(count >= 8) {
+      __m128i tmp = _mm_set_epi16(clamp16_from_float(*(src+7)), clamp16_from_float(*(src+6)),
+                                  clamp16_from_float(*(src+5)), clamp16_from_float(*(src+4)),              
+                                  clamp16_from_float(*(src+3)), clamp16_from_float(*(src+2)),              
+                                  clamp16_from_float(*(src+1)), clamp16_from_float(*(src+0)));
+      __m128i* d = (__m128i*) dst;
+      _mm_storeu_si128(d, tmp);
+      src += 8;
+      dst += 8;
+      count -= 8;
+   }
+   for(; count > 0; --count) {
+      *dst = clamp16_from_float(*src);
+      dst++; src++;
+   }
 }
 
-void memcpy_to_float_from_q4_27(float *dst, const int32_t *src, size_t count)
+void memcpy_to_i16_from_float(int16_t *dst, const float *src, size_t count)
+{
+   for(; count >= 16; count -= 16) {
+      __m256i tmp = _mm256_set_epi16(clamp16_from_float(*(src+15)), clamp16_from_float(*(src+14)),
+                                     clamp16_from_float(*(src+13)), clamp16_from_float(*(src+12)),
+                                     clamp16_from_float(*(src+11)), clamp16_from_float(*(src+10)),
+                                     clamp16_from_float(*(src+9)), clamp16_from_float(*(src+8)),
+                                     clamp16_from_float(*(src+7)), clamp16_from_float(*(src+6)),
+                                     clamp16_from_float(*(src+5)), clamp16_from_float(*(src+4)),
+                                     clamp16_from_float(*(src+3)), clamp16_from_float(*(src+2)),
+                                     clamp16_from_float(*(src+1)), clamp16_from_float(*(src+0)));
+      __m256i* d = (__m256i*) dst; 
+      _mm256_storeu_si256(d, tmp);
+      src += 16;
+      dst += 16;
+   }
+   memcpy_to_i16_from_float_small(dst, src, count);
+}
+
+/*void memcpy_to_float_from_q4_27(float *dst, const int32_t *src, size_t count)
 {
     for (; count > 0; --count) {
         *dst++ = float_from_q4_27(*src++);
     }
+}*/
+
+inline void memcpy_to_float_from_q4_27_small(float *dst, const int32_t *src, size_t count)
+{
+   if(count >= 4) {
+      __m128 tmp = _mm_set_ps(float_from_q4_27(*(src+3)), float_from_q4_27(*(src+2)), 
+		              float_from_q4_27(*(src+1)), float_from_q4_27(*(src+0)));
+      _mm_storeu_ps(dst, tmp);
+      src+= 4;
+      dst+= 4;
+      count-=4;
+   }
+   for(; count > 0; --count) {
+      *dst = float_from_q4_27(*src);
+      dst++; src++;
+   }
 }
 
-void memcpy_to_float_from_i16(float *dst, const int16_t *src, size_t count)
+void memcpy_to_float_from_q4_27(float *dst, const int32_t *src, size_t count)
+{
+   for(; count >= 8; count -= 8) {
+      __m256 tmp = _mm256_set_ps(float_from_q4_27(*(src+7)), float_from_q4_27(*(src+6)), 
+		                 float_from_q4_27(*(src+5)), float_from_q4_27(*(src+4)), 
+				 float_from_q4_27(*(src+3)), float_from_q4_27(*(src+2)), 
+				 float_from_q4_27(*(src+1)), float_from_q4_27(*(src+0)));
+      _mm256_storeu_ps(dst, tmp);
+      src+= 8;
+      dst += 8;
+   }
+   memcpy_to_float_from_q4_27_small(dst, src, count);
+}
+
+/*void memcpy_to_float_from_i16(float *dst, const int16_t *src, size_t count)
 {
     dst += count;
     src += count;
     for (; count > 0; --count) {
         *--dst = float_from_i16(*--src);
     }
+}*/
+inline void memcpy_to_float_from_i16_small(float *dst, const int16_t* src, size_t count)
+{
+   if(count >= 4) {
+      __m128 tmp = _mm_set_ps(float_from_i16(*(src+3)), float_from_i16(*(src+2)), 
+		              float_from_i16(*(src+1)), float_from_i16(*(src+0)));
+      _mm_storeu_ps(dst, tmp);
+      src+= 4;
+      dst+= 4;
+      count-=4;
+   }
+   for(; count > 0; --count) {
+      *dst = float_from_i16(*src);
+      dst++; src++;
+   }
 }
 
-void memcpy_to_float_from_u8(float *dst, const uint8_t *src, size_t count)
+void memcpy_to_float_from_i16(float *dst, const int16_t *src, size_t count)
+{
+   for(; count >= 8; count -= 8) {
+      __m256 tmp = _mm256_set_ps(float_from_i16(*(src+7)), float_from_i16(*(src+6)), 
+		                 float_from_i16(*(src+5)), float_from_i16(*(src+4)), 
+				 float_from_i16(*(src+3)), float_from_i16(*(src+2)), 
+				 float_from_i16(*(src+1)), float_from_i16(*(src+0)));
+      _mm256_storeu_ps(dst, tmp);
+      src+= 8;
+      dst += 8;
+   }
+   memcpy_to_float_from_i16_small(dst, src, count);
+}
+
+/*void memcpy_to_float_from_u8(float *dst, const uint8_t *src, size_t count)
 {
     dst += count;
     src += count;
     for (; count > 0; --count) {
         *--dst = float_from_u8(*--src);
     }
+}*/
+
+inline void memcpy_to_float_from_u8_small(float *dst, const uint8_t *src, size_t count)
+{
+   if(count >= 4) {
+      __m128 tmp = _mm_set_ps(float_from_u8(*(src+3)), float_from_u8(*(src+2)), 
+		              float_from_u8(*(src+1)), float_from_u8(*(src+0)));
+      _mm_storeu_ps(dst, tmp);
+      src+= 4;
+      dst+= 4;
+      count-=4;
+   }
+   for(; count > 0; --count) {
+      *dst = float_from_u8(*src);
+      dst++; src++;
+   }
 }
 
-void memcpy_to_float_from_p24(float *dst, const uint8_t *src, size_t count)
+void memcpy_to_float_from_u8(float *dst, const uint8_t *src, size_t count)
+{
+   for(; count >= 8; count -= 8) {
+      __m256 tmp = _mm256_set_ps(float_from_u8(*(src+7)), float_from_u8(*(src+6)), 
+		                 float_from_u8(*(src+5)), float_from_u8(*(src+4)), 
+				 float_from_u8(*(src+3)), float_from_u8(*(src+2)), 
+				 float_from_u8(*(src+1)), float_from_u8(*(src+0)));
+      _mm256_storeu_ps(dst, tmp);
+      src+= 8;
+      dst += 8;
+   }
+   memcpy_to_float_from_u8_small(dst, src, count);
+}
+
+/*void memcpy_to_float_from_p24(float *dst, const uint8_t *src, size_t count)
 {
     dst += count;
     src += count * 3;
@@ -130,6 +260,36 @@ void memcpy_to_float_from_p24(float *dst, const uint8_t *src, size_t count)
         src -= 3;
         *--dst = float_from_p24(src);
     }
+}*/
+
+inline void memcpy_to_float_from_p24_small(float *dst, const uint8_t *src, size_t count)
+{
+   if(count >= 4) {
+      __m128 tmp = _mm_set_ps(float_from_p24(src+9), float_from_p24(src+6), 
+		              float_from_p24(src+3), float_from_p24(src+0));
+      _mm_storeu_ps(dst, tmp);
+      src += 12;
+      dst += 4;
+      count -= 4;
+   }
+   for(; count > 0; --count) {
+      *dst = float_from_p24(src);
+      dst++; src += 3;
+   }
+}
+
+void memcpy_to_float_from_p24(float *dst, const uint8_t *src, size_t count)
+{
+   for(; count >= 8; count -= 8) {
+      __m256 tmp = _mm256_set_ps(float_from_p24(src+21), float_from_p24(src+18), 
+		                 float_from_p24(src+15), float_from_p24(src+12), 
+				 float_from_p24(src+9), float_from_p24(src+6), 
+				 float_from_p24(src+3), float_from_p24(src+0));
+      _mm256_storeu_ps(dst, tmp);
+      src += 24;
+      dst += 8;
+   }
+   memcpy_to_float_from_p24_small(dst, src, count);
 }
 
 void memcpy_to_i16_from_p24(int16_t *dst, const uint8_t *src, size_t count)
@@ -272,11 +432,41 @@ void memcpy_to_i16_from_q8_23(int16_t *dst, const int32_t *src, size_t count)
     }
 }
 
-void memcpy_to_float_from_q8_23(float *dst, const int32_t *src, size_t count)
+/*void memcpy_to_float_from_q8_23(float *dst, const int32_t *src, size_t count)
 {
     for (; count > 0; --count) {
         *dst++ = float_from_q8_23(*src++);
     }
+}*/
+
+inline void memcpy_to_float_from_q8_23_small(float *dst, const int32_t *src, size_t count)
+{
+   if(count >= 4) {
+      __m128 tmp = _mm_set_ps(float_from_q8_23(*(src+3)), float_from_q8_23(*(src+2)), 
+		              float_from_q8_23(*(src+1)), float_from_q8_23(*(src+0)));
+      _mm_storeu_ps(dst, tmp);
+      src+= 4;
+      dst+= 4;
+      count-=4;
+   }
+   for(; count > 0; --count) {
+      *dst = float_from_q8_23(*src);
+      dst++; src++;
+   }
+}
+
+void memcpy_to_float_from_q8_23(float *dst, const int32_t *src, size_t count)
+{
+   for(; count >= 8; count -= 8) {
+      __m256 tmp = _mm256_set_ps(float_from_q8_23(*(src+7)), float_from_q8_23(*(src+6)), 
+		                 float_from_q8_23(*(src+5)), float_from_q8_23(*(src+4)), 
+				 float_from_q8_23(*(src+3)), float_from_q8_23(*(src+2)), 
+				 float_from_q8_23(*(src+1)), float_from_q8_23(*(src+0)));
+      _mm256_storeu_ps(dst, tmp);
+      src+= 8;
+      dst += 8;
+   }
+   memcpy_to_float_from_q8_23_small(dst, src, count);
 }
 
 void memcpy_to_i32_from_u8(int32_t *dst, const uint8_t *src, size_t count)
@@ -304,14 +494,44 @@ void memcpy_to_i32_from_float(int32_t *dst, const float *src, size_t count)
     }
 }
 
-void memcpy_to_float_from_i32(float *dst, const int32_t *src, size_t count)
+/*void memcpy_to_float_from_i32(float *dst, const int32_t *src, size_t count)
 {
     for (; count > 0; --count) {
         *dst++ = float_from_i32(*src++);
     }
+}*/
+
+inline void memcpy_to_float_from_i32_small(float *dst, const int32_t *src, size_t count)
+{
+   if(count >= 4) {
+      __m128 tmp = _mm_set_ps(float_from_i32(*(src+3)), float_from_i32(*(src+2)), 
+		              float_from_i32(*(src+1)), float_from_i32(*(src+0)));
+      _mm_storeu_ps(dst, tmp);
+      src+= 4;
+      dst+= 4;
+      count-=4;
+   }
+   for(; count > 0; --count) {
+      *dst = float_from_i32(*src);
+      dst++; src++;
+   }
 }
 
-void memcpy_to_float_from_float_with_clamping(float *dst, const float *src, size_t count,
+void memcpy_to_float_from_i32(float *dst, const int32_t *src, size_t count)
+{
+   for(; count >= 8; count -= 8) {
+      __m256 tmp = _mm256_set_ps(float_from_i32(*(src+7)), float_from_i32(*(src+6)), 
+		                 float_from_i32(*(src+5)), float_from_i32(*(src+4)), 
+				 float_from_i32(*(src+3)), float_from_i32(*(src+2)), 
+				 float_from_i32(*(src+1)), float_from_i32(*(src+0)));
+      _mm256_storeu_ps(dst, tmp);
+      src+= 8;
+      dst += 8;
+   }
+   memcpy_to_float_from_i32_small(dst, src, count);
+}
+
+/*void memcpy_to_float_from_float_with_clamping(float *dst, const float *src, size_t count,
                                               float absMax) {
     // Note: using NEON intrinsics (vminq_f32, vld1q_f32...) did NOT accelerate
     // the function when benchmarked. The compiler already vectorize using FMINNM f32x4 & similar.
@@ -320,7 +540,40 @@ void memcpy_to_float_from_float_with_clamping(float *dst, const float *src, size
     for (; count > 0; --count) {
         const float sample = *src++;
         *dst++ = fmax(-absMax, fmin(absMax, sample));
+        // *dst++ = fmax(-absMax, fmin(absMax, *src++));
     }
+}*/
+
+inline void memcpy_to_float_from_float_with_clamping_small(float *dst, const float *src, size_t count,
+                                              float absMax) 
+{
+   if(count >= 4) {
+      __m128 tmp = _mm_set_ps(fmax(-absMax, fmin(absMax, *(src+3))), fmax(-absMax, fmin(absMax, *(src+2))),
+                              fmax(-absMax, fmin(absMax, *(src+1))), fmax(-absMax, fmin(absMax, *(src+0))));
+      _mm_storeu_ps(dst, tmp);
+      src+= 4;
+      dst+= 4;
+      count-=4;
+   }
+   for(; count > 0; --count) {
+      const float sample = *src++;
+      *dst++ = fmax(-absMax, fmin(absMax, sample));
+   }
+}
+
+void memcpy_to_float_from_float_with_clamping(float *dst, const float *src, size_t count,
+                                              float absMax)
+{	
+   for(; count >= 8; count -= 8) {
+      __m256 tmp = _mm256_set_ps(fmax(-absMax, fmin(absMax, *(src+7))), fmax(-absMax, fmin(absMax, *(src+6))), 
+                                 fmax(-absMax, fmin(absMax, *(src+5))), fmax(-absMax, fmin(absMax, *(src+4))),
+                                 fmax(-absMax, fmin(absMax, *(src+3))), fmax(-absMax, fmin(absMax, *(src+2))),
+                                 fmax(-absMax, fmin(absMax, *(src+1))), fmax(-absMax, fmin(absMax, *(src+0))));
+      _mm256_storeu_ps(dst, tmp);
+      src+= 8;
+      dst += 8;
+   }
+   memcpy_to_float_from_float_with_clamping_small(dst, src, count, absMax);
 }
 
 void downmix_to_mono_i16_from_stereo_i16(int16_t *dst, const int16_t *src, size_t count)
diff --git a/audio_utils/tests/primitives_benchmark.cpp b/audio_utils/tests/primitives_benchmark.cpp
index ac00b1fc..56641b1c 100644
--- a/audio_utils/tests/primitives_benchmark.cpp
+++ b/audio_utils/tests/primitives_benchmark.cpp
@@ -54,6 +54,7 @@ static void BM_MemcpyToFloatFromFloatWithClamping(benchmark::State& state) {
 }
 
 BENCHMARK(BM_MemcpyToFloatFromFloatWithClamping)->RangeMultiplier(2)->Ranges({{10, 8<<12}, {1, 2}});
+//BENCHMARK(BM_MemcpyToFloatFromFloatWithClamping)->Arg(8);
 
 static void BM_MemcpyFloat(benchmark::State& state) {
     const size_t count = state.range(0);
@@ -83,10 +84,10 @@ static void BM_MemcpyFloat(benchmark::State& state) {
 }
 
 BENCHMARK(BM_MemcpyFloat)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+//BENCHMARK(BM_MemcpyFloat)->Arg(8);
 
 static void BM_MemcpyToFloatFromI16(benchmark::State& state) {
     const size_t count = state.range(0);
-
     std::vector<int16_t> src(count);
     std::vector<float> dst(count);
 
@@ -109,7 +110,131 @@ static void BM_MemcpyToFloatFromI16(benchmark::State& state) {
 }
 
 BENCHMARK(BM_MemcpyToFloatFromI16)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+//BENCHMARK(BM_MemcpyToFloatFromI16)->Arg(8)->Arg(10)->Arg(16);
+
+static void BM_MemcpyToFloatFromQ427(benchmark::State& state) {
+    const size_t count = state.range(0);
+    std::vector<int32_t> src(count);
+    std::vector<float> dst(count);
+
+    // Initialize src buffer with deterministic pseudo-random values
+    std::minstd_rand gen(count);
+    std::uniform_int_distribution<> dis(INT32_MIN, INT32_MAX);
+    for (size_t i = 0; i < count; i++) {
+        src[i] = dis(gen);
+    }
+
+    // Run the test
+    while (state.KeepRunning()) {
+        benchmark::DoNotOptimize(src.data());
+        benchmark::DoNotOptimize(dst.data());
+        memcpy_to_float_from_q4_27(dst.data(), src.data(), count);
+        benchmark::ClobberMemory();
+    }
+
+    state.SetComplexityN(state.range(0));
+}
+BENCHMARK(BM_MemcpyToFloatFromQ427)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+//BENCHMARK(BM_MemcpyToFloatFromQ427)->Arg(8);
+
+static void BM_MemcpyToFloatFromU8(benchmark::State& state) {
+    const size_t count = state.range(0);
+    std::vector<uint8_t> src(count);
+    std::vector<float> dst(count);
+
+    // Initialize src buffer with deterministic pseudo-random values
+    std::minstd_rand gen(count);
+    std::uniform_int_distribution<> dis(0, UINT8_MAX);
+    for (size_t i = 0; i < count; i++) {
+        src[i] = dis(gen);
+    }
+
+    // Run the test
+    while (state.KeepRunning()) {
+        benchmark::DoNotOptimize(src.data());
+        benchmark::DoNotOptimize(dst.data());
+        memcpy_to_float_from_u8(dst.data(), src.data(), count);
+        benchmark::ClobberMemory();
+    }
+
+    state.SetComplexityN(state.range(0));
+}
+BENCHMARK(BM_MemcpyToFloatFromU8)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+//BENCHMARK(BM_MemcpyToFloatFromU8)->Arg(8);
+
+static void BM_MemcpyToFloatFromP24(benchmark::State& state) {
+    const size_t count = state.range(0);
+    std::vector<uint8_t> src(count);
+    std::vector<float> dst(count);
+
+    // Initialize src buffer with deterministic pseudo-random values
+    std::minstd_rand gen(count);
+    std::uniform_int_distribution<> dis(0, UINT8_MAX);
+    for (size_t i = 0; i < count; i++) {
+        src[i] = dis(gen);
+    }
 
+    // Run the test
+    while (state.KeepRunning()) {
+        benchmark::DoNotOptimize(src.data());
+        benchmark::DoNotOptimize(dst.data());
+        memcpy_to_float_from_p24(dst.data(), src.data(), count);
+        benchmark::ClobberMemory();
+    }
+
+    state.SetComplexityN(state.range(0));
+}
+BENCHMARK(BM_MemcpyToFloatFromP24)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+
+static void BM_MemcpyToFloatFromI32(benchmark::State& state) {
+    const size_t count = state.range(0);
+    std::vector<int32_t> src(count);
+    std::vector<float> dst(count);
+
+    // Initialize src buffer with deterministic pseudo-random values
+    std::minstd_rand gen(count);
+    std::uniform_int_distribution<> dis(INT32_MIN, INT32_MAX);
+    for (size_t i = 0; i < count; i++) {
+        src[i] = dis(gen);
+    }
+
+    // Run the test
+    while (state.KeepRunning()) {
+        benchmark::DoNotOptimize(src.data());
+        benchmark::DoNotOptimize(dst.data());
+        memcpy_to_float_from_i32(dst.data(), src.data(), count);
+        benchmark::ClobberMemory();
+    }
+
+    state.SetComplexityN(state.range(0));
+}
+BENCHMARK(BM_MemcpyToFloatFromI32)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+//BENCHMARK(BM_MemcpyToFloatFromI32)->Arg(8);
+
+static void BM_MemcpyToFloatFromQ823(benchmark::State& state) {
+    const size_t count = state.range(0);
+    std::vector<int32_t> src(count);
+    std::vector<float> dst(count);
+
+    // Initialize src buffer with deterministic pseudo-random values
+    std::minstd_rand gen(count);
+    std::uniform_int_distribution<> dis(INT32_MIN, INT32_MAX);
+    for (size_t i = 0; i < count; i++) {
+        src[i] = dis(gen);
+    }
+
+    // Run the test
+    while (state.KeepRunning()) {
+        benchmark::DoNotOptimize(src.data());
+        benchmark::DoNotOptimize(dst.data());
+        memcpy_to_float_from_q8_23(dst.data(), src.data(), count);
+        benchmark::ClobberMemory();
+    }
+
+    state.SetComplexityN(state.range(0));
+}
+BENCHMARK(BM_MemcpyToFloatFromQ823)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+//BENCHMARK(BM_MemcpyToFloatFromQ823)->Arg(8);
 
 static void BM_MemcpyToI16FromFloat(benchmark::State& state) {
     const size_t count = state.range(0);
@@ -136,5 +261,6 @@ static void BM_MemcpyToI16FromFloat(benchmark::State& state) {
 }
 
 BENCHMARK(BM_MemcpyToI16FromFloat)->RangeMultiplier(2)->Ranges({{10, 8<<12}});
+//BENCHMARK(BM_MemcpyToI16FromFloat)->Arg(8);
 
 BENCHMARK_MAIN();
-- 
2.17.1

