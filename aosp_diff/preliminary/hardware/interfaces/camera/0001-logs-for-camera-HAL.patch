From 739bd6f8b7ab16cbae45215e68ea733052654242 Mon Sep 17 00:00:00 2001
From: user189 <shiva.kumara.rudrappa@intel.com>
Date: Thu, 8 Apr 2021 11:13:53 +0530
Subject: [PATCH] logs for camera HAL

---
 camera/device/3.4/default/CameraDevice.cpp    |  3 +-
 .../3.4/default/CameraDeviceSession.cpp       | 14 ++++++++--
 .../3.4/default/ExternalCameraDevice.cpp      | 12 +++++---
 .../default/ExternalCameraDeviceSession.cpp   | 28 +++++++++++++------
 .../3.4/default/ExternalCameraUtils.cpp       | 10 +++++--
 5 files changed, 48 insertions(+), 19 deletions(-)

diff --git a/camera/device/3.4/default/CameraDevice.cpp b/camera/device/3.4/default/CameraDevice.cpp
index bc443deb3..e83c50a1a 100644
--- a/camera/device/3.4/default/CameraDevice.cpp
+++ b/camera/device/3.4/default/CameraDevice.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "CamDev@3.4-impl"
+#define LOG_TAG "shiva CamDev@3.4-impl"
 #include <log/log.h>
 
 #include <utils/Vector.h>
@@ -44,6 +44,7 @@ CameraDevice::~CameraDevice() {
 sp<V3_2::implementation::CameraDeviceSession> CameraDevice::createSession(camera3_device_t* device,
         const camera_metadata_t* deviceInfo,
         const sp<V3_2::ICameraDeviceCallback>& callback) {
+ALOGE("shiva createSession");
     sp<CameraDeviceSession> session = new CameraDeviceSession(device, deviceInfo, callback);
     IF_ALOGV() {
         session->getInterface()->interfaceChain([](
diff --git a/camera/device/3.4/default/CameraDeviceSession.cpp b/camera/device/3.4/default/CameraDeviceSession.cpp
index b4ebe2270..df03cb1bd 100644
--- a/camera/device/3.4/default/CameraDeviceSession.cpp
+++ b/camera/device/3.4/default/CameraDeviceSession.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "CamDevSession@3.4-impl"
+#define LOG_TAG "shiva CamDevSession@3.4-impl"
 #include <android/log.h>
 
 #include <set>
@@ -41,7 +41,7 @@ CameraDeviceSession::CameraDeviceSession(
         mResultBatcher_3_4(callback) {
 
     mHasCallback_3_4 = false;
-
+ALOGE("shiva CameraDeviceSession construct");
     auto castResult = ICameraDeviceCallback::castFrom(callback);
     if (castResult.isOk()) {
         sp<ICameraDeviceCallback> callback3_4 = castResult;
@@ -78,6 +78,7 @@ void CameraDeviceSession::configureStreams_3_4_Impl(
         uint32_t streamConfigCounter, bool useOverriddenFields)  {
     Status status = initStatus();
     HalStreamConfiguration outStreams;
+ALOGE("shiva configureStreams_3_4_Impl construct");
 
     // If callback is 3.2, make sure no physical stream is configured
     if (!mHasCallback_3_4) {
@@ -168,6 +169,7 @@ bool CameraDeviceSession::preProcessConfigurationLocked_3_4(
         const StreamConfiguration& requestedConfiguration, bool useOverriddenFields,
         camera3_stream_configuration_t *stream_list /*out*/,
         hidl_vec<camera3_stream_t*> *streams /*out*/) {
+ALOGE("shiva preProcessConfigurationLocked_3_4 construct");
 
     if ((stream_list == nullptr) || (streams == nullptr)) {
         return false;
@@ -248,6 +250,8 @@ bool CameraDeviceSession::preProcessConfigurationLocked_3_4(
 
 void CameraDeviceSession::postProcessConfigurationLocked_3_4(
         const StreamConfiguration& requestedConfiguration) {
+ALOGE("shiva postProcessConfigurationLocked_3_4 construct");
+
     // delete unused streams, note we do this after adding new streams to ensure new stream
     // will not have the same address as deleted stream, and HAL has a chance to reference
     // the to be deleted stream in configure_streams call
@@ -319,6 +323,7 @@ Return<void> CameraDeviceSession::processCaptureRequest_3_4(
             break;
         }
     }
+ALOGE("shiva processCaptureRequest_3_4");
 
     if (s == Status::OK && requests.size() > 1) {
         mResultBatcher_3_4.registerBatch(requests[0].v3_2.frameNumber, requests.size());
@@ -330,6 +335,8 @@ Return<void> CameraDeviceSession::processCaptureRequest_3_4(
 
 Status CameraDeviceSession::processOneCaptureRequest_3_4(const V3_4::CaptureRequest& request)  {
     Status status = initStatus();
+ALOGE("shiva processOneCaptureRequest_3_4");
+
     if (status != Status::OK) {
         ALOGE("%s: camera init failed or disconnected", __FUNCTION__);
         return status;
@@ -527,6 +534,7 @@ void CameraDeviceSession::sProcessCaptureResult_3_4(
         const camera3_capture_result *hal_result) {
     CameraDeviceSession *d =
             const_cast<CameraDeviceSession*>(static_cast<const CameraDeviceSession*>(cb));
+ALOGE("shiva sProcessCaptureResult_3_4");
 
     CaptureResult result = {};
     camera3_capture_result shadowResult;
@@ -745,6 +753,8 @@ void CameraDeviceSession::ResultBatcher_3_4::invokeProcessCaptureResultCallback_
 }
 
 void CameraDeviceSession::ResultBatcher_3_4::freeReleaseFences_3_4(hidl_vec<CaptureResult>& results) {
+ALOGE("shiva freeReleaseFences_3_4");
+
     for (auto& result : results) {
         if (result.v3_2.inputBuffer.releaseFence.getNativeHandle() != nullptr) {
             native_handle_t* handle = const_cast<native_handle_t*>(
diff --git a/camera/device/3.4/default/ExternalCameraDevice.cpp b/camera/device/3.4/default/ExternalCameraDevice.cpp
index 6cd5fdf4f..b55bd869a 100644
--- a/camera/device/3.4/default/ExternalCameraDevice.cpp
+++ b/camera/device/3.4/default/ExternalCameraDevice.cpp
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "ExtCamDev@3.4"
-//#define LOG_NDEBUG 0
+#define LOG_TAG "shiva ExtCamDev@3.4"
+#define LOG_NDEBUG 0
 #include <log/log.h>
 
 #include <algorithm>
@@ -55,6 +55,7 @@ ExternalCameraDevice::ExternalCameraDevice(
         mDevicePath(devicePath),
         mCfg(cfg) {
     std::smatch sm;
+ALOGE("shiva ExternalCameraDevice construct");
     if (std::regex_match(mDevicePath, sm, kDevicePathRE)) {
         mCameraId = std::to_string(mCfg.cameraIdOffset + std::stoi(sm[1]));
     } else {
@@ -94,6 +95,7 @@ Return<void> ExternalCameraDevice::getCameraCharacteristics(
     Mutex::Autolock _l(mLock);
     V3_2::CameraMetadata hidlChars;
 
+ALOGE("shiva getCameraCharacteristics");
     if (isInitFailedLocked()) {
         _hidl_cb(Status::INTERNAL_ERROR, hidlChars);
         return Void();
@@ -114,7 +116,7 @@ Return<void> ExternalCameraDevice::open(
         const sp<ICameraDeviceCallback>& callback, ICameraDevice::open_cb _hidl_cb) {
     Status status = Status::OK;
     sp<ExternalCameraDeviceSession> session = nullptr;
-
+ALOGE("shiva open");
     if (callback == nullptr) {
         ALOGE("%s: cannot open camera %s. callback is null!",
                 __FUNCTION__, mCameraId.c_str());
@@ -131,7 +133,7 @@ Return<void> ExternalCameraDevice::open(
 
     mLock.lock();
 
-    ALOGV("%s: Initializing device for camera %s", __FUNCTION__, mCameraId.c_str());
+    ALOGE("%s: Initializing device for camera %s", __FUNCTION__, mCameraId.c_str());
     session = mSession.promote();
     if (session != nullptr && !session->isClosed()) {
         ALOGE("%s: cannot open an already opened camera!", __FUNCTION__);
@@ -212,6 +214,7 @@ Return<void> ExternalCameraDevice::dumpState(const ::android::hardware::hidl_han
 
 
 status_t ExternalCameraDevice::initCameraCharacteristics() {
+ALOGE("shiva initCameraCharacteristics");
     if (mCameraCharacteristics.isEmpty()) {
         // init camera characteristics
         unique_fd fd(::open(mDevicePath.c_str(), O_RDWR));
@@ -264,6 +267,7 @@ do {                                               \
 status_t ExternalCameraDevice::initAvailableCapabilities(
         ::android::hardware::camera::common::V1_0::helper::CameraMetadata* metadata) {
 
+ALOGE("shiva initAvailableCapabilities");
     if (mSupportedFormats.empty()) {
         ALOGE("%s: Supported formats list is empty", __FUNCTION__);
         return UNKNOWN_ERROR;
diff --git a/camera/device/3.4/default/ExternalCameraDeviceSession.cpp b/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
index 5f8674219..df27442ef 100644
--- a/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
+++ b/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
@@ -13,8 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "ExtCamDevSsn@3.4"
-//#define LOG_NDEBUG 0
+#define LOG_TAG "shiva ExtCamDevSsn@3.4"
+#define LOG_NDEBUG 0
 #define ATRACE_TAG ATRACE_TAG_CAMERA
 #include <log/log.h>
 
@@ -107,6 +107,7 @@ ExternalCameraDeviceSession::ExternalCameraDeviceSession(
         mMaxJpegResolution(getMaxJpegResolution()) {}
 
 bool ExternalCameraDeviceSession::initialize() {
+ALOGE("shiva initialize");
     if (mV4l2Fd.get() < 0) {
         ALOGE("%s: invalid v4l2 device fd %d!", __FUNCTION__, mV4l2Fd.get());
         return true;
@@ -200,8 +201,9 @@ void ExternalCameraDeviceSession::closeOutputThreadImpl() {
 Status ExternalCameraDeviceSession::initStatus() const {
     Mutex::Autolock _l(mLock);
     Status status = Status::OK;
+ALOGE("shiva initStatus");
     if (mInitFail || mClosed) {
-        ALOGI("%s: sesssion initFailed %d closed %d", __FUNCTION__, mInitFail, mClosed);
+        ALOGE("%s: sesssion initFailed %d closed %d", __FUNCTION__, mInitFail, mClosed);
         status = Status::INTERNAL_ERROR;
     }
     return status;
@@ -346,7 +348,7 @@ Return<void> ExternalCameraDeviceSession::configureStreams(
     V3_2::HalStreamConfiguration outStreams;
     V3_3::HalStreamConfiguration outStreams_v33;
     Mutex::Autolock _il(mInterfaceLock);
-
+ALOGE("shiva configureStreams");
     Status status = configureStreams(streams, &outStreams_v33);
     size_t size = outStreams_v33.streams.size();
     outStreams.streams.resize(size);
@@ -362,6 +364,7 @@ Return<void> ExternalCameraDeviceSession::configureStreams_3_3(
         ICameraDeviceSession::configureStreams_3_3_cb _hidl_cb) {
     V3_3::HalStreamConfiguration outStreams;
     Mutex::Autolock _il(mInterfaceLock);
+ALOGE("shiva configureStreams_3_3");
 
     Status status = configureStreams(streams, &outStreams);
     _hidl_cb(status, outStreams);
@@ -375,6 +378,7 @@ Return<void> ExternalCameraDeviceSession::configureStreams_3_4(
     V3_3::HalStreamConfiguration outStreams_v33;
     V3_4::HalStreamConfiguration outStreams;
     Mutex::Autolock _il(mInterfaceLock);
+ALOGE("shiva configureStreams_3_4");
 
     config_v32.operationMode = requestedConfiguration.operationMode;
     config_v32.streams.resize(requestedConfiguration.streams.size());
@@ -426,7 +430,7 @@ Return<void> ExternalCameraDeviceSession::processCaptureRequest(
         ICameraDeviceSession::processCaptureRequest_cb _hidl_cb) {
     Mutex::Autolock _il(mInterfaceLock);
     updateBufferCaches(cachesToRemove);
-
+ALOGE("shiva processCaptureRequest");
     uint32_t numRequestProcessed = 0;
     Status s = Status::OK;
     for (size_t i = 0; i < requests.size(); i++, numRequestProcessed++) {
@@ -449,6 +453,7 @@ Return<void> ExternalCameraDeviceSession::processCaptureRequest_3_4(
 
     uint32_t numRequestProcessed = 0;
     Status s = Status::OK;
+ALOGE("shiva processCaptureRequest_3_4");
     for (size_t i = 0; i < requests.size(); i++, numRequestProcessed++) {
         s = processOneCaptureRequest(requests[i].v3_2);
         if (s != Status::OK) {
@@ -490,7 +495,7 @@ Return<void> ExternalCameraDeviceSession::close(bool callerIsDtor) {
             }
         }
         v4l2StreamOffLocked();
-        ALOGV("%s: closing V4L2 camera FD %d", __FUNCTION__, mV4l2Fd.get());
+        ALOGE("%s: closing V4L2 camera FD %d", __FUNCTION__, mV4l2Fd.get());
         mV4l2Fd.reset();
         mClosed = true;
     }
@@ -501,6 +506,7 @@ Status ExternalCameraDeviceSession::importRequestLocked(
     const CaptureRequest& request,
     hidl_vec<buffer_handle_t*>& allBufPtrs,
     hidl_vec<int>& allFences) {
+ALOGE("shiva importRequestLocked");
     return importRequestLockedImpl(request, allBufPtrs, allFences);
 }
 
@@ -509,6 +515,7 @@ Status ExternalCameraDeviceSession::importBuffer(int32_t streamId,
         /*out*/buffer_handle_t** outBufPtr,
         bool allowEmptyBuf) {
     Mutex::Autolock _l(mCbsLock);
+ALOGE("shiva importBuffer");
     return importBufferLocked(streamId, bufId, buf, outBufPtr, allowEmptyBuf);
 }
 
@@ -516,6 +523,7 @@ Status ExternalCameraDeviceSession::importBufferLocked(int32_t streamId,
         uint64_t bufId, buffer_handle_t buf,
         /*out*/buffer_handle_t** outBufPtr,
         bool allowEmptyBuf) {
+ALOGE("shiva importBufferLocked");
     return importBufferImpl(
             mCirculatingBuffers, sHandleImporter, streamId,
             bufId, buf, outBufPtr, allowEmptyBuf);
@@ -536,7 +544,7 @@ Status ExternalCameraDeviceSession::importRequestLockedImpl(
     allBufPtrs.resize(numBufs);
     allFences.resize(numBufs);
     std::vector<int32_t> streamIds(numBufs);
-
+ALOGE("shiva importRequestLockedImpl");
     for (size_t i = 0; i < numOutputBufs; i++) {
         allBufs[i] = request.outputBuffers[i].buffer.getNativeHandle();
         allBufIds[i] = request.outputBuffers[i].bufferId;
@@ -601,6 +609,7 @@ Status ExternalCameraDeviceSession::processOneCaptureRequest(const CaptureReques
         return status;
     }
 
+ALOGE("shiva processOneCaptureRequest");
     if (request.inputBuffer.streamId != -1) {
         ALOGE("%s: external camera does not support reprocessing!", __FUNCTION__);
         return Status::ILLEGAL_ARGUMENT;
@@ -767,6 +776,7 @@ Status ExternalCameraDeviceSession::processCaptureRequestError(
         /*out*/std::vector<NotifyMsg>* outMsgs,
         /*out*/std::vector<CaptureResult>* outResults) {
     ATRACE_CALL();
+ALOGE("shiva processCaptureRequestError");
     // Return V4L2 buffer to V4L2 buffer queue
     sp<V3_4::implementation::V4L2Frame> v4l2Frame =
             static_cast<V3_4::implementation::V4L2Frame*>(req->frameIn.get());
@@ -831,7 +841,7 @@ Status ExternalCameraDeviceSession::processCaptureResult(std::shared_ptr<HalRequ
     sp<V3_4::implementation::V4L2Frame> v4l2Frame =
             static_cast<V3_4::implementation::V4L2Frame*>(req->frameIn.get());
     enqueueV4l2Frame(v4l2Frame);
-
+ALOGE("shiva processCaptureResult");
     // NotifyShutter
     notifyShutter(req->frameNumber, req->shutterTs);
 
@@ -887,7 +897,7 @@ void ExternalCameraDeviceSession::invokeProcessCaptureResultCallback(
         hidl_vec<CaptureResult> &results, bool tryWriteFmq) {
     if (mProcessCaptureResultLock.tryLock() != OK) {
         const nsecs_t NS_TO_SECOND = 1000000000;
-        ALOGV("%s: previous call is not finished! waiting 1s...", __FUNCTION__);
+        ALOGE("%s: previous call is not finished! waiting 1s...", __FUNCTION__);
         if (mProcessCaptureResultLock.timedLock(/* 1s */NS_TO_SECOND) != OK) {
             ALOGE("%s: cannot acquire lock in 1s, cannot proceed",
                     __FUNCTION__);
diff --git a/camera/device/3.4/default/ExternalCameraUtils.cpp b/camera/device/3.4/default/ExternalCameraUtils.cpp
index 8f4626c56..ff93261cb 100644
--- a/camera/device/3.4/default/ExternalCameraUtils.cpp
+++ b/camera/device/3.4/default/ExternalCameraUtils.cpp
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "ExtCamUtils@3.4"
+#define LOG_TAG "shiva ExtCamUtils@3.4"
 //#define LOG_NDEBUG 0
 #include <log/log.h>
 
@@ -70,14 +70,14 @@ int V4L2Frame::map(uint8_t** data, size_t* dataSize) {
     }
     *data = mData;
     *dataSize = mDataSize;
-    ALOGV("%s: V4L map FD %d, data %p size %zu", __FUNCTION__, mFd, mData, mDataSize);
+    ALOGE("shiva %s: V4L map FD %d, data %p size %zu", __FUNCTION__, mFd, mData, mDataSize);
     return 0;
 }
 
 int V4L2Frame::unmap() {
     std::lock_guard<std::mutex> lk(mLock);
     if (mMapped) {
-        ALOGV("%s: V4L unmap data %p size %zu", __FUNCTION__, mData, mDataSize);
+        ALOGE("shiva %s: V4L unmap data %p size %zu", __FUNCTION__, mData, mDataSize);
         if (munmap(mData, mDataSize) != 0) {
             ALOGE("%s: V4L2 buffer unmap failed: %s", __FUNCTION__, strerror(errno));
             return -EINVAL;
@@ -103,6 +103,7 @@ AllocatedFrame::~AllocatedFrame() {}
 
 int AllocatedFrame::allocate(YCbCrLayout* out) {
     std::lock_guard<std::mutex> lk(mLock);
+ALOGE("shiva allocate");
     if ((mWidth % 2) || (mHeight % 2)) {
         ALOGE("%s: bad dimension %dx%d (not multiple of 2)", __FUNCTION__, mWidth, mHeight);
         return -EINVAL;
@@ -189,6 +190,7 @@ double SupportedV4L2Format::FrameRate::getDouble() const {
         /*out*/buffer_handle_t** outBufPtr,
         bool allowEmptyBuf) {
     using ::android::hardware::camera::common::V1_0::Status;
+ALOGE("shiva importBufferImpl");
     if (buf == nullptr && bufId == BUFFER_ID_NO_BUFFER) {
         if (allowEmptyBuf) {
             *outBufPtr = &sEmptyBuffer;
@@ -580,6 +582,7 @@ Size getMaxThumbnailResolution(const common::V1_0::helper::CameraMetadata& chars
 }
 
 void freeReleaseFences(hidl_vec<V3_2::CaptureResult>& results) {
+ALOGE("shiva freeReleaseFences");
     for (auto& result : results) {
         if (result.inputBuffer.releaseFence.getNativeHandle() != nullptr) {
             native_handle_t* handle = const_cast<native_handle_t*>(
@@ -672,6 +675,7 @@ AllocatedV4L2Frame::AllocatedV4L2Frame(sp<V3_4::implementation::V4L2Frame> frame
         Frame(frameIn->mWidth, frameIn->mHeight, frameIn->mFourcc) {
     uint8_t* dataIn;
     size_t dataSize;
+ALOGE("shiva AllocatedV4L2Frame");
     if (frameIn->getData(&dataIn, &dataSize) != 0) {
         ALOGE("%s: map input V4L2 frame failed!", __FUNCTION__);
         return;
-- 
2.17.1

