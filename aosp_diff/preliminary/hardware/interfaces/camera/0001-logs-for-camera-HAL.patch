From 94efc5d7f76e0f54747866eba658357bbd8681bf Mon Sep 17 00:00:00 2001
From: user189 <shiva.kumara.rudrappa@intel.com>
Date: Thu, 8 Apr 2021 11:13:53 +0530
Subject: [PATCH] logs for camera HAL

Signed-off-by: user189 <shiva.kumara.rudrappa@intel.com>
---
 camera/common/1.0/default/HandleImporter.cpp  | 24 ++++++++-
 camera/device/3.4/default/CameraDevice.cpp    |  3 +-
 .../3.4/default/CameraDeviceSession.cpp       | 39 +++++++++++++-
 .../3.4/default/ExternalCameraDevice.cpp      | 12 +++--
 .../default/ExternalCameraDeviceSession.cpp   | 53 +++++++++++++++----
 .../3.4/default/ExternalCameraUtils.cpp       | 14 +++--
 6 files changed, 123 insertions(+), 22 deletions(-)

diff --git a/camera/common/1.0/default/HandleImporter.cpp b/camera/common/1.0/default/HandleImporter.cpp
index 05a552cd9..b49a9df13 100644
--- a/camera/common/1.0/default/HandleImporter.cpp
+++ b/camera/common/1.0/default/HandleImporter.cpp
@@ -39,21 +39,25 @@ using IMapperV4 = android::hardware::graphics::mapper::V4_0::IMapper;
 HandleImporter::HandleImporter() : mInitialized(false) {}
 
 void HandleImporter::initializeLocked() {
+ALOGE("shiva initializeLocked start");
     if (mInitialized) {
         return;
     }
+ALOGE("shiva initializeLocked 1");
 
     mMapperV4 = IMapperV4::getService();
     if (mMapperV4 != nullptr) {
         mInitialized = true;
         return;
     }
+ALOGE("shiva initializeLocked 2");
 
     mMapperV3 = IMapperV3::getService();
     if (mMapperV3 != nullptr) {
         mInitialized = true;
         return;
     }
+ALOGE("shiva initializeLocked 3");
 
     mMapperV2 = IMapper::getService();
     if (mMapperV2 == nullptr) {
@@ -367,7 +371,7 @@ void* HandleImporter::lock(buffer_handle_t& buf, uint64_t cpuUsage,
                });
     }
 
-    ALOGV("%s: ptr %p accessRegion.top: %d accessRegion.left: %d accessRegion.width: %d "
+    ALOGE("%s: ptr %p accessRegion.top: %d accessRegion.left: %d accessRegion.width: %d "
           "accessRegion.height: %d",
           __FUNCTION__, ret, accessRegion.top, accessRegion.left, accessRegion.width,
           accessRegion.height);
@@ -378,21 +382,29 @@ YCbCrLayout HandleImporter::lockYCbCr(
         buffer_handle_t& buf, uint64_t cpuUsage,
         const IMapper::Rect& accessRegion) {
     Mutex::Autolock lock(mLock);
-
+ALOGE("shiva lockYCbCr start");
     if (!mInitialized) {
+ALOGE("shiva lockYCbCr 1");
+
         initializeLocked();
     }
 
     if (mMapperV4 != nullptr) {
+ALOGE("shiva lockYCbCr 2");
+
         return lockYCbCrInternal<IMapperV4, MapperErrorV4>(mMapperV4, buf, cpuUsage, accessRegion);
     }
 
     if (mMapperV3 != nullptr) {
+ALOGE("shiva lockYCbCr 3");
+
         return lockYCbCrInternal<IMapperV3, MapperErrorV3>(
                 mMapperV3, buf, cpuUsage, accessRegion);
     }
 
     if (mMapperV2 != nullptr) {
+ALOGE("shiva lockYCbCr 4");
+
         return lockYCbCrInternal<IMapper, MapperErrorV2>(
                 mMapperV2, buf, cpuUsage, accessRegion);
     }
@@ -402,13 +414,21 @@ YCbCrLayout HandleImporter::lockYCbCr(
 }
 
 int HandleImporter::unlock(buffer_handle_t& buf) {
+ALOGE("shiva unlock start");
+
     if (mMapperV4 != nullptr) {
+ALOGE("shiva unlock 1");
+
         return unlockInternal<IMapperV4, MapperErrorV4>(mMapperV4, buf);
     }
     if (mMapperV3 != nullptr) {
+ALOGE("shiva unlock 2");
+
         return unlockInternal<IMapperV3, MapperErrorV3>(mMapperV3, buf);
     }
     if (mMapperV2 != nullptr) {
+ALOGE("shiva unlock 3");
+
         return unlockInternal<IMapper, MapperErrorV2>(mMapperV2, buf);
     }
 
diff --git a/camera/device/3.4/default/CameraDevice.cpp b/camera/device/3.4/default/CameraDevice.cpp
index bc443deb3..e83c50a1a 100644
--- a/camera/device/3.4/default/CameraDevice.cpp
+++ b/camera/device/3.4/default/CameraDevice.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "CamDev@3.4-impl"
+#define LOG_TAG "shiva CamDev@3.4-impl"
 #include <log/log.h>
 
 #include <utils/Vector.h>
@@ -44,6 +44,7 @@ CameraDevice::~CameraDevice() {
 sp<V3_2::implementation::CameraDeviceSession> CameraDevice::createSession(camera3_device_t* device,
         const camera_metadata_t* deviceInfo,
         const sp<V3_2::ICameraDeviceCallback>& callback) {
+ALOGE("shiva createSession");
     sp<CameraDeviceSession> session = new CameraDeviceSession(device, deviceInfo, callback);
     IF_ALOGV() {
         session->getInterface()->interfaceChain([](
diff --git a/camera/device/3.4/default/CameraDeviceSession.cpp b/camera/device/3.4/default/CameraDeviceSession.cpp
index b4ebe2270..f9ac7782c 100644
--- a/camera/device/3.4/default/CameraDeviceSession.cpp
+++ b/camera/device/3.4/default/CameraDeviceSession.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "CamDevSession@3.4-impl"
+#define LOG_TAG "ssss CamDevSession@3.4-impl"
 #include <android/log.h>
 
 #include <set>
@@ -41,7 +41,7 @@ CameraDeviceSession::CameraDeviceSession(
         mResultBatcher_3_4(callback) {
 
     mHasCallback_3_4 = false;
-
+ALOGE("shiva CameraDeviceSession construct");
     auto castResult = ICameraDeviceCallback::castFrom(callback);
     if (castResult.isOk()) {
         sp<ICameraDeviceCallback> callback3_4 = castResult;
@@ -78,6 +78,7 @@ void CameraDeviceSession::configureStreams_3_4_Impl(
         uint32_t streamConfigCounter, bool useOverriddenFields)  {
     Status status = initStatus();
     HalStreamConfiguration outStreams;
+ALOGE("shiva configureStreams_3_4_Impl construct");
 
     // If callback is 3.2, make sure no physical stream is configured
     if (!mHasCallback_3_4) {
@@ -168,6 +169,7 @@ bool CameraDeviceSession::preProcessConfigurationLocked_3_4(
         const StreamConfiguration& requestedConfiguration, bool useOverriddenFields,
         camera3_stream_configuration_t *stream_list /*out*/,
         hidl_vec<camera3_stream_t*> *streams /*out*/) {
+ALOGE("shiva preProcessConfigurationLocked_3_4 construct");
 
     if ((stream_list == nullptr) || (streams == nullptr)) {
         return false;
@@ -248,6 +250,8 @@ bool CameraDeviceSession::preProcessConfigurationLocked_3_4(
 
 void CameraDeviceSession::postProcessConfigurationLocked_3_4(
         const StreamConfiguration& requestedConfiguration) {
+ALOGE("shiva postProcessConfigurationLocked_3_4 construct");
+
     // delete unused streams, note we do this after adding new streams to ensure new stream
     // will not have the same address as deleted stream, and HAL has a chance to reference
     // the to be deleted stream in configure_streams call
@@ -319,6 +323,7 @@ Return<void> CameraDeviceSession::processCaptureRequest_3_4(
             break;
         }
     }
+ALOGE("shiva processCaptureRequest_3_4");
 
     if (s == Status::OK && requests.size() > 1) {
         mResultBatcher_3_4.registerBatch(requests[0].v3_2.frameNumber, requests.size());
@@ -330,6 +335,8 @@ Return<void> CameraDeviceSession::processCaptureRequest_3_4(
 
 Status CameraDeviceSession::processOneCaptureRequest_3_4(const V3_4::CaptureRequest& request)  {
     Status status = initStatus();
+ALOGE("shiva processOneCaptureRequest_3_4");
+
     if (status != Status::OK) {
         ALOGE("%s: camera init failed or disconnected", __FUNCTION__);
         return status;
@@ -527,6 +534,7 @@ void CameraDeviceSession::sProcessCaptureResult_3_4(
         const camera3_capture_result *hal_result) {
     CameraDeviceSession *d =
             const_cast<CameraDeviceSession*>(static_cast<const CameraDeviceSession*>(cb));
+ALOGE("shiva sProcessCaptureResult_3_4");
 
     CaptureResult result = {};
     camera3_capture_result shadowResult;
@@ -628,10 +636,13 @@ CameraDeviceSession::ResultBatcher_3_4::ResultBatcher_3_4(
 void CameraDeviceSession::ResultBatcher_3_4::processCaptureResult_3_4(CaptureResult& result) {
     auto pair = getBatch(result.v3_2.frameNumber);
     int batchIdx = pair.first;
+ALOGE("shiva processCaptureResult_3_4 start");
     if (batchIdx == NOT_BATCHED) {
         processOneCaptureResult_3_4(result);
         return;
     }
+ALOGE("shiva processCaptureResult_3_4 1");
+
     std::shared_ptr<InflightBatch> batch = pair.second;
     {
         Mutex::Autolock _l(batch->mLock);
@@ -641,6 +652,7 @@ void CameraDeviceSession::ResultBatcher_3_4::processCaptureResult_3_4(CaptureRes
             processOneCaptureResult_3_4(result);
             return;
         }
+ALOGE("shiva processCaptureResult_3_4 2");
 
         // queue metadata
         if (result.v3_2.result.size() != 0) {
@@ -648,6 +660,7 @@ void CameraDeviceSession::ResultBatcher_3_4::processCaptureResult_3_4(CaptureRes
             batch->mResultMds[result.v3_2.partialResult].mMds.push_back(
                     std::make_pair(result.v3_2.frameNumber, result.v3_2.result));
         }
+ALOGE("shiva processCaptureResult_3_4 3");
 
         // queue buffer
         std::vector<int> filledStreams;
@@ -662,6 +675,7 @@ void CameraDeviceSession::ResultBatcher_3_4::processCaptureResult_3_4(CaptureRes
                 pushStreamBuffer(std::move(buffer), nonBatchedBuffers);
             }
         }
+ALOGE("shiva processCaptureResult_3_4 4");
 
         // send non-batched buffers up
         if (nonBatchedBuffers.size() > 0 || result.v3_2.inputBuffer.streamId != -1) {
@@ -677,16 +691,21 @@ void CameraDeviceSession::ResultBatcher_3_4::processCaptureResult_3_4(CaptureRes
             nonBatchedResult.v3_2.partialResult = 0; // 0 for buffer only results
             processOneCaptureResult_3_4(nonBatchedResult);
         }
+ALOGE("shiva processCaptureResult_3_4 5");
 
         if (result.v3_2.frameNumber == batch->mLastFrame) {
             // Send data up
             if (result.v3_2.partialResult > 0) {
                 sendBatchMetadataLocked(batch, result.v3_2.partialResult);
             }
+ALOGE("shiva processCaptureResult_3_4 6");
+
             // send buffer up
             if (filledStreams.size() > 0) {
                 sendBatchBuffersLocked(batch, filledStreams);
             }
+ALOGE("shiva processCaptureResult_3_4 7");
+
         }
     } // end of batch lock scope
 
@@ -694,19 +713,27 @@ void CameraDeviceSession::ResultBatcher_3_4::processCaptureResult_3_4(CaptureRes
     if (result.v3_2.frameNumber == batch->mLastFrame) {
         checkAndRemoveFirstBatch();
     }
+ALOGE("shiva processCaptureResult_3_4 end");
+
 }
 
 void CameraDeviceSession::ResultBatcher_3_4::processOneCaptureResult_3_4(CaptureResult& result) {
     hidl_vec<CaptureResult> results;
     results.resize(1);
     results[0] = std::move(result);
+ALOGE("shiva processOneCaptureResult_3_4 start");
     invokeProcessCaptureResultCallback_3_4(results, /* tryWriteFmq */true);
+ALOGE("shiva processOneCaptureResult_3_4 1");
+
     freeReleaseFences_3_4(results);
+ALOGE("shiva processOneCaptureResult_3_4 end");
+
     return;
 }
 
 void CameraDeviceSession::ResultBatcher_3_4::invokeProcessCaptureResultCallback_3_4(
         hidl_vec<CaptureResult> &results, bool tryWriteFmq) {
+ALOGE("shiva invokeProcessCaptureResultCallback_3_4 start");
     if (mProcessCaptureResultLock.tryLock() != OK) {
         ALOGV("%s: previous call is not finished! waiting 1s...", __FUNCTION__);
         if (mProcessCaptureResultLock.timedLock(1000000000 /* 1s */) != OK) {
@@ -715,6 +742,8 @@ void CameraDeviceSession::ResultBatcher_3_4::invokeProcessCaptureResultCallback_
             return;
         }
     }
+ALOGE("shiva invokeProcessCaptureResultCallback_3_4 1");
+
     if (tryWriteFmq && mResultMetadataQueue->availableToWrite() > 0) {
         for (CaptureResult &result : results) {
             if (result.v3_2.result.size() > 0) {
@@ -740,11 +769,17 @@ void CameraDeviceSession::ResultBatcher_3_4::invokeProcessCaptureResultCallback_
             }
         }
     }
+ALOGE("shiva invokeProcessCaptureResultCallback_3_4 2");
+
     mCallback_3_4->processCaptureResult_3_4(results);
     mProcessCaptureResultLock.unlock();
+ALOGE("shiva invokeProcessCaptureResultCallback_3_4 end");
+
 }
 
 void CameraDeviceSession::ResultBatcher_3_4::freeReleaseFences_3_4(hidl_vec<CaptureResult>& results) {
+ALOGE("shiva freeReleaseFences_3_4");
+
     for (auto& result : results) {
         if (result.v3_2.inputBuffer.releaseFence.getNativeHandle() != nullptr) {
             native_handle_t* handle = const_cast<native_handle_t*>(
diff --git a/camera/device/3.4/default/ExternalCameraDevice.cpp b/camera/device/3.4/default/ExternalCameraDevice.cpp
index 6cd5fdf4f..24ac25fa5 100644
--- a/camera/device/3.4/default/ExternalCameraDevice.cpp
+++ b/camera/device/3.4/default/ExternalCameraDevice.cpp
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "ExtCamDev@3.4"
-//#define LOG_NDEBUG 0
+#define LOG_TAG "ssss ExtCamDev@3.4"
+#define LOG_NDEBUG 0
 #include <log/log.h>
 
 #include <algorithm>
@@ -55,6 +55,7 @@ ExternalCameraDevice::ExternalCameraDevice(
         mDevicePath(devicePath),
         mCfg(cfg) {
     std::smatch sm;
+ALOGE("shiva ExternalCameraDevice construct");
     if (std::regex_match(mDevicePath, sm, kDevicePathRE)) {
         mCameraId = std::to_string(mCfg.cameraIdOffset + std::stoi(sm[1]));
     } else {
@@ -94,6 +95,7 @@ Return<void> ExternalCameraDevice::getCameraCharacteristics(
     Mutex::Autolock _l(mLock);
     V3_2::CameraMetadata hidlChars;
 
+ALOGE("shiva getCameraCharacteristics");
     if (isInitFailedLocked()) {
         _hidl_cb(Status::INTERNAL_ERROR, hidlChars);
         return Void();
@@ -114,7 +116,7 @@ Return<void> ExternalCameraDevice::open(
         const sp<ICameraDeviceCallback>& callback, ICameraDevice::open_cb _hidl_cb) {
     Status status = Status::OK;
     sp<ExternalCameraDeviceSession> session = nullptr;
-
+ALOGE("shiva open");
     if (callback == nullptr) {
         ALOGE("%s: cannot open camera %s. callback is null!",
                 __FUNCTION__, mCameraId.c_str());
@@ -131,7 +133,7 @@ Return<void> ExternalCameraDevice::open(
 
     mLock.lock();
 
-    ALOGV("%s: Initializing device for camera %s", __FUNCTION__, mCameraId.c_str());
+    ALOGE("%s: Initializing device for camera %s", __FUNCTION__, mCameraId.c_str());
     session = mSession.promote();
     if (session != nullptr && !session->isClosed()) {
         ALOGE("%s: cannot open an already opened camera!", __FUNCTION__);
@@ -212,6 +214,7 @@ Return<void> ExternalCameraDevice::dumpState(const ::android::hardware::hidl_han
 
 
 status_t ExternalCameraDevice::initCameraCharacteristics() {
+ALOGE("shiva initCameraCharacteristics");
     if (mCameraCharacteristics.isEmpty()) {
         // init camera characteristics
         unique_fd fd(::open(mDevicePath.c_str(), O_RDWR));
@@ -264,6 +267,7 @@ do {                                               \
 status_t ExternalCameraDevice::initAvailableCapabilities(
         ::android::hardware::camera::common::V1_0::helper::CameraMetadata* metadata) {
 
+ALOGE("shiva initAvailableCapabilities");
     if (mSupportedFormats.empty()) {
         ALOGE("%s: Supported formats list is empty", __FUNCTION__);
         return UNKNOWN_ERROR;
diff --git a/camera/device/3.4/default/ExternalCameraDeviceSession.cpp b/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
index 5f8674219..7b4c2fc42 100644
--- a/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
+++ b/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
@@ -13,8 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "ExtCamDevSsn@3.4"
-//#define LOG_NDEBUG 0
+#define LOG_TAG "ssss ExtCamDevSsn@3.4"
+#define LOG_NDEBUG 0
 #define ATRACE_TAG ATRACE_TAG_CAMERA
 #include <log/log.h>
 
@@ -107,6 +107,7 @@ ExternalCameraDeviceSession::ExternalCameraDeviceSession(
         mMaxJpegResolution(getMaxJpegResolution()) {}
 
 bool ExternalCameraDeviceSession::initialize() {
+ALOGE("shiva initialize");
     if (mV4l2Fd.get() < 0) {
         ALOGE("%s: invalid v4l2 device fd %d!", __FUNCTION__, mV4l2Fd.get());
         return true;
@@ -201,7 +202,7 @@ Status ExternalCameraDeviceSession::initStatus() const {
     Mutex::Autolock _l(mLock);
     Status status = Status::OK;
     if (mInitFail || mClosed) {
-        ALOGI("%s: sesssion initFailed %d closed %d", __FUNCTION__, mInitFail, mClosed);
+        ALOGE("%s: sesssion initFailed %d closed %d", __FUNCTION__, mInitFail, mClosed);
         status = Status::INTERNAL_ERROR;
     }
     return status;
@@ -346,7 +347,6 @@ Return<void> ExternalCameraDeviceSession::configureStreams(
     V3_2::HalStreamConfiguration outStreams;
     V3_3::HalStreamConfiguration outStreams_v33;
     Mutex::Autolock _il(mInterfaceLock);
-
     Status status = configureStreams(streams, &outStreams_v33);
     size_t size = outStreams_v33.streams.size();
     outStreams.streams.resize(size);
@@ -426,7 +426,7 @@ Return<void> ExternalCameraDeviceSession::processCaptureRequest(
         ICameraDeviceSession::processCaptureRequest_cb _hidl_cb) {
     Mutex::Autolock _il(mInterfaceLock);
     updateBufferCaches(cachesToRemove);
-
+ALOGE("shiva processCaptureRequest");
     uint32_t numRequestProcessed = 0;
     Status s = Status::OK;
     for (size_t i = 0; i < requests.size(); i++, numRequestProcessed++) {
@@ -490,7 +490,7 @@ Return<void> ExternalCameraDeviceSession::close(bool callerIsDtor) {
             }
         }
         v4l2StreamOffLocked();
-        ALOGV("%s: closing V4L2 camera FD %d", __FUNCTION__, mV4l2Fd.get());
+        ALOGE("%s: closing V4L2 camera FD %d", __FUNCTION__, mV4l2Fd.get());
         mV4l2Fd.reset();
         mClosed = true;
     }
@@ -501,6 +501,7 @@ Status ExternalCameraDeviceSession::importRequestLocked(
     const CaptureRequest& request,
     hidl_vec<buffer_handle_t*>& allBufPtrs,
     hidl_vec<int>& allFences) {
+ALOGE("shiva importRequestLocked");
     return importRequestLockedImpl(request, allBufPtrs, allFences);
 }
 
@@ -516,6 +517,7 @@ Status ExternalCameraDeviceSession::importBufferLocked(int32_t streamId,
         uint64_t bufId, buffer_handle_t buf,
         /*out*/buffer_handle_t** outBufPtr,
         bool allowEmptyBuf) {
+ALOGE("shiva importBufferLocked");
     return importBufferImpl(
             mCirculatingBuffers, sHandleImporter, streamId,
             bufId, buf, outBufPtr, allowEmptyBuf);
@@ -536,7 +538,7 @@ Status ExternalCameraDeviceSession::importRequestLockedImpl(
     allBufPtrs.resize(numBufs);
     allFences.resize(numBufs);
     std::vector<int32_t> streamIds(numBufs);
-
+ALOGE("shiva importRequestLockedImpl");
     for (size_t i = 0; i < numOutputBufs; i++) {
         allBufs[i] = request.outputBuffers[i].buffer.getNativeHandle();
         allBufIds[i] = request.outputBuffers[i].bufferId;
@@ -601,6 +603,7 @@ Status ExternalCameraDeviceSession::processOneCaptureRequest(const CaptureReques
         return status;
     }
 
+ALOGE("shiva processOneCaptureRequest");
     if (request.inputBuffer.streamId != -1) {
         ALOGE("%s: external camera does not support reprocessing!", __FUNCTION__);
         return Status::ILLEGAL_ARGUMENT;
@@ -831,7 +834,7 @@ Status ExternalCameraDeviceSession::processCaptureResult(std::shared_ptr<HalRequ
     sp<V3_4::implementation::V4L2Frame> v4l2Frame =
             static_cast<V3_4::implementation::V4L2Frame*>(req->frameIn.get());
     enqueueV4l2Frame(v4l2Frame);
-
+ALOGE("shiva processCaptureResult");
     // NotifyShutter
     notifyShutter(req->frameNumber, req->shutterTs);
 
@@ -843,6 +846,7 @@ Status ExternalCameraDeviceSession::processCaptureResult(std::shared_ptr<HalRequ
     result.partialResult = 1;
     result.inputBuffer.streamId = -1;
     result.outputBuffers.resize(req->buffers.size());
+
     for (size_t i = 0; i < req->buffers.size(); i++) {
         result.outputBuffers[i].streamId = req->buffers[i].streamId;
         result.outputBuffers[i].bufferId = req->buffers[i].bufferId;
@@ -851,7 +855,9 @@ Status ExternalCameraDeviceSession::processCaptureResult(std::shared_ptr<HalRequ
             if (req->buffers[i].acquireFence >= 0) {
                 native_handle_t* handle = native_handle_create(/*numFds*/1, /*numInts*/0);
                 handle->data[0] = req->buffers[i].acquireFence;
+
                 result.outputBuffers[i].releaseFence.setTo(handle, /*shouldOwn*/false);
+
             }
             notifyError(req->frameNumber, req->buffers[i].streamId, ErrorCode::ERROR_BUFFER);
         } else {
@@ -860,7 +866,9 @@ Status ExternalCameraDeviceSession::processCaptureResult(std::shared_ptr<HalRequ
             if (req->buffers[i].acquireFence >= 0) {
                 native_handle_t* handle = native_handle_create(/*numFds*/1, /*numInts*/0);
                 handle->data[0] = req->buffers[i].acquireFence;
+
                 result.outputBuffers[i].releaseFence.setTo(handle, /*shouldOwn*/false);
+
             }
         }
     }
@@ -877,23 +885,30 @@ Status ExternalCameraDeviceSession::processCaptureResult(std::shared_ptr<HalRequ
         mInflightFrames.erase(req->frameNumber);
     }
 
+ALOGE("shiva processCaptureResult 5b");
     // Callback into framework
     invokeProcessCaptureResultCallback(results, /* tryWriteFmq */true);
+ALOGE("shiva processCaptureResult 5");
+
     freeReleaseFences(results);
+ALOGE("shiva processCaptureResult end");
+
     return Status::OK;
 }
 
 void ExternalCameraDeviceSession::invokeProcessCaptureResultCallback(
         hidl_vec<CaptureResult> &results, bool tryWriteFmq) {
+ALOGE("shiva invokeProcessCaptureResultCallback start");
     if (mProcessCaptureResultLock.tryLock() != OK) {
         const nsecs_t NS_TO_SECOND = 1000000000;
-        ALOGV("%s: previous call is not finished! waiting 1s...", __FUNCTION__);
+        ALOGE("shiva %s: previous call is not finished! waiting 1s...", __FUNCTION__);
         if (mProcessCaptureResultLock.timedLock(/* 1s */NS_TO_SECOND) != OK) {
-            ALOGE("%s: cannot acquire lock in 1s, cannot proceed",
+            ALOGE("shiva %s: cannot acquire lock in 1s, cannot proceed",
                     __FUNCTION__);
             return;
         }
     }
+
     if (tryWriteFmq && mResultMetadataQueue->availableToWrite() > 0) {
         for (CaptureResult &result : results) {
             if (result.result.size() > 0) {
@@ -909,13 +924,18 @@ void ExternalCameraDeviceSession::invokeProcessCaptureResultCallback(
             }
         }
     }
+ALOGE("shiva invokeProcessCaptureResultCallback 2");
+
     auto status = mCallback->processCaptureResult(results);
     if (!status.isOk()) {
         ALOGE("%s: processCaptureResult ERROR : %s", __FUNCTION__,
               status.description().c_str());
     }
+ALOGE("shiva invokeProcessCaptureResultCallback 3");
 
     mProcessCaptureResultLock.unlock();
+ALOGE("shiva invokeProcessCaptureResultCallback end");
+
 }
 
 ExternalCameraDeviceSession::OutputThread::OutputThread(
@@ -1374,6 +1394,7 @@ int ExternalCameraDeviceSession::OutputThread::createJpegLocked(
     const uint8_t* exifData = utils->getApp1Buffer();
 
     /* Lock the HAL jpeg code buffer */
+ALOGE("shiva sHandleImporter.lock ");
     void *bufPtr = sHandleImporter.lock(
             *(halBuf.bufPtr), halBuf.usage, maxJpegCodeSize);
 
@@ -1396,6 +1417,8 @@ int ExternalCameraDeviceSession::OutputThread::createJpegLocked(
     memcpy(blobDst, &blob, sizeof(CameraBlob));
 
     /* Unlock the HAL jpeg code buffer */
+ALOGE("shiva sHandleImporter unlock");
+
     int relFence = sHandleImporter.unlock(*(halBuf.bufPtr));
     if (relFence >= 0) {
         halBuf.acquireFence = relFence;
@@ -1527,6 +1550,8 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
                 }
             } break;
             case PixelFormat::Y16: {
+ALOGE("shiva sHandleImporter 4");
+
                 void* outLayout = sHandleImporter.lock(*(halBuf.bufPtr), halBuf.usage, inDataSize);
 
                 std::memcpy(outLayout, inData, inDataSize);
@@ -1541,6 +1566,8 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
                 IMapper::Rect outRect {0, 0,
                         static_cast<int32_t>(halBuf.width),
                         static_cast<int32_t>(halBuf.height)};
+ALOGE("shiva sHandleImporter 5");
+
                 YCbCrLayout outLayout = sHandleImporter.lockYCbCr(
                         *(halBuf.bufPtr), halBuf.usage, outRect);
                 ALOGV("%s: outLayout y %p cb %p cr %p y_str %d c_str %d c_step %d",
@@ -1575,6 +1602,8 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
                     lk.unlock();
                     return onDeviceError("%s: format coversion failed!", __FUNCTION__);
                 }
+ALOGE("shiva sHandleImporter 6");
+
                 int relFence = sHandleImporter.unlock(*(halBuf.bufPtr));
                 if (relFence >= 0) {
                     halBuf.acquireFence = relFence;
@@ -1797,6 +1826,8 @@ void ExternalCameraDeviceSession::OutputThread::dump(int fd) {
 
 void ExternalCameraDeviceSession::cleanupBuffersLocked(int id) {
     for (auto& pair : mCirculatingBuffers.at(id)) {
+ALOGE("shiva sHandleImporter 7");
+
         sHandleImporter.freeBuffer(pair.second);
     }
     mCirculatingBuffers[id].clear();
@@ -1814,6 +1845,8 @@ void ExternalCameraDeviceSession::updateBufferCaches(const hidl_vec<BufferCache>
         CirculatingBuffers& cbs = cbsIt->second;
         auto it = cbs.find(cache.bufferId);
         if (it != cbs.end()) {
+ALOGE("shiva sHandleImporter 8");
+
             sHandleImporter.freeBuffer(it->second);
             cbs.erase(it);
         } else {
diff --git a/camera/device/3.4/default/ExternalCameraUtils.cpp b/camera/device/3.4/default/ExternalCameraUtils.cpp
index 8f4626c56..53cab5881 100644
--- a/camera/device/3.4/default/ExternalCameraUtils.cpp
+++ b/camera/device/3.4/default/ExternalCameraUtils.cpp
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "ExtCamUtils@3.4"
+#define LOG_TAG "sssss ExtCamUtils@3.4"
 //#define LOG_NDEBUG 0
 #include <log/log.h>
 
@@ -70,14 +70,14 @@ int V4L2Frame::map(uint8_t** data, size_t* dataSize) {
     }
     *data = mData;
     *dataSize = mDataSize;
-    ALOGV("%s: V4L map FD %d, data %p size %zu", __FUNCTION__, mFd, mData, mDataSize);
+    ALOGE("shiva %s: V4L map FD %d, data %p size %zu", __FUNCTION__, mFd, mData, mDataSize);
     return 0;
 }
 
 int V4L2Frame::unmap() {
     std::lock_guard<std::mutex> lk(mLock);
     if (mMapped) {
-        ALOGV("%s: V4L unmap data %p size %zu", __FUNCTION__, mData, mDataSize);
+        ALOGE("shiva %s: V4L unmap data %p size %zu", __FUNCTION__, mData, mDataSize);
         if (munmap(mData, mDataSize) != 0) {
             ALOGE("%s: V4L2 buffer unmap failed: %s", __FUNCTION__, strerror(errno));
             return -EINVAL;
@@ -103,6 +103,7 @@ AllocatedFrame::~AllocatedFrame() {}
 
 int AllocatedFrame::allocate(YCbCrLayout* out) {
     std::lock_guard<std::mutex> lk(mLock);
+ALOGE("shiva allocate");
     if ((mWidth % 2) || (mHeight % 2)) {
         ALOGE("%s: bad dimension %dx%d (not multiple of 2)", __FUNCTION__, mWidth, mHeight);
         return -EINVAL;
@@ -189,6 +190,7 @@ double SupportedV4L2Format::FrameRate::getDouble() const {
         /*out*/buffer_handle_t** outBufPtr,
         bool allowEmptyBuf) {
     using ::android::hardware::camera::common::V1_0::Status;
+ALOGE("shiva importBufferImpl");
     if (buf == nullptr && bufId == BUFFER_ID_NO_BUFFER) {
         if (allowEmptyBuf) {
             *outBufPtr = &sEmptyBuffer;
@@ -580,8 +582,11 @@ Size getMaxThumbnailResolution(const common::V1_0::helper::CameraMetadata& chars
 }
 
 void freeReleaseFences(hidl_vec<V3_2::CaptureResult>& results) {
+ALOGE("shiva freeReleaseFences");
     for (auto& result : results) {
         if (result.inputBuffer.releaseFence.getNativeHandle() != nullptr) {
+ALOGE("shiva freeReleaseFences 1");
+
             native_handle_t* handle = const_cast<native_handle_t*>(
                     result.inputBuffer.releaseFence.getNativeHandle());
             native_handle_close(handle);
@@ -589,6 +594,8 @@ void freeReleaseFences(hidl_vec<V3_2::CaptureResult>& results) {
         }
         for (auto& buf : result.outputBuffers) {
             if (buf.releaseFence.getNativeHandle() != nullptr) {
+ALOGE("shiva freeReleaseFences 2");
+
                 native_handle_t* handle = const_cast<native_handle_t*>(
                         buf.releaseFence.getNativeHandle());
                 native_handle_close(handle);
@@ -672,6 +679,7 @@ AllocatedV4L2Frame::AllocatedV4L2Frame(sp<V3_4::implementation::V4L2Frame> frame
         Frame(frameIn->mWidth, frameIn->mHeight, frameIn->mFourcc) {
     uint8_t* dataIn;
     size_t dataSize;
+ALOGE("shiva AllocatedV4L2Frame");
     if (frameIn->getData(&dataIn, &dataSize) != 0) {
         ALOGE("%s: map input V4L2 frame failed!", __FUNCTION__);
         return;
-- 
2.17.1

