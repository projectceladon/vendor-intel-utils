From e0c9e37d51e7a66147fb39a6106769f9c7ba5bf5 Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Fri, 18 Jun 2021 16:25:22 +0530
Subject: [PATCH] debug change for camera switching 2

Signed-off-by: shivasku82 <shiva.kumara.rudrappa@intel.com>
---
 camera/device/1.0/default/CameraDevice.cpp    |   3 +-
 camera/device/3.4/default/CameraDevice.cpp    |   5 +-
 .../3.4/default/ExternalCameraDevice.cpp      |   4 +-
 .../default/ExternalCameraDeviceSession.cpp   | 109 +++++++++++++++---
 .../ExternalCameraDeviceSession.h             |   2 +
 .../ExternalCameraProviderImpl_2_4.cpp        |   4 +-
 6 files changed, 107 insertions(+), 20 deletions(-)

diff --git a/camera/device/1.0/default/CameraDevice.cpp b/camera/device/1.0/default/CameraDevice.cpp
index 2dd6094a5..8ddb645fa 100644
--- a/camera/device/1.0/default/CameraDevice.cpp
+++ b/camera/device/1.0/default/CameraDevice.cpp
@@ -641,7 +641,7 @@ Return<Status> CameraDevice::dumpState(const hidl_handle& handle) {
 }
 
 Return<Status> CameraDevice::open(const sp<ICameraDeviceCallback>& callback) {
-    ALOGI("Opening camera %s", mCameraId.c_str());
+    ALOGE("Opening camera %s", mCameraId.c_str());
     Mutex::Autolock _l(mLock);
 
     camera_info info;
@@ -1000,6 +1000,7 @@ Return<Status> CameraDevice::sendCommand(CommandType cmd, int32_t arg1, int32_t
 }
 
 Return<void> CameraDevice::close() {
+	ALOGE("shiva CameraDevice Close");
     Mutex::Autolock _l(mLock);
     closeLocked();
     return Void();
diff --git a/camera/device/3.4/default/CameraDevice.cpp b/camera/device/3.4/default/CameraDevice.cpp
index bc443deb3..a8936d1ca 100644
--- a/camera/device/3.4/default/CameraDevice.cpp
+++ b/camera/device/3.4/default/CameraDevice.cpp
@@ -36,9 +36,12 @@ CameraDevice::CameraDevice(
     sp<CameraModule> module, const std::string& cameraId,
     const SortedVector<std::pair<std::string, std::string>>& cameraDeviceNames) :
         V3_2::implementation::CameraDevice(module, cameraId, cameraDeviceNames) {
+		ALOGE("shiva CameraDevice constructor");
 }
 
 CameraDevice::~CameraDevice() {
+	                ALOGE("shiva CameraDevice Destory");
+
 }
 
 sp<V3_2::implementation::CameraDeviceSession> CameraDevice::createSession(camera3_device_t* device,
@@ -48,7 +51,7 @@ sp<V3_2::implementation::CameraDeviceSession> CameraDevice::createSession(camera
     IF_ALOGV() {
         session->getInterface()->interfaceChain([](
             ::android::hardware::hidl_vec<::android::hardware::hidl_string> interfaceChain) {
-                ALOGV("Session interface chain:");
+                ALOGE("Session interface chain:");
                 for (const auto& iface : interfaceChain) {
                     ALOGV("  %s", iface.c_str());
                 }
diff --git a/camera/device/3.4/default/ExternalCameraDevice.cpp b/camera/device/3.4/default/ExternalCameraDevice.cpp
index 6cd5fdf4f..ac5b73197 100644
--- a/camera/device/3.4/default/ExternalCameraDevice.cpp
+++ b/camera/device/3.4/default/ExternalCameraDevice.cpp
@@ -15,7 +15,7 @@
  */
 
 #define LOG_TAG "ExtCamDev@3.4"
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #include <log/log.h>
 
 #include <algorithm>
@@ -131,7 +131,7 @@ Return<void> ExternalCameraDevice::open(
 
     mLock.lock();
 
-    ALOGV("%s: Initializing device for camera %s", __FUNCTION__, mCameraId.c_str());
+    ALOGE("%s: Initializing device for camera %s", __FUNCTION__, mCameraId.c_str());
     session = mSession.promote();
     if (session != nullptr && !session->isClosed()) {
         ALOGE("%s: cannot open an already opened camera!", __FUNCTION__);
diff --git a/camera/device/3.4/default/ExternalCameraDeviceSession.cpp b/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
index 5f8674219..1a1f9e0c8 100644
--- a/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
+++ b/camera/device/3.4/default/ExternalCameraDeviceSession.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 #define LOG_TAG "ExtCamDevSsn@3.4"
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #define ATRACE_TAG ATRACE_TAG_CAMERA
 #include <log/log.h>
 
@@ -88,6 +88,7 @@ const int ExternalCameraDeviceSession::kMaxProcessedStream;
 const int ExternalCameraDeviceSession::kMaxStallStream;
 HandleImporter ExternalCameraDeviceSession::sHandleImporter;
 
+
 ExternalCameraDeviceSession::ExternalCameraDeviceSession(
         const sp<ICameraDeviceCallback>& callback,
         const ExternalCameraConfig& cfg,
@@ -112,6 +113,7 @@ bool ExternalCameraDeviceSession::initialize() {
         return true;
     }
 
+
     struct v4l2_capability capability;
     int ret = ioctl(mV4l2Fd.get(), VIDIOC_QUERYCAP, &capability);
     std::string make, model;
@@ -424,6 +426,7 @@ Return<void> ExternalCameraDeviceSession::processCaptureRequest(
         const hidl_vec<CaptureRequest>& requests,
         const hidl_vec<BufferCache>& cachesToRemove,
         ICameraDeviceSession::processCaptureRequest_cb _hidl_cb) {
+	ALOGE("shiva received processCaptureRequest");
     Mutex::Autolock _il(mInterfaceLock);
     updateBufferCaches(cachesToRemove);
 
@@ -473,6 +476,7 @@ Return<Status> ExternalCameraDeviceSession::flush() {
 
 Return<void> ExternalCameraDeviceSession::close(bool callerIsDtor) {
     Mutex::Autolock _il(mInterfaceLock);
+    ALOGE("shiva ExternalCameraDeviceSession::close ");
     bool closed = isClosed();
     if (!closed) {
         if (callerIsDtor) {
@@ -486,6 +490,8 @@ Return<void> ExternalCameraDeviceSession::close(bool callerIsDtor) {
         {
             Mutex::Autolock _l(mCbsLock);
             for(auto pair : mStreamMap) {
+		        ALOGE("shiva ExternalCameraDeviceSession::close cleanupBuffersLocked ");
+
                 cleanupBuffersLocked(/*Stream ID*/pair.first);
             }
         }
@@ -561,7 +567,7 @@ Status ExternalCameraDeviceSession::importRequestLockedImpl(
     for (size_t i = 0; i < numOutputBufs; i++) {
         if (!sHandleImporter.importFence(
                 request.outputBuffers[i].acquireFence, allFences[i])) {
-            ALOGE("%s: output buffer %zu acquire fence is invalid", __FUNCTION__, i);
+            ALOGE("shiva %s: output buffer %zu acquire fence is invalid", __FUNCTION__, i);
             cleanupInflightFences(allFences, i);
             return Status::INTERNAL_ERROR;
         }
@@ -588,7 +594,7 @@ int ExternalCameraDeviceSession::waitForV4L2BufferReturnLocked(std::unique_lock<
     // mV4l2BufferLock
     mLock.lock();
     if (st == std::cv_status::timeout) {
-        ALOGE("%s: wait for V4L2 buffer return timeout!", __FUNCTION__);
+        ALOGE("shiva %s: wait for V4L2 buffer return timeout!", __FUNCTION__);
         return -1;
     }
     return 0;
@@ -730,6 +736,7 @@ Status ExternalCameraDeviceSession::processOneCaptureRequest(const CaptureReques
         halBuf.format = stream.format;
         halBuf.usage = stream.usage;
         halBuf.bufPtr = allBufPtrs[i];
+	//memset(halBuf.bufPtr, 0x00, ((halBuf.height * halBuf.width) * 1.5));
         halBuf.acquireFence = allFences[i];
         halBuf.fenceTimeout = false;
     }
@@ -767,6 +774,7 @@ Status ExternalCameraDeviceSession::processCaptureRequestError(
         /*out*/std::vector<NotifyMsg>* outMsgs,
         /*out*/std::vector<CaptureResult>* outResults) {
     ATRACE_CALL();
+    ALOGE("shiva processCaptureRequestError");
     // Return V4L2 buffer to V4L2 buffer queue
     sp<V3_4::implementation::V4L2Frame> v4l2Frame =
             static_cast<V3_4::implementation::V4L2Frame*>(req->frameIn.get());
@@ -827,6 +835,7 @@ Status ExternalCameraDeviceSession::processCaptureRequestError(
 
 Status ExternalCameraDeviceSession::processCaptureResult(std::shared_ptr<HalRequest>& req) {
     ATRACE_CALL();
+    ALOGE("shiva processCaptureResult E");
     // Return V4L2 buffer to V4L2 buffer queue
     sp<V3_4::implementation::V4L2Frame> v4l2Frame =
             static_cast<V3_4::implementation::V4L2Frame*>(req->frameIn.get());
@@ -916,6 +925,7 @@ void ExternalCameraDeviceSession::invokeProcessCaptureResultCallback(
     }
 
     mProcessCaptureResultLock.unlock();
+    ALOGE("shiva mProcessCaptureResultLock.unlock");
 }
 
 ExternalCameraDeviceSession::OutputThread::OutputThread(
@@ -1376,7 +1386,7 @@ int ExternalCameraDeviceSession::OutputThread::createJpegLocked(
     /* Lock the HAL jpeg code buffer */
     void *bufPtr = sHandleImporter.lock(
             *(halBuf.bufPtr), halBuf.usage, maxJpegCodeSize);
-
+ALOGE("shiva createJpegLocked lock %p", halBuf.bufPtr);
     if (!bufPtr) {
         return lfail("%s: could not lock %zu bytes", __FUNCTION__, maxJpegCodeSize);
     }
@@ -1397,6 +1407,7 @@ int ExternalCameraDeviceSession::OutputThread::createJpegLocked(
 
     /* Unlock the HAL jpeg code buffer */
     int relFence = sHandleImporter.unlock(*(halBuf.bufPtr));
+    ALOGE("shiva sHandleImporterteJpegLocked .unlock %p ",halBuf.bufPtr);
     if (relFence >= 0) {
         halBuf.acquireFence = relFence;
     }
@@ -1413,6 +1424,64 @@ int ExternalCameraDeviceSession::OutputThread::createJpegLocked(
     return 0;
 }
 
+
+
+void ExternalCameraDeviceSession::OutputThread::dumpFrame(unsigned char *bufdest) {
+#if 0
+	FILE* pFile;
+    static int buf_count = 0;
+    char file_name[100] = "/storage/emulated/0/output";
+    unsigned int img_id = buf_count % 20;
+    sprintf(file_name, "/storage/emulated/0/out%d.yuv", img_id);
+    //sprintf(file_name, "%d.yuv", img_id);
+    pFile = fopen(file_name,"wb");
+
+    if (pFile ){
+        fwrite(bufdest,1,640 * 480,pFile);
+
+    }
+    else
+        ALOGE("shiva updated Can't open file");
+
+    if((buf_count % 20) == 1)
+    ALOGE("shiva file name %s",file_name);
+ buf_count++;
+    if(pFile)
+    fclose(pFile);
+
+        FILE* pFile_new;
+    char file_new[100] = "/data/output";
+    sprintf(file_new, "/data/out%d.yuv", img_id);
+
+        pFile_new = fopen("/data/output.yuv","wa");
+#endif
+	FILE* pFile;
+	    char file_new[100] = "/data/output.yuv";
+
+	    static int buf_count = 0;
+	    sprintf(file_new, "/data/out%d.yuv", buf_count);
+
+	pFile = fopen(file_new,"w+");
+
+	unsigned int buf_sz = 640 * 480 ;
+	if (pFile ){
+           fwrite(bufdest,1, buf_sz,pFile);
+	}
+	else
+	    ALOGE("shiva fail to write data");
+
+	if(pFile == NULL)
+		ALOGE("Error: %d (%s)\n", errno, strerror(errno));
+
+	buf_count++;
+	    if(buf_count > 20)
+		    buf_count = 0;
+
+
+	if(pFile)
+            fclose(pFile);
+}
+
 bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
     std::shared_ptr<HalRequest> req;
     auto parent = mParent.promote();
@@ -1459,12 +1528,12 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
     size_t inDataSize;
     if (req->frameIn->getData(&inData, &inDataSize) != 0) {
         lk.unlock();
-        return onDeviceError("%s: V4L2 buffer map failed", __FUNCTION__);
+        return onDeviceError("shiva %s: V4L2 buffer map failed", __FUNCTION__);
     }
 
     // TODO: in some special case maybe we can decode jpg directly to gralloc output?
     if (req->frameIn->mFourcc == V4L2_PIX_FMT_MJPEG) {
-        ATRACE_BEGIN("MJPGtoI420");
+        ALOGE("shiva  MJPGtoI420 V4L2_PIX_FMT_MJPEG");
         int res = libyuv::MJPGToI420(
             inData, inDataSize, static_cast<uint8_t*>(mYu12FrameLayout.y), mYu12FrameLayout.yStride,
             static_cast<uint8_t*>(mYu12FrameLayout.cb), mYu12FrameLayout.cStride,
@@ -1474,7 +1543,7 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
 
         if (res != 0) {
             // For some webcam, the first few V4L2 frames might be malformed...
-            ALOGE("%s: Convert V4L2 frame to YU12 failed! res %d", __FUNCTION__, res);
+            ALOGE("shiva %s: Convert V4L2 frame to YU12 failed! res %d", __FUNCTION__, res);
             lk.unlock();
             Status st = parent->processCaptureRequestError(req);
             if (st != Status::OK) {
@@ -1490,7 +1559,7 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
     ATRACE_END();
 
     if (res != 0) {
-        ALOGE("%s: wait for BufferRequest done failed! res %d", __FUNCTION__, res);
+        ALOGE("shiva %s: wait for BufferRequest done failed! res %d", __FUNCTION__, res);
         lk.unlock();
         return onDeviceError("%s: failed to process buffer request error!", __FUNCTION__);
     }
@@ -1519,7 +1588,7 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
         switch (halBuf.format) {
             case PixelFormat::BLOB: {
                 int ret = createJpegLocked(halBuf, req->setting);
-
+ALOGE("shiva PixelFormat::BLOB \n");
                 if(ret != 0) {
                     lk.unlock();
                     return onDeviceError("%s: createJpegLocked failed with %d",
@@ -1528,10 +1597,13 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
             } break;
             case PixelFormat::Y16: {
                 void* outLayout = sHandleImporter.lock(*(halBuf.bufPtr), halBuf.usage, inDataSize);
-
+ALOGE("shiva sHandleImporter.lock Y16 %p",halBuf.bufPtr);
                 std::memcpy(outLayout, inData, inDataSize);
 
                 int relFence = sHandleImporter.unlock(*(halBuf.bufPtr));
+		ALOGE("shiva sHandleImporter.unlock Y16 %p", halBuf.bufPtr);
+
+		ALOGE("shiva PixelFormat::Y16 sHandleImporter.unlock relFence %d", relFence);
                 if (relFence >= 0) {
                     halBuf.acquireFence = relFence;
                 }
@@ -1541,12 +1613,17 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
                 IMapper::Rect outRect {0, 0,
                         static_cast<int32_t>(halBuf.width),
                         static_cast<int32_t>(halBuf.height)};
+		ALOGE("shiva sHandleImporter.lockYCbCr %p", halBuf.bufPtr);
                 YCbCrLayout outLayout = sHandleImporter.lockYCbCr(
                         *(halBuf.bufPtr), halBuf.usage, outRect);
-                ALOGV("%s: outLayout y %p cb %p cr %p y_str %d c_str %d c_step %d",
+                ALOGV("shiva %s: outLayout y %p cb %p cr %p y_str %d c_str %d c_step %d",
                         __FUNCTION__, outLayout.y, outLayout.cb, outLayout.cr,
                         outLayout.yStride, outLayout.cStride, outLayout.chromaStep);
 
+		unsigned int temp_sz = (640 *480) * 1.5;
+		memset(outLayout.y, 0x00, temp_sz);
+		//memset(outLayout.cr, 0x00, temp_sz);
+		//dumpFrame((unsigned char*)outLayout.y);
                 // Convert to output buffer size/format
                 uint32_t outputFourcc = getFourCcFromLayout(outLayout);
                 ALOGV("%s: converting to format %c%c%c%c", __FUNCTION__,
@@ -1564,7 +1641,7 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
                 ATRACE_END();
                 if (ret != 0) {
                     lk.unlock();
-                    return onDeviceError("%s: crop and scale failed!", __FUNCTION__);
+                    return onDeviceError("shiva %s: crop and scale failed!", __FUNCTION__);
                 }
 
                 Size sz {halBuf.width, halBuf.height};
@@ -1573,9 +1650,10 @@ bool ExternalCameraDeviceSession::OutputThread::threadLoop() {
                 ATRACE_END();
                 if (ret != 0) {
                     lk.unlock();
-                    return onDeviceError("%s: format coversion failed!", __FUNCTION__);
+                    return onDeviceError("shiva %s: format coversion failed!", __FUNCTION__);
                 }
                 int relFence = sHandleImporter.unlock(*(halBuf.bufPtr));
+                ALOGE("shiva sHandleImporter.unlock Ycbcr  relFence %d and halBuf.bufPtr %p ",relFence, halBuf.bufPtr);
                 if (relFence >= 0) {
                     halBuf.acquireFence = relFence;
                 }
@@ -1798,6 +1876,7 @@ void ExternalCameraDeviceSession::OutputThread::dump(int fd) {
 void ExternalCameraDeviceSession::cleanupBuffersLocked(int id) {
     for (auto& pair : mCirculatingBuffers.at(id)) {
         sHandleImporter.freeBuffer(pair.second);
+	ALOGE("shiva sHandleImporter.freeBuffer cleanupBuffersLocked %p",pair.second);
     }
     mCirculatingBuffers[id].clear();
     mCirculatingBuffers.erase(id);
@@ -1814,7 +1893,9 @@ void ExternalCameraDeviceSession::updateBufferCaches(const hidl_vec<BufferCache>
         CirculatingBuffers& cbs = cbsIt->second;
         auto it = cbs.find(cache.bufferId);
         if (it != cbs.end()) {
-            sHandleImporter.freeBuffer(it->second);
+                    ALOGE("shiva sHandleImporter.freeBuffer updateBufferCaches ");
+
+		sHandleImporter.freeBuffer(it->second);
             cbs.erase(it);
         } else {
             ALOGE("%s: stream %d buffer %" PRIu64 " is not cached",
diff --git a/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraDeviceSession.h b/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraDeviceSession.h
index 180f0c155..2480bc02d 100644
--- a/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraDeviceSession.h
+++ b/camera/device/3.4/default/include/ext_device_v3_4_impl/ExternalCameraDeviceSession.h
@@ -124,6 +124,8 @@ struct ExternalCameraDeviceSession : public virtual RefBase,
         Status submitRequest(const std::shared_ptr<HalRequest>&);
         void flush();
         void dump(int fd);
+	void dumpFrame(unsigned char *bufdest);
+
         virtual bool threadLoop() override;
 
         void setExifMakeModel(const std::string& make, const std::string& model);
diff --git a/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.cpp b/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.cpp
index ba515a821..2a3dccdad 100644
--- a/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.cpp
+++ b/camera/provider/2.4/default/ExternalCameraProviderImpl_2_4.cpp
@@ -15,7 +15,7 @@
  */
 
 #define LOG_TAG "CamPrvdr@2.4-external"
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #include <log/log.h>
 
 #include <regex>
@@ -211,7 +211,7 @@ Return<void> ExternalCameraProviderImpl_2_4::getCameraDeviceInterface_V3_x(
 }
 
 void ExternalCameraProviderImpl_2_4::addExternalCamera(const char* devName) {
-    ALOGI("ExtCam: adding %s to External Camera HAL!", devName);
+    ALOGE("ExtCam: adding %s to External Camera HAL!", devName);
     Mutex::Autolock _l(mLock);
     std::string deviceName;
     std::string cameraId = std::to_string(mCfg.cameraIdOffset +
-- 
2.32.0

