From 33fdd0e9683e8acc71f5749f61add47954aba616 Mon Sep 17 00:00:00 2001
From: manxiaoliang <xiaoliangx.man@intel.com>
Date: Wed, 23 Aug 2023 08:21:53 +0000
Subject: [PATCH] Enable graphics.composer3 AIDL HAL service.

Add the implementations of HWComposer3 AIDL HAL.

Tracked-On: OAM-110596
Change-Id: I0183bae5a0e0b41988e1e1553915a48aca81fdfd
Signed-off-by: manxiaoliang <xiaoliangx.man@intel.com>
---
 graphics/composer/aidl/default/Android.bp     |   78 ++
 graphics/composer/aidl/default/Composer.cpp   |   98 ++
 graphics/composer/aidl/default/Composer.h     |   52 +
 .../composer/aidl/default/ComposerClient.cpp  |  598 ++++++++
 .../composer/aidl/default/ComposerClient.h    |  151 +++
 .../aidl/default/ComposerCommandEngine.cpp    |  459 +++++++
 .../aidl/default/ComposerCommandEngine.h      |  119 ++
 graphics/composer/aidl/default/NOTICE         |  190 +++
 graphics/composer/aidl/default/Util.h         |   94 ++
 ...rdware.graphics.composer3-service.intel.rc |    7 +
 ...dware.graphics.composer3-service.intel.xml |   10 +
 .../composer/aidl/default/impl/HalImpl.cpp    | 1199 +++++++++++++++++
 graphics/composer/aidl/default/impl/HalImpl.h |  264 ++++
 .../composer/aidl/default/impl/HwcLoader.cpp  |   97 ++
 .../composer/aidl/default/impl/HwcLoader.h    |   48 +
 .../aidl/default/impl/ResourceManager.cpp     |  251 ++++
 .../aidl/default/impl/ResourceManager.h       |   79 ++
 .../aidl/default/impl/TranslateHwcAidl.h      |  152 +++
 .../aidl/default/include/IComposerHal.h       |  225 ++++
 .../aidl/default/include/IResourceManager.h   |   75 ++
 graphics/composer/aidl/default/service.cpp    |   61 +
 21 files changed, 4307 insertions(+)
 create mode 100644 graphics/composer/aidl/default/Android.bp
 create mode 100644 graphics/composer/aidl/default/Composer.cpp
 create mode 100644 graphics/composer/aidl/default/Composer.h
 create mode 100644 graphics/composer/aidl/default/ComposerClient.cpp
 create mode 100644 graphics/composer/aidl/default/ComposerClient.h
 create mode 100644 graphics/composer/aidl/default/ComposerCommandEngine.cpp
 create mode 100644 graphics/composer/aidl/default/ComposerCommandEngine.h
 create mode 100644 graphics/composer/aidl/default/NOTICE
 create mode 100644 graphics/composer/aidl/default/Util.h
 create mode 100644 graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.rc
 create mode 100644 graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.xml
 create mode 100644 graphics/composer/aidl/default/impl/HalImpl.cpp
 create mode 100644 graphics/composer/aidl/default/impl/HalImpl.h
 create mode 100644 graphics/composer/aidl/default/impl/HwcLoader.cpp
 create mode 100644 graphics/composer/aidl/default/impl/HwcLoader.h
 create mode 100644 graphics/composer/aidl/default/impl/ResourceManager.cpp
 create mode 100644 graphics/composer/aidl/default/impl/ResourceManager.h
 create mode 100644 graphics/composer/aidl/default/impl/TranslateHwcAidl.h
 create mode 100644 graphics/composer/aidl/default/include/IComposerHal.h
 create mode 100644 graphics/composer/aidl/default/include/IResourceManager.h
 create mode 100644 graphics/composer/aidl/default/service.cpp

diff --git a/graphics/composer/aidl/default/Android.bp b/graphics/composer/aidl/default/Android.bp
new file mode 100644
index 0000000000..0783f284f3
--- /dev/null
+++ b/graphics/composer/aidl/default/Android.bp
@@ -0,0 +1,78 @@
+//  Copyright (C) 2022 The Android Open Source Project
+// 
+//  Licensed under the Apache License, Version 2.0 (the "License");
+//  you may not use this file except in compliance with the License.
+//  You may obtain a copy of the License at
+// 
+//       http://www.apache.org/licenses/LICENSE-2.0
+// 
+//  Unless required by applicable law or agreed to in writing, software
+//  distributed under the License is distributed on an "AS IS" BASIS,
+//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//  See the License for the specific language governing permissions and
+//  limitations under the License.
+
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "hardware_interfaces_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["hardware_interfaces_license"],    
+}
+
+cc_binary {
+    name: "android.hardware.graphics.composer3-service.intel",
+    relative_install_path: "hw",
+    init_rc: ["android.hardware.graphics.composer3-service.intel.rc"],
+    vendor: true,
+    cflags:[
+        "-Wall",
+        "-Werror",
+        "-DLOG_TAG=\"hwc3\"",
+    ],
+    cppflags: [
+        "-Wextra",
+        "-Wunused",
+        "-Wunreachable-code",
+        "-Wno-sign-compare",
+        "-Wno-unused-parameter",
+    ],
+    local_include_dirs:[
+        "include",
+        "impl",
+    ],
+    include_dirs: [ 
+    ],
+    header_libs: [
+        "android.hardware.graphics.composer3-command-buffer",
+    ],
+    static_libs:[
+        "libaidlcommonsupport",
+    ],
+    shared_libs: [
+        "android.hardware.graphics.composer@2.1-resources",
+        "android.hardware.graphics.composer@2.2-resources",
+        "android.hardware.graphics.composer3-V2-ndk",
+        "libbase",
+        "libbinder_ndk",
+        "libcutils",
+        "libhardware",
+        "libhwc2on1adapter",
+        "libhwc2onfbadapter",
+        "libhardware_legacy",
+        "liblog",
+        "libsync",
+        "libutils",
+    ],
+    srcs: [
+        "Composer.cpp",
+        "ComposerClient.cpp",
+        "ComposerCommandEngine.cpp",
+        "impl/HalImpl.cpp",
+        "impl/HwcLoader.cpp",
+        "impl/ResourceManager.cpp",
+        "service.cpp",
+    ],
+}
+
diff --git a/graphics/composer/aidl/default/Composer.cpp b/graphics/composer/aidl/default/Composer.cpp
new file mode 100644
index 0000000000..4a57d96004
--- /dev/null
+++ b/graphics/composer/aidl/default/Composer.cpp
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define ATRACE_TAG (ATRACE_TAG_GRAPHICS | ATRACE_TAG_HAL)
+
+#include "Composer.h"
+
+#include <android-base/logging.h>
+#include <android/binder_ibinder_platform.h>
+
+#include "Util.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+ndk::ScopedAStatus Composer::createClient(std::shared_ptr<IComposerClient>* outClient) {
+    DEBUG_FUNC();
+    std::unique_lock<std::mutex> lock(mClientMutex);
+    if (!waitForClientDestroyedLocked(lock)) {
+        *outClient = nullptr;
+        return TO_BINDER_STATUS(EX_NO_RESOURCES);
+    }
+
+    auto client = ndk::SharedRefBase::make<ComposerClient>(mHal.get());
+    if (!client || !client->init()) {
+        *outClient = nullptr;
+        return TO_BINDER_STATUS(EX_NO_RESOURCES);
+    }
+
+    auto clientDestroyed = [this]() { onClientDestroyed(); };
+    client->setOnClientDestroyed(clientDestroyed);
+
+    mClientAlive = true;
+    *outClient = client;
+
+    return ndk::ScopedAStatus::ok();
+}
+
+binder_status_t Composer::dump(int fd, const char** /*args*/, uint32_t /*numArgs*/) {
+    std::string output;
+    mHal->dumpDebugInfo(&output);
+    write(fd, output.c_str(), output.size());
+    return STATUS_OK;
+}
+
+ndk::ScopedAStatus Composer::getCapabilities(std::vector<Capability>* caps) {
+    DEBUG_FUNC();
+    mHal->getCapabilities(caps);
+    return ndk::ScopedAStatus::ok();
+}
+
+bool Composer::waitForClientDestroyedLocked(std::unique_lock<std::mutex>& lock) {
+    if (mClientAlive) {
+        using namespace std::chrono_literals;
+
+        // In surface flinger we delete a composer client on one thread and
+        // then create a new client on another thread. Although surface
+        // flinger ensures the calls are made in that sequence (destroy and
+        // then create), sometimes the calls land in the composer service
+        // inverted (create and then destroy). Wait for a brief period to
+        // see if the existing client is destroyed.
+        LOG(DEBUG) << "waiting for previous client to be destroyed";
+        mClientDestroyedCondition.wait_for(lock, 1s,
+                                           [this]() -> bool { return !mClientAlive; });
+        if (mClientAlive) {
+            LOG(DEBUG) << "previous client was not destroyed";
+        }
+    }
+
+    return !mClientAlive;
+}
+
+void Composer::onClientDestroyed() {
+    std::lock_guard<std::mutex> lock(mClientMutex);
+    mClientAlive = false;
+    mClientDestroyedCondition.notify_all();
+}
+
+::ndk::SpAIBinder Composer::createBinder() {
+    auto binder = BnComposer::createBinder();
+    AIBinder_setInheritRt(binder.get(), true);
+    return binder;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
+
diff --git a/graphics/composer/aidl/default/Composer.h b/graphics/composer/aidl/default/Composer.h
new file mode 100644
index 0000000000..5c2b5e2cbc
--- /dev/null
+++ b/graphics/composer/aidl/default/Composer.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HWC_COMPOSER_H
+#define ANDROID_HWC_COMPOSER_H
+
+#include <aidl/android/hardware/graphics/composer3/BnComposer.h>
+#include <utils/Mutex.h>
+
+#include "include/IComposerHal.h"
+#include "ComposerClient.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class Composer : public BnComposer {
+public:
+    Composer(std::unique_ptr<IComposerHal> hal) : mHal(std::move(hal)) {}
+
+    binder_status_t dump(int fd, const char** args, uint32_t numArgs) override;
+
+    // compser3 api
+    ndk::ScopedAStatus createClient(std::shared_ptr<IComposerClient>* client) override;
+    ndk::ScopedAStatus getCapabilities(std::vector<Capability>* caps) override;
+
+protected:
+    ndk::SpAIBinder createBinder() override;
+
+private:
+    bool waitForClientDestroyedLocked(std::unique_lock<std::mutex>& lock);
+    void onClientDestroyed();
+
+    const std::unique_ptr<IComposerHal> mHal;
+    std::mutex mClientMutex;
+    bool mClientAlive GUARDED_BY(mClientMutex) = false;
+    std::condition_variable mClientDestroyedCondition;
+};
+
+}  // namespace aidl::android::hardware::graphics::composer3::impl
+#endif
\ No newline at end of file
diff --git a/graphics/composer/aidl/default/ComposerClient.cpp b/graphics/composer/aidl/default/ComposerClient.cpp
new file mode 100644
index 0000000000..f142f998ef
--- /dev/null
+++ b/graphics/composer/aidl/default/ComposerClient.cpp
@@ -0,0 +1,598 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define ATRACE_TAG (ATRACE_TAG_GRAPHICS | ATRACE_TAG_HAL)
+
+#include "ComposerClient.h"
+
+#include <android-base/logging.h>
+#include <android/binder_ibinder_platform.h>
+
+#include "Util.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+bool ComposerClient::init() {
+    DEBUG_FUNC();
+    mResources = IResourceManager::create();
+    if (!mResources) {
+        LOG(ERROR) << "failed to create composer resources";
+        return false;
+    }
+
+    mCommandEngine = std::make_unique<ComposerCommandEngine>(mHal, mResources.get());
+    if (mCommandEngine == nullptr) {
+        return false;
+    }
+    if (!mCommandEngine->init()) {
+        mCommandEngine = nullptr;
+        return false;
+    }
+
+    return true;
+}
+
+ComposerClient::~ComposerClient() {
+    DEBUG_FUNC();
+    // not initialized
+    if (!mCommandEngine) {
+        return;
+    }
+
+    LOG(DEBUG) << "destroying composer client";
+
+    mHal->unregisterEventCallback();
+    destroyResources();
+
+    if (mOnClientDestroyed) {
+        mOnClientDestroyed();
+    }
+
+    LOG(DEBUG) << "removed composer client";
+}
+
+// no need to check nullptr for output parameter, the aidl stub code won't pass nullptr
+ndk::ScopedAStatus ComposerClient::createLayer(int64_t display, int32_t bufferSlotCount,
+                                               int64_t* layer) {
+    DEBUG_FUNC();
+    auto err = mHal->createLayer(display, layer);
+    if (!err) {
+        err = mResources->addLayer(display, *layer, bufferSlotCount);
+        if (err) {
+            layer = 0;
+        }
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::createVirtualDisplay(int32_t width, int32_t height,
+                                                        AidlPixelFormat formatHint,
+                                                        int32_t outputBufferSlotCount,
+                                                        VirtualDisplay* display) {
+    DEBUG_FUNC();
+    auto err = mHal->createVirtualDisplay(width, height, formatHint, display);
+    if (!err) {
+        err = mResources->addVirtualDisplay(display->display, outputBufferSlotCount);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::destroyLayer(int64_t display, int64_t layer) {
+    DEBUG_FUNC();
+    auto err = mHal->destroyLayer(display, layer);
+    if (!err) {
+        err = mResources->removeLayer(display, layer);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::destroyVirtualDisplay(int64_t display) {
+    DEBUG_FUNC();
+    auto err = mHal->destroyVirtualDisplay(display);
+    if (!err) {
+        err = mResources->removeDisplay(display);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::executeCommands(const std::vector<DisplayCommand>& commands,
+                                                   std::vector<CommandResultPayload>* results) {
+    DEBUG_FUNC();
+    auto err = mCommandEngine->execute(commands, results);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getActiveConfig(int64_t display, int32_t* config) {
+    DEBUG_FUNC();
+    auto err = mHal->getActiveConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getColorModes(int64_t display,
+                                                 std::vector<ColorMode>* colorModes) {
+    DEBUG_FUNC();
+    auto err = mHal->getColorModes(display, colorModes);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                                                std::vector<float>* matrix) {
+    DEBUG_FUNC();
+    if (dataspace != common::Dataspace::SRGB_LINEAR) {
+        return TO_BINDER_STATUS(EX_BAD_PARAMETER);
+    }
+
+    auto err = mHal->getDataspaceSaturationMatrix(dataspace, matrix);
+    if (err) {
+        constexpr std::array<float, 16> unit {
+                1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
+                0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
+        };
+        matrix->clear();
+        matrix->insert(matrix->begin(), unit.begin(), unit.end());
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayAttribute(int64_t display, int32_t config,
+                                                       DisplayAttribute attribute, int32_t* value) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayAttribute(display, config, attribute, value);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayCapabilities(int64_t display,
+                                                          std::vector<DisplayCapability>* caps) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayCapabilities(display, caps);
+    if (err) {
+        return TO_BINDER_STATUS(err);
+    }
+
+    bool support = false;
+    err = mHal->getDisplayIdleTimerSupport(display, support);
+    if (err != ::android::OK) {
+        LOG(ERROR) << "failed to getDisplayIdleTimerSupport: " << err;
+    }
+
+    if (support) {
+        caps->push_back(DisplayCapability::DISPLAY_IDLE_TIMER);
+    }
+
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayConfigs(int64_t display,
+                                                     std::vector<int32_t>* configs) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayConfigs(display, configs);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayConnectionType(int64_t display,
+                                                            DisplayConnectionType* type) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayConnectionType(display, type);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayIdentificationData(int64_t display,
+                                                                DisplayIdentification* id) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayIdentificationData(display, id);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayName(int64_t display, std::string* name) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayName(display, name);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayVsyncPeriod(int64_t display, int32_t* vsyncPeriod) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayVsyncPeriod(display, vsyncPeriod);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayedContentSample(int64_t display, int64_t maxFrames,
+                                                             int64_t timestamp,
+                                                             DisplayContentSample* samples) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayedContentSample(display, maxFrames, timestamp, samples);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayedContentSamplingAttributes(
+        int64_t display, DisplayContentSamplingAttributes* attrs) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayedContentSamplingAttributes(display, attrs);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayPhysicalOrientation(int64_t display,
+                                                                 common::Transform* orientation) {
+    DEBUG_FUNC();
+    auto err = mHal->getDisplayPhysicalOrientation(display, orientation);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getHdrCapabilities(int64_t display, HdrCapabilities* caps) {
+    DEBUG_FUNC();
+    auto err = mHal->getHdrCapabilities(display, caps);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getOverlaySupport(OverlayProperties* properties) {
+    return ndk::ScopedAStatus::ok();
+}
+
+ndk::ScopedAStatus ComposerClient::getMaxVirtualDisplayCount(int32_t* count) {
+    DEBUG_FUNC();
+    auto err = mHal->getMaxVirtualDisplayCount(count);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getPerFrameMetadataKeys(int64_t display,
+                                                           std::vector<PerFrameMetadataKey>* keys) {
+    DEBUG_FUNC();
+    auto err = mHal->getPerFrameMetadataKeys(display, keys);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getReadbackBufferAttributes(int64_t display,
+                                                               ReadbackBufferAttributes* attrs) {
+    DEBUG_FUNC();
+    auto err = mHal->getReadbackBufferAttributes(display, attrs);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getReadbackBufferFence(int64_t display,
+                                                          ndk::ScopedFileDescriptor* acquireFence) {
+    DEBUG_FUNC();
+    auto err = mHal->getReadbackBufferFence(display, acquireFence);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getRenderIntents(int64_t display, ColorMode mode,
+                                                    std::vector<RenderIntent>* intents) {
+    DEBUG_FUNC();
+    auto err = mHal->getRenderIntents(display, mode, intents);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getSupportedContentTypes(int64_t display,
+                                                            std::vector<ContentType>* types) {
+    DEBUG_FUNC();
+    auto err = mHal->getSupportedContentTypes(display, types);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getDisplayDecorationSupport(
+        int64_t display, std::optional<common::DisplayDecorationSupport>* supportStruct) {
+    DEBUG_FUNC();
+    bool support = false;
+    auto err = mHal->getRCDLayerSupport(display, support);
+    if (err != ::android::OK) {
+        LOG(ERROR) << "failed to getRCDLayerSupport: " << err;
+    }
+    if (support) {
+        // TODO (b/218499393): determine from mHal instead of hard coding.
+        auto& s = supportStruct->emplace();
+        s.format = common::PixelFormat::R_8;
+        s.alphaInterpretation = common::AlphaInterpretation::COVERAGE;
+    } else {
+        supportStruct->reset();
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::registerCallback(
+        const std::shared_ptr<IComposerCallback>& callback) {
+    DEBUG_FUNC();
+    // no locking as we require this function to be called only once
+    mHalEventCallback = std::make_unique<HalEventCallback>(mHal, mResources.get(), callback);
+    mHal->registerEventCallback(mHalEventCallback.get());
+    return ndk::ScopedAStatus::ok();
+}
+
+ndk::ScopedAStatus ComposerClient::setActiveConfig(int64_t display, int32_t config) {
+    DEBUG_FUNC();
+    auto err = mHal->setActiveConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setActiveConfigWithConstraints(
+        int64_t display, int32_t config, const VsyncPeriodChangeConstraints& constraints,
+        VsyncPeriodChangeTimeline* timeline) {
+    DEBUG_FUNC();
+    auto err = mHal->setActiveConfigWithConstraints(display, config, constraints, timeline);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setBootDisplayConfig(int64_t display, int32_t config) {
+    DEBUG_FUNC();
+    auto err = mHal->setBootDisplayConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::clearBootDisplayConfig(int64_t display) {
+    DEBUG_FUNC();
+    auto err = mHal->clearBootDisplayConfig(display);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getPreferredBootDisplayConfig(int64_t display, int32_t* config) {
+    DEBUG_FUNC();
+    auto err = mHal->getPreferredBootDisplayConfig(display, config);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::getHdrConversionCapabilities(
+      std::vector<aidl::android::hardware::graphics::common::HdrConversionCapability>*) {
+    
+    return ndk::ScopedAStatus::ok();
+}
+ndk::ScopedAStatus ComposerClient::setHdrConversionStrategy(
+            const aidl::android::hardware::graphics::common::HdrConversionStrategy& conversionStrategy,
+            aidl::android::hardware::graphics::common::Hdr* preferredHdrOutputType) {
+    return ndk::ScopedAStatus::ok();
+}
+    
+
+ndk::ScopedAStatus ComposerClient::setAutoLowLatencyMode(int64_t display, bool on) {
+    DEBUG_FUNC();
+    auto err = mHal->setAutoLowLatencyMode(display, on);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setClientTargetSlotCount(int64_t display, int32_t count) {
+    DEBUG_FUNC();
+    auto err = mResources->setDisplayClientTargetCacheSize(display, count);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setColorMode(int64_t display, ColorMode mode,
+                                                RenderIntent intent) {
+    DEBUG_FUNC();
+    auto err = mHal->setColorMode(display, mode, intent);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setContentType(int64_t display, ContentType type) {
+    DEBUG_FUNC();
+    auto err = mHal->setContentType(display, type);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setDisplayedContentSamplingEnabled(
+        int64_t display, bool enable, FormatColorComponent componentMask, int64_t maxFrames) {
+    DEBUG_FUNC();
+    auto err = mHal->setDisplayedContentSamplingEnabled(display, enable, componentMask, maxFrames);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setPowerMode(int64_t display, PowerMode mode) {
+    DEBUG_FUNC();
+    auto err = mHal->setPowerMode(display, mode);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setReadbackBuffer(
+        int64_t display, const AidlNativeHandle& aidlBuffer,
+        const ndk::ScopedFileDescriptor& releaseFence) {
+    DEBUG_FUNC();
+    buffer_handle_t readbackBuffer;
+    // Note ownership of the buffer is not passed to resource manager.
+    buffer_handle_t buffer = ::android::makeFromAidl(aidlBuffer);
+    auto bufReleaser = mResources->createReleaser(true /* isBuffer */);
+    auto err = mResources->getDisplayReadbackBuffer(display, buffer,
+                                                    readbackBuffer, bufReleaser.get());
+    if (!err) {
+        err = mHal->setReadbackBuffer(display, readbackBuffer, releaseFence);
+    }
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setVsyncEnabled(int64_t display, bool enabled) {
+    DEBUG_FUNC();
+    auto err = mHal->setVsyncEnabled(display, enabled);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setIdleTimerEnabled(int64_t display, int32_t timeout) {
+    DEBUG_FUNC();
+    auto err = mHal->setIdleTimerEnabled(display, timeout);
+    return TO_BINDER_STATUS(err);
+}
+
+ndk::ScopedAStatus ComposerClient::setRefreshRateChangedCallbackDebugEnabled(int64_t displayId,
+                                                               bool enabled) {
+    return ndk::ScopedAStatus::ok();
+}
+
+void ComposerClient::HalEventCallback::onHotplug(int64_t display, bool connected) {
+    DEBUG_FUNC();
+    if (connected) {
+        if (mResources->hasDisplay(display)) {
+            // This is a subsequent hotplug "connected" for a display. This signals a
+            // display change and thus the framework may want to reallocate buffers. We
+            // need to free all cached handles, since they are holding a strong reference
+            // to the underlying buffers.
+            cleanDisplayResources(display);
+            mResources->removeDisplay(display);
+        }
+        mResources->addPhysicalDisplay(display);
+    } else {
+        mResources->removeDisplay(display);
+    }
+
+    auto ret = mCallback->onHotplug(display, connected);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onHotplug:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onRefresh(int64_t display) {
+    DEBUG_FUNC();
+    mResources->setDisplayMustValidateState(display, true);
+    auto ret = mCallback->onRefresh(display);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onRefresh:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onVsync(int64_t display, int64_t timestamp,
+                                               int32_t vsyncPeriodNanos) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onVsync(display, timestamp, vsyncPeriodNanos);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onVsync:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onVsyncPeriodTimingChanged(
+        int64_t display, const VsyncPeriodChangeTimeline& timeline) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onVsyncPeriodTimingChanged(display, timeline);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onVsyncPeriodTimingChanged:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onVsyncIdle(int64_t display) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onVsyncIdle(display);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onVsyncIdle:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::onSeamlessPossible(int64_t display) {
+    DEBUG_FUNC();
+    auto ret = mCallback->onSeamlessPossible(display);
+    if (!ret.isOk()) {
+        LOG(ERROR) << "failed to send onSealmessPossible:" << ret.getDescription();
+    }
+}
+
+void ComposerClient::HalEventCallback::cleanDisplayResources(int64_t display) {
+    DEBUG_FUNC();
+    size_t cacheSize;
+    auto err = mResources->getDisplayClientTargetCacheSize(display, &cacheSize);
+    if (!err) {
+        for (int slot = 0; slot < cacheSize; slot++) {
+            // Replace the buffer slots with NULLs. Keep the old handle until it is
+            // replaced in ComposerHal, otherwise we risk leaving a dangling pointer.
+            buffer_handle_t outHandle;
+            auto bufReleaser = mResources->createReleaser(true /* isBuffer */);
+            err = mResources->getDisplayClientTarget(display, slot, /*useCache*/ true,
+                                                    /*rawHandle*/ nullptr, outHandle,
+                                                    bufReleaser.get());
+            if (err) {
+                continue;
+            }
+            const std::vector<common::Rect> damage;
+            ndk::ScopedFileDescriptor fence; // empty fence
+            common::Dataspace dataspace = common::Dataspace::UNKNOWN;
+            err = mHal->setClientTarget(display, outHandle, fence, dataspace, damage);
+            if (err) {
+                LOG(ERROR) << "Can't clean slot " << slot
+                           << " of the client target buffer cache for display" << display;
+            }
+        }
+    } else {
+        LOG(ERROR) << "Can't clean client target cache for display " << display;
+    }
+
+    err = mResources->getDisplayOutputBufferCacheSize(display, &cacheSize);
+    if (!err) {
+        for (int slot = 0; slot < cacheSize; slot++) {
+            // Replace the buffer slots with NULLs. Keep the old handle until it is
+            // replaced in ComposerHal, otherwise we risk leaving a dangling pointer.
+            buffer_handle_t outputBuffer;
+            auto bufReleaser = mResources->createReleaser(true /* isBuffer */);
+            err = mResources->getDisplayOutputBuffer(display, slot, /*useCache*/ true,
+                                                    /*rawHandle*/ nullptr, outputBuffer,
+                                                    bufReleaser.get());
+            if (err) {
+                continue;
+            }
+            ndk::ScopedFileDescriptor emptyFd;
+            err = mHal->setOutputBuffer(display, outputBuffer, /*fence*/ emptyFd);
+            if (err) {
+                LOG(ERROR) << "Can't clean slot " << slot
+                           << " of the output buffer cache for display " << display;
+            }
+        }
+    } else {
+        LOG(ERROR) << "Can't clean output buffer cache for display " << display;
+    }
+}
+
+void ComposerClient::destroyResources() {
+    DEBUG_FUNC();
+    // We want to call hwc2_close here (and move hwc2_open to the
+    // constructor), with the assumption that hwc2_close would
+    //
+    //  - clean up all resources owned by the client
+    //  - make sure all displays are blank (since there is no layer)
+    //
+    // But since SF used to crash at this point, different hwcomposer2
+    // implementations behave differently on hwc2_close.  Our only portable
+    // choice really is to abort().  But that is not an option anymore
+    // because we might also have VTS or VR as clients that can come and go.
+    //
+    // Below we manually clean all resources (layers and virtual
+    // displays), and perform a presentDisplay afterwards.
+    mResources->clear([this](int64_t display, bool isVirtual, const std::vector<int64_t> layers) {
+        LOG(WARNING) << "destroying client resources for display " << display;
+        for (auto layer : layers) {
+            mHal->destroyLayer(display, layer);
+        }
+
+        if (isVirtual) {
+            mHal->destroyVirtualDisplay(display);
+        } else {
+            LOG(WARNING) << "performing a final presentDisplay";
+            std::vector<int64_t> changedLayers;
+            std::vector<Composition> compositionTypes;
+            uint32_t displayRequestMask = 0;
+            std::vector<int64_t> requestedLayers;
+            std::vector<int32_t> requestMasks;
+            ClientTargetProperty clientTargetProperty;
+            DimmingStage dimmingStage;
+            mHal->validateDisplay(display, &changedLayers, &compositionTypes, &displayRequestMask,
+                                  &requestedLayers, &requestMasks, &clientTargetProperty,
+                                  &dimmingStage);
+            mHal->acceptDisplayChanges(display);
+
+            ndk::ScopedFileDescriptor presentFence;
+            std::vector<int64_t> releasedLayers;
+            std::vector<ndk::ScopedFileDescriptor> releaseFences;
+            mHal->presentDisplay(display, presentFence, &releasedLayers, &releaseFences);
+        }
+    });
+    mResources.reset();
+}
+
+::ndk::SpAIBinder ComposerClient::createBinder() {
+    auto binder = BnComposerClient::createBinder();
+    AIBinder_setInheritRt(binder.get(), true);
+    return binder;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/ComposerClient.h b/graphics/composer/aidl/default/ComposerClient.h
new file mode 100644
index 0000000000..2a849522d5
--- /dev/null
+++ b/graphics/composer/aidl/default/ComposerClient.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <aidl/android/hardware/graphics/common/DisplayDecorationSupport.h>
+#include <aidl/android/hardware/graphics/composer3/BnComposerClient.h>
+#include <utils/Mutex.h>
+
+#include <memory>
+
+#include "ComposerCommandEngine.h"
+#include "include/IComposerHal.h"
+#include "include/IResourceManager.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class ComposerClient : public BnComposerClient {
+public:
+    ComposerClient(IComposerHal* hal) : mHal(hal) {}
+    virtual ~ComposerClient();
+    bool init();
+    void setOnClientDestroyed(std::function<void()> onClientDestroyed) {
+        mOnClientDestroyed = onClientDestroyed;
+    }
+
+    class HalEventCallback : public IComposerHal::EventCallback {
+      public:
+          HalEventCallback(IComposerHal* hal, IResourceManager* resources,
+                           const std::shared_ptr<IComposerCallback>& callback)
+                : mHal(hal), mResources(resources), mCallback(callback) {}
+          void onHotplug(int64_t display, bool connected) override;
+          void onRefresh(int64_t display) override;
+          void onVsync(int64_t display, int64_t timestamp, int32_t vsyncPeriodNanos) override;
+          void onVsyncPeriodTimingChanged(int64_t display,
+                                          const VsyncPeriodChangeTimeline& timeline) override;
+          void onVsyncIdle(int64_t display) override;
+          void onSeamlessPossible(int64_t display) override;
+
+      private:
+        void cleanDisplayResources(int64_t display);
+
+        IComposerHal* mHal;
+        IResourceManager* mResources;
+        const std::shared_ptr<IComposerCallback> mCallback;
+    };
+
+    // composer3 interface
+    ndk::ScopedAStatus createLayer(int64_t display, int32_t bufferSlotCount,
+                                   int64_t* layer) override;
+    ndk::ScopedAStatus createVirtualDisplay(int32_t width, int32_t height,
+                                            AidlPixelFormat formatHint,
+                                            int32_t outputBufferSlotCount,
+                                            VirtualDisplay* display) override;
+    ndk::ScopedAStatus destroyLayer(int64_t display, int64_t layer) override;
+    ndk::ScopedAStatus destroyVirtualDisplay(int64_t display) override;
+    ndk::ScopedAStatus executeCommands(const std::vector<DisplayCommand>& commands,
+                                       std::vector<CommandResultPayload>* results) override;
+    ndk::ScopedAStatus getActiveConfig(int64_t display, int32_t* config) override;
+    ndk::ScopedAStatus getColorModes(int64_t display, std::vector<ColorMode>* colorModes) override;
+    ndk::ScopedAStatus getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                                    std::vector<float>* matrix) override;
+    ndk::ScopedAStatus getDisplayAttribute(int64_t display, int32_t config,
+                                           DisplayAttribute attribute, int32_t* value) override;
+    ndk::ScopedAStatus getDisplayCapabilities(int64_t display,
+                                              std::vector<DisplayCapability>* caps) override;
+    ndk::ScopedAStatus getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) override;
+    ndk::ScopedAStatus getDisplayConnectionType(int64_t display,
+                                                DisplayConnectionType* type) override;
+    ndk::ScopedAStatus getDisplayIdentificationData(int64_t display,
+                                                    DisplayIdentification* id) override;
+    ndk::ScopedAStatus getDisplayName(int64_t display, std::string* name) override;
+    ndk::ScopedAStatus getDisplayVsyncPeriod(int64_t display, int32_t* vsyncPeriod) override;
+    ndk::ScopedAStatus getDisplayedContentSample(int64_t display, int64_t maxFrames,
+                                                 int64_t timestamp,
+                                                 DisplayContentSample* samples) override;
+    ndk::ScopedAStatus getDisplayedContentSamplingAttributes(
+            int64_t display, DisplayContentSamplingAttributes* attrs) override;
+    ndk::ScopedAStatus getDisplayPhysicalOrientation(int64_t display,
+                                                     common::Transform* orientation) override;
+    ndk::ScopedAStatus getHdrCapabilities(int64_t display, HdrCapabilities* caps) override;
+    ndk::ScopedAStatus getOverlaySupport(OverlayProperties* properties) override;
+    ndk::ScopedAStatus getMaxVirtualDisplayCount(int32_t* count) override;
+    ndk::ScopedAStatus getPerFrameMetadataKeys(int64_t display,
+                                               std::vector<PerFrameMetadataKey>* keys) override;
+    ndk::ScopedAStatus getReadbackBufferAttributes(int64_t display,
+                                                   ReadbackBufferAttributes* attrs) override;
+    ndk::ScopedAStatus getReadbackBufferFence(int64_t display,
+                                              ndk::ScopedFileDescriptor* acquireFence) override;
+    ndk::ScopedAStatus getRenderIntents(int64_t display, ColorMode mode,
+                                        std::vector<RenderIntent>* intents) override;
+    ndk::ScopedAStatus getSupportedContentTypes(int64_t display,
+                                                std::vector<ContentType>* types) override;
+    ndk::ScopedAStatus getDisplayDecorationSupport(
+            int64_t display, std::optional<common::DisplayDecorationSupport>* support) override;
+    ndk::ScopedAStatus registerCallback(
+            const std::shared_ptr<IComposerCallback>& callback) override;
+    ndk::ScopedAStatus setActiveConfig(int64_t display, int32_t config) override;
+    ndk::ScopedAStatus setActiveConfigWithConstraints(
+            int64_t display, int32_t config, const VsyncPeriodChangeConstraints& constraints,
+            VsyncPeriodChangeTimeline* timeline) override;
+    ndk::ScopedAStatus setBootDisplayConfig(int64_t display, int32_t config) override;
+    ndk::ScopedAStatus clearBootDisplayConfig(int64_t display) override;
+    ndk::ScopedAStatus getPreferredBootDisplayConfig(int64_t display, int32_t* config) override;
+    ndk::ScopedAStatus getHdrConversionCapabilities(
+      std::vector<aidl::android::hardware::graphics::common::HdrConversionCapability>*) override;
+    ndk::ScopedAStatus setHdrConversionStrategy(
+            const aidl::android::hardware::graphics::common::HdrConversionStrategy& conversionStrategy,
+            aidl::android::hardware::graphics::common::Hdr* preferredHdrOutputType) override;
+    ndk::ScopedAStatus setAutoLowLatencyMode(int64_t display, bool on) override;
+    ndk::ScopedAStatus setClientTargetSlotCount(int64_t display, int32_t count) override;
+    ndk::ScopedAStatus setColorMode(int64_t display, ColorMode mode, RenderIntent intent) override;
+    ndk::ScopedAStatus setContentType(int64_t display, ContentType type) override;
+    ndk::ScopedAStatus setDisplayedContentSamplingEnabled(int64_t display, bool enable,
+                                                          FormatColorComponent componentMask,
+                                                          int64_t maxFrames) override;
+    ndk::ScopedAStatus setPowerMode(int64_t display, PowerMode mode) override;
+    ndk::ScopedAStatus setReadbackBuffer(int64_t display, const AidlNativeHandle& buffer,
+                                         const ndk::ScopedFileDescriptor& releaseFence) override;
+    ndk::ScopedAStatus setVsyncEnabled(int64_t display, bool enabled) override;
+    ndk::ScopedAStatus setIdleTimerEnabled(int64_t display, int32_t timeout) override;
+    ndk::ScopedAStatus setRefreshRateChangedCallbackDebugEnabled(int64_t displayId,
+                                                               bool enabled) override;
+protected:
+    ::ndk::SpAIBinder createBinder() override;
+
+private:
+    void destroyResources();
+
+    IComposerHal* mHal;
+    std::unique_ptr<IResourceManager> mResources;
+    std::unique_ptr<ComposerCommandEngine> mCommandEngine;
+    std::function<void()> mOnClientDestroyed;
+    std::unique_ptr<HalEventCallback> mHalEventCallback;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
+
diff --git a/graphics/composer/aidl/default/ComposerCommandEngine.cpp b/graphics/composer/aidl/default/ComposerCommandEngine.cpp
new file mode 100644
index 0000000000..ff66f9dfee
--- /dev/null
+++ b/graphics/composer/aidl/default/ComposerCommandEngine.cpp
@@ -0,0 +1,459 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <set>
+
+#include "ComposerCommandEngine.h"
+#include "Util.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+#define DISPATCH_LAYER_COMMAND(display, layerCmd, field, funcName)               \
+    do {                                                                         \
+        if (layerCmd.field) {                                                    \
+            executeSetLayer##funcName(display, layerCmd.layer, *layerCmd.field); \
+        }                                                                        \
+    } while (0)
+
+#define DISPATCH_LAYER_COMMAND_SIMPLE(display, layerCmd, field, funcName)     \
+    do {                                                                      \
+        dispatchLayerCommand(display, layerCmd.layer, #field, layerCmd.field, \
+                             &IComposerHal::setLayer##funcName);              \
+    } while (0)
+
+#define DISPATCH_DISPLAY_COMMAND(displayCmd, field, funcName)                \
+    do {                                                                     \
+        if (displayCmd.field) {                                              \
+            execute##funcName(displayCmd.display, *displayCmd.field);        \
+        }                                                                    \
+    } while (0)
+
+#define DISPATCH_DISPLAY_BOOL_COMMAND(displayCmd, field, funcName)           \
+    do {                                                                     \
+        if (displayCmd.field) {                                              \
+            execute##funcName(displayCmd.display);                           \
+        }                                                                    \
+    } while (0)
+
+#define DISPATCH_DISPLAY_BOOL_COMMAND_AND_DATA(displayCmd, field, data, funcName) \
+    do {                                                                          \
+        if (displayCmd.field) {                                                   \
+            execute##funcName(displayCmd.display, displayCmd.data);               \
+        }                                                                         \
+    } while (0)
+
+bool ComposerCommandEngine::init() {
+    mWriter = std::make_unique<ComposerServiceWriter>();
+    return (mWriter != nullptr);
+}
+
+int32_t ComposerCommandEngine::execute(const std::vector<DisplayCommand>& commands,
+                                       std::vector<CommandResultPayload>* result) {
+    std::set<int64_t> displaysPendingBrightenssChange;
+    mCommandIndex = 0;
+    for (const auto& command : commands) {
+        dispatchDisplayCommand(command);
+        ++mCommandIndex;
+        // The input commands could have 2+ commands for the same display.
+        // If the first has pending brightness change, the second presentDisplay will apply it.
+        if (command.validateDisplay || command.presentDisplay ||
+            command.presentOrValidateDisplay) {
+            displaysPendingBrightenssChange.erase(command.display);
+        } else if (command.brightness) {
+            displaysPendingBrightenssChange.insert(command.display);
+        }
+    }
+
+    *result = mWriter->getPendingCommandResults();
+    mWriter->reset();
+
+    // standalone display brightness command shouldn't wait for next present or validate
+    for (auto display : displaysPendingBrightenssChange) {
+        auto err = mHal->flushDisplayBrightnessChange(display);
+        if (err) {
+            return err;
+        }
+    }
+    return ::android::NO_ERROR;
+}
+
+void ComposerCommandEngine::dispatchDisplayCommand(const DisplayCommand& command) {
+    //  place SetDisplayBrightness before SetLayerWhitePointNits since current
+    //  display brightness is used to validate the layer white point nits.
+    DISPATCH_DISPLAY_COMMAND(command, brightness, SetDisplayBrightness);
+    for (const auto& layerCmd : command.layers) {
+        dispatchLayerCommand(command.display, layerCmd);
+    }
+
+    DISPATCH_DISPLAY_COMMAND(command, colorTransformMatrix, SetColorTransform);
+    DISPATCH_DISPLAY_COMMAND(command, clientTarget, SetClientTarget);
+    DISPATCH_DISPLAY_COMMAND(command, virtualDisplayOutputBuffer, SetOutputBuffer);
+    DISPATCH_DISPLAY_BOOL_COMMAND_AND_DATA(command, validateDisplay, expectedPresentTime,
+                                           ValidateDisplay);
+    DISPATCH_DISPLAY_BOOL_COMMAND(command, acceptDisplayChanges, AcceptDisplayChanges);
+    DISPATCH_DISPLAY_BOOL_COMMAND(command, presentDisplay, PresentDisplay);
+    DISPATCH_DISPLAY_BOOL_COMMAND_AND_DATA(command, presentOrValidateDisplay, expectedPresentTime,
+                                           PresentOrValidateDisplay);
+}
+
+void ComposerCommandEngine::dispatchLayerCommand(int64_t display, const LayerCommand& command) {
+    DISPATCH_LAYER_COMMAND(display, command, cursorPosition, CursorPosition);
+    DISPATCH_LAYER_COMMAND(display, command, buffer, Buffer);
+    DISPATCH_LAYER_COMMAND(display, command, damage, SurfaceDamage);
+    DISPATCH_LAYER_COMMAND(display, command, blendMode, BlendMode);
+    DISPATCH_LAYER_COMMAND(display, command, color, Color);
+    DISPATCH_LAYER_COMMAND(display, command, composition, Composition);
+    DISPATCH_LAYER_COMMAND(display, command, dataspace, Dataspace);
+    DISPATCH_LAYER_COMMAND(display, command, displayFrame, DisplayFrame);
+    DISPATCH_LAYER_COMMAND(display, command, planeAlpha, PlaneAlpha);
+    DISPATCH_LAYER_COMMAND(display, command, sidebandStream, SidebandStream);
+    DISPATCH_LAYER_COMMAND(display, command, sourceCrop, SourceCrop);
+    DISPATCH_LAYER_COMMAND(display, command, transform, Transform);
+    DISPATCH_LAYER_COMMAND(display, command, visibleRegion, VisibleRegion);
+    DISPATCH_LAYER_COMMAND(display, command, z, ZOrder);
+    DISPATCH_LAYER_COMMAND(display, command, colorTransform, ColorTransform);
+    DISPATCH_LAYER_COMMAND(display, command, brightness, Brightness);
+    DISPATCH_LAYER_COMMAND(display, command, perFrameMetadata, PerFrameMetadata);
+    DISPATCH_LAYER_COMMAND(display, command, perFrameMetadataBlob, PerFrameMetadataBlobs);
+    DISPATCH_LAYER_COMMAND_SIMPLE(display, command, blockingRegion, BlockingRegion);
+}
+
+int32_t ComposerCommandEngine::executeValidateDisplayInternal(int64_t display) {
+    std::vector<int64_t> changedLayers;
+    std::vector<Composition> compositionTypes;
+    uint32_t displayRequestMask = 0x0;
+    std::vector<int64_t> requestedLayers;
+    std::vector<int32_t> requestMasks;
+    ClientTargetProperty clientTargetProperty{common::PixelFormat::RGBA_8888,
+                                              common::Dataspace::UNKNOWN};
+    DimmingStage dimmingStage;
+    auto err =
+            mHal->validateDisplay(display, &changedLayers, &compositionTypes, &displayRequestMask,
+                                  &requestedLayers, &requestMasks, &clientTargetProperty,
+                                  &dimmingStage);
+    mResources->setDisplayMustValidateState(display, false);
+    if (!err) {
+        mWriter->setChangedCompositionTypes(display, changedLayers, compositionTypes);
+        mWriter->setDisplayRequests(display, displayRequestMask, requestedLayers, requestMasks);
+        static constexpr float kBrightness = 1.f;
+        mWriter->setClientTargetProperty(display, clientTargetProperty, kBrightness, dimmingStage);
+    } else {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+    return err;
+}
+
+void ComposerCommandEngine::executeSetColorTransform(int64_t display,
+                                                     const std::vector<float>& matrix) {
+    auto err = mHal->setColorTransform(display, matrix);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetClientTarget(int64_t display, const ClientTarget& command) {
+    bool useCache = !command.buffer.handle;
+    buffer_handle_t handle = useCache
+                             ? nullptr
+                             : ::android::makeFromAidl(*command.buffer.handle);
+    buffer_handle_t clientTarget;
+    auto bufferReleaser = mResources->createReleaser(true);
+    auto err = mResources->getDisplayClientTarget(display, command.buffer.slot, useCache, handle,
+                                                  clientTarget, bufferReleaser.get());
+    if (!err) {
+        err = mHal->setClientTarget(display, clientTarget, command.buffer.fence,
+                                    command.dataspace, command.damage);
+        if (err) {
+            LOG(ERROR) << __func__ << " setClientTarget: err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    } else {
+        LOG(ERROR) << __func__ << " getDisplayClientTarget : err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetOutputBuffer(uint64_t display, const Buffer& buffer) {
+    bool useCache = !buffer.handle;
+    buffer_handle_t handle = useCache
+                             ? nullptr
+                             : ::android::makeFromAidl(*buffer.handle);
+    buffer_handle_t outputBuffer;
+    auto bufferReleaser = mResources->createReleaser(true);
+    auto err = mResources->getDisplayOutputBuffer(display, buffer.slot, useCache, handle,
+                                                  outputBuffer, bufferReleaser.get());
+    if (!err) {
+        err = mHal->setOutputBuffer(display, outputBuffer, buffer.fence);
+        if (err) {
+            LOG(ERROR) << __func__ << " setOutputBuffer: err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    } else {
+        LOG(ERROR) << __func__ << " getDisplayOutputBuffer: err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetExpectedPresentTimeInternal(
+        int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+    mHal->setExpectedPresentTime(display, expectedPresentTime);
+}
+
+void ComposerCommandEngine::executeValidateDisplay(
+        int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+    executeSetExpectedPresentTimeInternal(display, expectedPresentTime);
+    executeValidateDisplayInternal(display);
+}
+
+void ComposerCommandEngine::executeSetDisplayBrightness(uint64_t display,
+                                        const DisplayBrightness& command) {
+    auto err = mHal->setDisplayBrightness(display, command.brightness);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executePresentOrValidateDisplay(
+        int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+    executeSetExpectedPresentTimeInternal(display, expectedPresentTime);
+
+    int err;
+    // First try to Present as is.
+    if (mHal->hasCapability(Capability::SKIP_VALIDATE)) {
+        err = executePresentDisplay(display);
+        if (!err) {
+            mWriter->setPresentOrValidateResult(display, PresentOrValidate::Result::Presented);
+            return;
+        }
+    }
+
+    // Fallback to validate
+    err = executeValidateDisplayInternal(display);
+    if (!err) {
+        mWriter->setPresentOrValidateResult(display, PresentOrValidate::Result::Validated);
+    }
+}
+
+void ComposerCommandEngine::executeAcceptDisplayChanges(int64_t display) {
+    auto err = mHal->acceptDisplayChanges(display);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+int ComposerCommandEngine::executePresentDisplay(int64_t display) {
+    ndk::ScopedFileDescriptor presentFence;
+    std::vector<int64_t> layers;
+    std::vector<ndk::ScopedFileDescriptor> fences;
+    auto err = mResources->mustValidateDisplay(display)
+            ? IComposerClient::EX_NOT_VALIDATED
+            : mHal->presentDisplay(display, presentFence, &layers, &fences);
+    if (!err) {
+        mWriter->setPresentFence(display, std::move(presentFence));
+        mWriter->setReleaseFences(display, layers, std::move(fences));
+    }
+
+    return err;
+}
+
+void ComposerCommandEngine::executeSetLayerCursorPosition(int64_t display, int64_t layer,
+                                       const common::Point& cursorPosition) {
+    auto err = mHal->setLayerCursorPosition(display, layer, cursorPosition.x, cursorPosition.y);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerBuffer(int64_t display, int64_t layer,
+                                                  const Buffer& buffer) {
+    bool useCache = !buffer.handle;
+    buffer_handle_t handle = useCache
+                             ? nullptr
+                             : ::android::makeFromAidl(*buffer.handle);
+    buffer_handle_t hwcBuffer;
+    auto bufferReleaser = mResources->createReleaser(true);
+    auto err = mResources->getLayerBuffer(display, layer, buffer.slot, useCache,
+                                          handle, hwcBuffer, bufferReleaser.get());
+    if (!err) {
+        err = mHal->setLayerBuffer(display, layer, hwcBuffer, buffer.fence);
+        if (err) {
+            LOG(ERROR) << __func__ << ": setLayerBuffer err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    } else {
+        LOG(ERROR) << __func__ << ": getLayerBuffer err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerSurfaceDamage(int64_t display, int64_t layer,
+                              const std::vector<std::optional<common::Rect>>& damage) {
+    auto err = mHal->setLayerSurfaceDamage(display, layer, damage);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerBlendMode(int64_t display, int64_t layer,
+                                                     const ParcelableBlendMode& blendMode) {
+    auto err = mHal->setLayerBlendMode(display, layer, blendMode.blendMode);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerColor(int64_t display, int64_t layer,
+                                                 const Color& color) {
+    auto err = mHal->setLayerColor(display, layer, color);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerComposition(int64_t display, int64_t layer,
+                                                       const ParcelableComposition& composition) {
+    auto err = mHal->setLayerCompositionType(display, layer, composition.composition);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerDataspace(int64_t display, int64_t layer,
+                                                     const ParcelableDataspace& dataspace) {
+    auto err = mHal->setLayerDataspace(display, layer, dataspace.dataspace);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerDisplayFrame(int64_t display, int64_t layer,
+                                                        const common::Rect& rect) {
+    auto err = mHal->setLayerDisplayFrame(display, layer, rect);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerPlaneAlpha(int64_t display, int64_t layer,
+                                                      const PlaneAlpha& planeAlpha) {
+    auto err = mHal->setLayerPlaneAlpha(display, layer, planeAlpha.alpha);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerSidebandStream(int64_t display, int64_t layer,
+                                                 const AidlNativeHandle& sidebandStream) {
+    buffer_handle_t handle = ::android::makeFromAidl(sidebandStream);
+    buffer_handle_t stream;
+
+    auto bufferReleaser = mResources->createReleaser(false);
+    auto err = mResources->getLayerSidebandStream(display, layer, handle,
+                                                  stream, bufferReleaser.get());
+    if (err) {
+        err = mHal->setLayerSidebandStream(display, layer, stream);
+    }
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerSourceCrop(int64_t display, int64_t layer,
+                                                      const common::FRect& sourceCrop) {
+    auto err = mHal->setLayerSourceCrop(display, layer, sourceCrop);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerTransform(int64_t display, int64_t layer,
+                                                     const ParcelableTransform& transform) {
+    auto err = mHal->setLayerTransform(display, layer, transform.transform);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerVisibleRegion(int64_t display, int64_t layer,
+                          const std::vector<std::optional<common::Rect>>& visibleRegion) {
+    auto err = mHal->setLayerVisibleRegion(display, layer, visibleRegion);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerZOrder(int64_t display, int64_t layer,
+                                                  const ZOrder& zOrder) {
+    auto err = mHal->setLayerZOrder(display, layer, zOrder.z);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerPerFrameMetadata(int64_t display, int64_t layer,
+                const std::vector<std::optional<PerFrameMetadata>>& perFrameMetadata) {
+    auto err = mHal->setLayerPerFrameMetadata(display, layer, perFrameMetadata);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerColorTransform(int64_t display, int64_t layer,
+                                                       const std::vector<float>& matrix) {
+    auto err = mHal->setLayerColorTransform(display, layer, matrix);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerBrightness(int64_t display, int64_t layer,
+                                                      const LayerBrightness& brightness) {
+    auto err = mHal->setLayerBrightness(display, layer, brightness.brightness);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+void ComposerCommandEngine::executeSetLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                      const std::vector<std::optional<PerFrameMetadataBlob>>& metadata) {
+    auto err = mHal->setLayerPerFrameMetadataBlobs(display, layer, metadata);
+    if (err) {
+        LOG(ERROR) << __func__ << ": err " << err;
+        mWriter->setError(mCommandIndex, err);
+    }
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/ComposerCommandEngine.h b/graphics/composer/aidl/default/ComposerCommandEngine.h
new file mode 100644
index 0000000000..ae68285709
--- /dev/null
+++ b/graphics/composer/aidl/default/ComposerCommandEngine.h
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android/hardware/graphics/composer3/ComposerServiceWriter.h>
+#include <utils/Mutex.h>
+
+#include <memory>
+
+#include "include/IComposerHal.h"
+#include "include/IResourceManager.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class ComposerCommandEngine {
+  public:
+      ComposerCommandEngine(IComposerHal* hal, IResourceManager* resources)
+            : mHal(hal), mResources(resources) {}
+      bool init();
+
+      int32_t execute(const std::vector<DisplayCommand>& commands,
+                      std::vector<CommandResultPayload>* result);
+
+      template <typename InputType, typename Functor>
+      void dispatchLayerCommand(int64_t display, int64_t layer, const std::string& funcName,
+                                const InputType input, const Functor func);
+
+      void reset() {
+          mWriter->reset();
+      }
+
+  private:
+      void dispatchDisplayCommand(const DisplayCommand& displayCommand);
+      void dispatchLayerCommand(int64_t display, const LayerCommand& displayCommand);
+
+      void executeSetColorTransform(int64_t display, const std::vector<float>& matrix);
+      void executeSetClientTarget(int64_t display, const ClientTarget& command);
+      void executeSetDisplayBrightness(uint64_t display, const DisplayBrightness& command);
+      void executeSetOutputBuffer(uint64_t display, const Buffer& buffer);
+      void executeValidateDisplay(int64_t display,
+                                  const std::optional<ClockMonotonicTimestamp> expectedPresentTime);
+      void executePresentOrValidateDisplay(
+              int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime);
+      void executeAcceptDisplayChanges(int64_t display);
+      int executePresentDisplay(int64_t display);
+
+      void executeSetLayerCursorPosition(int64_t display, int64_t layer,
+                                         const common::Point& cursorPosition);
+      void executeSetLayerBuffer(int64_t display, int64_t layer, const Buffer& buffer);
+      void executeSetLayerSurfaceDamage(int64_t display, int64_t layer,
+                                        const std::vector<std::optional<common::Rect>>& damage);
+      void executeSetLayerBlendMode(int64_t display, int64_t layer,
+                                    const ParcelableBlendMode& blendMode);
+      void executeSetLayerColor(int64_t display, int64_t layer, const Color& color);
+      void executeSetLayerComposition(int64_t display, int64_t layer,
+                                      const ParcelableComposition& composition);
+      void executeSetLayerDataspace(int64_t display, int64_t layer,
+                                    const ParcelableDataspace& dataspace);
+      void executeSetLayerDisplayFrame(int64_t display, int64_t layer, const common::Rect& rect);
+      void executeSetLayerPlaneAlpha(int64_t display, int64_t layer, const PlaneAlpha& planeAlpha);
+      void executeSetLayerSidebandStream(int64_t display, int64_t layer,
+                                         const AidlNativeHandle& sidebandStream);
+      void executeSetLayerSourceCrop(int64_t display, int64_t layer,
+                                     const common::FRect& sourceCrop);
+      void executeSetLayerTransform(int64_t display, int64_t layer,
+                                    const ParcelableTransform& transform);
+      void executeSetLayerVisibleRegion(
+              int64_t display, int64_t layer,
+              const std::vector<std::optional<common::Rect>>& visibleRegion);
+      void executeSetLayerZOrder(int64_t display, int64_t layer, const ZOrder& zOrder);
+      void executeSetLayerPerFrameMetadata(
+              int64_t display, int64_t layer,
+              const std::vector<std::optional<PerFrameMetadata>>& perFrameMetadata);
+      void executeSetLayerColorTransform(int64_t display, int64_t layer,
+                                         const std::vector<float>& colorTransform);
+      void executeSetLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+              const std::vector<std::optional<PerFrameMetadataBlob>>& perFrameMetadataBlob);
+      void executeSetLayerBrightness(int64_t display, int64_t layer,
+                                     const LayerBrightness& brightness);
+
+      int32_t executeValidateDisplayInternal(int64_t display);
+      void executeSetExpectedPresentTimeInternal(
+              int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime);
+
+      IComposerHal* mHal;
+      IResourceManager* mResources;
+      std::unique_ptr<ComposerServiceWriter> mWriter;
+      int32_t mCommandIndex;
+};
+
+template <typename InputType, typename Functor>
+void ComposerCommandEngine::dispatchLayerCommand(int64_t display, int64_t layer,
+                                                 const std::string& funcName, const InputType input,
+                                                 const Functor func) {
+    if (input) {
+        auto err = (mHal->*func)(display, layer, *input);
+        if (err) {
+            LOG(ERROR) << funcName << ": err " << err;
+            mWriter->setError(mCommandIndex, err);
+        }
+    }
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
+
diff --git a/graphics/composer/aidl/default/NOTICE b/graphics/composer/aidl/default/NOTICE
new file mode 100644
index 0000000000..316b4eb5a9
--- /dev/null
+++ b/graphics/composer/aidl/default/NOTICE
@@ -0,0 +1,190 @@
+
+   Copyright (c) 2014, The Android Open Source Project
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
diff --git a/graphics/composer/aidl/default/Util.h b/graphics/composer/aidl/default/Util.h
new file mode 100644
index 0000000000..53057879f8
--- /dev/null
+++ b/graphics/composer/aidl/default/Util.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android-base/logging.h>
+#include <string_view>
+#include <utils/Trace.h>
+
+// #define LOG_FUNC
+#define TRACE_FUNC
+
+#ifdef TRACE_FUNC
+#define DEBUG_FUNC() constexpr static FullMethodName __kFullNameObj__ =                     \
+                                           FullMethodName{ __PRETTY_FUNCTION__ };           \
+                     constexpr static const char *__kFullName__ =  __kFullNameObj__.get();  \
+                     ATRACE_NAME(__kFullName__)
+#else
+
+#ifdef LOG_FUNC
+#define DEBUG_FUNC() DebugFunction _dbgFnObj_(__func__)
+#else
+#define DEBUG_FUNC()
+#endif
+
+#endif
+
+#define RET_IF_ERR(expr)                  \
+    do {                                  \
+        auto err = (expr);                \
+        if (err) [[unlikely]] return err; \
+    } while (0)
+
+
+#define TO_BINDER_STATUS(x) x == 0                                                \
+                            ? ndk::ScopedAStatus::ok()                            \
+                            : ndk::ScopedAStatus::fromServiceSpecificError(x)
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+class DebugFunction {
+public:
+    DebugFunction(const char* name) : mName(name) { LOG(INFO) << mName << " Enter"; }
+
+    ~DebugFunction() { LOG(INFO) << mName << " Exit"; }
+
+private:
+    const char* mName;
+};
+
+class FullMethodName {
+public:
+    constexpr FullMethodName(const std::string_view prettyName) : mBuf() {
+        // remove every thing before 'impl::'
+        auto start = prettyName.find("impl::");
+        if (start == prettyName.npos) {
+            start = 0;
+        }
+        // remove everything after '('
+        auto end = prettyName.rfind('(');
+        if (end == prettyName.npos) {
+            end = prettyName.length();
+        }
+
+        auto len = std::min(end - start, mBuf.size());
+        // to a null-terminated string
+        // prettyName.copy(mBuf.data(), len, start) is available in c++20
+        for (int i = 0; i < len; ++i) {
+            mBuf[i] = prettyName[start + i];
+        }
+    }
+
+    constexpr const char *get() const {
+        return mBuf.data();
+    }
+
+private:
+    std::array<char, 256> mBuf;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.rc b/graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.rc
new file mode 100644
index 0000000000..5819e7d0c8
--- /dev/null
+++ b/graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.rc
@@ -0,0 +1,7 @@
+service vendor.hwcomposer-3 /vendor/bin/hw/android.hardware.graphics.composer3-service.intel
+    class hal animation
+    user system
+    group graphics drmrpc
+    capabilities SYS_NICE
+    onrestart restart surfaceflinger
+    task_profiles ServiceCapacityLow
diff --git a/graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.xml b/graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.xml
new file mode 100644
index 0000000000..861b4b7f40
--- /dev/null
+++ b/graphics/composer/aidl/default/android.hardware.graphics.composer3-service.intel.xml
@@ -0,0 +1,10 @@
+<manifest version="1.0" type="device">
+    <hal format="aidl">
+        <name>android.hardware.graphics.composer3</name>
+        <version>2</version>
+        <interface>
+            <name>IComposer</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+</manifest>
\ No newline at end of file
diff --git a/graphics/composer/aidl/default/impl/HalImpl.cpp b/graphics/composer/aidl/default/impl/HalImpl.cpp
new file mode 100644
index 0000000000..d387ee2531
--- /dev/null
+++ b/graphics/composer/aidl/default/impl/HalImpl.cpp
@@ -0,0 +1,1199 @@
+/*
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "HalImpl.h"
+
+#include <aidl/android/hardware/graphics/composer3/IComposerCallback.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerClient.h>
+#include <android-base/logging.h>
+#include "TranslateHwcAidl.h"
+#include "Util.h"
+#include "HwcLoader.h"
+#include <cmath>
+
+using namespace aidl::android::hardware::graphics::composer3::passthrough;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+std::unique_ptr<IComposerHal> IComposerHal::create() {
+    hwc2_device_t* device = HwcLoader::load();
+    if (!device) {
+        ALOGE("HwcLoader::load() failed");
+        return nullptr;
+    }
+    return std::make_unique<HalImpl>(device);
+}
+
+namespace hook {
+
+void hotplug(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay,
+                        int32_t connected) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onHotplug(display, connected == HWC2_CONNECTION_CONNECTED);
+}
+
+void refresh(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onRefresh(display);
+}
+
+void vsync(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay,
+                           int64_t timestamp, hwc2_vsync_period_t hwcVsyncPeriodNanos) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+    int32_t vsyncPeriodNanos;
+
+    h2a::translate(hwcDisplay, display);
+    h2a::translate(hwcVsyncPeriodNanos, vsyncPeriodNanos);
+    hal->getEventCallback()->onVsync(display, timestamp, vsyncPeriodNanos);
+}
+
+void vsyncPeriodTimingChanged(hwc2_callback_data_t callbackData,
+                                         hwc2_display_t hwcDisplay,
+                                         hwc_vsync_period_change_timeline_t* hwcTimeline) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+    VsyncPeriodChangeTimeline timeline;
+
+    h2a::translate(hwcDisplay, display);
+    h2a::translate(*hwcTimeline, timeline);
+    hal->getEventCallback()->onVsyncPeriodTimingChanged(display, timeline);
+}
+
+void vsyncIdle(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onVsyncIdle(display);
+}
+
+void seamlessPossible(hwc2_callback_data_t callbackData, hwc2_display_t hwcDisplay) {
+    auto hal = static_cast<HalImpl*>(callbackData);
+    int64_t display;
+
+    h2a::translate(hwcDisplay, display);
+    hal->getEventCallback()->onSeamlessPossible(display);
+}
+
+} // nampesapce hook
+
+HalImpl::HalImpl(hwc2_device_t* device) : mDevice(device) {
+    initCaps();
+    if (hasCapability(aidl::android::hardware::graphics::composer3::Capability::PRESENT_FENCE_IS_NOT_RELIABLE)) {
+        ALOGE("present fence must be reliable");
+        mDevice->common.close(&mDevice->common);
+        mDevice = nullptr;
+    }
+
+    if (!initDispatch()) {
+        ALOGE("initDispatch failed!");
+        mDevice->common.close(&mDevice->common);
+        mDevice = nullptr;
+    }
+}
+
+HalImpl::~HalImpl(){
+    if (mDevice) {
+        mDevice->common.close(&mDevice->common);
+        mDevice = nullptr;
+    }
+}
+
+void HalImpl::initCaps() {
+    uint32_t count = 0;
+    mDevice->getCapabilities(mDevice, &count, nullptr);
+
+    std::vector<int32_t> halCaps(count);
+    mDevice->getCapabilities(mDevice, &count, halCaps.data());
+
+    for (auto hwcCap : halCaps) {
+        Capability cap;
+        h2a::translate(hwcCap, cap);
+        mCaps.insert(cap);
+    }
+
+    mCaps.insert(Capability::BOOT_DISPLAY_CONFIG);
+}
+
+template <typename T>
+bool HalImpl::initDispatch(hwc2_function_descriptor_t desc, T* outPfn) {
+    auto pfn = mDevice->getFunction(mDevice, desc);
+    if (pfn) {
+        *outPfn = reinterpret_cast<T>(pfn);
+        return true;
+    } else {
+        ALOGE("failed to get hwcomposer2 function %d", desc);
+        return false;
+    }
+}
+
+template <typename T>
+bool HalImpl::initOptionalDispatch(hwc2_function_descriptor_t desc, T* outPfn) {
+    auto pfn = mDevice->getFunction(mDevice, desc);
+    if (pfn) {
+        *outPfn = reinterpret_cast<T>(pfn);
+        return true;
+    } else {
+        return false;
+    }
+}
+
+bool HalImpl::initDispatch() {
+    if (
+        !initDispatch(HWC2_FUNCTION_ACCEPT_DISPLAY_CHANGES, &mDispatch.acceptDisplayChanges) ||
+        !initDispatch(HWC2_FUNCTION_CREATE_LAYER, &mDispatch.createLayer) ||
+        !initDispatch(HWC2_FUNCTION_CREATE_VIRTUAL_DISPLAY, &mDispatch.createVirtualDisplay) ||
+        !initDispatch(HWC2_FUNCTION_DESTROY_LAYER, &mDispatch.destroyLayer) ||
+        !initDispatch(HWC2_FUNCTION_DESTROY_VIRTUAL_DISPLAY, &mDispatch.destroyVirtualDisplay) ||
+        !initDispatch(HWC2_FUNCTION_DUMP, &mDispatch.dump) ||
+        !initDispatch(HWC2_FUNCTION_GET_ACTIVE_CONFIG, &mDispatch.getActiveConfig) ||
+        !initDispatch(HWC2_FUNCTION_GET_CHANGED_COMPOSITION_TYPES, &mDispatch.getChangedCompositionTypes) ||
+        !initDispatch(HWC2_FUNCTION_GET_CLIENT_TARGET_SUPPORT, &mDispatch.getClientTargetSupport) ||
+        !initDispatch(HWC2_FUNCTION_GET_COLOR_MODES, &mDispatch.getColorModes) ||
+        !initDispatch(HWC2_FUNCTION_GET_DISPLAY_ATTRIBUTE, &mDispatch.getDisplayAttribute) ||
+        !initDispatch(HWC2_FUNCTION_GET_DISPLAY_CONFIGS, &mDispatch.getDisplayConfigs) ||
+        !initDispatch(HWC2_FUNCTION_GET_DISPLAY_NAME, &mDispatch.getDisplayName) ||
+        !initDispatch(HWC2_FUNCTION_GET_DISPLAY_REQUESTS, &mDispatch.getDisplayRequests) ||
+        !initDispatch(HWC2_FUNCTION_GET_DISPLAY_TYPE, &mDispatch.getDisplayType) ||
+        !initDispatch(HWC2_FUNCTION_GET_DOZE_SUPPORT, &mDispatch.getDozeSupport) ||
+        !initDispatch(HWC2_FUNCTION_GET_HDR_CAPABILITIES, &mDispatch.getHdrCapabilities) ||
+        !initDispatch(HWC2_FUNCTION_GET_MAX_VIRTUAL_DISPLAY_COUNT, &mDispatch.getMaxVirtualDisplayCount) ||
+        !initDispatch(HWC2_FUNCTION_GET_RELEASE_FENCES, &mDispatch.getReleaseFences) ||
+        !initDispatch(HWC2_FUNCTION_PRESENT_DISPLAY, &mDispatch.presentDisplay) ||
+        !initDispatch(HWC2_FUNCTION_REGISTER_CALLBACK, &mDispatch.registerCallback) ||
+        !initDispatch(HWC2_FUNCTION_SET_ACTIVE_CONFIG, &mDispatch.setActiveConfig) ||
+        !initDispatch(HWC2_FUNCTION_SET_CLIENT_TARGET, &mDispatch.setClientTarget) ||
+        !initDispatch(HWC2_FUNCTION_SET_COLOR_MODE, &mDispatch.setColorMode) ||
+        !initDispatch(HWC2_FUNCTION_SET_COLOR_TRANSFORM, &mDispatch.setColorTransform) ||
+        !initDispatch(HWC2_FUNCTION_SET_CURSOR_POSITION, &mDispatch.setCursorPosition) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_BLEND_MODE, &mDispatch.setLayerBlendMode) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_BUFFER, &mDispatch.setLayerBuffer) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_COLOR, &mDispatch.setLayerColor) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_COMPOSITION_TYPE, &mDispatch.setLayerCompositionType) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_DATASPACE, &mDispatch.setLayerDataspace) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_DISPLAY_FRAME, &mDispatch.setLayerDisplayFrame) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_PLANE_ALPHA, &mDispatch.setLayerPlaneAlpha)
+        ) {
+        return false;
+    }
+
+    if (hasCapability(aidl::android::hardware::graphics::composer3::Capability::SIDEBAND_STREAM)) {
+        if (!initDispatch(HWC2_FUNCTION_SET_LAYER_SIDEBAND_STREAM,
+                          &mDispatch.setLayerSidebandStream)) {
+            return false;
+        }
+    }
+
+    if (!initDispatch(HWC2_FUNCTION_SET_LAYER_SOURCE_CROP, &mDispatch.setLayerSourceCrop) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_SURFACE_DAMAGE, &mDispatch.setLayerSurfaceDamage) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_TRANSFORM, &mDispatch.setLayerTransform) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_VISIBLE_REGION, &mDispatch.setLayerVisibleRegion) ||
+        !initDispatch(HWC2_FUNCTION_SET_LAYER_Z_ORDER, &mDispatch.setLayerZOrder) ||
+        !initDispatch(HWC2_FUNCTION_SET_OUTPUT_BUFFER, &mDispatch.setOutputBuffer) ||
+        !initDispatch(HWC2_FUNCTION_SET_POWER_MODE, &mDispatch.setPowerMode) ||
+        !initDispatch(HWC2_FUNCTION_SET_VSYNC_ENABLED, &mDispatch.setVsyncEnabled) ||
+        !initDispatch(HWC2_FUNCTION_VALIDATE_DISPLAY, &mDispatch.validateDisplay)
+        ) {
+        return false;
+    }
+    //  2.2
+    initOptionalDispatch(HWC2_FUNCTION_SET_LAYER_FLOAT_COLOR, &mDispatch.setLayerFloatColor);
+    initOptionalDispatch(HWC2_FUNCTION_SET_LAYER_PER_FRAME_METADATA,&mDispatch.setLayerPerFrameMetadata) ;
+    initOptionalDispatch(HWC2_FUNCTION_GET_PER_FRAME_METADATA_KEYS, &mDispatch.getPerFrameMetadataKeys) ;
+    initOptionalDispatch(HWC2_FUNCTION_SET_READBACK_BUFFER, &mDispatch.setReadbackBuffer);
+    initOptionalDispatch(HWC2_FUNCTION_GET_READBACK_BUFFER_ATTRIBUTES,&mDispatch.getReadbackBufferAttributes) ;
+    initOptionalDispatch(HWC2_FUNCTION_GET_READBACK_BUFFER_FENCE,&mDispatch.getReadbackBufferFence);
+    initOptionalDispatch(HWC2_FUNCTION_GET_RENDER_INTENTS, &mDispatch.getRenderIntents);
+    initOptionalDispatch(HWC2_FUNCTION_SET_COLOR_MODE_WITH_RENDER_INTENT, &mDispatch.setColorModeWithRenderIntent);
+    initOptionalDispatch(HWC2_FUNCTION_GET_DATASPACE_SATURATION_MATRIX, &mDispatch.getDataspaceSaturationMatrix);
+   
+    //  2.3
+    if(!initDispatch(HWC2_FUNCTION_GET_DISPLAY_CAPABILITIES, &mDispatch.getDisplayCapabilities)||
+       !initDispatch(HWC2_FUNCTION_SET_DISPLAY_BRIGHTNESS, &mDispatch.setDisplayBrightness)){
+        return false;
+    }
+
+    initOptionalDispatch(HWC2_FUNCTION_GET_DISPLAY_IDENTIFICATION_DATA,&mDispatch.getDisplayIdentificationData);
+    initOptionalDispatch(HWC2_FUNCTION_SET_LAYER_COLOR_TRANSFORM, &mDispatch.setLayerColorTransform);
+    initOptionalDispatch(HWC2_FUNCTION_GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES,&mDispatch.getDisplayedContentSamplingAttributes);
+    initOptionalDispatch(HWC2_FUNCTION_SET_DISPLAYED_CONTENT_SAMPLING_ENABLED,&mDispatch.setDisplayedContentSamplingEnabled);
+    initOptionalDispatch(HWC2_FUNCTION_GET_DISPLAYED_CONTENT_SAMPLE, &mDispatch.getDisplayedContentSample);
+    initOptionalDispatch(HWC2_FUNCTION_SET_LAYER_PER_FRAME_METADATA_BLOBS, &mDispatch.setLayerPerFrameMetadataBlobs);
+    initOptionalDispatch(HWC2_FUNCTION_GET_DISPLAY_BRIGHTNESS_SUPPORT, &mDispatch.getDisplayBrightnessSupport);
+    //  2.4
+    if(!initDispatch(HWC2_FUNCTION_GET_DISPLAY_VSYNC_PERIOD, &mDispatch.getDisplayVsyncPeriod) ||
+       !initDispatch(HWC2_FUNCTION_SET_ACTIVE_CONFIG_WITH_CONSTRAINTS, &mDispatch.setActiveConfigWithConstraints)){
+        return false;
+    }
+ 
+    initOptionalDispatch(HWC2_FUNCTION_GET_DISPLAY_CONNECTION_TYPE, &mDispatch.getDisplayConnectionType);
+    initOptionalDispatch(HWC2_FUNCTION_SET_AUTO_LOW_LATENCY_MODE, &mDispatch.setAutoLowLatencyMode);
+    initOptionalDispatch(HWC2_FUNCTION_GET_SUPPORTED_CONTENT_TYPES, &mDispatch.getSupportedContentTypes);
+    initOptionalDispatch(HWC2_FUNCTION_SET_CONTENT_TYPE, &mDispatch.setContentType);
+    initOptionalDispatch(HWC2_FUNCTION_GET_CLIENT_TARGET_PROPERTY, &mDispatch.getClientTargetProperty) ;
+    initOptionalDispatch(HWC2_FUNCTION_SET_LAYER_GENERIC_METADATA, &mDispatch.setLayerGenericMetadata);
+    initOptionalDispatch(HWC2_FUNCTION_GET_LAYER_GENERIC_METADATA_KEY, &mDispatch.getLayerGenericMetadataKey);
+ 
+
+    return true;
+}
+
+bool HalImpl::hasCapability(Capability cap) {
+    return mCaps.find(cap) != mCaps.end();
+}
+
+void HalImpl::getCapabilities(std::vector<Capability>* caps) {
+    caps->clear();
+    caps->insert(caps->begin(), mCaps.begin(), mCaps.end());
+}
+
+void HalImpl::dumpDebugInfo(std::string* output) {
+    if (output == nullptr) return;
+    if (!mDispatch.dump) return;
+
+    uint32_t len = 0;
+    mDispatch.dump(mDevice, &len, nullptr);
+    if (len > 0) {
+        // mDispatch.dump(..) api is expecting char *.
+        // So reserve memory before passing address as an argument.
+        output->reserve(len);
+        mDispatch.dump(mDevice, &len, output->data());
+    }
+}
+
+void HalImpl::registerEventCallback(EventCallback* callback) {
+    mEventCallback = callback;
+
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_HOTPLUG, this,
+                               reinterpret_cast<hwc2_function_pointer_t>(hook::hotplug));
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_REFRESH, this,
+                               reinterpret_cast<hwc2_function_pointer_t>(hook::refresh));
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_VSYNC_2_4, this,
+                               reinterpret_cast<hwc2_function_pointer_t>(hook::vsync));
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_VSYNC_PERIOD_TIMING_CHANGED, this,
+                               reinterpret_cast<hwc2_function_pointer_t>(hook::vsyncPeriodTimingChanged));
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_SEAMLESS_POSSIBLE, this,
+                               reinterpret_cast<hwc2_function_pointer_t>(hook::seamlessPossible));
+    // ToDo register HWC3 Callback TRANSACTION_onVsyncIdle
+}
+
+void HalImpl::unregisterEventCallback() {
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_HOTPLUG, this, nullptr);
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_REFRESH, this, nullptr);
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_VSYNC_2_4, this, nullptr);
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_VSYNC_PERIOD_TIMING_CHANGED, this, nullptr);
+    mDispatch.registerCallback(mDevice, HWC2_CALLBACK_SEAMLESS_POSSIBLE, this, nullptr);
+    // ToDo unregister HWC3 Callback TRANSACTION_onVsyncIdle
+    mEventCallback = nullptr;
+}
+
+int32_t HalImpl::acceptDisplayChanges(int64_t display) {
+    if (!mDispatch.acceptDisplayChanges) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    return mDispatch.acceptDisplayChanges(mDevice, display);
+}
+
+int32_t HalImpl::createLayer(int64_t display, int64_t* outLayer) {
+    if (!mDispatch.createLayer) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc2_layer_t hwcLayer = 0;
+    RET_IF_ERR(mDispatch.createLayer(mDevice, display,&hwcLayer));
+
+    h2a::translate(hwcLayer, *outLayer);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::destroyLayer(int64_t display, int64_t layer) {
+    if (!mDispatch.destroyLayer) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    RET_IF_ERR(mDispatch.destroyLayer(mDevice, display, layer));
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::createVirtualDisplay(uint32_t width, uint32_t height, AidlPixelFormat format,
+                                      VirtualDisplay* outDisplay) {
+    if (!mDispatch.createVirtualDisplay) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    int32_t hwcFormat;
+    a2h::translate(format, hwcFormat);
+    RET_IF_ERR(mDispatch.createVirtualDisplay(mDevice, width, height, &hwcFormat,(uint64_t*)&(outDisplay->display)));
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::destroyVirtualDisplay(int64_t display) {
+    if (!mDispatch.destroyVirtualDisplay) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    return mDispatch.destroyVirtualDisplay(mDevice, display);
+}
+
+int32_t HalImpl::getActiveConfig(int64_t display, int32_t* outConfig) {
+    if (!mDispatch.getActiveConfig) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc2_config_t hwcConfig;
+    RET_IF_ERR(mDispatch.getActiveConfig(mDevice, display,&hwcConfig));
+
+    h2a::translate(hwcConfig, *outConfig);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getColorModes(int64_t display, std::vector<ColorMode>* outModes) {
+    if (!mDispatch.getColorModes) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getColorModes(mDevice, display,&count, nullptr));
+
+    std::vector<int32_t> hwcModes(count);
+    RET_IF_ERR(mDispatch.getColorModes(mDevice, display,&count, hwcModes.data()));
+
+    h2a::translate(hwcModes, *outModes);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDataspaceSaturationMatrix([[maybe_unused]] common::Dataspace dataspace,
+                                              std::vector<float>* matrix) {
+    // if (!mDispatch.getDataspaceSaturationMatrix) {
+    //     return HWC2_ERROR_UNSUPPORTED;
+    // }
+    // auto error = mDispatch.getDataspaceSaturationMatrix(mDevice, static_cast<int32_t>(dataspace),matrix->data());
+    if(dataspace == common::Dataspace::UNKNOWN)
+       return HWC2_ERROR_BAD_PARAMETER;
+
+    auto error = HWC2_ERROR_UNSUPPORTED;
+    if (error != HWC2_ERROR_NONE) {
+        std::vector<float> unitMatrix = {
+                1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
+                0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
+        };
+
+        *matrix = std::move(unitMatrix);
+    }
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayAttribute(int64_t display, int32_t config,
+                                     DisplayAttribute attribute, int32_t* outValue) {
+    if (!mDispatch.getDisplayAttribute) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc2_config_t hwcConfig;
+    int32_t hwcAttr;
+    a2h::translate(config, hwcConfig);
+    a2h::translate(attribute, hwcAttr);
+
+    auto err = mDispatch.getDisplayAttribute(mDevice, display, hwcConfig, hwcAttr, outValue);
+    if (err != HWC2_ERROR_NONE && *outValue == -1) {
+        return HWC2_ERROR_BAD_PARAMETER;
+    }
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayBrightnessSupport(int64_t display, bool& outSupport) {
+    if (!mDispatch.getDisplayBrightnessSupport) {
+        outSupport = false;
+        std::vector<DisplayCapability> capabilities;
+
+        auto error = getDisplayCapabilities(display, &capabilities);
+        if (error != HWC2_ERROR_NONE) 
+            return HWC2_ERROR_UNSUPPORTED;
+        
+        outSupport =std::find(capabilities.begin(), capabilities.end(),
+                          DisplayCapability::BRIGHTNESS) != capabilities.end();
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    RET_IF_ERR(mDispatch.getDisplayBrightnessSupport(mDevice, display, &outSupport));
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayCapabilities(int64_t display,
+                                        std::vector<DisplayCapability>* caps) {
+    if (!mDispatch.getDisplayCapabilities) {
+        ALOGE(" unsupported getDisplayCapabilities ");
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getDisplayCapabilities(mDevice, display, &count, nullptr));
+
+    std::vector<uint32_t> hwcCaps(count);
+    RET_IF_ERR(mDispatch.getDisplayCapabilities(mDevice, display, &count, hwcCaps.data()));
+
+    h2a::translate(hwcCaps, *caps);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) {
+    if (!mDispatch.getDisplayConfigs) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getDisplayConfigs(mDevice, display, &count, nullptr));
+
+    std::vector<hwc2_config_t> hwcConfigs(count);
+    RET_IF_ERR(mDispatch.getDisplayConfigs(mDevice, display, &count, hwcConfigs.data()));
+
+    h2a::translate(hwcConfigs, *configs);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayConnectionType(int64_t display, DisplayConnectionType* outType) {
+    if (!mDispatch.getDisplayConnectionType) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t hwcType = HWC2_DISPLAY_CONNECTION_TYPE_INTERNAL;
+    RET_IF_ERR(mDispatch.getDisplayConnectionType(mDevice,display,&hwcType));
+    h2a::translate(hwcType, *outType);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayIdentificationData(int64_t display, DisplayIdentification *id) {
+    if (!mDispatch.getDisplayIdentificationData) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint8_t port;
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getDisplayIdentificationData(mDevice, display,&port, &count, nullptr));
+
+    id->data.resize(count);
+    RET_IF_ERR(mDispatch.getDisplayIdentificationData(mDevice, display,&port, &count, id->data.data()));
+
+    h2a::translate(port, id->port);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayName(int64_t display, std::string* outName) {
+    if (!mDispatch.getDisplayName) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getDisplayName(mDevice, display,&count, nullptr));
+
+    outName->resize(count);
+    RET_IF_ERR(mDispatch.getDisplayName(mDevice, display,&count, outName->data()));
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayVsyncPeriod(int64_t display, int32_t* outVsyncPeriod) {
+    if (!mDispatch.getDisplayVsyncPeriod) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc2_vsync_period_t hwcVsyncPeriod;
+    RET_IF_ERR(mDispatch.getDisplayVsyncPeriod(mDevice, display, &hwcVsyncPeriod));
+
+    h2a::translate(hwcVsyncPeriod, *outVsyncPeriod);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayedContentSample([[maybe_unused]] int64_t display,
+                                           [[maybe_unused]] int64_t maxFrames,
+                                           [[maybe_unused]] int64_t timestamp,
+                                           [[maybe_unused]] DisplayContentSample* samples) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+
+int32_t HalImpl::getDisplayedContentSamplingAttributes(
+        [[maybe_unused]] int64_t display,
+        [[maybe_unused]] DisplayContentSamplingAttributes* attrs) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::getDisplayPhysicalOrientation([[maybe_unused]] int64_t display,
+                                               [[maybe_unused]] common::Transform* orientation) {
+    if(static_cast<int>(display) == -1)
+        return HWC2_ERROR_BAD_DISPLAY;
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDozeSupport(int64_t display, bool& support) {
+    if (!mDispatch.getDozeSupport) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcSupport;
+    RET_IF_ERR(mDispatch.getDozeSupport(mDevice, display, &hwcSupport));
+
+    h2a::translate(hwcSupport, support);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getHdrCapabilities(int64_t display, HdrCapabilities* caps) {
+    if (!mDispatch.getHdrCapabilities) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getHdrCapabilities(mDevice, display,&count, nullptr, &caps->maxLuminance,
+                                              &caps->maxAverageLuminance,
+                                              &caps->minLuminance));
+    std::vector<int32_t> hwcHdrTypes(count);
+    RET_IF_ERR(mDispatch.getHdrCapabilities(mDevice, display,&count, hwcHdrTypes.data(),
+                                              &caps->maxLuminance,
+                                              &caps->maxAverageLuminance,
+                                              &caps->minLuminance));
+
+    h2a::translate(hwcHdrTypes, caps->types);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getMaxVirtualDisplayCount(int32_t* count) {
+    if (!mDispatch.getMaxVirtualDisplayCount) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    uint32_t hwcCount = mDispatch.getMaxVirtualDisplayCount(mDevice);
+    h2a::translate(hwcCount, *count);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getPerFrameMetadataKeys(int64_t display,
+                                         std::vector<PerFrameMetadataKey>* keys) {
+    if (!mDispatch.getPerFrameMetadataKeys) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getPerFrameMetadataKeys(mDevice, display, &count, nullptr));
+
+    std::vector<PerFrameMetadataKey> outkeys(count);
+    RET_IF_ERR(mDispatch.getPerFrameMetadataKeys(mDevice, display, &count,
+            reinterpret_cast<std::underlying_type<PerFrameMetadataKey>::type*>(
+                outkeys.data())));
+    outkeys.resize(count);
+    *keys = std::move(outkeys);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getReadbackBufferAttributes(int64_t display,
+                                             ReadbackBufferAttributes* attrs) {
+    if (!mDispatch.getReadbackBufferAttributes) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t format = -1;
+    int32_t dataspace = -1;
+    RET_IF_ERR(mDispatch.getReadbackBufferAttributes(mDevice, display, &format, &dataspace));
+
+    h2a::translate(format, attrs->format);
+    h2a::translate(dataspace, attrs->dataspace);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getReadbackBufferFence(int64_t display,
+                                        ndk::ScopedFileDescriptor* acquireFence) {
+    if (!mDispatch.getReadbackBufferFence) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t fd = -1;
+    RET_IF_ERR(mDispatch.getReadbackBufferFence(mDevice, display, &fd));
+
+    h2a::translate(fd, *acquireFence);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getRenderIntents(int64_t display, ColorMode mode,
+                                  std::vector<RenderIntent>* intents) {
+    if (!mDispatch.getRenderIntents) {
+       
+        int32_t hwc_type = HWC2_DISPLAY_TYPE_INVALID;
+        if (mDispatch.getDisplayType(mDevice, display, &hwc_type) == HWC2_ERROR_BAD_DISPLAY) {
+            return HWC2_ERROR_BAD_DISPLAY;
+        }
+        if (mode < ColorMode::NATIVE || mode > ColorMode::DISPLAY_P3) {
+            return HWC2_ERROR_BAD_PARAMETER;
+        }
+
+        *intents = std::vector<RenderIntent>({RenderIntent::COLORIMETRIC});
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcMode;
+    uint32_t count = 0;
+    a2h::translate(mode, hwcMode);
+    RET_IF_ERR(mDispatch.getRenderIntents(mDevice, display, hwcMode, &count, nullptr));
+
+    std::vector<int32_t> hwcIntents(count);
+    RET_IF_ERR(mDispatch.getRenderIntents(mDevice, display,hwcMode, &count, hwcIntents.data()));
+    RET_IF_ERR(mDispatch.getRenderIntents(mDevice, display, hwcMode, &count,hwcIntents.data()));
+
+    h2a::translate(hwcIntents, *intents);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getSupportedContentTypes(int64_t display, std::vector<ContentType>* types) {
+    if (!mDispatch.getSupportedContentTypes) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getSupportedContentTypes(mDevice, display, &count, nullptr));
+
+    std::vector<uint32_t> hwcTypes(count);
+    RET_IF_ERR(mDispatch.getSupportedContentTypes(mDevice, display, &count, hwcTypes.data()));
+
+    h2a::translate(hwcTypes, *types);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::flushDisplayBrightnessChange([[maybe_unused]] int64_t display) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::presentDisplay(int64_t display, ndk::ScopedFileDescriptor& fence,
+                       std::vector<int64_t>* outLayers,
+                       std::vector<ndk::ScopedFileDescriptor>* outReleaseFences) {
+    if (!mDispatch.presentDisplay) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcFence;
+    RET_IF_ERR(mDispatch.presentDisplay(mDevice, display, &hwcFence));
+    h2a::translate(hwcFence, fence);
+
+    uint32_t count = 0;
+    RET_IF_ERR(mDispatch.getReleaseFences(mDevice, display, &count, nullptr, nullptr));
+
+    std::vector<hwc2_layer_t> hwcLayers(count);
+    std::vector<int32_t> hwcFences(count);
+    RET_IF_ERR(mDispatch.getReleaseFences(mDevice, display, &count, hwcLayers.data(),hwcFences.data()));
+
+    h2a::translate(hwcLayers, *outLayers);
+    h2a::translate(hwcFences, *outReleaseFences);
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::setActiveConfig(int64_t display, int32_t config) {
+    if (!mDispatch.setActiveConfig) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    return mDispatch.setActiveConfig(mDevice, display, config);
+}
+
+int32_t HalImpl::setActiveConfigWithConstraints(
+            int64_t display, int32_t config,
+            const VsyncPeriodChangeConstraints& vsyncPeriodChangeConstraints,
+            VsyncPeriodChangeTimeline* timeline) {
+
+    if (!mDispatch.setActiveConfigWithConstraints) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc2_config_t hwcConfig;
+    hwc_vsync_period_change_constraints_t hwcConstraints;
+
+    a2h::translate(config, hwcConfig);
+    a2h::translate(vsyncPeriodChangeConstraints, hwcConstraints);
+
+    hwc_vsync_period_change_timeline_t hwcTimeline;
+    RET_IF_ERR(mDispatch.setActiveConfigWithConstraints(
+                mDevice, display, hwcConfig, &hwcConstraints, &hwcTimeline));
+
+    h2a::translate(hwcTimeline, *timeline);
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::setBootDisplayConfig([[maybe_unused]] int64_t display, 
+                                      [[maybe_unused]] int32_t config) {
+    if(static_cast<int>(display) == -1)
+        return HWC2_ERROR_BAD_DISPLAY;
+    if(config == IComposerClient::INVALID_CONFIGURATION)
+        return HWC2_ERROR_BAD_CONFIG;
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::clearBootDisplayConfig([[maybe_unused]] int64_t display) {
+    if(static_cast<int>(display) == -1)
+        return HWC2_ERROR_BAD_DISPLAY;
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getPreferredBootDisplayConfig([[maybe_unused]] int64_t display,
+                                               [[maybe_unused]] int32_t* config) {
+    if(static_cast<int>(display) == -1)
+        return HWC2_ERROR_BAD_DISPLAY;
+    std::vector<int32_t> configs;
+    getDisplayConfigs(display, &configs);
+    if(!configs.empty())
+        *config = configs[0];
+    else
+        *config = 1;
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::setAutoLowLatencyMode(int64_t display, bool on) {
+    if (!mDispatch.setAutoLowLatencyMode) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    return mDispatch.setAutoLowLatencyMode(mDevice, display, on);
+}
+
+int32_t HalImpl::setClientTarget(int64_t display, buffer_handle_t target,
+                                 const ndk::ScopedFileDescriptor& fence,
+                                 common::Dataspace dataspace,
+                                 const std::vector<common::Rect>& damage) {
+    if (!mDispatch.setClientTarget) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcFence;
+    int32_t hwcDataspace;
+    std::vector<hwc_rect_t> hwcDamage;
+
+    a2h::translate(fence, hwcFence);
+    a2h::translate(dataspace, hwcDataspace);
+    a2h::translate(damage, hwcDamage);
+    hwc_region_t region = { hwcDamage.size(), hwcDamage.data() };
+    return mDispatch.setClientTarget(mDevice, display, target, hwcFence, hwcDataspace, region);
+}
+
+int32_t HalImpl::setColorMode(int64_t display, ColorMode mode, RenderIntent intent) {
+    int32_t hwcMode;
+    a2h::translate(mode, hwcMode);
+    if (!mDispatch.setColorModeWithRenderIntent ) {
+        if (intent < RenderIntent::COLORIMETRIC || intent > RenderIntent::TONE_MAP_ENHANCE) {
+            return HWC2_ERROR_BAD_PARAMETER;
+        }
+        if (intent != RenderIntent::COLORIMETRIC) {
+            return HWC2_ERROR_UNSUPPORTED;
+        }
+
+        if (!mDispatch.setColorMode) {
+            return HWC2_ERROR_UNSUPPORTED;
+        }
+
+        return mDispatch.setColorMode(mDevice,display,hwcMode);
+    }
+    int32_t hwcIntent;
+    a2h::translate(intent, hwcIntent);
+    return mDispatch.setColorModeWithRenderIntent(mDevice, display, hwcMode, hwcIntent);
+}
+
+int32_t HalImpl::setColorTransform(int64_t display, const std::vector<float>& matrix) {
+
+    if (!mDispatch.setColorTransform) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    const bool isIdentity = (std::equal(matrix.begin(), matrix.end(), mkIdentity.begin()));
+    const common::ColorTransform hint = isIdentity ? common::ColorTransform::IDENTITY
+                                                   : common::ColorTransform::ARBITRARY_MATRIX;
+    int32_t hwcHint;
+    a2h::translate(hint, hwcHint);
+    return mDispatch.setColorTransform(mDevice, display, matrix.data(), hwcHint);
+}
+
+int32_t HalImpl::setContentType(int64_t display, ContentType contentType) {
+
+    if (!mDispatch.setContentType) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t type;
+    a2h::translate(contentType, type);
+    return mDispatch.setContentType(mDevice, display, type);
+}
+
+int32_t HalImpl::setDisplayBrightness(int64_t display, float brightness) {
+    if (std::isnan(brightness) || brightness > 1.0f ||
+         (brightness < 0.0f && brightness != -1.0f)) {
+        return HWC2_ERROR_BAD_PARAMETER;
+    }
+
+    if (!mDispatch.setDisplayBrightness) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    return mDispatch.setDisplayBrightness(mDevice, display, brightness);
+}
+
+int32_t HalImpl::setDisplayedContentSamplingEnabled(int64_t display, bool enable,
+                                                    FormatColorComponent componentMask,int64_t maxFrames) {
+
+    if (!mDispatch.setDisplayedContentSamplingEnabled) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    return mDispatch.setDisplayedContentSamplingEnabled(
+            mDevice, display, static_cast<int32_t>(enable), static_cast<uint8_t>(componentMask), maxFrames);
+}
+
+int32_t HalImpl::setLayerBlendMode(int64_t display, int64_t layer, common::BlendMode mode) {
+
+    if (!mDispatch.setLayerBlendMode) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcMode;
+    a2h::translate(mode, hwcMode);
+    return mDispatch.setLayerBlendMode(mDevice, display, layer, hwcMode);
+}
+
+int32_t HalImpl::setLayerBuffer(int64_t display, int64_t layer, buffer_handle_t buffer,
+                                const ndk::ScopedFileDescriptor& acquireFence) {
+    if (!mDispatch.setLayerBuffer) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    int32_t hwcFd;
+    a2h::translate(acquireFence, hwcFd);
+    return mDispatch.setLayerBuffer(mDevice, display, layer, buffer, hwcFd);
+}
+
+int32_t HalImpl::setLayerColor(int64_t display, int64_t layer, Color color) {
+
+    if (!mDispatch.setLayerColor) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc_color_t hwcColor;
+    a2h::translate(color, hwcColor);
+    return mDispatch.setLayerColor(mDevice, display, layer, hwcColor);
+}
+
+int32_t HalImpl::setLayerColorTransform(int64_t display, int64_t layer,
+                                        const std::vector<float>& matrix) {
+    if (!mDispatch.setLayerColorTransform) {
+        const bool isIdentity = (std::equal(matrix.begin(), matrix.end(), mkIdentity.begin()));
+        if (isIdentity) {
+            mClientCompositionLayers[display].erase(layer);
+            return HWC2_ERROR_UNSUPPORTED;
+        }
+
+        mClientCompositionLayers[display].insert(layer);
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    return mDispatch.setLayerColorTransform(mDevice, display, layer, matrix.data());
+}
+
+int32_t HalImpl::setLayerCompositionType(int64_t display, int64_t layer, Composition type) {
+
+    if (!mDispatch.setLayerCompositionType) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcType;
+    a2h::translate(type, hwcType);
+    return mDispatch.setLayerCompositionType(mDevice, display, layer, hwcType);
+}
+
+int32_t HalImpl::setLayerCursorPosition(int64_t display, int64_t layer, int32_t x, int32_t y) {
+    if (!mDispatch.setCursorPosition) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    return mDispatch.setCursorPosition(mDevice, display, layer, x, y);
+}
+
+int32_t HalImpl::setLayerDataspace(int64_t display, int64_t layer, common::Dataspace dataspace) {
+    if (!mDispatch.setLayerDataspace) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcDataspace;
+    a2h::translate(dataspace, hwcDataspace);
+    return mDispatch.setLayerDataspace(mDevice, display, layer, hwcDataspace);
+}
+
+int32_t HalImpl::setLayerDisplayFrame(int64_t display, int64_t layer, const common::Rect& frame) {
+    if (!mDispatch.setLayerDisplayFrame) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc_rect_t hwcFrame;
+    a2h::translate(frame, hwcFrame);
+    return mDispatch.setLayerDisplayFrame(mDevice, display, layer, hwcFrame);
+}
+
+int32_t HalImpl::setLayerPerFrameMetadata(int64_t display, int64_t layer,
+                                          const std::vector<std::optional<PerFrameMetadata>>& metadata) {
+    if (!mDispatch.setLayerPerFrameMetadata) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    std::vector<int32_t> keys;
+    std::vector<float> values;
+
+    for (const auto& m : metadata) {
+        if (m) {
+            int32_t key;
+            a2h::translate(m->key, key);
+            keys.push_back(key);
+            values.push_back(m->value);
+        }
+    }
+
+    return mDispatch.setLayerPerFrameMetadata(mDevice, display, layer, metadata.size(), keys.data(),
+                                              values.data());
+}
+
+int32_t HalImpl::setLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                           const std::vector<std::optional<PerFrameMetadataBlob>>& blobs) {
+    if (!mDispatch.setLayerPerFrameMetadataBlobs) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    std::vector<int32_t> keys;
+    std::vector<uint32_t> sizes;
+    std::vector<uint8_t> values;
+    for(auto b: blobs){
+        if(b){
+            int32_t key;
+            a2h::translate(b->key, key);
+            keys.push_back(key);
+            sizes.push_back(b->blob.size());
+            values.insert(values.end(), b->blob.begin(), b->blob.end());
+        }
+    }
+
+    return mDispatch.setLayerPerFrameMetadataBlobs(
+            mDevice, display, layer, static_cast<uint32_t>(blobs.size()),
+           keys.data(), reinterpret_cast<uint32_t*>(sizes.data()),
+            values.data());
+}
+
+int32_t HalImpl::setLayerPlaneAlpha(int64_t display, int64_t layer, float alpha) {
+    if (!mDispatch.setLayerPlaneAlpha) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    return mDispatch.setLayerPlaneAlpha(mDevice, display, layer, alpha);
+}
+
+int32_t HalImpl::setLayerSidebandStream([[maybe_unused]] int64_t display,
+                                        [[maybe_unused]] int64_t layer,
+                                        [[maybe_unused]] buffer_handle_t stream) {
+
+    if (!mDispatch.setLayerSidebandStream) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+    return mDispatch.setLayerSidebandStream(mDevice, display, layer, stream);
+}
+
+int32_t HalImpl::setLayerSourceCrop(int64_t display, int64_t layer, const common::FRect& crop) {
+    if (!mDispatch.setLayerSourceCrop) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc_frect_t hwcCrop;
+    a2h::translate(crop, hwcCrop);
+    return mDispatch.setLayerSourceCrop(mDevice, display, layer, hwcCrop);
+}
+
+int32_t HalImpl::setLayerSurfaceDamage(int64_t display, int64_t layer,
+                                  const std::vector<std::optional<common::Rect>>& damage) {
+    if (!mDispatch.setLayerSurfaceDamage) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    std::vector<hwc_rect_t> hwcDamage;
+    a2h::translate(damage, hwcDamage);
+    hwc_region_t region = { hwcDamage.size(), hwcDamage.data() };
+    return mDispatch.setLayerSurfaceDamage(mDevice, display, layer, region);
+}
+
+int32_t HalImpl::setLayerTransform(int64_t display, int64_t layer, common::Transform transform) {
+    if (!mDispatch.setLayerTransform) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcTransform;
+    a2h::translate(transform, hwcTransform);
+    return mDispatch.setLayerTransform(mDevice, display, layer, hwcTransform);
+}
+
+int32_t HalImpl::setLayerVisibleRegion(int64_t display, int64_t layer,
+                               const std::vector<std::optional<common::Rect>>& visible) {
+    if (!mDispatch.setLayerVisibleRegion) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    std::vector<hwc_rect_t> hwcVisible;
+    a2h::translate(visible, hwcVisible);
+    hwc_region_t region = { hwcVisible.size(), hwcVisible.data() };
+    return mDispatch.setLayerVisibleRegion(mDevice, display, layer, region);
+}
+
+int32_t HalImpl::setLayerBrightness([[maybe_unused]] int64_t display, 
+                                    [[maybe_unused]] int64_t layer, 
+                                    [[maybe_unused]] float brightness) {
+    if (std::isnan(brightness) || brightness > 1.0f || brightness < 0.0f ) {
+        return HWC2_ERROR_BAD_PARAMETER;
+    }
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::setLayerZOrder(int64_t display, int64_t layer, uint32_t z) {
+    if (!mDispatch.setLayerZOrder) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    return mDispatch.setLayerZOrder(mDevice, display, layer, z);
+}
+
+int32_t HalImpl::setOutputBuffer(int64_t display, buffer_handle_t buffer,
+                                 const ndk::ScopedFileDescriptor& releaseFence) {
+    if (!mDispatch.setOutputBuffer) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcFence;
+    a2h::translate(releaseFence, hwcFence);
+
+    auto err = mDispatch.setOutputBuffer(mDevice, display, buffer, hwcFence);;
+    if (err == HWC2_ERROR_NONE && hwcFence >= 0) {
+        close(hwcFence);
+    }
+    return err;
+}
+
+int32_t HalImpl::setPowerMode(int64_t display, PowerMode mode) {
+    if (mode == PowerMode::ON_SUSPEND || mode == PowerMode::DOZE_SUSPEND) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    if (!mDispatch.setPowerMode) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcMode;
+    a2h::translate(mode, hwcMode);
+    return mDispatch.setPowerMode(mDevice, display, hwcMode);
+}
+
+int32_t HalImpl::setReadbackBuffer(int64_t display, buffer_handle_t buffer,
+                                   const ndk::ScopedFileDescriptor& releaseFence) {
+    if (!mDispatch.setReadbackBuffer) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    int32_t hwcFence;
+    a2h::translate(releaseFence, hwcFence);
+
+    return mDispatch.setReadbackBuffer(mDevice, display, buffer, hwcFence);
+}
+
+int32_t HalImpl::setVsyncEnabled(int64_t display, bool enabled) {
+    if (!mDispatch.setVsyncEnabled) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    hwc2_vsync_t hwcEnable;
+    a2h::translate(enabled, hwcEnable);
+    return mDispatch.setVsyncEnabled(mDevice, display, static_cast<int32_t>(hwcEnable));
+}
+
+int32_t HalImpl::setIdleTimerEnabled([[maybe_unused]] int64_t display, 
+                                     [[maybe_unused]] int32_t timeout) {
+    return HWC2_ERROR_UNSUPPORTED;
+}
+
+int32_t HalImpl::validateDisplay(int64_t display, std::vector<int64_t>* outChangedLayers,
+                                 std::vector<Composition>* outCompositionTypes,
+                                 uint32_t* outDisplayRequestMask,
+                                 std::vector<int64_t>* outRequestedLayers,
+                                 std::vector<int32_t>* outRequestMasks,
+                                 ClientTargetProperty* outClientTargetProperty,
+                                 [[maybe_unused]] DimmingStage* outDimmingStage) {
+    if (!mDispatch.validateDisplay) {
+        return HWC2_ERROR_UNSUPPORTED;
+    }
+
+    uint32_t typesCount = 0;
+    uint32_t reqsCount = 0;
+    auto err = mDispatch.validateDisplay(mDevice, display, &typesCount, &reqsCount);
+
+    if (err != HWC2_ERROR_NONE && err != HWC2_ERROR_HAS_CHANGES) {
+        return err;
+    }
+    RET_IF_ERR( mDispatch.getChangedCompositionTypes(mDevice, display, &typesCount, nullptr, nullptr));
+    std::vector<hwc2_layer_t> hwcChangedLayers(typesCount);
+    std::vector<int32_t> hwcCompositionTypes(typesCount);
+    RET_IF_ERR( mDispatch.getChangedCompositionTypes(mDevice, display, &typesCount, hwcChangedLayers.data(),
+                                                      hwcCompositionTypes.data()));
+
+    int32_t displayReqs;
+    RET_IF_ERR(mDispatch.getDisplayRequests(mDevice, display, &displayReqs, &reqsCount, nullptr,nullptr));
+
+    std::vector<hwc2_layer_t> hwcRequestedLayers(reqsCount);
+    outRequestMasks->resize(reqsCount);
+    RET_IF_ERR(mDispatch.getDisplayRequests(mDevice, display, &displayReqs, &reqsCount,
+                                              hwcRequestedLayers.data(), outRequestMasks->data()));
+
+    h2a::translate(hwcChangedLayers, *outChangedLayers);
+    h2a::translate(hwcCompositionTypes, *outCompositionTypes);
+    *outDisplayRequestMask = displayReqs;
+    h2a::translate(hwcRequestedLayers, *outRequestedLayers);
+
+    if (mDispatch.getClientTargetProperty)
+    {
+        hwc_client_target_property hwcProperty;
+        [[maybe_unused]]auto err = mDispatch.getClientTargetProperty(mDevice,display,&hwcProperty);
+        h2a::translate(hwcProperty, *outClientTargetProperty); 
+    }
+
+    return HWC2_ERROR_NONE;
+}
+
+int HalImpl::setExpectedPresentTime([[maybe_unused]] int64_t display, 
+                                    [[maybe_unused]] const std::optional<ClockMonotonicTimestamp> expectedPresentTime) {
+
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getRCDLayerSupport([[maybe_unused]] int64_t display, 
+                                    [[maybe_unused]]bool& outSupport) {
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::setLayerBlockingRegion([[maybe_unused]] int64_t display, 
+                                        [[maybe_unused]] int64_t layer,
+                                        [[maybe_unused]] const std::vector<std::optional<common::Rect>>& blockingRegion) {
+    return HWC2_ERROR_NONE;
+}
+
+int32_t HalImpl::getDisplayIdleTimerSupport([[maybe_unused]] int64_t display, 
+                                            [[maybe_unused]] bool& outSupport) {
+    return HWC2_ERROR_NONE;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/impl/HalImpl.h b/graphics/composer/aidl/default/impl/HalImpl.h
new file mode 100644
index 0000000000..d6876b15e6
--- /dev/null
+++ b/graphics/composer/aidl/default/impl/HalImpl.h
@@ -0,0 +1,264 @@
+/*
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <unordered_set>
+#include <map>
+
+#include "include/IComposerHal.h"
+#define HWC2_INCLUDE_STRINGIFICATION
+#define HWC2_USE_CPP11
+#include <hardware/hwcomposer2.h>
+#undef HWC2_INCLUDE_STRINGIFICATION
+#undef HWC2_USE_CPP11
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// Forward aidl call to HWC
+class HalImpl : public IComposerHal {
+  public:
+    HalImpl(hwc2_device_t* device);
+    virtual ~HalImpl();
+
+    void getCapabilities(std::vector<Capability>* caps) override;
+    void dumpDebugInfo(std::string* output) override;
+    bool hasCapability(Capability cap) override;
+
+    void registerEventCallback(EventCallback* callback) override;
+    void unregisterEventCallback() override;
+
+    int32_t acceptDisplayChanges(int64_t display) override;
+    int32_t createLayer(int64_t display, int64_t* outLayer) override;
+    int32_t createVirtualDisplay(uint32_t width, uint32_t height, AidlPixelFormat format,
+                                 VirtualDisplay* outDisplay) override;
+    int32_t destroyLayer(int64_t display, int64_t layer) override;
+    int32_t destroyVirtualDisplay(int64_t display) override;
+    int32_t flushDisplayBrightnessChange(int64_t display) override;
+    int32_t getActiveConfig(int64_t display, int32_t* outConfig) override;
+    int32_t getColorModes(int64_t display, std::vector<ColorMode>* outModes) override;
+
+    int32_t getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                         std::vector<float>* matrix) override;
+    int32_t getDisplayAttribute(int64_t display, int32_t config, DisplayAttribute attribute,
+                                int32_t* outValue) override;
+    int32_t getDisplayBrightnessSupport(int64_t display, bool& outSupport) override;
+    int32_t getDisplayCapabilities(int64_t display, std::vector<DisplayCapability>* caps) override;
+    int32_t getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) override;
+    int32_t getDisplayConnectionType(int64_t display, DisplayConnectionType* outType) override;
+    int32_t getDisplayIdentificationData(int64_t display, DisplayIdentification* id) override;
+    int32_t getDisplayName(int64_t display, std::string* outName) override;
+    int32_t getDisplayVsyncPeriod(int64_t display, int32_t* outVsyncPeriod) override;
+    int32_t getDisplayedContentSample(int64_t display, int64_t maxFrames, int64_t timestamp,
+                                      DisplayContentSample* samples) override;
+    int32_t getDisplayedContentSamplingAttributes(int64_t display,
+                                                  DisplayContentSamplingAttributes* attrs) override;
+    int32_t getDisplayPhysicalOrientation(int64_t display, common::Transform* orientation) override;
+    int32_t getDozeSupport(int64_t display, bool& outSupport) override;
+    int32_t getHdrCapabilities(int64_t display, HdrCapabilities* caps) override;
+    int32_t getMaxVirtualDisplayCount(int32_t* count) override;
+    int32_t getPerFrameMetadataKeys(int64_t display,
+                                    std::vector<PerFrameMetadataKey>* keys) override;
+
+    int32_t getReadbackBufferAttributes(int64_t display, ReadbackBufferAttributes* attrs) override;
+    int32_t getReadbackBufferFence(int64_t display,
+                                   ndk::ScopedFileDescriptor* acquireFence) override;
+    int32_t getRenderIntents(int64_t display, ColorMode mode,
+                             std::vector<RenderIntent>* intents) override;
+    int32_t getSupportedContentTypes(int64_t display, std::vector<ContentType>* types) override;
+    int32_t presentDisplay(int64_t display, ndk::ScopedFileDescriptor& fence,
+                           std::vector<int64_t>* outLayers,
+                           std::vector<ndk::ScopedFileDescriptor>* outReleaseFences) override;
+    int32_t setActiveConfig(int64_t display, int32_t config) override;
+    int32_t setActiveConfigWithConstraints(
+            int64_t display, int32_t config,
+            const VsyncPeriodChangeConstraints& vsyncPeriodChangeConstraints,
+            VsyncPeriodChangeTimeline* timeline) override;
+    int32_t setBootDisplayConfig(int64_t display, int32_t config) override;
+    int32_t clearBootDisplayConfig(int64_t display) override;
+    int32_t getPreferredBootDisplayConfig(int64_t display, int32_t* config) override;
+    int32_t setAutoLowLatencyMode(int64_t display, bool on) override;
+    int32_t setClientTarget(int64_t display, buffer_handle_t target,
+                            const ndk::ScopedFileDescriptor& fence, common::Dataspace dataspace,
+                            const std::vector<common::Rect>& damage) override;
+    int32_t setColorMode(int64_t display, ColorMode mode, RenderIntent intent) override;
+    int32_t setColorTransform(int64_t display, const std::vector<float>& matrix) override;
+    int32_t setContentType(int64_t display, ContentType contentType) override;
+    int32_t setDisplayBrightness(int64_t display, float brightness) override;
+    int32_t setDisplayedContentSamplingEnabled(int64_t display, bool enable,
+                                               FormatColorComponent componentMask,
+                                               int64_t maxFrames) override;
+    int32_t setLayerBlendMode(int64_t display, int64_t layer, common::BlendMode mode) override;
+    int32_t setLayerBuffer(int64_t display, int64_t layer, buffer_handle_t buffer,
+                           const ndk::ScopedFileDescriptor& acquireFence) override;
+    int32_t setLayerColor(int64_t display, int64_t layer, Color color) override;
+    int32_t setLayerColorTransform(int64_t display, int64_t layer,
+                                   const std::vector<float>& matrix) override;
+    int32_t setLayerCompositionType(int64_t display, int64_t layer, Composition type) override;
+    int32_t setLayerCursorPosition(int64_t display, int64_t layer, int32_t x, int32_t y) override;
+    int32_t setLayerDataspace(int64_t display, int64_t layer, common::Dataspace dataspace) override;
+    int32_t setLayerDisplayFrame(int64_t display, int64_t layer,
+                                 const common::Rect& frame) override;
+    int32_t setLayerPerFrameMetadata(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadata>>& metadata) override;
+    int32_t setLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadataBlob>>& blobs) override;
+    int32_t setLayerPlaneAlpha(int64_t display, int64_t layer, float alpha) override;
+    int32_t setLayerSidebandStream(int64_t display, int64_t layer,
+                                   buffer_handle_t stream) override;
+    int32_t setLayerSourceCrop(int64_t display, int64_t layer, const common::FRect& crop) override;
+    int32_t setLayerSurfaceDamage(int64_t display, int64_t layer,
+                                  const std::vector<std::optional<common::Rect>>& damage) override;
+    int32_t setLayerTransform(int64_t display, int64_t layer, common::Transform transform) override;
+    int32_t setLayerVisibleRegion(int64_t display, int64_t layer,
+                          const std::vector<std::optional<common::Rect>>& visible) override;
+    int32_t setLayerBrightness(int64_t display, int64_t layer, float brightness) override;
+    int32_t setLayerZOrder(int64_t display, int64_t layer, uint32_t z) override;
+    int32_t setOutputBuffer(int64_t display, buffer_handle_t buffer,
+                            const ndk::ScopedFileDescriptor& releaseFence) override;
+    int32_t setPowerMode(int64_t display, PowerMode mode) override;
+    int32_t setReadbackBuffer(int64_t display, buffer_handle_t buffer,
+                              const ndk::ScopedFileDescriptor& releaseFence) override;
+    int32_t setVsyncEnabled(int64_t display, bool enabled) override;
+    int32_t getDisplayIdleTimerSupport(int64_t display, bool& outSupport) override;
+    int32_t setIdleTimerEnabled(int64_t display, int32_t timeout) override;
+    int32_t getRCDLayerSupport(int64_t display, bool& outSupport) override;
+    int32_t setLayerBlockingRegion(
+            int64_t display, int64_t layer,
+            const std::vector<std::optional<common::Rect>>& blockingRegion) override;
+    int32_t validateDisplay(int64_t display, std::vector<int64_t>* outChangedLayers,
+                            std::vector<Composition>* outCompositionTypes,
+                            uint32_t* outDisplayRequestMask,
+                            std::vector<int64_t>* outRequestedLayers,
+                            std::vector<int32_t>* outRequestMasks,
+                            ClientTargetProperty* outClientTargetProperty,
+                            DimmingStage* outDimmingStage) override;
+    int32_t setExpectedPresentTime(
+            int64_t display,
+            const std::optional<ClockMonotonicTimestamp> expectedPresentTime) override;
+
+    EventCallback* getEventCallback() { return mEventCallback; }
+
+private:
+    template <typename T>
+    bool initOptionalDispatch(hwc2_function_descriptor_t desc, T* outPfn); 
+
+    template <typename T>
+    bool initDispatch(hwc2_function_descriptor_t desc, T* outPfn);
+
+    bool initDispatch();
+    void initCaps();
+
+    struct {
+        HWC2_PFN_ACCEPT_DISPLAY_CHANGES acceptDisplayChanges;
+        HWC2_PFN_CREATE_LAYER createLayer;
+        HWC2_PFN_CREATE_VIRTUAL_DISPLAY createVirtualDisplay;
+        HWC2_PFN_DESTROY_LAYER destroyLayer;
+        HWC2_PFN_DESTROY_VIRTUAL_DISPLAY destroyVirtualDisplay;
+        HWC2_PFN_DUMP dump;
+        HWC2_PFN_GET_ACTIVE_CONFIG getActiveConfig;
+        HWC2_PFN_GET_CHANGED_COMPOSITION_TYPES getChangedCompositionTypes;
+        HWC2_PFN_GET_CLIENT_TARGET_SUPPORT getClientTargetSupport;
+        HWC2_PFN_GET_COLOR_MODES getColorModes;
+        HWC2_PFN_GET_DISPLAY_ATTRIBUTE getDisplayAttribute;
+        HWC2_PFN_GET_DISPLAY_CONFIGS getDisplayConfigs;
+        HWC2_PFN_GET_DISPLAY_NAME getDisplayName;
+        HWC2_PFN_GET_DISPLAY_REQUESTS getDisplayRequests;
+        HWC2_PFN_GET_DISPLAY_TYPE getDisplayType;
+        HWC2_PFN_GET_DOZE_SUPPORT getDozeSupport;
+        HWC2_PFN_GET_HDR_CAPABILITIES getHdrCapabilities;
+        HWC2_PFN_GET_MAX_VIRTUAL_DISPLAY_COUNT getMaxVirtualDisplayCount;
+        HWC2_PFN_GET_RELEASE_FENCES getReleaseFences;
+        HWC2_PFN_PRESENT_DISPLAY presentDisplay;
+        HWC2_PFN_REGISTER_CALLBACK registerCallback;
+        HWC2_PFN_SET_ACTIVE_CONFIG setActiveConfig;
+        HWC2_PFN_SET_CLIENT_TARGET setClientTarget;
+        HWC2_PFN_SET_COLOR_MODE setColorMode;
+        HWC2_PFN_SET_COLOR_TRANSFORM setColorTransform;
+        HWC2_PFN_SET_CURSOR_POSITION setCursorPosition;
+        HWC2_PFN_SET_LAYER_BLEND_MODE setLayerBlendMode;
+        HWC2_PFN_SET_LAYER_BUFFER setLayerBuffer;
+        HWC2_PFN_SET_LAYER_COLOR setLayerColor;
+        HWC2_PFN_SET_LAYER_COMPOSITION_TYPE setLayerCompositionType;
+        HWC2_PFN_SET_LAYER_DATASPACE setLayerDataspace;
+        HWC2_PFN_SET_LAYER_DISPLAY_FRAME setLayerDisplayFrame;
+        HWC2_PFN_SET_LAYER_PLANE_ALPHA setLayerPlaneAlpha;
+        HWC2_PFN_SET_LAYER_SIDEBAND_STREAM setLayerSidebandStream;
+        HWC2_PFN_SET_LAYER_SOURCE_CROP setLayerSourceCrop;
+        HWC2_PFN_SET_LAYER_SURFACE_DAMAGE setLayerSurfaceDamage;
+        HWC2_PFN_SET_LAYER_TRANSFORM setLayerTransform;
+        HWC2_PFN_SET_LAYER_VISIBLE_REGION setLayerVisibleRegion;
+        HWC2_PFN_SET_LAYER_Z_ORDER setLayerZOrder;
+        HWC2_PFN_SET_OUTPUT_BUFFER setOutputBuffer;
+        HWC2_PFN_SET_POWER_MODE setPowerMode;
+        HWC2_PFN_SET_VSYNC_ENABLED setVsyncEnabled;
+        HWC2_PFN_VALIDATE_DISPLAY validateDisplay;
+
+        // 2.2
+        ///
+        HWC2_PFN_SET_LAYER_FLOAT_COLOR setLayerFloatColor;
+
+        HWC2_PFN_SET_LAYER_PER_FRAME_METADATA setLayerPerFrameMetadata;
+        HWC2_PFN_GET_PER_FRAME_METADATA_KEYS getPerFrameMetadataKeys;
+        HWC2_PFN_SET_READBACK_BUFFER setReadbackBuffer;
+        HWC2_PFN_GET_READBACK_BUFFER_ATTRIBUTES getReadbackBufferAttributes;
+        HWC2_PFN_GET_READBACK_BUFFER_FENCE getReadbackBufferFence;
+        HWC2_PFN_GET_RENDER_INTENTS getRenderIntents;
+        //
+        HWC2_PFN_SET_COLOR_MODE_WITH_RENDER_INTENT setColorModeWithRenderIntent;
+        HWC2_PFN_GET_DATASPACE_SATURATION_MATRIX getDataspaceSaturationMatrix;
+
+        // 2.3
+        HWC2_PFN_GET_DISPLAY_IDENTIFICATION_DATA getDisplayIdentificationData;
+        HWC2_PFN_SET_LAYER_COLOR_TRANSFORM setLayerColorTransform;
+        HWC2_PFN_GET_DISPLAYED_CONTENT_SAMPLING_ATTRIBUTES getDisplayedContentSamplingAttributes;
+        HWC2_PFN_SET_DISPLAYED_CONTENT_SAMPLING_ENABLED setDisplayedContentSamplingEnabled;
+        HWC2_PFN_GET_DISPLAYED_CONTENT_SAMPLE getDisplayedContentSample;
+        HWC2_PFN_GET_DISPLAY_CAPABILITIES getDisplayCapabilities;
+        HWC2_PFN_SET_LAYER_PER_FRAME_METADATA_BLOBS setLayerPerFrameMetadataBlobs;
+        HWC2_PFN_GET_DISPLAY_BRIGHTNESS_SUPPORT getDisplayBrightnessSupport;
+        HWC2_PFN_SET_DISPLAY_BRIGHTNESS setDisplayBrightness;
+
+        // 2.4
+        HWC2_PFN_GET_DISPLAY_CONNECTION_TYPE getDisplayConnectionType;
+        HWC2_PFN_GET_DISPLAY_VSYNC_PERIOD getDisplayVsyncPeriod;
+        HWC2_PFN_SET_ACTIVE_CONFIG_WITH_CONSTRAINTS setActiveConfigWithConstraints;
+        HWC2_PFN_SET_AUTO_LOW_LATENCY_MODE setAutoLowLatencyMode;
+        HWC2_PFN_GET_SUPPORTED_CONTENT_TYPES getSupportedContentTypes;
+        HWC2_PFN_SET_CONTENT_TYPE setContentType;
+        HWC2_PFN_GET_CLIENT_TARGET_PROPERTY getClientTargetProperty;
+        HWC2_PFN_SET_LAYER_GENERIC_METADATA setLayerGenericMetadata;
+        HWC2_PFN_GET_LAYER_GENERIC_METADATA_KEY getLayerGenericMetadataKey;
+    } mDispatch = {};
+
+    hwc2_device_t* mDevice;
+
+    EventCallback* mEventCallback;
+    std::unordered_set<Capability> mCaps;
+    
+    std::map<int64_t, std::unordered_set<int64_t>> mClientCompositionLayers;
+
+    constexpr static std::array<float, 16> mkIdentity = {
+        1.0f, 0.0f, 0.0f, 0.0f,
+        0.0f, 1.0f, 0.0f, 0.0f,
+        0.0f, 0.0f, 1.0f, 0.0f,
+        0.0f, 0.0f, 0.0f, 1.0f,
+    };
+
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/impl/HwcLoader.cpp b/graphics/composer/aidl/default/impl/HwcLoader.cpp
new file mode 100644
index 0000000000..0c60bac288
--- /dev/null
+++ b/graphics/composer/aidl/default/impl/HwcLoader.cpp
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "HwcLoader.h"
+#include <hwc2on1adapter/HWC2On1Adapter.h>
+#include <hwc2onfbadapter/HWC2OnFbAdapter.h>
+namespace aidl::android::hardware::graphics::composer3::passthrough{
+
+hwc2_device_t* HwcLoader::load() {
+    const hw_module_t* module = loadModule();
+    if (!module) {
+        return nullptr;
+    }
+
+    bool adapted;
+    hwc2_device_t* device = openDeviceWithAdapter(module, &adapted);
+    if (!device) {
+        return nullptr;
+    }
+    return device;
+}
+
+const hw_module_t* HwcLoader::loadModule() {
+    const hw_module_t* module;
+    int error = hw_get_module(HWC_HARDWARE_MODULE_ID, &module);
+    if (error) {
+        ALOGI("falling back to gralloc module");
+        error = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
+    }
+
+    if (error) {
+        ALOGE("failed to get hwcomposer or gralloc module");
+        return nullptr;
+    }
+
+    return module;
+}
+
+hwc2_device_t* HwcLoader::openDeviceWithAdapter(const hw_module_t* module, bool* outAdapted) {
+    if (module->id && std::string(module->id) == GRALLOC_HARDWARE_MODULE_ID) {
+        *outAdapted = true;
+        return adaptGrallocModule(module);
+    }
+
+    hw_device_t* device;
+    int error = module->methods->open(module, HWC_HARDWARE_COMPOSER, &device);
+    if (error) {
+        ALOGE("failed to open hwcomposer device: %s", strerror(-error));
+        return nullptr;
+    }
+
+    int major = (device->version >> 24) & 0xf;
+    if (major != 2) {
+        *outAdapted = true;
+        return adaptHwc1Device(std::move(reinterpret_cast<hwc_composer_device_1*>(device)));
+    }
+
+    *outAdapted = false;
+    return reinterpret_cast<hwc2_device_t*>(device);
+}
+
+hwc2_device_t* HwcLoader::adaptGrallocModule(const hw_module_t* module) {
+    framebuffer_device_t* device;
+    int error = framebuffer_open(module, &device);
+    if (error) {
+        ALOGE("failed to open framebuffer device: %s", strerror(-error));
+        return nullptr;
+    }
+
+    return new ::android::HWC2OnFbAdapter(device);
+}
+
+hwc2_device_t* HwcLoader::adaptHwc1Device(hwc_composer_device_1* device) {
+    int minor = (device->common.version >> 16) & 0xf;
+    if (minor < 1) {
+        ALOGE("hwcomposer 1.0 is not supported");
+        device->common.close(&device->common);
+        return nullptr;
+    }
+
+    return new ::android::HWC2On1Adapter(device);
+}
+
+} //namespace aidl::android::hardware::graphics::composer3::passthrough
diff --git a/graphics/composer/aidl/default/impl/HwcLoader.h b/graphics/composer/aidl/default/impl/HwcLoader.h
new file mode 100644
index 0000000000..471f5e31dc
--- /dev/null
+++ b/graphics/composer/aidl/default/impl/HwcLoader.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <hardware/fb.h>
+#include <hardware/gralloc.h>
+#include <hardware/hardware.h>
+#include <hardware/hwcomposer.h>
+#define HWC2_INCLUDE_STRINGIFICATION
+#define HWC2_USE_CPP11
+#include <hardware/hwcomposer2.h>
+#undef HWC2_INCLUDE_STRINGIFICATION
+#undef HWC2_USE_CPP11
+#include <log/log.h>
+
+namespace aidl::android::hardware::graphics::composer3::passthrough{
+
+class HwcLoader {
+   public:
+    static hwc2_device_t* load();
+    // load hwcomposer2 module
+    static const hw_module_t* loadModule();
+
+   protected:
+    // open hwcomposer2 device, install an adapter if necessary
+    static hwc2_device_t* openDeviceWithAdapter(const hw_module_t* module, bool* outAdapted) ;
+
+   private:
+    static hwc2_device_t* adaptGrallocModule(const hw_module_t* module);
+    static hwc2_device_t* adaptHwc1Device(hwc_composer_device_1* device);
+};
+
+}  // namespace aidl::android::hardware::graphics::composer3::passthrough
diff --git a/graphics/composer/aidl/default/impl/ResourceManager.cpp b/graphics/composer/aidl/default/impl/ResourceManager.cpp
new file mode 100644
index 0000000000..bb9cb92472
--- /dev/null
+++ b/graphics/composer/aidl/default/impl/ResourceManager.cpp
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <aidlcommonsupport/NativeHandle.h>
+
+#include "ResourceManager.h"
+#include "TranslateHwcAidl.h"
+
+using android::hardware::graphics::composer::V2_1::Display;
+using android::hardware::graphics::composer::V2_1::Error;
+using android::hardware::graphics::composer::V2_1::Layer;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+std::unique_ptr<IResourceManager> IResourceManager::create() {
+    return std::make_unique<ResourceManager>();
+}
+
+std::unique_ptr<IBufferReleaser> ResourceManager::createReleaser(bool isBuffer) {
+    return std::make_unique<BufferReleaser>(isBuffer);
+}
+
+void ResourceManager::clear(RemoveDisplay removeDisplay) {
+    mResources->clear([removeDisplay](Display hwcDisplay, bool isVirtual,
+                                      const std::vector<Layer> hwcLayers) {
+        int64_t display;
+        std::vector<int64_t> layers;
+        h2a::translate(hwcDisplay, display);
+        h2a::translate(hwcLayers, layers);
+
+        removeDisplay(display, isVirtual, layers);
+    });
+}
+
+bool ResourceManager::hasDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    return mResources->hasDisplay(hwcDisplay);
+}
+
+int32_t ResourceManager::addPhysicalDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->addPhysicalDisplay(hwcDisplay);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+
+int32_t ResourceManager::addVirtualDisplay(int64_t display, uint32_t outputBufferCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->addVirtualDisplay(hwcDisplay, outputBufferCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::removeDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->removeDisplay(hwcDisplay);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::setDisplayClientTargetCacheSize(int64_t display,
+                                                         uint32_t clientTargetCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->setDisplayClientTargetCacheSize(hwcDisplay, clientTargetCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayClientTargetCacheSize(int64_t display, size_t* outCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->getDisplayClientTargetCacheSize(hwcDisplay, outCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayOutputBufferCacheSize(int64_t display, size_t* outCacheSize) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Error hwcErr = mResources->getDisplayOutputBufferCacheSize(hwcDisplay, outCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::addLayer(int64_t display, int64_t layer, uint32_t bufferCacheSize) {
+    Display hwcDisplay;
+    Layer hwcLayer;
+
+    a2h::translate(display, hwcDisplay);
+    a2h::translate(layer, hwcLayer);
+
+    Error hwcErr = mResources->addLayer(hwcDisplay, hwcLayer, bufferCacheSize);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::removeLayer(int64_t display, int64_t layer) {
+    Display hwcDisplay;
+    Layer hwcLayer;
+
+    a2h::translate(display, hwcDisplay);
+    a2h::translate(layer, hwcLayer);
+    Error hwcErr = mResources->removeLayer(hwcDisplay, hwcLayer);
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+void ResourceManager::setDisplayMustValidateState(int64_t display, bool mustValidate) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    mResources->setDisplayMustValidateState(hwcDisplay, mustValidate);
+}
+
+bool ResourceManager::mustValidateDisplay(int64_t display) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    return mResources->mustValidateDisplay(hwcDisplay);
+}
+
+int32_t ResourceManager::getDisplayReadbackBuffer(int64_t display, const buffer_handle_t handle,
+                                                  buffer_handle_t& outHandle,
+                                                  IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    // dynamic_cast is not available
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getDisplayReadbackBuffer(hwcDisplay, handle, &outHandle,
+                                                        br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayClientTarget(int64_t display, uint32_t slot, bool fromCache,
+                                                const buffer_handle_t handle,
+                                                buffer_handle_t& outHandle,
+                                                IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getDisplayClientTarget(hwcDisplay, slot, fromCache, handle,
+                                                      &outHandle, br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getDisplayOutputBuffer(int64_t display, uint32_t slot, bool fromCache,
+                                   const buffer_handle_t handle,
+                                   buffer_handle_t& outHandle,
+                                   IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getDisplayOutputBuffer(hwcDisplay, slot, fromCache, handle,
+                                                      &outHandle, br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getLayerBuffer(int64_t display, int64_t layer, uint32_t slot,
+                                        bool fromCache, const buffer_handle_t rawHandle,
+                                        buffer_handle_t& outBufferHandle,
+                                        IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Layer hwcLayer;
+    a2h::translate(layer, hwcLayer);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getLayerBuffer(hwcDisplay, hwcLayer, slot, fromCache,
+                                                rawHandle, &outBufferHandle,
+                                                br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+int32_t ResourceManager::getLayerSidebandStream(int64_t display, int64_t layer,
+                                                const buffer_handle_t rawHandle,
+                                                buffer_handle_t& outStreamHandle,
+                                                IBufferReleaser* bufReleaser) {
+    Display hwcDisplay;
+    a2h::translate(display, hwcDisplay);
+
+    Layer hwcLayer;
+    a2h::translate(layer, hwcLayer);
+
+    auto br = static_cast<BufferReleaser*>(bufReleaser);
+    Error hwcErr = mResources->getLayerSidebandStream(hwcDisplay, hwcLayer, rawHandle,
+                                                      &outStreamHandle, br->getReplacedHandle());
+
+    int32_t err;
+    h2a::translate(hwcErr, err);
+    return err;
+}
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/impl/ResourceManager.h b/graphics/composer/aidl/default/impl/ResourceManager.h
new file mode 100644
index 0000000000..97dcdfedf9
--- /dev/null
+++ b/graphics/composer/aidl/default/impl/ResourceManager.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <composer-resources/2.2/ComposerResources.h>
+
+#include "include/IResourceManager.h"
+
+using android::hardware::graphics::composer::V2_2::hal::ComposerResources;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// Wrapper of ComposerResources before there is an aidl version
+class BufferReleaser : public IBufferReleaser {
+  public:
+    BufferReleaser(bool isBuffer) : mReplacedHandle(isBuffer) {}
+    virtual ~BufferReleaser() = default;
+
+    ComposerResources::ReplacedHandle* getReplacedHandle() { return &mReplacedHandle; }
+
+  private:
+    // ReplacedHandle releases buffer at its destruction.
+    ComposerResources::ReplacedHandle mReplacedHandle;
+};
+
+class ResourceManager : public IResourceManager {
+  public:
+    virtual ~ResourceManager() = default;
+
+    std::unique_ptr<IBufferReleaser> createReleaser(bool isBuffer) override;
+    void clear(RemoveDisplay removeDisplay) override;
+    bool hasDisplay(int64_t display) override;
+    int32_t addPhysicalDisplay(int64_t display) override;
+    int32_t addVirtualDisplay(int64_t display, uint32_t outputBufferCacheSize) override;
+    int32_t removeDisplay(int64_t display) override;
+    int32_t setDisplayClientTargetCacheSize(int64_t display,
+                                            uint32_t clientTargetCacheSize) override;
+    int32_t getDisplayClientTargetCacheSize(int64_t display, size_t* outCacheSize) override;
+    int32_t getDisplayOutputBufferCacheSize(int64_t display, size_t* outCacheSize) override;
+    int32_t addLayer(int64_t display, int64_t layer, uint32_t bufferCacheSize) override;
+    int32_t removeLayer(int64_t display, int64_t layer) override;
+    void setDisplayMustValidateState(int64_t display, bool mustValidate) override;
+    bool mustValidateDisplay(int64_t display) override;
+    int32_t getDisplayReadbackBuffer(int64_t display, const buffer_handle_t handle,
+                                     buffer_handle_t& outHandle,
+                                     IBufferReleaser* bufReleaser) override;
+    int32_t getDisplayClientTarget(int64_t display, uint32_t slot, bool fromCache,
+                                   const buffer_handle_t handle, buffer_handle_t& outHandle,
+                                   IBufferReleaser* bufReleaser) override;
+    int32_t getDisplayOutputBuffer(int64_t display, uint32_t slot, bool fromCache,
+                                   const buffer_handle_t handle, buffer_handle_t& outHandle,
+                                   IBufferReleaser* bufReleaser) override;
+    int32_t getLayerBuffer(int64_t display, int64_t layer, uint32_t slot, bool fromCache,
+                           const buffer_handle_t rawHandle,
+                           buffer_handle_t& outBufferHandle,
+                           IBufferReleaser* bufReleaser) override;
+    int32_t getLayerSidebandStream(int64_t display, int64_t layer,
+                                   const buffer_handle_t rawHandle,
+                                   buffer_handle_t& outStreamHandle,
+                                   IBufferReleaser* bufReleaser) override;
+  private:
+    std::unique_ptr<ComposerResources> mResources = ComposerResources::create();
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/impl/TranslateHwcAidl.h b/graphics/composer/aidl/default/impl/TranslateHwcAidl.h
new file mode 100644
index 0000000000..7f55cccdd0
--- /dev/null
+++ b/graphics/composer/aidl/default/impl/TranslateHwcAidl.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android-base/logging.h>
+// hwc2 types
+#include <hardware/hwcomposer2.h>
+// aidl types
+#include "include/IComposerHal.h"
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// hwc2 to aidl conversion
+namespace h2a {
+
+template <typename T, typename U>
+inline void translate(const T& in, U& out) {
+    out = static_cast<U>(in);
+}
+
+template <typename T, typename U>
+inline void translate(const std::vector<T>& in, std::vector<U>& out) {
+    out.clear();
+    for (auto const &t : in) {
+        U u;
+        translate(t, u);
+        out.emplace_back(std::move(u));
+    }
+}
+
+template<>
+inline void translate(const hwc_vsync_period_change_timeline_t& in,
+                      VsyncPeriodChangeTimeline& out) {
+    out.newVsyncAppliedTimeNanos = in.newVsyncAppliedTimeNanos;
+    out.refreshRequired = in.refreshRequired;
+    out.refreshTimeNanos = in.refreshTimeNanos;
+}
+
+template<>
+inline void translate(const int32_t& fd, ndk::ScopedFileDescriptor& sfd) {
+    // ownership of fd is transferred to sfd
+    sfd = ndk::ScopedFileDescriptor(fd);
+}
+
+template<>
+inline void translate(const hwc_client_target_property& in, ClientTargetProperty& out) {
+    translate(in.pixelFormat, out.pixelFormat);
+    translate(in.dataspace, out.dataspace);
+}
+
+} // namespace h2a
+
+// aidl to hwc2 conversion
+namespace a2h {
+
+template <typename T, typename U>
+inline void translate(const T& in, U& out) {
+    out = static_cast<U>(in);
+}
+
+template <typename T, typename U>
+inline void translate(const std::vector<std::optional<T>>& in, std::vector<U>& out) {
+    out.clear();
+    for (auto const &t : in) {
+        U u;
+        if (t) {
+            translate(*t, u);
+            out.emplace_back(std::move(u));
+        }
+    }
+}
+
+template <typename T, typename U>
+inline void translate(const std::vector<T>& in, std::vector<U>& out) {
+    out.clear();
+    for (auto const &t : in) {
+        U u;
+        translate(t, u);
+        out.emplace_back(std::move(u));
+    }
+}
+
+template<>
+inline void translate(const common::Rect& in, hwc_rect_t& out) {
+     out.left = in.left;
+     out.top = in.top;
+     out.right =in.right;
+     out.bottom =in.bottom;
+}
+
+template<>
+inline void translate(const common::FRect& in, hwc_frect_t& out) {
+     out.left = in.left;
+     out.top = in.top;
+     out.right =in.right;
+     out.bottom =in.bottom;
+}
+
+template <>
+inline void translate(const VsyncPeriodChangeConstraints& in,
+                      hwc_vsync_period_change_constraints_t& out) {
+    out.desiredTimeNanos = in.desiredTimeNanos;
+    out.seamlessRequired = in.seamlessRequired;
+}
+
+template<>
+inline void translate(const ndk::ScopedFileDescriptor& in, int32_t& out) {
+    // it's not defined as const. drop the const to avoid dup
+    auto& sfd = const_cast<ndk::ScopedFileDescriptor&>(in);
+    // take the ownership
+    out = sfd.get();
+    *sfd.getR() = -1;
+}
+
+template<>
+inline void translate(const bool& in, hwc2_vsync_t& out) {
+    // HWC_VSYNC_DISABLE is 2
+    out = in ? HWC2_VSYNC_ENABLE : HWC2_VSYNC_DISABLE;
+}
+
+template<>
+inline void translate(const Color& in, hwc_color_t& out) {
+    const auto floatColorToUint8Clamped = [](float val) -> uint8_t {
+        const auto intVal = static_cast<uint64_t>(std::round(255.0f * val));
+        const auto minVal = static_cast<uint64_t>(0);
+        const auto maxVal = static_cast<uint64_t>(255);
+        return std::clamp(intVal, minVal, maxVal);
+    };
+
+    out.r = floatColorToUint8Clamped(in.r);
+    out.g = floatColorToUint8Clamped(in.g);
+    out.b = floatColorToUint8Clamped(in.b);
+    out.a = floatColorToUint8Clamped(in.a);
+}
+
+} // namespace a2h
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/include/IComposerHal.h b/graphics/composer/aidl/default/include/IComposerHal.h
new file mode 100644
index 0000000000..6fe25c5b7f
--- /dev/null
+++ b/graphics/composer/aidl/default/include/IComposerHal.h
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+/**
+ * Idealy IComposerHal should use aidl NativeHandle not native_handle_t/buffer_handle_t.
+ * However current patten is the HWC lib does not own buffer resources (HWC lib
+ * does own the fences).
+ */
+#include <aidl/android/hardware/common/NativeHandle.h>
+#include <aidl/android/hardware/graphics/common/BlendMode.h>
+#include <aidl/android/hardware/graphics/common/ColorTransform.h>
+#include <aidl/android/hardware/graphics/common/Dataspace.h>
+#include <aidl/android/hardware/graphics/common/FRect.h>
+#include <aidl/android/hardware/graphics/common/PixelFormat.h>
+#include <aidl/android/hardware/graphics/common/Point.h>
+#include <aidl/android/hardware/graphics/common/Rect.h>
+#include <aidl/android/hardware/graphics/common/Transform.h>
+#include <aidl/android/hardware/graphics/composer3/Buffer.h>
+#include <aidl/android/hardware/graphics/composer3/Capability.h>
+#include <aidl/android/hardware/graphics/composer3/ChangedCompositionTypes.h>
+#include <aidl/android/hardware/graphics/composer3/ClientTarget.h>
+#include <aidl/android/hardware/graphics/composer3/ClientTargetProperty.h>
+#include <aidl/android/hardware/graphics/composer3/ClientTargetPropertyWithBrightness.h>
+#include <aidl/android/hardware/graphics/composer3/Color.h>
+#include <aidl/android/hardware/graphics/composer3/ColorMode.h>
+#include <aidl/android/hardware/graphics/composer3/CommandError.h>
+#include <aidl/android/hardware/graphics/composer3/CommandResultPayload.h>
+#include <aidl/android/hardware/graphics/composer3/Composition.h>
+#include <aidl/android/hardware/graphics/composer3/ContentType.h>
+#include <aidl/android/hardware/graphics/composer3/DimmingStage.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayAttribute.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayBrightness.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCapability.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCommand.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayConnectionType.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayContentSample.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayContentSamplingAttributes.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayIdentification.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayRequest.h>
+#include <aidl/android/hardware/graphics/composer3/FormatColorComponent.h>
+#include <aidl/android/hardware/graphics/composer3/HdrCapabilities.h>
+#include <aidl/android/hardware/graphics/composer3/LayerBrightness.h>
+#include <aidl/android/hardware/graphics/composer3/LayerCommand.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableBlendMode.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableComposition.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableDataspace.h>
+#include <aidl/android/hardware/graphics/composer3/ParcelableTransform.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadata.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadataBlob.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadataKey.h>
+#include <aidl/android/hardware/graphics/composer3/PlaneAlpha.h>
+#include <aidl/android/hardware/graphics/composer3/PowerMode.h>
+#include <aidl/android/hardware/graphics/composer3/PresentFence.h>
+#include <aidl/android/hardware/graphics/composer3/PresentOrValidate.h>
+#include <aidl/android/hardware/graphics/composer3/ReadbackBufferAttributes.h>
+#include <aidl/android/hardware/graphics/composer3/ReleaseFences.h>
+#include <aidl/android/hardware/graphics/composer3/RenderIntent.h>
+#include <aidl/android/hardware/graphics/composer3/VirtualDisplay.h>
+#include <aidl/android/hardware/graphics/composer3/VsyncPeriodChangeConstraints.h>
+#include <aidl/android/hardware/graphics/composer3/VsyncPeriodChangeTimeline.h>
+#include <aidl/android/hardware/graphics/composer3/ZOrder.h>
+#include <cutils/native_handle.h>
+
+// avoid naming conflict
+using AidlPixelFormat = aidl::android::hardware::graphics::common::PixelFormat;
+using AidlNativeHandle = aidl::android::hardware::common::NativeHandle;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+// Abstraction of ComposerHal. Returned error code is compatible with AIDL
+// IComposerClient interface.
+class IComposerHal {
+ public:
+    static std::unique_ptr<IComposerHal> create();
+    virtual ~IComposerHal() = default;
+
+    virtual void getCapabilities(std::vector<Capability>* caps) = 0;
+    virtual void dumpDebugInfo(std::string* output) = 0;
+    virtual bool hasCapability(Capability cap) = 0;
+
+    class EventCallback {
+      public:
+        virtual ~EventCallback() = default;
+        virtual void onHotplug(int64_t display, bool connected) = 0;
+        virtual void onRefresh(int64_t display) = 0;
+        virtual void onVsync(int64_t display, int64_t timestamp, int32_t vsyncPeriodNanos) = 0;
+        virtual void onVsyncPeriodTimingChanged(int64_t display,
+                                                const VsyncPeriodChangeTimeline& timeline) = 0;
+        virtual void onVsyncIdle(int64_t display) = 0;
+        virtual void onSeamlessPossible(int64_t display) = 0;
+    };
+    virtual void registerEventCallback(EventCallback* callback) = 0;
+    virtual void unregisterEventCallback() = 0;
+
+    virtual int32_t acceptDisplayChanges(int64_t display) = 0;
+    virtual int32_t createLayer(int64_t display, int64_t* outLayer) = 0;
+    virtual int32_t createVirtualDisplay(uint32_t width, uint32_t height, AidlPixelFormat format,
+                                         VirtualDisplay* outDisplay) = 0;
+    virtual int32_t destroyLayer(int64_t display, int64_t layer) = 0;
+    virtual int32_t destroyVirtualDisplay(int64_t display) = 0;
+    virtual int32_t flushDisplayBrightnessChange(int64_t display) = 0;
+    virtual int32_t getActiveConfig(int64_t display, int32_t* outConfig) = 0;
+    virtual int32_t getColorModes(int64_t display, std::vector<ColorMode>* outModes) = 0;
+    virtual int32_t getDataspaceSaturationMatrix(common::Dataspace dataspace,
+                                                 std::vector<float>* matrix) = 0;
+    virtual int32_t getDisplayAttribute(int64_t display, int32_t config,
+                                      DisplayAttribute attribute, int32_t* outValue) = 0;
+    virtual int32_t getDisplayBrightnessSupport(int64_t display, bool& outSupport) = 0;
+    virtual int32_t getDisplayIdleTimerSupport(int64_t display, bool& outSupport) = 0;
+
+    virtual int32_t getDisplayCapabilities(int64_t display,
+                                           std::vector<DisplayCapability>* caps) = 0;
+    virtual int32_t getDisplayConfigs(int64_t display, std::vector<int32_t>* configs) = 0;
+    virtual int32_t getDisplayConnectionType(int64_t display, DisplayConnectionType* outType) = 0;
+    virtual int32_t getDisplayIdentificationData(int64_t display, DisplayIdentification *id) = 0;
+    virtual int32_t getDisplayName(int64_t display, std::string* outName) = 0;
+    virtual int32_t getDisplayVsyncPeriod(int64_t display, int32_t* outVsyncPeriod) = 0;
+    virtual int32_t getDisplayedContentSample(int64_t display, int64_t maxFrames,
+                                            int64_t timestamp, DisplayContentSample* samples) = 0;
+    virtual int32_t getDisplayedContentSamplingAttributes(
+            int64_t display, DisplayContentSamplingAttributes* attrs) = 0;
+    virtual int32_t getDisplayPhysicalOrientation(int64_t display,
+                                                  common::Transform* orientation) = 0;
+    virtual int32_t getDozeSupport(int64_t display, bool& outSupport) = 0;
+    virtual int32_t getHdrCapabilities(int64_t display, HdrCapabilities* caps) = 0;
+    virtual int32_t getMaxVirtualDisplayCount(int32_t* count) = 0;
+    virtual int32_t getPerFrameMetadataKeys(int64_t display,
+                                            std::vector<PerFrameMetadataKey>* keys) = 0;
+    virtual int32_t getReadbackBufferAttributes(int64_t display,
+                                                ReadbackBufferAttributes* attrs) = 0;
+    virtual int32_t getReadbackBufferFence(int64_t display,
+                                           ndk::ScopedFileDescriptor* aqcuireFence) = 0;
+    virtual int32_t getRenderIntents(int64_t display, ColorMode mode,
+                                     std::vector<RenderIntent>* intents) = 0;
+    virtual int32_t getSupportedContentTypes(int64_t display, std::vector<ContentType>* types) = 0;
+    virtual int32_t presentDisplay(int64_t display, ndk::ScopedFileDescriptor& fence,
+                                   std::vector<int64_t>* outLayers,
+                                   std::vector<ndk::ScopedFileDescriptor>* outReleaseFences) = 0;
+    virtual int32_t setActiveConfig(int64_t display, int32_t config) = 0;
+    virtual int32_t setActiveConfigWithConstraints(
+            int64_t display, int32_t config,
+            const VsyncPeriodChangeConstraints& vsyncPeriodChangeConstraints,
+            VsyncPeriodChangeTimeline* timeline) = 0;
+    virtual int32_t setBootDisplayConfig(int64_t display, int32_t config) = 0;
+    virtual int32_t clearBootDisplayConfig(int64_t display) = 0;
+    virtual int32_t getPreferredBootDisplayConfig(int64_t display, int32_t* config) = 0;
+    virtual int32_t setAutoLowLatencyMode(int64_t display, bool on) = 0;
+    virtual int32_t setClientTarget(int64_t display, buffer_handle_t target,
+                                    const ndk::ScopedFileDescriptor& fence,
+                                    common::Dataspace dataspace,
+                                    const std::vector<common::Rect>& damage) = 0; // cmd
+    virtual int32_t setColorMode(int64_t display, ColorMode mode, RenderIntent intent) = 0;
+    virtual int32_t setColorTransform(int64_t display, const std::vector<float>& matrix) = 0; // cmd
+    virtual int32_t setContentType(int64_t display, ContentType contentType) = 0;
+    virtual int32_t setDisplayBrightness(int64_t display, float brightness) = 0;
+    virtual int32_t setDisplayedContentSamplingEnabled(int64_t display, bool enable,
+                                                       FormatColorComponent componentMask,
+                                                       int64_t maxFrames) = 0;
+    virtual int32_t setLayerBlendMode(int64_t display, int64_t layer, common::BlendMode mode) = 0;
+    virtual int32_t setLayerBuffer(int64_t display, int64_t layer, buffer_handle_t buffer,
+                                   const ndk::ScopedFileDescriptor& acquireFence) = 0;
+    virtual int32_t setLayerColor(int64_t display, int64_t layer, Color color) = 0;
+    virtual int32_t setLayerColorTransform(int64_t display, int64_t layer,
+                                           const std::vector<float>& matrix) = 0;
+    virtual int32_t setLayerCompositionType(int64_t display, int64_t layer, Composition type) = 0;
+    virtual int32_t setLayerCursorPosition(int64_t display, int64_t layer, int32_t x,
+                                           int32_t y) = 0;
+    virtual int32_t setLayerDataspace(int64_t display, int64_t layer,
+                                      common::Dataspace dataspace) = 0;
+    virtual int32_t setLayerDisplayFrame(int64_t display, int64_t layer,
+                                         const common::Rect& frame) = 0;
+    virtual int32_t setLayerPerFrameMetadata(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadata>>& metadata) = 0;
+    virtual int32_t setLayerPerFrameMetadataBlobs(int64_t display, int64_t layer,
+                            const std::vector<std::optional<PerFrameMetadataBlob>>& blobs) = 0;
+    virtual int32_t setLayerPlaneAlpha(int64_t display, int64_t layer, float alpha) = 0;
+    virtual int32_t setLayerSidebandStream(int64_t display, int64_t layer,
+                                           buffer_handle_t stream) = 0;
+    virtual int32_t setLayerSourceCrop(int64_t display, int64_t layer,
+                                       const common::FRect& crop) = 0;
+    virtual int32_t setLayerSurfaceDamage(int64_t display, int64_t layer,
+                        const std::vector<std::optional<common::Rect>>& damage) = 0;
+    virtual int32_t setLayerTransform(int64_t display, int64_t layer,
+                                      common::Transform transform) = 0;
+    virtual int32_t setLayerVisibleRegion(int64_t display, int64_t layer,
+                                 const std::vector<std::optional<common::Rect>>& visible) = 0;
+    virtual int32_t setLayerBrightness(int64_t display, int64_t layer, float brightness) = 0;
+    virtual int32_t setLayerZOrder(int64_t display, int64_t layer, uint32_t z) = 0;
+    virtual int32_t setOutputBuffer(int64_t display, buffer_handle_t buffer,
+                                    const ndk::ScopedFileDescriptor& releaseFence) = 0;
+    virtual int32_t setPowerMode(int64_t display, PowerMode mode) = 0;
+    virtual int32_t setReadbackBuffer(int64_t display, buffer_handle_t buffer,
+                                      const ndk::ScopedFileDescriptor& releaseFence) = 0;
+    virtual int32_t setVsyncEnabled(int64_t display, bool enabled) = 0;
+    virtual int32_t validateDisplay(int64_t display, std::vector<int64_t>* outChangedLayers,
+                                    std::vector<Composition>* outCompositionTypes,
+                                    uint32_t* outDisplayRequestMask,
+                                    std::vector<int64_t>* outRequestedLayers,
+                                    std::vector<int32_t>* outRequestMasks,
+                                    ClientTargetProperty* outClientTargetProperty,
+                                    DimmingStage* outDimmingStage) = 0;
+    virtual int32_t setExpectedPresentTime(
+            int64_t display, const std::optional<ClockMonotonicTimestamp> expectedPresentTime) = 0;
+    virtual int32_t setIdleTimerEnabled(int64_t display, int32_t timeout) = 0;
+    virtual int32_t getRCDLayerSupport(int64_t display, bool& outSupport) = 0;
+    virtual int32_t setLayerBlockingRegion(
+            int64_t display, int64_t layer,
+            const std::vector<std::optional<common::Rect>>& blockingRegion) = 0;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::detail
diff --git a/graphics/composer/aidl/default/include/IResourceManager.h b/graphics/composer/aidl/default/include/IResourceManager.h
new file mode 100644
index 0000000000..7def129b16
--- /dev/null
+++ b/graphics/composer/aidl/default/include/IResourceManager.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <aidlcommonsupport/NativeHandle.h>
+
+using AidlNativeHandle = aidl::android::hardware::common::NativeHandle;
+
+namespace aidl::android::hardware::graphics::composer3::impl {
+
+/// Some IResourceManager functions return a replaced buffer and that buffer should be
+// released later (at the time of IBufferReleaser object destruction)
+class IBufferReleaser {
+ public:
+    virtual ~IBufferReleaser() = default;
+};
+
+class IResourceManager {
+public:
+    static std::unique_ptr<IResourceManager> create();
+    using RemoveDisplay = std::function<void(int64_t display, bool isVirtual,
+                                             const std::vector<int64_t>& layers)>;
+    virtual ~IResourceManager() = default;
+    virtual std::unique_ptr<IBufferReleaser> createReleaser(bool isBuffer) = 0;
+
+    virtual void clear(RemoveDisplay removeDisplay) = 0;
+    virtual bool hasDisplay(int64_t display) = 0;
+    virtual int32_t addPhysicalDisplay(int64_t display) = 0;
+    virtual int32_t addVirtualDisplay(int64_t display, uint32_t outputBufferCacheSize) = 0;
+    virtual int32_t removeDisplay(int64_t display) = 0;
+    virtual int32_t setDisplayClientTargetCacheSize(int64_t display,
+                                                    uint32_t clientTargetCacheSize) = 0;
+    virtual int32_t getDisplayClientTargetCacheSize(int64_t display, size_t* outCacheSize) = 0;
+    virtual int32_t getDisplayOutputBufferCacheSize(int64_t display, size_t* outCacheSize) = 0;
+    virtual int32_t addLayer(int64_t display, int64_t layer, uint32_t bufferCacheSize) = 0;
+    virtual int32_t removeLayer(int64_t display, int64_t layer) = 0;
+    virtual void setDisplayMustValidateState(int64_t display, bool mustValidate) = 0;
+    virtual bool mustValidateDisplay(int64_t display) = 0;
+    virtual int32_t getDisplayReadbackBuffer(int64_t display, const buffer_handle_t handle,
+                                             buffer_handle_t& outHandle,
+                                             IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getDisplayClientTarget(int64_t display, uint32_t slot, bool fromCache,
+                                           const buffer_handle_t handle,
+                                           buffer_handle_t& outHandle,
+                                           IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getDisplayOutputBuffer(int64_t display, uint32_t slot, bool fromCache,
+                                           const buffer_handle_t handle,
+                                           buffer_handle_t& outHandle,
+                                           IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getLayerBuffer(int64_t display, int64_t layer, uint32_t slot,
+                                   bool fromCache,
+                                   const buffer_handle_t rawHandle,
+                                   buffer_handle_t& outBufferHandle,
+                                   IBufferReleaser* bufReleaser) = 0;
+    virtual int32_t getLayerSidebandStream(int64_t display, int64_t layer,
+                                           const buffer_handle_t rawHandle,
+                                           buffer_handle_t& outStreamHandle,
+                                           IBufferReleaser* bufReleaser) = 0;
+};
+
+} // namespace aidl::android::hardware::graphics::composer3::impl
diff --git a/graphics/composer/aidl/default/service.cpp b/graphics/composer/aidl/default/service.cpp
new file mode 100644
index 0000000000..d6274310e2
--- /dev/null
+++ b/graphics/composer/aidl/default/service.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2021, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <android-base/logging.h>
+#include <android/binder_manager.h>
+#include <android/binder_process.h>
+// #include <binder/ProcessState.h>
+#include <sched.h>
+
+#include "Composer.h"
+
+using aidl::android::hardware::graphics::composer3::impl::Composer;
+using aidl::android::hardware::graphics::composer3::impl::IComposerHal;
+
+using android::base::InitLogging;
+using android::base::StderrLogger;
+using android::sp;
+
+int main(int /*argc*/, char* argv[]) {
+    InitLogging(argv, android::base::LogdLogger(android::base::SYSTEM));
+    LOG(INFO) << "hwc3 starting up";
+    
+    ABinderProcess_setThreadPoolMaxThreadCount(5);
+    
+
+    struct sched_param param = {0};
+    param.sched_priority = 2;
+    if (sched_setscheduler(0, SCHED_FIFO | SCHED_RESET_ON_FORK, &param) != 0) {
+        LOG(ERROR) << "Couldn't set SCHED_FIFO: " << errno;
+    }
+
+    std::unique_ptr<IComposerHal> halImpl = IComposerHal::create();
+    CHECK(halImpl != nullptr);
+
+    std::shared_ptr<Composer> composer = ndk::SharedRefBase::make<Composer>(std::move(halImpl));
+    CHECK(composer != nullptr);
+
+    const std::string instance = std::string() + Composer::descriptor + "/default";
+
+    binder_status_t status =
+            AServiceManager_addService(composer->asBinder().get(), instance.c_str());
+    CHECK(status == STATUS_OK);
+    
+    ABinderProcess_startThreadPool();
+    ABinderProcess_joinThreadPool();
+
+    return EXIT_FAILURE;  
+}
\ No newline at end of file
-- 
2.43.0

