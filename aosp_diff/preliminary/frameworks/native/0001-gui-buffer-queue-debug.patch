From 543662de7fea1c59c8ad0f00b6bba1d36faa9c15 Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Fri, 30 Jul 2021 11:02:12 +0530
Subject: [PATCH] gui buffer queue debug

---
 libs/gui/BufferHubProducer.cpp      | 18 ++++++++--------
 libs/gui/BufferItemConsumer.cpp     |  2 +-
 libs/gui/BufferQueue.cpp            |  2 +-
 libs/gui/BufferQueueConsumer.cpp    | 32 ++++++++++++++---------------
 libs/gui/BufferQueueProducer.cpp    |  2 +-
 libs/gui/GLConsumer.cpp             |  2 +-
 libs/gui/QueueBufferInputOutput.cpp |  2 +-
 7 files changed, 30 insertions(+), 30 deletions(-)

diff --git a/libs/gui/BufferHubProducer.cpp b/libs/gui/BufferHubProducer.cpp
index 489f3c356..6957112d8 100644
--- a/libs/gui/BufferHubProducer.cpp
+++ b/libs/gui/BufferHubProducer.cpp
@@ -136,7 +136,7 @@ status_t BufferHubProducer::dequeueBuffer(int* out_slot, sp<Fence>* out_fence, u
                                           uint32_t height, PixelFormat format, uint64_t usage,
                                           uint64_t* /*outBufferAge*/,
                                           FrameEventHistoryDelta* /* out_timestamps */) {
-    ALOGV("dequeueBuffer: w=%u, h=%u, format=%d, usage=%" PRIu64, width, height, format, usage);
+    ALOGE("dequeueBuffer: w=%u, h=%u, format=%d, usage=%" PRIu64, width, height, format, usage);
 
     status_t ret;
     std::unique_lock<std::mutex> lock(mutex_);
@@ -281,7 +281,7 @@ status_t BufferHubProducer::DetachBufferLocked(size_t slot) {
 }
 
 status_t BufferHubProducer::detachNextBuffer(sp<GraphicBuffer>* out_buffer, sp<Fence>* out_fence) {
-    ALOGV("detachNextBuffer.");
+    ALOGE("detachNextBuffer.");
 
     if (out_buffer == nullptr || out_fence == nullptr) {
         ALOGE("detachNextBuffer: Invalid parameter: out_buffer=%p, out_fence=%p", out_buffer,
@@ -341,7 +341,7 @@ status_t BufferHubProducer::detachNextBuffer(sp<GraphicBuffer>* out_buffer, sp<F
         return BAD_VALUE;
     }
 
-    ALOGV("detachNextBuffer: slot=%zu", slot);
+    ALOGE("detachNextBuffer: slot=%zu", slot);
     buffers_[slot].mBufferState.freeQueued();
     buffers_[slot].mBufferState.dequeue();
 
@@ -361,7 +361,7 @@ status_t BufferHubProducer::detachNextBuffer(sp<GraphicBuffer>* out_buffer, sp<F
 status_t BufferHubProducer::attachBuffer(int* out_slot, const sp<GraphicBuffer>& buffer) {
     // In the BufferHub design, all buffers are allocated and owned by the BufferHub. Thus only
     // GraphicBuffers that are originated from BufferHub can be attached to a BufferHubProducer.
-    ALOGV("queueBuffer: buffer=%p", buffer.get());
+    ALOGE("queueBuffer: buffer=%p", buffer.get());
 
     if (out_slot == nullptr) {
         ALOGE("attachBuffer: out_slot cannot be NULL.");
@@ -395,7 +395,7 @@ status_t BufferHubProducer::attachBuffer(int* out_slot, const sp<GraphicBuffer>&
 
 status_t BufferHubProducer::queueBuffer(int slot, const QueueBufferInput& input,
                                         QueueBufferOutput* output) {
-    ALOGV("queueBuffer: slot %d", slot);
+    ALOGE("queueBuffer: slot %d", slot);
 
     if (output == nullptr) {
         return BAD_VALUE;
@@ -528,7 +528,7 @@ status_t BufferHubProducer::cancelBuffer(int slot, const sp<Fence>& fence) {
 }
 
 status_t BufferHubProducer::query(int what, int* out_value) {
-    ALOGV(__FUNCTION__);
+    ALOGE(__FUNCTION__);
 
     std::unique_lock<std::mutex> lock(mutex_);
 
@@ -587,7 +587,7 @@ status_t BufferHubProducer::query(int what, int* out_value) {
             return BAD_VALUE;
     }
 
-    ALOGV("query: key=%d, v=%d", what, value);
+    ALOGE("query: key=%d, v=%d", what, value);
     *out_value = value;
     return NO_ERROR;
 }
@@ -598,7 +598,7 @@ status_t BufferHubProducer::connect(const sp<IProducerListener>& /* listener */,
     // Consumer interaction are actually handled by buffer hub, and we need
     // to maintain consumer operations here. We only need to perform basic input
     // parameter checks here.
-    ALOGV(__FUNCTION__);
+    ALOGE(__FUNCTION__);
 
     if (output == nullptr) {
         return BAD_VALUE;
@@ -645,7 +645,7 @@ status_t BufferHubProducer::disconnect(int api, DisconnectMode /*mode*/) {
     // Consumer interaction are actually handled by buffer hub, and we need
     // to maintain consumer operations here.  We only need to perform basic input
     // parameter checks here.
-    ALOGV(__FUNCTION__);
+    ALOGE(__FUNCTION__);
 
     std::unique_lock<std::mutex> lock(mutex_);
 
diff --git a/libs/gui/BufferItemConsumer.cpp b/libs/gui/BufferItemConsumer.cpp
index f50bc203e..831055c57 100644
--- a/libs/gui/BufferItemConsumer.cpp
+++ b/libs/gui/BufferItemConsumer.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #define LOG_TAG "BufferItemConsumer"
 //#define ATRACE_TAG ATRACE_TAG_GRAPHICS
 #include <utils/Log.h>
diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index c1d92a2a7..56dd77be1 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -16,7 +16,7 @@
 
 #define LOG_TAG "BufferQueue"
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #ifndef NO_BUFFERHUB
 #include <gui/BufferHubConsumer.h>
diff --git a/libs/gui/BufferQueueConsumer.cpp b/libs/gui/BufferQueueConsumer.cpp
index da6143c59..2cc51ba9a 100644
--- a/libs/gui/BufferQueueConsumer.cpp
+++ b/libs/gui/BufferQueueConsumer.cpp
@@ -20,7 +20,7 @@
 
 #define LOG_TAG "BufferQueueConsumer"
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #if DEBUG_ONLY_CODE
 #define VALIDATE_CONSISTENCY() do { mCore->validateConsistencyLocked(); } while (0)
@@ -168,7 +168,7 @@ status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
                     break;
                 }
 
-                BQ_LOGV("acquireBuffer: drop desire=%" PRId64 " expect=%" PRId64
+                BQ_LOGE("acquireBuffer: drop desire=%" PRId64 " expect=%" PRId64
                         " size=%zu",
                         desiredPresent, expectedPresent, mCore->mQueue.size());
 
@@ -218,7 +218,7 @@ status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
                 return PRESENT_LATER;
             }
 
-            BQ_LOGV("acquireBuffer: accept desire=%" PRId64 " expect=%" PRId64 " "
+            BQ_LOGE("acquireBuffer: accept desire=%" PRId64 " expect=%" PRId64 " "
                     "(%" PRId64 ") now=%" PRId64, desiredPresent, expectedPresent,
                     desiredPresent - expectedPresent,
                     systemTime(CLOCK_MONOTONIC));
@@ -261,7 +261,7 @@ status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
 
         ATRACE_BUFFER_INDEX(slot);
 
-        BQ_LOGV("acquireBuffer: acquiring { slot=%d/%" PRIu64 " buffer=%p }",
+        BQ_LOGE("acquireBuffer: acquiring { slot=%d/%" PRIu64 " buffer=%p }",
                 slot, outBuffer->mFrameNumber, outBuffer->mGraphicBuffer->handle);
 
         if (!outBuffer->mIsStale) {
@@ -311,7 +311,7 @@ status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
 status_t BufferQueueConsumer::detachBuffer(int slot) {
     ATRACE_CALL();
     ATRACE_BUFFER_INDEX(slot);
-    BQ_LOGV("detachBuffer: slot %d", slot);
+    BQ_LOGE("detachBuffer: slot %d", slot);
     std::lock_guard<std::mutex> lock(mCore->mMutex);
 
     if (mCore->mIsAbandoned) {
@@ -487,7 +487,7 @@ status_t BufferQueueConsumer::releaseBuffer(int slot, uint64_t frameNumber,
         if (mCore->mBufferReleasedCbEnabled) {
             listener = mCore->mConnectedProducerListener;
         }
-        BQ_LOGV("releaseBuffer: releasing slot %d", slot);
+        BQ_LOGE("releaseBuffer: releasing slot %d", slot);
 
         mCore->mDequeueCondition.notify_all();
         VALIDATE_CONSISTENCY();
@@ -510,7 +510,7 @@ status_t BufferQueueConsumer::connect(
         return BAD_VALUE;
     }
 
-    BQ_LOGV("connect: controlledByApp=%s",
+    BQ_LOGE("connect: controlledByApp=%s",
             controlledByApp ? "true" : "false");
 
     std::lock_guard<std::mutex> lock(mCore->mMutex);
@@ -580,7 +580,7 @@ status_t BufferQueueConsumer::getReleasedBuffers(uint64_t *outSlotMask) {
         ++current;
     }
 
-    BQ_LOGV("getReleasedBuffers: returning mask %#" PRIx64, mask);
+    BQ_LOGE("getReleasedBuffers: returning mask %#" PRIx64, mask);
     *outSlotMask = mask;
     return NO_ERROR;
 }
@@ -595,7 +595,7 @@ status_t BufferQueueConsumer::setDefaultBufferSize(uint32_t width,
         return BAD_VALUE;
     }
 
-    BQ_LOGV("setDefaultBufferSize: width=%u height=%u", width, height);
+    BQ_LOGE("setDefaultBufferSize: width=%u height=%u", width, height);
 
     std::lock_guard<std::mutex> lock(mCore->mMutex);
     mCore->mDefaultWidth = width;
@@ -694,7 +694,7 @@ status_t BufferQueueConsumer::setMaxAcquiredBufferCount(
             return BAD_VALUE;
         }
 
-        BQ_LOGV("setMaxAcquiredBufferCount: %d", maxAcquiredBuffers);
+        BQ_LOGE("setMaxAcquiredBufferCount: %d", maxAcquiredBuffers);
         mCore->mMaxAcquiredBufferCount = maxAcquiredBuffers;
         VALIDATE_CONSISTENCY();
         if (delta < 0 && mCore->mBufferReleasedCbEnabled) {
@@ -711,7 +711,7 @@ status_t BufferQueueConsumer::setMaxAcquiredBufferCount(
 
 status_t BufferQueueConsumer::setConsumerName(const String8& name) {
     ATRACE_CALL();
-    BQ_LOGV("setConsumerName: '%s'", name.string());
+    BQ_LOGE("setConsumerName: '%s'", name.string());
     std::lock_guard<std::mutex> lock(mCore->mMutex);
     mCore->mConsumerName = name;
     mConsumerName = name;
@@ -720,7 +720,7 @@ status_t BufferQueueConsumer::setConsumerName(const String8& name) {
 
 status_t BufferQueueConsumer::setDefaultBufferFormat(PixelFormat defaultFormat) {
     ATRACE_CALL();
-    BQ_LOGV("setDefaultBufferFormat: %u", defaultFormat);
+    BQ_LOGE("setDefaultBufferFormat: %u", defaultFormat);
     std::lock_guard<std::mutex> lock(mCore->mMutex);
     mCore->mDefaultBufferFormat = defaultFormat;
     return NO_ERROR;
@@ -729,7 +729,7 @@ status_t BufferQueueConsumer::setDefaultBufferFormat(PixelFormat defaultFormat)
 status_t BufferQueueConsumer::setDefaultBufferDataSpace(
         android_dataspace defaultDataSpace) {
     ATRACE_CALL();
-    BQ_LOGV("setDefaultBufferDataSpace: %u", defaultDataSpace);
+    BQ_LOGE("setDefaultBufferDataSpace: %u", defaultDataSpace);
     std::lock_guard<std::mutex> lock(mCore->mMutex);
     mCore->mDefaultBufferDataSpace = defaultDataSpace;
     return NO_ERROR;
@@ -737,7 +737,7 @@ status_t BufferQueueConsumer::setDefaultBufferDataSpace(
 
 status_t BufferQueueConsumer::setConsumerUsageBits(uint64_t usage) {
     ATRACE_CALL();
-    BQ_LOGV("setConsumerUsageBits: %#" PRIx64, usage);
+    BQ_LOGE("setConsumerUsageBits: %#" PRIx64, usage);
     std::lock_guard<std::mutex> lock(mCore->mMutex);
     mCore->mConsumerUsageBits = usage;
     return NO_ERROR;
@@ -745,7 +745,7 @@ status_t BufferQueueConsumer::setConsumerUsageBits(uint64_t usage) {
 
 status_t BufferQueueConsumer::setConsumerIsProtected(bool isProtected) {
     ATRACE_CALL();
-    BQ_LOGV("setConsumerIsProtected: %s", isProtected ? "true" : "false");
+    BQ_LOGE("setConsumerIsProtected: %s", isProtected ? "true" : "false");
     std::lock_guard<std::mutex> lock(mCore->mMutex);
     mCore->mConsumerIsProtected = isProtected;
     return NO_ERROR;
@@ -753,7 +753,7 @@ status_t BufferQueueConsumer::setConsumerIsProtected(bool isProtected) {
 
 status_t BufferQueueConsumer::setTransformHint(uint32_t hint) {
     ATRACE_CALL();
-    BQ_LOGV("setTransformHint: %#x", hint);
+    BQ_LOGE("setTransformHint: %#x", hint);
     std::lock_guard<std::mutex> lock(mCore->mMutex);
     mCore->mTransformHint = hint;
     return NO_ERROR;
diff --git a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
index a7cf39add..5efe051a7 100644
--- a/libs/gui/BufferQueueProducer.cpp
+++ b/libs/gui/BufferQueueProducer.cpp
@@ -18,7 +18,7 @@
 
 #define LOG_TAG "BufferQueueProducer"
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #if DEBUG_ONLY_CODE
 #define VALIDATE_CONSISTENCY() do { mCore->validateConsistencyLocked(); } while (0)
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 59f1bcd24..3bee487ba 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -16,7 +16,7 @@
 
 #define LOG_TAG "GLConsumer"
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #define GL_GLEXT_PROTOTYPES
 #define EGL_EGLEXT_PROTOTYPES
diff --git a/libs/gui/QueueBufferInputOutput.cpp b/libs/gui/QueueBufferInputOutput.cpp
index 30f0ef678..087d6c388 100644
--- a/libs/gui/QueueBufferInputOutput.cpp
+++ b/libs/gui/QueueBufferInputOutput.cpp
@@ -18,7 +18,7 @@
 
 #define LOG_TAG "QueueBufferInputOutput"
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <gui/IGraphicBufferProducer.h>
 
-- 
2.32.0

