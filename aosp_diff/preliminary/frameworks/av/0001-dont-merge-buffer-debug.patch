From c87edd16f99c78343e41f85121e1d0745290f5b4 Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Wed, 11 Aug 2021 23:12:31 +0530
Subject: [PATCH] dont merge buffer debug


diff --git a/services/camera/libcameraservice/device3/Camera3BufferManager.cpp b/services/camera/libcameraservice/device3/Camera3BufferManager.cpp
index d6bf83eba8..071974f01a 100644
--- a/services/camera/libcameraservice/device3/Camera3BufferManager.cpp
+++ b/services/camera/libcameraservice/device3/Camera3BufferManager.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 #define LOG_TAG "Camera3-BufferManager"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
 
@@ -158,6 +158,7 @@ status_t Camera3BufferManager::unregisterStream(int streamId, int streamSetId) {
 
 void Camera3BufferManager::notifyBufferRemoved(int streamId, int streamSetId) {
     Mutex::Autolock l(mLock);
+    ALOGE("notifyBufferRemoved E");
     StreamSet &streamSet = mStreamSetMap.editValueFor(streamSetId);
     size_t& attachedBufferCount =
             streamSet.attachedBufferCountMap.editValueFor(streamId);
@@ -241,7 +242,7 @@ status_t Camera3BufferManager::getBufferForStream(int streamId, int streamSetId,
     ATRACE_CALL();
 
     Mutex::Autolock l(mLock);
-    ALOGV("%s: get buffer for stream %d with stream set %d", __FUNCTION__,
+    ALOGE("%s: get buffer for stream %d with stream set %d", __FUNCTION__,
             streamId, streamSetId);
 
     if (!checkIfStreamRegisteredLocked(streamId, streamSetId)) {
@@ -284,7 +285,7 @@ status_t Camera3BufferManager::getBufferForStream(int streamId, int streamSetId,
                         std::to_string(getpid()) + "]");
         status_t res = buffer.graphicBuffer->initCheck();
 
-        ALOGV("%s: allocating a new graphic buffer (%dx%d, format 0x%x) %p with handle %p",
+        ALOGE("%s: allocating a new graphic buffer (%dx%d, format 0x%x) %p with handle %p",
                 __FUNCTION__, info.width, info.height, info.format,
                 buffer.graphicBuffer.get(), buffer.graphicBuffer->handle);
         if (res < 0) {
@@ -341,7 +342,7 @@ status_t Camera3BufferManager::onBufferReleased(
     }
 
     Mutex::Autolock l(mLock);
-    ALOGV("Stream %d set %d: Buffer released", streamId, streamSetId);
+    ALOGE("Stream %d set %d: Buffer released", streamId, streamSetId);
     *shouldFreeBuffer = false;
 
     if (!checkIfStreamRegisteredLocked(streamId, streamSetId)){
@@ -399,7 +400,7 @@ status_t Camera3BufferManager::onBuffersRemoved(int streamId, int streamSetId, s
     ATRACE_CALL();
     Mutex::Autolock l(mLock);
 
-    ALOGV("Stream %d set %d: Buffer removed", streamId, streamSetId);
+    ALOGE("Stream %d set %d: Buffer removed", streamId, streamSetId);
 
     if (!checkIfStreamRegisteredLocked(streamId, streamSetId)){
         ALOGV("%s: signaling buffer removal for an already unregistered stream "
diff --git a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
index 01ca0064ec..7a49f98858 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
@@ -16,7 +16,7 @@
 
 #define LOG_TAG "Camera3-OutputStream"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <utils/Log.h>
 #include <utils/Trace.h>
@@ -166,25 +166,27 @@ status_t Camera3OutputStream::getBufferLocked(camera3_stream_buffer *buffer,
     ANativeWindowBuffer* anb;
     int fenceFd = -1;
 
+    ALOGE("BUFFER_DEBUG getBufferLocked E %p ", buffer->buffer);
     status_t res;
     res = getBufferLockedCommon(&anb, &fenceFd);
     if (res != OK) {
         return res;
     }
-
+ALOGE("BUFFER_DEBUG getBufferLocked 1 %p ", &(anb->handle));
     /**
      * FenceFD now owned by HAL except in case of error,
      * in which case we reassign it to acquire_fence
      */
     handoutBufferLocked(*buffer, &(anb->handle), /*acquireFence*/fenceFd,
                         /*releaseFence*/-1, CAMERA3_BUFFER_STATUS_OK, /*output*/true);
-
+ALOGE("BUFFER_DEBUG handoutBufferLocked %p",&(anb->handle));
     return OK;
 }
 
 status_t Camera3OutputStream::queueBufferToConsumer(sp<ANativeWindow>& consumer,
             ANativeWindowBuffer* buffer, int anwReleaseFence,
             const std::vector<size_t>&) {
+	 ALOGE("BUFFER_DEBUG queueBufferToConsumer buffer %p and %s",&(buffer->hanle), consumer.getConsumerName());
     return consumer->queueBuffer(consumer.get(), buffer, anwReleaseFence);
 }
 
@@ -192,7 +194,7 @@ status_t Camera3OutputStream::returnBufferLocked(
         const camera3_stream_buffer &buffer,
         nsecs_t timestamp, const std::vector<size_t>& surface_ids) {
     ATRACE_HFR_CALL();
-
+    
     status_t res = returnAnyBufferLocked(buffer, timestamp, /*output*/true, surface_ids);
 
     if (res != OK) {
@@ -233,6 +235,7 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
     mLock.unlock();
 
     ANativeWindowBuffer *anwBuffer = container_of(buffer.buffer, ANativeWindowBuffer, handle);
+    ALOGE("BUFFER_DEBUG returnBufferCheckedLocked E %p", anwBuffer->handle);
     /**
      * Return buffer back to ANativeWindow
      */
@@ -279,7 +282,7 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
                   __FUNCTION__, mId, strerror(-res), res);
             return res;
         }
-
+ ALOGE("queueBufferToConsumer returnBufferCheckedLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
         res = queueBufferToConsumer(currentConsumer, anwBuffer, anwReleaseFence, surface_ids);
         if (shouldLogError(res, state)) {
             ALOGE("%s: Stream %d: Error queueing buffer to native window:"
@@ -287,7 +290,7 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
         }
     }
     mLock.lock();
-
+ALOGE(" mLock.lock() called"); 
     // Once a valid buffer has been returned to the queue, can no longer
     // dequeue all buffers for preallocation.
     if (buffer.status != CAMERA3_BUFFER_STATUS_ERROR) {
@@ -295,11 +298,12 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
     }
 
     if (res != OK) {
+	    ALOGE("close(anwReleaseFence)");
         close(anwReleaseFence);
     }
 
     *releaseFenceOut = releaseFence;
-
+ALOGE("return res");
     return res;
 }
 
@@ -493,6 +497,7 @@ status_t Camera3OutputStream::configureConsumerQueueLocked() {
     if (mBufferManager != 0 && mSetId > CAMERA3_STREAM_SET_ID_INVALID &&
             !(isConsumedByHWComposer() || isConsumedByHWTexture())) {
         uint64_t consumerUsage = 0;
+	ALOGE("BUFFER_DEBUG mBufferManager 1");
         getEndpointUsage(&consumerUsage);
         StreamInfo streamInfo(
                 getId(), getStreamSetId(), getWidth(), getHeight(), getFormat(), getDataSpace(),
@@ -502,6 +507,7 @@ status_t Camera3OutputStream::configureConsumerQueueLocked() {
         res = mBufferManager->registerStream(weakThis,
                 streamInfo);
         if (res == OK) {
+		ALOGE("BUFFER_DEBUG mBufferManager setting to true");
             // Disable buffer allocation for this BufferQueue, buffer manager will take over
             // the buffer allocation responsibility.
             mConsumer->getIGraphicBufferProducer()->allowAllocation(false);
@@ -525,7 +531,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
     }
 
     bool gotBufferFromManager = false;
-
+ALOGE("BUFFER_DEBUG getBufferLockedCommon anb %p", anb->handle);
     if (mUseBufferManager) {
         sp<GraphicBuffer> gb;
         res = mBufferManager->getBufferForStream(getId(), getStreamSetId(), &gb, fenceFd);
@@ -533,6 +539,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
             // Attach this buffer to the bufferQueue: the buffer will be in dequeue state after a
             // successful return.
             *anb = gb.get();
+	    ALOGE("BUFFER_DEBUG attach buffer anb %p ", anb->handle);
             res = mConsumer->attachBuffer(*anb);
             if (shouldLogError(res, mState)) {
                 ALOGE("%s: Stream %d: Can't attach the output buffer to this surface: %s (%d)",
@@ -543,11 +550,11 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
                 return res;
             }
             gotBufferFromManager = true;
-            ALOGV("Stream %d: Attached new buffer", getId());
+            ALOGE("Stream %d: Attached new buffer", getId());
         } else if (res == ALREADY_EXISTS) {
             // Have sufficient free buffers already attached, can just
             // dequeue from buffer queue
-            ALOGV("Stream %d: Reusing attached buffer", getId());
+            ALOGE("Stream %d: Reusing attached buffer", getId());
             gotBufferFromManager = false;
         } else if (res != OK) {
             ALOGE("%s: Stream %d: Can't get next output buffer from buffer manager: %s (%d)",
@@ -572,6 +579,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
 
         nsecs_t dequeueStart = systemTime(SYSTEM_TIME_MONOTONIC);
         res = currentConsumer->dequeueBuffer(currentConsumer.get(), anb, fenceFd);
+	ALOGE("BUFFER_DEBUG dequeueBuffer %p", anb->handle);
         nsecs_t dequeueEnd = systemTime(SYSTEM_TIME_MONOTONIC);
         mDequeueBufferLatency.add(dequeueStart, dequeueEnd);
 
@@ -588,9 +596,10 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
                 // Attach this buffer to the bufferQueue: the buffer will be in dequeue state after
                 // a successful return.
                 *anb = gb.get();
+		ALOGE("BUFFER_DEBUG attach buffer %p", anb->handle);
                 res = mConsumer->attachBuffer(*anb);
                 gotBufferFromManager = true;
-                ALOGV("Stream %d: Attached new buffer", getId());
+                ALOGE("Stream %d: Attached new buffer", getId());
 
                 if (res != OK) {
                     if (shouldLogError(res, mState)) {
@@ -850,6 +859,7 @@ void Camera3OutputStream::onBuffersRemovedLocked(
 
 status_t Camera3OutputStream::detachBuffer(sp<GraphicBuffer>* buffer, int* fenceFd) {
     Mutex::Autolock l(mLock);
+    ALOGE("shiva detachBuffer %p",buffer);
     return detachBufferLocked(buffer, fenceFd);
 }
 
diff --git a/services/camera/libcameraservice/device3/Camera3Stream.cpp b/services/camera/libcameraservice/device3/Camera3Stream.cpp
index 20f616853a..45f5ee6617 100644
--- a/services/camera/libcameraservice/device3/Camera3Stream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3Stream.cpp
@@ -16,7 +16,7 @@
 
 #define LOG_TAG "Camera3-Stream"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <utils/Log.h>
 #include <utils/Trace.h>
-- 
2.32.0

