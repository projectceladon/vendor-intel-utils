From 5fc37faa9880e00605baf7bd5756985a0a2d4b99 Mon Sep 17 00:00:00 2001
From: renchenglei <chenglei.ren@intel.com>
Date: Thu, 12 Nov 2020 01:45:25 +0800
Subject: [PATCH] Using RGB565 in case YV12 is not supported

Tracked-On:
---
 .../colorconversion/SoftwareRenderer.cpp       | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
index 471131561531..756c94353de0 100644
--- a/media/libstagefright/colorconversion/SoftwareRenderer.cpp
+++ b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
@@ -98,6 +98,15 @@ void SoftwareRenderer::resetFormatIfChanged(
         dataSpaceChangedForPlanar16 = true;
     }
 
+    char szVendorIntelVideoCodec[PROPERTY_VALUE_MAX] = {'\0'};
+    bool noYUV = false;
+
+    if(property_get("vendor.intel.video.codec", szVendorIntelVideoCodec, NULL) > 0 ) {
+        if (strncmp(szVendorIntelVideoCodec, "hardware", PROPERTY_VALUE_MAX) != 0 ) {
+            noYUV = true;
+        }
+    }
+
     if (static_cast<int32_t>(mColorFormat) == colorFormatNew &&
         mWidth == widthNew &&
         mHeight == heightNew &&
@@ -105,7 +114,8 @@ void SoftwareRenderer::resetFormatIfChanged(
         mCropTop == cropTopNew &&
         mCropRight == cropRightNew &&
         mCropBottom == cropBottomNew &&
-        !dataSpaceChangedForPlanar16) {
+        !dataSpaceChangedForPlanar16 &&
+        !noYUV) {
         // Nothing changed, no need to reset renderer.
         return;
     }
@@ -134,6 +144,9 @@ void SoftwareRenderer::resetFormatIfChanged(
             case OMX_COLOR_FormatYUV420SemiPlanar:
             case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
             {
+                if (noYUV) {
+                    break;
+                }
                 halFormat = HAL_PIXEL_FORMAT_YV12;
                 bufWidth = (mCropWidth + 1) & ~1;
                 bufHeight = (mCropHeight + 1) & ~1;
@@ -164,6 +177,9 @@ void SoftwareRenderer::resetFormatIfChanged(
                     // use render engine to convert it to RGB if needed.
                     halFormat = HAL_PIXEL_FORMAT_RGBA_1010102;
                 } else {
+                    if (noYUV) {
+                        break;
+                    }
                     halFormat = HAL_PIXEL_FORMAT_YV12;
                 }
                 bufWidth = (mCropWidth + 1) & ~1;
-- 
2.17.1

