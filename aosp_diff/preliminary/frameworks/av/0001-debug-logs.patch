From 214a793becc1e81dccac0570d2498988d14b38c1 Mon Sep 17 00:00:00 2001
From: gkdeepa <g.k.deepa@intel.com>
Date: Wed, 11 Aug 2021 15:09:07 +0530
Subject: [PATCH] debug logs

Tracked-On:
---
 0001-buffer-addr-debug (2).patch              | 217 ++++++++++++++++++
 .../device3/Camera3OutputStream.cpp           |  10 +-
 2 files changed, 222 insertions(+), 5 deletions(-)
 create mode 100644 0001-buffer-addr-debug (2).patch

diff --git a/0001-buffer-addr-debug (2).patch b/0001-buffer-addr-debug (2).patch
new file mode 100644
index 0000000000..81afd5ed4e
--- /dev/null
+++ b/0001-buffer-addr-debug (2).patch	
@@ -0,0 +1,217 @@
+From 26d27f53a4a235ffe9bab99c27bf7483c0b410c6 Mon Sep 17 00:00:00 2001
+From: shivasku82 <shiva.kumara.rudrappa@intel.com>
+Date: Fri, 6 Aug 2021 15:23:57 +0530
+Subject: [PATCH] buffer addr debug
+
+Signed-off-by: shivasku82 <shiva.kumara.rudrappa@intel.com>
+
+diff --git a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
+index 01ca0064ec..a2caf8feab 100644
+--- a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
++++ b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
+@@ -16,7 +16,7 @@
+ 
+ #define LOG_TAG "Camera3-OutputStream"
+ #define ATRACE_TAG ATRACE_TAG_CAMERA
+-//#define LOG_NDEBUG 0
++#define LOG_NDEBUG 0
+ 
+ #include <utils/Log.h>
+ #include <utils/Trace.h>
+@@ -165,12 +165,13 @@ status_t Camera3OutputStream::getBufferLocked(camera3_stream_buffer *buffer,
+ 
+     ANativeWindowBuffer* anb;
+     int fenceFd = -1;
+-
++ALOGE("BUFFER_DEBUG getBufferLocked E %p and status %d aquire %d release %d", buffer->buffer, buffer->status, buffer->acquire_fence, buffer->release_fence);
+     status_t res;
+     res = getBufferLockedCommon(&anb, &fenceFd);
+     if (res != OK) {
+         return res;
+     }
++ALOGE("BUFFER_DEBUG getBufferLocked 1 %p ", &(anb->handle));
+ 
+     /**
+      * FenceFD now owned by HAL except in case of error,
+@@ -178,13 +179,15 @@ status_t Camera3OutputStream::getBufferLocked(camera3_stream_buffer *buffer,
+      */
+     handoutBufferLocked(*buffer, &(anb->handle), /*acquireFence*/fenceFd,
+                         /*releaseFence*/-1, CAMERA3_BUFFER_STATUS_OK, /*output*/true);
+-
++    ALOGE("BUFFER_DEBUG handoutBufferLocked %p",&(anb->handle));
+     return OK;
+ }
+ 
+ status_t Camera3OutputStream::queueBufferToConsumer(sp<ANativeWindow>& consumer,
+             ANativeWindowBuffer* buffer, int anwReleaseFence,
+             const std::vector<size_t>&) {
++
++     ALOGE("BUFFER_DEBUG queueBufferToConsumer buffer %p and %s",&(buffer->hanle), consumer.getConsumerName());
+     return consumer->queueBuffer(consumer.get(), buffer, anwReleaseFence);
+ }
+ 
+@@ -192,6 +195,7 @@ status_t Camera3OutputStream::returnBufferLocked(
+         const camera3_stream_buffer &buffer,
+         nsecs_t timestamp, const std::vector<size_t>& surface_ids) {
+     ATRACE_HFR_CALL();
++ALOGE("BUFFER_DEBUG returnBufferLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
+ 
+     status_t res = returnAnyBufferLocked(buffer, timestamp, /*output*/true, surface_ids);
+ 
+@@ -201,7 +205,7 @@ status_t Camera3OutputStream::returnBufferLocked(
+ 
+     mLastTimestamp = timestamp;
+     mFrameCount++;
+-
++    ALOGE("returnBufferLocked mFrameCount %d",mFrameCount);
+     return OK;
+ }
+ 
+@@ -231,8 +235,9 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
+     sp<ANativeWindow> currentConsumer = mConsumer;
+     StreamState state = mState;
+     mLock.unlock();
+-
+     ANativeWindowBuffer *anwBuffer = container_of(buffer.buffer, ANativeWindowBuffer, handle);
++ALOGE("BUFFER_DEBUG returnBufferCheckedLocked E %p", anwBuffer->handle);
++   // memset(buffer.buffer,0x00,640*480*1.5);
+     /**
+      * Return buffer back to ANativeWindow
+      */
+@@ -280,6 +285,7 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
+             return res;
+         }
+ 
++      ALOGE("queueBufferToConsumer returnBufferCheckedLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
+         res = queueBufferToConsumer(currentConsumer, anwBuffer, anwReleaseFence, surface_ids);
+         if (shouldLogError(res, state)) {
+             ALOGE("%s: Stream %d: Error queueing buffer to native window:"
+@@ -287,17 +293,19 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
+         }
+     }
+     mLock.lock();
+-
++    ALOGE(" mLock.lock() called"); 
+     // Once a valid buffer has been returned to the queue, can no longer
+     // dequeue all buffers for preallocation.
+     if (buffer.status != CAMERA3_BUFFER_STATUS_ERROR) {
++        ALOGE("buffer.status != CAMERA3_BUFFER_STATUS_ERROR");
+         mStreamUnpreparable = true;
+     }
+ 
+     if (res != OK) {
++        ALOGE("close(anwReleaseFence)");
+         close(anwReleaseFence);
+     }
+-
++    ALOGE("return res");
+     *releaseFenceOut = releaseFence;
+ 
+     return res;
+@@ -493,6 +501,7 @@ status_t Camera3OutputStream::configureConsumerQueueLocked() {
+     if (mBufferManager != 0 && mSetId > CAMERA3_STREAM_SET_ID_INVALID &&
+             !(isConsumedByHWComposer() || isConsumedByHWTexture())) {
+         uint64_t consumerUsage = 0;
++	ALOGE("BUFFER_DEBUG mBufferManager 1");
+         getEndpointUsage(&consumerUsage);
+         StreamInfo streamInfo(
+                 getId(), getStreamSetId(), getWidth(), getHeight(), getFormat(), getDataSpace(),
+@@ -502,6 +511,8 @@ status_t Camera3OutputStream::configureConsumerQueueLocked() {
+         res = mBufferManager->registerStream(weakThis,
+                 streamInfo);
+         if (res == OK) {
++		        ALOGE("BUFFER_DEBUG mBufferManager setting to true");
++
+             // Disable buffer allocation for this BufferQueue, buffer manager will take over
+             // the buffer allocation responsibility.
+             mConsumer->getIGraphicBufferProducer()->allowAllocation(false);
+@@ -525,7 +536,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
+     }
+ 
+     bool gotBufferFromManager = false;
+-
++ALOGE("BUFFER_DEBUG getBufferLockedCommon anb %p", anb->handle);
+     if (mUseBufferManager) {
+         sp<GraphicBuffer> gb;
+         res = mBufferManager->getBufferForStream(getId(), getStreamSetId(), &gb, fenceFd);
+@@ -533,6 +544,8 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
+             // Attach this buffer to the bufferQueue: the buffer will be in dequeue state after a
+             // successful return.
+             *anb = gb.get();
++	    ALOGE("BUFFER_DEBUG attach buffer anb %p ", anb->handle);
++
+             res = mConsumer->attachBuffer(*anb);
+             if (shouldLogError(res, mState)) {
+                 ALOGE("%s: Stream %d: Can't attach the output buffer to this surface: %s (%d)",
+@@ -543,11 +556,11 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
+                 return res;
+             }
+             gotBufferFromManager = true;
+-            ALOGV("Stream %d: Attached new buffer", getId());
++            ALOGE("Stream %d: Attached new buffer", getId());
+         } else if (res == ALREADY_EXISTS) {
+             // Have sufficient free buffers already attached, can just
+             // dequeue from buffer queue
+-            ALOGV("Stream %d: Reusing attached buffer", getId());
++            ALOGE("Stream %d: Reusing attached buffer", getId());
+             gotBufferFromManager = false;
+         } else if (res != OK) {
+             ALOGE("%s: Stream %d: Can't get next output buffer from buffer manager: %s (%d)",
+@@ -572,6 +585,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
+ 
+         nsecs_t dequeueStart = systemTime(SYSTEM_TIME_MONOTONIC);
+         res = currentConsumer->dequeueBuffer(currentConsumer.get(), anb, fenceFd);
++	ALOGE("BUFFER_DEBUG dequeueBuffer %p", anb->handle);
+         nsecs_t dequeueEnd = systemTime(SYSTEM_TIME_MONOTONIC);
+         mDequeueBufferLatency.add(dequeueStart, dequeueEnd);
+ 
+@@ -588,9 +602,11 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
+                 // Attach this buffer to the bufferQueue: the buffer will be in dequeue state after
+                 // a successful return.
+                 *anb = gb.get();
++		        ALOGE("BUFFER_DEBUG attach buffer %p", anb->handle);
++
+                 res = mConsumer->attachBuffer(*anb);
+                 gotBufferFromManager = true;
+-                ALOGV("Stream %d: Attached new buffer", getId());
++                ALOGE("BUFFER_DEBUG Stream %d: Attached new buffer", getId());
+ 
+                 if (res != OK) {
+                     if (shouldLogError(res, mState)) {
+@@ -798,7 +814,7 @@ void Camera3OutputStream::BufferProducerListener::onBufferReleased() {
+         return;
+     }
+ 
+-    ALOGV("Stream %d: Buffer released", stream->getId());
++    ALOGE("BUFFER_DEBUG Stream %d: Buffer released", stream->getId());
+     bool shouldFreeBuffer = false;
+     status_t res = stream->mBufferManager->onBufferReleased(
+         stream->getId(), stream->getStreamSetId(), &shouldFreeBuffer);
+@@ -850,6 +866,7 @@ void Camera3OutputStream::onBuffersRemovedLocked(
+ 
+ status_t Camera3OutputStream::detachBuffer(sp<GraphicBuffer>* buffer, int* fenceFd) {
+     Mutex::Autolock l(mLock);
++    ALOGE("shiva detachBuffer %p",buffer);
+     return detachBufferLocked(buffer, fenceFd);
+ }
+ 
+@@ -867,7 +884,7 @@ status_t Camera3OutputStream::detachBufferLocked(sp<GraphicBuffer>* buffer, int*
+         // buffer manager that this buffer has been freed. It's not fatal, but should be avoided,
+         // therefore log a warning.
+         *buffer = 0;
+-        ALOGW("%s: the released buffer has already been freed by the buffer queue!", __FUNCTION__);
++        ALOGE("%s: the released buffer has already been freed by the buffer queue!", __FUNCTION__);
+     } else if (res != OK) {
+         // Treat other errors as abandonment
+         if (shouldLogError(res, mState)) {
+@@ -876,6 +893,7 @@ status_t Camera3OutputStream::detachBufferLocked(sp<GraphicBuffer>* buffer, int*
+         mState = STATE_ABANDONED;
+         return res;
+     }
++    ALOGE("shiva detachBufferLocked %p",buffer);
+ 
+     if (fenceFd != nullptr) {
+         if (fence!= 0 && fence->isValid()) {
+-- 
+2.32.0
+
diff --git a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
index a2caf8feab..4cf8c9caab 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
@@ -187,7 +187,7 @@ status_t Camera3OutputStream::queueBufferToConsumer(sp<ANativeWindow>& consumer,
             ANativeWindowBuffer* buffer, int anwReleaseFence,
             const std::vector<size_t>&) {
 
-     ALOGE("BUFFER_DEBUG queueBufferToConsumer buffer %p and %s",&(buffer->hanle), consumer.getConsumerName());
+     ALOGE("BUFFER_DEBUG queueBufferToConsumer buffer %p ",buffer->handle);
     return consumer->queueBuffer(consumer.get(), buffer, anwReleaseFence);
 }
 
@@ -536,7 +536,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
     }
 
     bool gotBufferFromManager = false;
-ALOGE("BUFFER_DEBUG getBufferLockedCommon anb %p", anb->handle);
+ALOGE("BUFFER_DEBUG getBufferLockedCommon anb %p", (*anb)->handle);
     if (mUseBufferManager) {
         sp<GraphicBuffer> gb;
         res = mBufferManager->getBufferForStream(getId(), getStreamSetId(), &gb, fenceFd);
@@ -544,7 +544,7 @@ ALOGE("BUFFER_DEBUG getBufferLockedCommon anb %p", anb->handle);
             // Attach this buffer to the bufferQueue: the buffer will be in dequeue state after a
             // successful return.
             *anb = gb.get();
-	    ALOGE("BUFFER_DEBUG attach buffer anb %p ", anb->handle);
+	    ALOGE("BUFFER_DEBUG attach buffer anb %p ", (*anb)->handle);
 
             res = mConsumer->attachBuffer(*anb);
             if (shouldLogError(res, mState)) {
@@ -585,7 +585,7 @@ ALOGE("BUFFER_DEBUG getBufferLockedCommon anb %p", anb->handle);
 
         nsecs_t dequeueStart = systemTime(SYSTEM_TIME_MONOTONIC);
         res = currentConsumer->dequeueBuffer(currentConsumer.get(), anb, fenceFd);
-	ALOGE("BUFFER_DEBUG dequeueBuffer %p", anb->handle);
+	ALOGE("BUFFER_DEBUG dequeueBuffer %p", (*anb)->handle);
         nsecs_t dequeueEnd = systemTime(SYSTEM_TIME_MONOTONIC);
         mDequeueBufferLatency.add(dequeueStart, dequeueEnd);
 
@@ -602,7 +602,7 @@ ALOGE("BUFFER_DEBUG getBufferLockedCommon anb %p", anb->handle);
                 // Attach this buffer to the bufferQueue: the buffer will be in dequeue state after
                 // a successful return.
                 *anb = gb.get();
-		        ALOGE("BUFFER_DEBUG attach buffer %p", anb->handle);
+		        ALOGE("BUFFER_DEBUG attach buffer %p", (*anb)->handle);
 
                 res = mConsumer->attachBuffer(*anb);
                 gotBufferFromManager = true;
-- 
2.17.1

