From 24a953b57616376795fe92bb1dd0e7fe5df45bc6 Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Fri, 6 Aug 2021 15:23:57 +0530
Subject: [PATCH] buffer addr debug

---
 .../device3/.Camera3StreamSplitter.cpp.swp    | Bin 0 -> 20480 bytes
 .../device3/Camera3OutputStream.cpp           |  32 +++++++++++-------
 .../device3/Camera3StreamSplitter.cpp         |  22 ++++++++----
 3 files changed, 36 insertions(+), 18 deletions(-)
 create mode 100644 services/camera/libcameraservice/device3/.Camera3StreamSplitter.cpp.swp

diff --git a/services/camera/libcameraservice/device3/.Camera3StreamSplitter.cpp.swp b/services/camera/libcameraservice/device3/.Camera3StreamSplitter.cpp.swp
new file mode 100644
index 0000000000000000000000000000000000000000..061340f2e6d616be3d6ad9cadd8cf3754937f525
GIT binary patch
literal 20480
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

literal 0
HcmV?d00001

diff --git a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
index 01ca0064ec..6f7555419b 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
@@ -16,7 +16,7 @@
 
 #define LOG_TAG "Camera3-OutputStream"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <utils/Log.h>
 #include <utils/Trace.h>
@@ -165,7 +165,7 @@ status_t Camera3OutputStream::getBufferLocked(camera3_stream_buffer *buffer,
 
     ANativeWindowBuffer* anb;
     int fenceFd = -1;
-
+ALOGE("BUFFER_DEBUG getBufferLocked E %p and status %d aquire %d release %d", buffer->buffer, buffer->status, buffer->acquire_fence, buffer->release_fence);
     status_t res;
     res = getBufferLockedCommon(&anb, &fenceFd);
     if (res != OK) {
@@ -178,13 +178,14 @@ status_t Camera3OutputStream::getBufferLocked(camera3_stream_buffer *buffer,
      */
     handoutBufferLocked(*buffer, &(anb->handle), /*acquireFence*/fenceFd,
                         /*releaseFence*/-1, CAMERA3_BUFFER_STATUS_OK, /*output*/true);
-
+    ALOGE("handoutBufferLocked %p",&(anb->handle));
     return OK;
 }
 
 status_t Camera3OutputStream::queueBufferToConsumer(sp<ANativeWindow>& consumer,
             ANativeWindowBuffer* buffer, int anwReleaseFence,
             const std::vector<size_t>&) {
+     ALOGE("queueBufferToConsumer buffer %p",buffer);
     return consumer->queueBuffer(consumer.get(), buffer, anwReleaseFence);
 }
 
@@ -192,6 +193,7 @@ status_t Camera3OutputStream::returnBufferLocked(
         const camera3_stream_buffer &buffer,
         nsecs_t timestamp, const std::vector<size_t>& surface_ids) {
     ATRACE_HFR_CALL();
+ALOGE("BUFFER_DEBUG returnBufferLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
 
     status_t res = returnAnyBufferLocked(buffer, timestamp, /*output*/true, surface_ids);
 
@@ -201,7 +203,7 @@ status_t Camera3OutputStream::returnBufferLocked(
 
     mLastTimestamp = timestamp;
     mFrameCount++;
-
+    ALOGE("returnBufferLocked mFrameCount %d",mFrameCount);
     return OK;
 }
 
@@ -231,11 +233,13 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
     sp<ANativeWindow> currentConsumer = mConsumer;
     StreamState state = mState;
     mLock.unlock();
-
     ANativeWindowBuffer *anwBuffer = container_of(buffer.buffer, ANativeWindowBuffer, handle);
+ALOGE("BUFFER_DEBUG returnBufferCheckedLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
     /**
      * Return buffer back to ANativeWindow
      */
+    //memset(buffer.buffer,0x00,640*480*3/2);
+     
     if (buffer.status == CAMERA3_BUFFER_STATUS_ERROR || mDropBuffers || timestamp == 0) {
         // Cancel buffer
         if (mDropBuffers) {
@@ -280,6 +284,7 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
             return res;
         }
 
+      ALOGE("queueBufferToConsumer returnBufferCheckedLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
         res = queueBufferToConsumer(currentConsumer, anwBuffer, anwReleaseFence, surface_ids);
         if (shouldLogError(res, state)) {
             ALOGE("%s: Stream %d: Error queueing buffer to native window:"
@@ -287,17 +292,19 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
         }
     }
     mLock.lock();
-
+    ALOGE(" mLock.lock() called"); 
     // Once a valid buffer has been returned to the queue, can no longer
     // dequeue all buffers for preallocation.
     if (buffer.status != CAMERA3_BUFFER_STATUS_ERROR) {
+        ALOGE("buffer.status != CAMERA3_BUFFER_STATUS_ERROR");
         mStreamUnpreparable = true;
     }
 
     if (res != OK) {
+        ALOGE("close(anwReleaseFence)");
         close(anwReleaseFence);
     }
-
+    ALOGE("return res");
     *releaseFenceOut = releaseFence;
 
     return res;
@@ -543,11 +550,11 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
                 return res;
             }
             gotBufferFromManager = true;
-            ALOGV("Stream %d: Attached new buffer", getId());
+            ALOGE("Stream %d: Attached new buffer", getId());
         } else if (res == ALREADY_EXISTS) {
             // Have sufficient free buffers already attached, can just
             // dequeue from buffer queue
-            ALOGV("Stream %d: Reusing attached buffer", getId());
+            ALOGE("Stream %d: Reusing attached buffer", getId());
             gotBufferFromManager = false;
         } else if (res != OK) {
             ALOGE("%s: Stream %d: Can't get next output buffer from buffer manager: %s (%d)",
@@ -572,6 +579,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
 
         nsecs_t dequeueStart = systemTime(SYSTEM_TIME_MONOTONIC);
         res = currentConsumer->dequeueBuffer(currentConsumer.get(), anb, fenceFd);
+	ALOGE("BUFFER_DEBUG dequeueBuffer 1");
         nsecs_t dequeueEnd = systemTime(SYSTEM_TIME_MONOTONIC);
         mDequeueBufferLatency.add(dequeueStart, dequeueEnd);
 
@@ -590,7 +598,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
                 *anb = gb.get();
                 res = mConsumer->attachBuffer(*anb);
                 gotBufferFromManager = true;
-                ALOGV("Stream %d: Attached new buffer", getId());
+                ALOGE("BUFFER_DEBUG Stream %d: Attached new buffer", getId());
 
                 if (res != OK) {
                     if (shouldLogError(res, mState)) {
@@ -798,7 +806,7 @@ void Camera3OutputStream::BufferProducerListener::onBufferReleased() {
         return;
     }
 
-    ALOGV("Stream %d: Buffer released", stream->getId());
+    ALOGE("BUFFER_DEBUG Stream %d: Buffer released", stream->getId());
     bool shouldFreeBuffer = false;
     status_t res = stream->mBufferManager->onBufferReleased(
         stream->getId(), stream->getStreamSetId(), &shouldFreeBuffer);
@@ -867,7 +875,7 @@ status_t Camera3OutputStream::detachBufferLocked(sp<GraphicBuffer>* buffer, int*
         // buffer manager that this buffer has been freed. It's not fatal, but should be avoided,
         // therefore log a warning.
         *buffer = 0;
-        ALOGW("%s: the released buffer has already been freed by the buffer queue!", __FUNCTION__);
+        ALOGE("%s: the released buffer has already been freed by the buffer queue!", __FUNCTION__);
     } else if (res != OK) {
         // Treat other errors as abandonment
         if (shouldLogError(res, mState)) {
diff --git a/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp b/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
index 5c6c518fae..e0c36e9ddb 100644
--- a/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
+++ b/services/camera/libcameraservice/device3/Camera3StreamSplitter.cpp
@@ -18,7 +18,7 @@
 
 #define LOG_TAG "Camera3StreamSplitter"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <gui/BufferItem.h>
 #include <gui/IGraphicBufferConsumer.h>
@@ -61,6 +61,7 @@ status_t Camera3StreamSplitter::connect(const std::unordered_map<size_t, sp<Surf
 
     mMaxHalBuffers = halMaxBuffers;
     mConsumerName = getUniqueConsumerName();
+    ALOGE("%s halMaxBuffers %zu ", __FUNCTION__,halMaxBuffers);
     // Add output surfaces. This has to be before creating internal buffer queue
     // in order to get max consumer side buffers.
     for (auto &it : surfaces) {
@@ -94,8 +95,9 @@ status_t Camera3StreamSplitter::connect(const std::unordered_map<size_t, sp<Surf
     if (*consumer == nullptr) {
         return NO_MEMORY;
     }
-
-    res = mProducer->setAsyncMode(true);
+//Deepa
+    //res = mProducer->setAsyncMode(true);
+    res = mProducer->setAsyncMode(false);
     if (res != OK) {
         SP_LOGE("%s: Failed to enable input queue async mode: %s(%d)", __FUNCTION__,
                 strerror(-res), res);
@@ -122,7 +124,6 @@ status_t Camera3StreamSplitter::getOnFrameAvailableResult() {
 void Camera3StreamSplitter::disconnect() {
     ATRACE_CALL();
     Mutex::Autolock lock(mMutex);
-
     for (auto& notifier : mNotifiers) {
         sp<IGraphicBufferProducer> producer = notifier.first;
         sp<OutputListener> listener = notifier.second;
@@ -132,6 +133,7 @@ void Camera3StreamSplitter::disconnect() {
 
     for (auto& output : mOutputs) {
         if (output.second != nullptr) {
+ALOGE("%s output.second->disconnect(NATIVE_WINDOW_API_CAMERA) ", __FUNCTION__);
             output.second->disconnect(NATIVE_WINDOW_API_CAMERA);
         }
     }
@@ -172,6 +174,7 @@ status_t Camera3StreamSplitter::addOutput(size_t surfaceId, const sp<Surface>& o
     }
 
     if (mMaxConsumerBuffers > mAcquiredInputBuffers) {
+        ALOGE("%s mMaxConsumerBuffers mMaxConsumerBuffers > mAcquiredInputBuffers ",__FUNCTION__);
         res = mConsumer->setMaxAcquiredBufferCount(mMaxConsumerBuffers);
     }
 
@@ -208,6 +211,7 @@ status_t Camera3StreamSplitter::addOutputLocked(size_t surfaceId, const sp<Surfa
     // Connect to the buffer producer
     sp<OutputListener> listener(new OutputListener(this, gbp));
     IInterface::asBinder(gbp)->linkToDeath(listener);
+    ALOGE("%s outputQueue->connect ",__FUNCTION__);
     res = outputQueue->connect(NATIVE_WINDOW_API_CAMERA, listener);
     if (res != NO_ERROR) {
         SP_LOGE("addOutput: failed to connect (%d)", res);
@@ -249,7 +253,7 @@ status_t Camera3StreamSplitter::addOutputLocked(size_t surfaceId, const sp<Surfa
                 kHalBufMgrDequeueBufferTimeout : kNormalDequeueBufferTimeout;
         outputQueue->setDequeueTimeout(timeout);
     }
-
+    ALOGE("allowAllocation false");
     res = gbp->allowAllocation(false);
     if (res != OK) {
         SP_LOGE("%s: Failed to turn off allocation for outputQueue", __FUNCTION__);
@@ -303,15 +307,19 @@ status_t Camera3StreamSplitter::removeOutputLocked(size_t surfaceId) {
     std::vector<uint64_t> pendingBufferIds;
     auto& outputSlots = *mOutputSlots[gbp];
     for (size_t i = 0; i < outputSlots.size(); i++) {
+          
+            ALOGE("outputSlots.size()outputSlots.size() ptr %zu",outputSlots.size());  
         if (outputSlots[i] != nullptr) {
             pendingBufferIds.push_back(outputSlots[i]->getId());
             auto rc = gbp->detachBuffer(i);
+            ALOGE("outputSlots.size()outputSlots.size() %zu",outputSlots.size());  
             if (rc != NO_ERROR) {
                 //Buffers that fail to detach here will be scheduled for detach in the
                 //input buffer queue and the rest of the registered outputs instead.
                 //This will help ensure that camera stops accessing buffers that still
                 //can get referenced by the disconnected output.
                 mDetachedBuffers.emplace(outputSlots[i]->getId());
+                ALOGE("mDetachedBuffers gbp->detachBuffer %zu",i);  
             }
         }
     }
@@ -336,7 +344,7 @@ status_t Camera3StreamSplitter::removeOutputLocked(size_t surfaceId) {
     mNotifiers[gbp] = nullptr;
     mMaxConsumerBuffers -= mConsumerBufferCount[surfaceId];
     mConsumerBufferCount[surfaceId] = 0;
-
+    ALOGE("mMaxConsumerBuffers at the end %zu",mMaxConsumerBuffers);
     return res;
 }
 
@@ -387,6 +395,7 @@ status_t Camera3StreamSplitter::outputBufferLocked(const sp<IGraphicBufferProduc
     // queue, no onBufferReleased is called by the buffer queue.
     // Proactively trigger the callback to avoid buffer loss.
     if (queueOutput.bufferReplaced) {
+        ALOGE("queueOutput.bufferReplaced is true onBufferReplacedLocked called"); 
         onBufferReplacedLocked(output, surfaceId);
     }
 
@@ -695,6 +704,7 @@ void Camera3StreamSplitter::returnOutputBufferLocked(const sp<Fence>& fence,
     auto detachBuffer = mDetachedBuffers.find(buffer->getId());
     bool detach = (detachBuffer != mDetachedBuffers.end());
     if (detach) {
+        ALOGE("detach is true Detach from producer slot %d",slot);
         auto res = from->detachBuffer(slot);
         if (res == NO_ERROR) {
             outputSlots[slot] = nullptr;
-- 
2.17.1

