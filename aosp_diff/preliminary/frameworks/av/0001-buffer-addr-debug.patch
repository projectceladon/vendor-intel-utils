From 63ceb96b205341fed34f6f4c531fdbff97170b0e Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Fri, 6 Aug 2021 15:23:57 +0530
Subject: [PATCH] buffer addr debug

Signed-off-by: shivasku82 <shiva.kumara.rudrappa@intel.com>

diff --git a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
index 01ca0064ec..3748da79a7 100644
--- a/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
+++ b/services/camera/libcameraservice/device3/Camera3OutputStream.cpp
@@ -16,7 +16,7 @@
 
 #define LOG_TAG "Camera3-OutputStream"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <utils/Log.h>
 #include <utils/Trace.h>
@@ -165,7 +165,7 @@ status_t Camera3OutputStream::getBufferLocked(camera3_stream_buffer *buffer,
 
     ANativeWindowBuffer* anb;
     int fenceFd = -1;
-
+ALOGE("BUFFER_DEBUG getBufferLocked E %p and status %d aquire %d release %d", buffer->buffer, buffer->status, buffer->acquire_fence, buffer->release_fence);
     status_t res;
     res = getBufferLockedCommon(&anb, &fenceFd);
     if (res != OK) {
@@ -178,13 +178,14 @@ status_t Camera3OutputStream::getBufferLocked(camera3_stream_buffer *buffer,
      */
     handoutBufferLocked(*buffer, &(anb->handle), /*acquireFence*/fenceFd,
                         /*releaseFence*/-1, CAMERA3_BUFFER_STATUS_OK, /*output*/true);
-
+    ALOGE("handoutBufferLocked %p",&(anb->handle));
     return OK;
 }
 
 status_t Camera3OutputStream::queueBufferToConsumer(sp<ANativeWindow>& consumer,
             ANativeWindowBuffer* buffer, int anwReleaseFence,
             const std::vector<size_t>&) {
+     ALOGE("queueBufferToConsumer buffer %p",buffer);
     return consumer->queueBuffer(consumer.get(), buffer, anwReleaseFence);
 }
 
@@ -192,6 +193,7 @@ status_t Camera3OutputStream::returnBufferLocked(
         const camera3_stream_buffer &buffer,
         nsecs_t timestamp, const std::vector<size_t>& surface_ids) {
     ATRACE_HFR_CALL();
+ALOGE("BUFFER_DEBUG returnBufferLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
 
     status_t res = returnAnyBufferLocked(buffer, timestamp, /*output*/true, surface_ids);
 
@@ -201,7 +203,7 @@ status_t Camera3OutputStream::returnBufferLocked(
 
     mLastTimestamp = timestamp;
     mFrameCount++;
-
+    ALOGE("returnBufferLocked mFrameCount %d",mFrameCount);
     return OK;
 }
 
@@ -231,8 +233,9 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
     sp<ANativeWindow> currentConsumer = mConsumer;
     StreamState state = mState;
     mLock.unlock();
-
     ANativeWindowBuffer *anwBuffer = container_of(buffer.buffer, ANativeWindowBuffer, handle);
+ALOGE("BUFFER_DEBUG returnBufferCheckedLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
+    memset(buffer.buffer,0x00,640*480*1.5);
     /**
      * Return buffer back to ANativeWindow
      */
@@ -280,6 +283,7 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
             return res;
         }
 
+      ALOGE("queueBufferToConsumer returnBufferCheckedLocked E %p, status %d , acquire fence %d release fence %d", buffer.buffer, buffer.status, buffer.acquire_fence, buffer.release_fence);
         res = queueBufferToConsumer(currentConsumer, anwBuffer, anwReleaseFence, surface_ids);
         if (shouldLogError(res, state)) {
             ALOGE("%s: Stream %d: Error queueing buffer to native window:"
@@ -287,17 +291,19 @@ status_t Camera3OutputStream::returnBufferCheckedLocked(
         }
     }
     mLock.lock();
-
+    ALOGE(" mLock.lock() called"); 
     // Once a valid buffer has been returned to the queue, can no longer
     // dequeue all buffers for preallocation.
     if (buffer.status != CAMERA3_BUFFER_STATUS_ERROR) {
+        ALOGE("buffer.status != CAMERA3_BUFFER_STATUS_ERROR");
         mStreamUnpreparable = true;
     }
 
     if (res != OK) {
+        ALOGE("close(anwReleaseFence)");
         close(anwReleaseFence);
     }
-
+    ALOGE("return res");
     *releaseFenceOut = releaseFence;
 
     return res;
@@ -543,11 +549,11 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
                 return res;
             }
             gotBufferFromManager = true;
-            ALOGV("Stream %d: Attached new buffer", getId());
+            ALOGE("Stream %d: Attached new buffer", getId());
         } else if (res == ALREADY_EXISTS) {
             // Have sufficient free buffers already attached, can just
             // dequeue from buffer queue
-            ALOGV("Stream %d: Reusing attached buffer", getId());
+            ALOGE("Stream %d: Reusing attached buffer", getId());
             gotBufferFromManager = false;
         } else if (res != OK) {
             ALOGE("%s: Stream %d: Can't get next output buffer from buffer manager: %s (%d)",
@@ -572,6 +578,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
 
         nsecs_t dequeueStart = systemTime(SYSTEM_TIME_MONOTONIC);
         res = currentConsumer->dequeueBuffer(currentConsumer.get(), anb, fenceFd);
+	ALOGE("BUFFER_DEBUG dequeueBuffer 1");
         nsecs_t dequeueEnd = systemTime(SYSTEM_TIME_MONOTONIC);
         mDequeueBufferLatency.add(dequeueStart, dequeueEnd);
 
@@ -590,7 +597,7 @@ status_t Camera3OutputStream::getBufferLockedCommon(ANativeWindowBuffer** anb, i
                 *anb = gb.get();
                 res = mConsumer->attachBuffer(*anb);
                 gotBufferFromManager = true;
-                ALOGV("Stream %d: Attached new buffer", getId());
+                ALOGE("BUFFER_DEBUG Stream %d: Attached new buffer", getId());
 
                 if (res != OK) {
                     if (shouldLogError(res, mState)) {
@@ -798,7 +805,7 @@ void Camera3OutputStream::BufferProducerListener::onBufferReleased() {
         return;
     }
 
-    ALOGV("Stream %d: Buffer released", stream->getId());
+    ALOGE("BUFFER_DEBUG Stream %d: Buffer released", stream->getId());
     bool shouldFreeBuffer = false;
     status_t res = stream->mBufferManager->onBufferReleased(
         stream->getId(), stream->getStreamSetId(), &shouldFreeBuffer);
@@ -867,7 +874,7 @@ status_t Camera3OutputStream::detachBufferLocked(sp<GraphicBuffer>* buffer, int*
         // buffer manager that this buffer has been freed. It's not fatal, but should be avoided,
         // therefore log a warning.
         *buffer = 0;
-        ALOGW("%s: the released buffer has already been freed by the buffer queue!", __FUNCTION__);
+        ALOGE("%s: the released buffer has already been freed by the buffer queue!", __FUNCTION__);
     } else if (res != OK) {
         // Treat other errors as abandonment
         if (shouldLogError(res, mState)) {
-- 
2.32.0

