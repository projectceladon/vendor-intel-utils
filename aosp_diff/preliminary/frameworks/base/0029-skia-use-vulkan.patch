From ccba1c06aa1e7eec08bcf5725ada8c1e38cf22ed Mon Sep 17 00:00:00 2001
From: "Li, HaihongX" <haihongx.li@intel.com>
Date: Tue, 11 Mar 2025 05:26:15 +0000
Subject: [PATCH] skia use vulkan

This commit revert d290c36e6e30a2be150605cf8437d36e095e1ab7.
As intel vulkan driver has only 1 render queue.

Signed-off-by: Li, HaihongX <haihongx.li@intel.com>
---
 libs/hwui/Properties.cpp                 | 14 ++++----
 libs/hwui/Properties.h                   |  2 +-
 libs/hwui/renderthread/VulkanManager.cpp | 42 +++++++++++-------------
 libs/hwui/renderthread/VulkanManager.h   | 26 +++++++++++++--
 4 files changed, 51 insertions(+), 33 deletions(-)

diff --git a/libs/hwui/Properties.cpp b/libs/hwui/Properties.cpp
index b6476c9d466f..7b179b401af9 100644
--- a/libs/hwui/Properties.cpp
+++ b/libs/hwui/Properties.cpp
@@ -25,6 +25,7 @@
 #include <optional>
 
 #include "Debug.h"
+#include "log/log_main.h"
 #include "HWUIProperties.sysprop.h"
 #include "src/core/SkTraceEventCommon.h"
 
@@ -252,15 +253,12 @@ RenderPipelineType Properties::getRenderPipelineType() {
     return sRenderPipelineType;
 }
 
-void Properties::overrideRenderPipelineType(RenderPipelineType type) {
+void Properties::overrideRenderPipelineType(RenderPipelineType type, bool inUnitTest) {
     // If we're doing actual rendering then we can't change the renderer after it's been set.
-    // Unit tests can freely change this as often as it wants, though, as there's no actual
-    // GL rendering happening
-    if (sRenderPipelineType != RenderPipelineType::NotInitialized) {
-        LOG_ALWAYS_FATAL_IF(sRenderPipelineType != type,
-                            "Trying to change pipeline but it's already set");
-        return;
-    }
+    // Unit tests can freely change this as often as it wants.
+    LOG_ALWAYS_FATAL_IF(sRenderPipelineType != RenderPipelineType::NotInitialized &&
+                                sRenderPipelineType != type && !inUnitTest,
+                        "Trying to change pipeline but it's already set.");
     sRenderPipelineType = type;
 }
 
diff --git a/libs/hwui/Properties.h b/libs/hwui/Properties.h
index db471527b861..a876c8a7edf2 100644
--- a/libs/hwui/Properties.h
+++ b/libs/hwui/Properties.h
@@ -320,7 +320,7 @@ public:
     static bool enableRTAnimations;
 
     // Used for testing only to change the render pipeline.
-    static void overrideRenderPipelineType(RenderPipelineType);
+    static void overrideRenderPipelineType(RenderPipelineType, bool inUnitTest = false);
 
     static bool runningInEmulator;
 
diff --git a/libs/hwui/renderthread/VulkanManager.cpp b/libs/hwui/renderthread/VulkanManager.cpp
index bae5f8bfdcb8..ad98fda54d4a 100644
--- a/libs/hwui/renderthread/VulkanManager.cpp
+++ b/libs/hwui/renderthread/VulkanManager.cpp
@@ -31,7 +31,7 @@
 #include <include/gpu/ganesh/vk/GrVkTypes.h>
 #include <include/gpu/vk/VulkanBackendContext.h>
 #include <ui/FatVector.h>
-
+#include <cstring>
 #include <sstream>
 
 #include "Properties.h"
@@ -94,6 +94,19 @@ static void free_features_extensions_structs(const VkPhysicalDeviceFeatures2& fe
     }
 }
 
+skgpu::VulkanGetProc VulkanManager::sSkiaGetProp = [](const char* proc_name, VkInstance instance,
+                                             VkDevice device) {
+    if (device != VK_NULL_HANDLE) {
+        if (strcmp("vkQueueSubmit", proc_name) == 0) {
+            return (PFN_vkVoidFunction)VulkanManager::interceptedVkQueueSubmit;
+        } else if (strcmp("vkQueueWaitIdle", proc_name) == 0) {
+            return (PFN_vkVoidFunction)VulkanManager::interceptedVkQueueWaitIdle;
+        }
+        return vkGetDeviceProcAddr(device, proc_name);
+    }
+    return vkGetInstanceProcAddr(instance, proc_name);
+};
+
 #define GET_PROC(F) m##F = (PFN_vk##F)vkGetInstanceProcAddr(VK_NULL_HANDLE, "vk" #F)
 #define GET_INST_PROC(F) m##F = (PFN_vk##F)vkGetInstanceProcAddr(mInstance, "vk" #F)
 #define GET_DEV_PROC(F) m##F = (PFN_vk##F)vkGetDeviceProcAddr(mDevice, "vk" #F)
@@ -129,7 +142,6 @@ VulkanManager::~VulkanManager() {
     }
 
     mGraphicsQueue = VK_NULL_HANDLE;
-    mAHBUploadQueue = VK_NULL_HANDLE;
     mDevice = VK_NULL_HANDLE;
     mPhysicalDevice = VK_NULL_HANDLE;
     mInstance = VK_NULL_HANDLE;
@@ -232,7 +244,7 @@ void VulkanManager::setupDevice(skgpu::VulkanExtensions& grExtensions,
     std::unique_ptr<VkQueueFamilyProperties[]> queueProps(new VkQueueFamilyProperties[queueCount]);
     mGetPhysicalDeviceQueueFamilyProperties(mPhysicalDevice, &queueCount, queueProps.get());
 
-    constexpr auto kRequestedQueueCount = 2;
+    constexpr auto kRequestedQueueCount = 1;
 
     // iterate to find the graphics queue
     mGraphicsQueueIndex = queueCount;
@@ -269,14 +281,7 @@ void VulkanManager::setupDevice(skgpu::VulkanExtensions& grExtensions,
         LOG_ALWAYS_FATAL_IF(!hasKHRSwapchainExtension);
     }
 
-    auto getProc = [](const char* proc_name, VkInstance instance, VkDevice device) {
-        if (device != VK_NULL_HANDLE) {
-            return vkGetDeviceProcAddr(device, proc_name);
-        }
-        return vkGetInstanceProcAddr(instance, proc_name);
-    };
-
-    grExtensions.init(getProc, mInstance, mPhysicalDevice, mInstanceExtensions.size(),
+    grExtensions.init(sSkiaGetProp, mInstance, mPhysicalDevice, mInstanceExtensions.size(),
                       mInstanceExtensions.data(), mDeviceExtensions.size(),
                       mDeviceExtensions.data());
 
@@ -426,7 +431,6 @@ void VulkanManager::initialize() {
         this->setupDevice(mExtensions, mPhysicalDeviceFeatures2);
 
         mGetDeviceQueue(mDevice, mGraphicsQueueIndex, 0, &mGraphicsQueue);
-        mGetDeviceQueue(mDevice, mGraphicsQueueIndex, 1, &mAHBUploadQueue);
 
         if (Properties::enablePartialUpdates && Properties::useBufferAge) {
             mSwapBehavior = SwapBehavior::BufferAge;
@@ -516,24 +520,16 @@ static void onGrContextReleased(void* context) {
 
 sk_sp<GrDirectContext> VulkanManager::createContext(GrContextOptions& options,
                                                     ContextType contextType) {
-    auto getProc = [](const char* proc_name, VkInstance instance, VkDevice device) {
-        if (device != VK_NULL_HANDLE) {
-            return vkGetDeviceProcAddr(device, proc_name);
-        }
-        return vkGetInstanceProcAddr(instance, proc_name);
-    };
-
     skgpu::VulkanBackendContext backendContext;
     backendContext.fInstance = mInstance;
     backendContext.fPhysicalDevice = mPhysicalDevice;
     backendContext.fDevice = mDevice;
-    backendContext.fQueue =
-            (contextType == ContextType::kRenderThread) ? mGraphicsQueue : mAHBUploadQueue;
+    backendContext.fQueue = mGraphicsQueue;
     backendContext.fGraphicsQueueIndex = mGraphicsQueueIndex;
     backendContext.fMaxAPIVersion = mAPIVersion;
     backendContext.fVkExtensions = &mExtensions;
     backendContext.fDeviceFeatures2 = &mPhysicalDeviceFeatures2;
-    backendContext.fGetProc = std::move(getProc);
+    backendContext.fGetProc = sSkiaGetProp;
     backendContext.fDeviceLostContext = nullptr;
     backendContext.fDeviceLostProc = (contextType == ContextType::kRenderThread)
                                              ? deviceLostProcRenderThread
@@ -733,6 +729,7 @@ VulkanManager::VkDrawResult VulkanManager::finishFrame(SkSurface* surface) {
         drawResult.presentFence.reset(fenceFd);
     } else {
         ALOGE("VulkanManager::finishFrame(): Semaphore submission failed");
+        std::lock_guard<std::mutex> lock(mGraphicsQueueMutex);
         mQueueWaitIdle(mGraphicsQueue);
     }
 
@@ -754,6 +751,7 @@ void VulkanManager::swapBuffers(VulkanSurface* surface, const SkRect& dirtyRect,
 void VulkanManager::destroySurface(VulkanSurface* surface) {
     // Make sure all submit commands have finished before starting to destroy objects.
     if (VK_NULL_HANDLE != mGraphicsQueue) {
+        std::lock_guard<std::mutex> lock(mGraphicsQueueMutex);
         mQueueWaitIdle(mGraphicsQueue);
     }
 
diff --git a/libs/hwui/renderthread/VulkanManager.h b/libs/hwui/renderthread/VulkanManager.h
index f0425719ea89..8bf50496f3ec 100644
--- a/libs/hwui/renderthread/VulkanManager.h
+++ b/libs/hwui/renderthread/VulkanManager.h
@@ -17,6 +17,11 @@
 #ifndef VULKANMANAGER_H
 #define VULKANMANAGER_H
 
+#include <functional>
+#include <mutex>
+
+#include "vulkan/vulkan_core.h"
+
 #if !defined(VK_USE_PLATFORM_ANDROID_KHR)
 #define VK_USE_PLATFORM_ANDROID_KHR
 #endif
@@ -26,7 +31,7 @@
 #include <utils/StrongPointer.h>
 #include <vk/VulkanExtensions.h>
 #include <vulkan/vulkan.h>
-
+#include <include/gpu/ganesh/vk/GrVkTypes.h>
 // VK_ANDROID_frame_boundary is a bespoke extension defined by AGI
 // (https://github.com/google/agi) to enable profiling of apps rendering via
 // HWUI. This extension is not defined in Khronos, hence the need to declare it
@@ -189,8 +194,25 @@ private:
     VkDevice mDevice = VK_NULL_HANDLE;
 
     uint32_t mGraphicsQueueIndex;
+
+    std::mutex mGraphicsQueueMutex;
     VkQueue mGraphicsQueue = VK_NULL_HANDLE;
-    VkQueue mAHBUploadQueue = VK_NULL_HANDLE;
+
+    static VKAPI_ATTR VkResult interceptedVkQueueSubmit(VkQueue queue, uint32_t submitCount,
+                                                        const VkSubmitInfo* pSubmits,
+                                                        VkFence fence) {
+        sp<VulkanManager> manager = VulkanManager::getInstance();
+        std::lock_guard<std::mutex> lock(manager->mGraphicsQueueMutex);
+        return manager->mQueueSubmit(queue, submitCount, pSubmits, fence);
+    }
+
+    static VKAPI_ATTR VkResult interceptedVkQueueWaitIdle(VkQueue queue) {
+        sp<VulkanManager> manager = VulkanManager::getInstance();
+        std::lock_guard<std::mutex> lock(manager->mGraphicsQueueMutex);
+        return manager->mQueueWaitIdle(queue);
+    }
+
+    static skgpu::VulkanGetProc sSkiaGetProp;
 
     // Variables saved to populate VkFunctorInitParams.
     static const uint32_t mAPIVersion = VK_MAKE_VERSION(1, 1, 0);
-- 
2.25.1

