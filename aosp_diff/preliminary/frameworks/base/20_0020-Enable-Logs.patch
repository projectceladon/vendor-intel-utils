From 034a501257393ecec4ada253f190a062a786ce43 Mon Sep 17 00:00:00 2001
From: pmandri <padmashree.mandri@intel.com>
Date: Thu, 7 Apr 2022 12:24:27 +0530
Subject: [PATCH] Enable Logs

Tracked-On:
Signed-off-by: pmandri <padmashree.mandri@intel.com>
---
 media/java/android/media/AudioManager.java    |  2 +-
 .../android/server/WiredAccessoryManager.java | 47 +++++++++++++++++--
 .../server/input/InputManagerService.java     |  3 +-
 3 files changed, 45 insertions(+), 7 deletions(-)

diff --git a/media/java/android/media/AudioManager.java b/media/java/android/media/AudioManager.java
index 3b9c05bbe64f..1e03007f26d1 100644
--- a/media/java/android/media/AudioManager.java
+++ b/media/java/android/media/AudioManager.java
@@ -99,7 +99,7 @@ public class AudioManager {
     private boolean mUseFixedVolumeInitialized;
     private boolean mUseFixedVolume;
     private static final String TAG = "AudioManager";
-    private static final boolean DEBUG = false;
+    private static final boolean DEBUG = true;
     private static final AudioPortEventHandler sAudioPortEventHandler = new AudioPortEventHandler();
     private static final AudioVolumeGroupChangeHandler sAudioAudioVolumeGroupChangedHandler =
             new AudioVolumeGroupChangeHandler();
diff --git a/services/core/java/com/android/server/WiredAccessoryManager.java b/services/core/java/com/android/server/WiredAccessoryManager.java
index a233881fdad7..55dc91187385 100755
--- a/services/core/java/com/android/server/WiredAccessoryManager.java
+++ b/services/core/java/com/android/server/WiredAccessoryManager.java
@@ -55,7 +55,7 @@ import java.util.Locale;
  */
 final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     private static final String TAG = WiredAccessoryManager.class.getSimpleName();
-    private static final boolean LOG = false;
+    private static final boolean LOG = true;
 
     private static final int BIT_HEADSET = (1 << 0);
     private static final int BIT_HEADSET_NO_MIC = (1 << 1);
@@ -105,17 +105,22 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     }
 
     private void onSystemReady() {
+        Slog.e(TAG, "in onSystemReady func");
         if (mUseDevInputEventForAudioJack) {
+            Slog.e(TAG, "in onSystemready func mUseDevInputEventForAudioJack ");
             int switchValues = 0;
             if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_HEADPHONE_INSERT)
                     == 1) {
                 switchValues |= SW_HEADPHONE_INSERT_BIT;
+                Slog.e(TAG, "in onSystemready func mUseDevInputEventForAudioJack if 1 ");
             }
             if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_MICROPHONE_INSERT)
                     == 1) {
+                Slog.e(TAG, "in onSystemready func mUseDevInputEventForAudioJack if 2 ");
                 switchValues |= SW_MICROPHONE_INSERT_BIT;
             }
             if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_LINEOUT_INSERT) == 1) {
+                Slog.e(TAG, "in onSystemready func mUseDevInputEventForAudioJack if 3 ");
                 switchValues |= SW_LINEOUT_INSERT_BIT;
             }
             notifyWiredAccessoryChanged(0, switchValues,
@@ -124,12 +129,15 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
 
         if (ExtconUEventObserver.extconExists()) {
+            Slog.e(TAG, "Eneterd ExtconUEventObserver.extconExists");
             if (mUseDevInputEventForAudioJack) {
                 Log.w(TAG, "Both input event and extcon are used for audio jack,"
                         + " please just choose one.");
             }
+            Slog.e(TAG, "Before mExtconObserver.init");
             mExtconObserver.init();
         } else {
+            Slog.e(TAG, "Before mObserver.init");
             mObserver.init();
         }
     }
@@ -149,34 +157,42 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                     (SW_HEADPHONE_INSERT_BIT | SW_MICROPHONE_INSERT_BIT | SW_LINEOUT_INSERT_BIT)) {
                 case 0:
                     headset = 0;
+                    Slog.e(TAG, " case 0 " + headset);
                     break;
 
                 case SW_HEADPHONE_INSERT_BIT:
                     headset = BIT_HEADSET_NO_MIC;
+                    Slog.e(TAG, "notifyWiredAccessory SW_HAEDPHONE_INSERT_BIT " + headset);
                     break;
 
                 case SW_LINEOUT_INSERT_BIT:
                     headset = BIT_LINEOUT;
+                    Slog.e(TAG, "notifyWiredAccessory SW_LINEOUT_INSERT_BIT " + headset);
                     break;
 
                 case SW_HEADPHONE_INSERT_BIT | SW_MICROPHONE_INSERT_BIT:
                     headset = BIT_HEADSET;
+                    Slog.e(TAG, "notifyWiredAccessory SW_HEADPHONE_INSERT_BIT | SW_MICROPHONE_INSERT_BIT " + headset);
                     break;
 
                 case SW_MICROPHONE_INSERT_BIT:
                     headset = BIT_HEADSET;
+                    Slog.e(TAG, "notifyWiredAccessory SW_MICROPHONE_INSERT_BIT " + headset);
                     break;
 
                 case SW_HEADPHONE_INSERT_BIT | SW_LINEOUT_INSERT_BIT:
                     headset = BIT_HEADSET;
+                    Slog.e(TAG, "notifyWiredAccessory SW_HEADPHONE_INSERT_BIT | SW_NINEOUT_INSERT_BIT " + headset);
                     break;
 
                 case SW_HEADPHONE_INSERT_BIT | SW_LINEOUT_INSERT_BIT | SW_MICROPHONE_INSERT_BIT:
                     headset = BIT_HEADSET;
+                    Slog.e(TAG, "notifyWiredAccessory SW_HEADPHONE_INSERT_BIT | SW_LINEOUT_INSERT_BIT | SW_MICROPHONE_INSERT_BIT " + headset);
                     break;
 
                 default:
                     headset = 0;
+                    Slog.e(TAG, "default case hedaset 0 " + headset);
                     break;
             }
 
@@ -221,7 +237,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
         if (mHeadsetState == headsetState) {
             Log.e(TAG, "No state change.");
-            return;
+            //return;
         }
 
         // reject all suspect transitions: only accept state changes from:
@@ -239,7 +255,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
         }
         if (!h2wStateChange && !usbStateChange) {
             Log.e(TAG, "invalid transition, returning ...");
-            return;
+            //return;
         }
 
         mWakeLock.acquire();
@@ -295,17 +311,23 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             }
 
             if (headset == BIT_HEADSET) {
+                Slog.e(TAG, "setDeviceState() BIT_HEADSET: " + headset);
                 outDevice = AudioManager.DEVICE_OUT_WIRED_HEADSET;
                 inDevice = AudioManager.DEVICE_IN_WIRED_HEADSET;
             } else if (headset == BIT_HEADSET_NO_MIC) {
+                Slog.e(TAG, "setDeviceState() BIT_HEADSET_NO_MIC: " + headset);
                 outDevice = AudioManager.DEVICE_OUT_WIRED_HEADPHONE;
             } else if (headset == BIT_LINEOUT) {
+                Slog.e(TAG, "setDeviceState() BIT_LINEOUT: " + headset);
                 outDevice = AudioManager.DEVICE_OUT_LINE;
             } else if (headset == BIT_USB_HEADSET_ANLG) {
+                Slog.e(TAG, "setDeviceState() BIT_USB_HEADSET_ANLG: " + headset);
                 outDevice = AudioManager.DEVICE_OUT_ANLG_DOCK_HEADSET;
             } else if (headset == BIT_USB_HEADSET_DGTL) {
+                Slog.e(TAG, "setDeviceState() BIT_USB_HEADSET_ANLG: " + headset);
                 outDevice = AudioManager.DEVICE_OUT_DGTL_DOCK_HEADSET;
             } else if (headset == BIT_HDMI_AUDIO) {
+                Slog.e(TAG, "setDeviceState() BIT_HDMIA_AUDIO: " + headset);
                 outDevice = AudioManager.DEVICE_OUT_HDMI;
             } else {
                 Slog.e(TAG, "setDeviceState() invalid headset type: " + headset);
@@ -359,8 +381,10 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                         int len = file.read(buffer, 0, 1024);
                         file.close();
                         curState = Integer.parseInt((new String(buffer, 0, len)).trim());
+                        Slog.e(TAG, "UEventObserver fun");
 
                         if (curState > 0) {
+                            Slog.e(TAG, "UEventObserver enetered if case where curState > 0");
                             updateStateLocked(uei.getDevPath(), uei.getDevName(), curState);
                         }
                     } catch (FileNotFoundException e) {
@@ -378,6 +402,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             // observe three UEVENTs
             for (int i = 0; i < mUEventInfo.size(); ++i) {
                 UEventInfo uei = mUEventInfo.get(i);
+                Slog.e(TAG, "UEventInfo : %d\n" + i);
                 startObserving("DEVPATH=" + uei.getDevPath());
             }
         }
@@ -390,6 +415,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             if (!mUseDevInputEventForAudioJack) {
                 uei = new UEventInfo(NAME_H2W, BIT_HEADSET, BIT_HEADSET_NO_MIC, BIT_LINEOUT);
                 if (uei.checkSwitchExists()) {
+                    Slog.e(TAG, "newevent for h2w");
                     retVal.add(uei);
                 } else {
                     Slog.w(TAG, "This kernel does not have wired headset support");
@@ -399,6 +425,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             // Monitor USB
             uei = new UEventInfo(NAME_USB_AUDIO, BIT_USB_HEADSET_ANLG, BIT_USB_HEADSET_DGTL, 0);
             if (uei.checkSwitchExists()) {
+                Slog.e(TAG, "New event for usb");
                 retVal.add(uei);
             } else {
                 Slog.w(TAG, "This kernel does not have usb audio support");
@@ -414,10 +441,13 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             // "hdmi" switch instead.
             uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, BIT_LINEOUT, 0);
             if (uei.checkSwitchExists()) {
+                Slog.e(TAG, "New event for HDMI_audio");
                 retVal.add(uei);
             } else {
                 uei = new UEventInfo(NAME_HDMI, BIT_HDMI_AUDIO, BIT_LINEOUT, 0);
+                Slog.e(TAG, "New event for HDMI");
                 if (uei.checkSwitchExists()) {
+                    Slog.e(TAG, "New event for HDMI");
                     retVal.add(uei);
                 } else {
                     Slog.w(TAG, "This kernel does not have HDMI audio support");
@@ -447,6 +477,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             for (int i = 0; i < mUEventInfo.size(); ++i) {
                 UEventInfo uei = mUEventInfo.get(i);
                 if (devPath.equals(uei.getDevPath())) {
+                   Slog.e(TAG, "upadtestateLocked devpath.equals(uei.getdevPath())");
                     updateLocked(name, uei.computeNewHeadsetState(mHeadsetState, state));
                     return;
                 }
@@ -458,27 +489,32 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             private final int mState1Bits;
             private final int mState2Bits;
             private final int mStateNbits;
-
+            
             public UEventInfo(String devName, int state1Bits, int state2Bits, int stateNbits) {
                 mDevName = devName;
+                Slog.e(TAG, "Entered UEventInfo");
                 mState1Bits = state1Bits;
                 mState2Bits = state2Bits;
                 mStateNbits = stateNbits;
             }
 
             public String getDevName() {
+                Slog.e(TAG, "Entered getDevName");
                 return mDevName;
             }
 
             public String getDevPath() {
+                Slog.e(TAG, "Entered getDevpath");
                 return String.format(Locale.US, "/devices/virtual/switch/%s", mDevName);
             }
 
             public String getSwitchStatePath() {
+                Slog.e(TAG, "Eneterd getSwitchStatePath");
                 return String.format(Locale.US, "/sys/class/switch/%s/state", mDevName);
             }
 
             public boolean checkSwitchExists() {
+                Slog.e(TAG, "Enetered checkSwitchExists");
                 File f = new File(getSwitchStatePath());
                 return f.exists();
             }
@@ -503,12 +539,13 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
         }
 
         private void init() {
+            Slog.e(TAG, "Eneterd WiredAccessoryExtconObserver init()");
             for (ExtconInfo extconInfo : mExtconInfos) {
                 Pair<Integer, Integer> state = null;
                 try {
                     state = parseStateFromFile(extconInfo);
                 } catch (FileNotFoundException e) {
-                    Slog.w(TAG, extconInfo.getStatePath()
+                    Slog.e(TAG, extconInfo.getStatePath()
                             + " not found while attempting to determine initial state", e);
                 } catch (IOException e) {
                     Slog.e(
diff --git a/services/core/java/com/android/server/input/InputManagerService.java b/services/core/java/com/android/server/input/InputManagerService.java
index 6fb9e58a49d1..14b9d6d72095 100644
--- a/services/core/java/com/android/server/input/InputManagerService.java
+++ b/services/core/java/com/android/server/input/InputManagerService.java
@@ -149,7 +149,7 @@ import java.util.Objects;
 public class InputManagerService extends IInputManager.Stub
         implements Watchdog.Monitor {
     static final String TAG = "InputManager";
-    static final boolean DEBUG = false;
+    static final boolean DEBUG = true;
 
     private static final String EXCLUDED_DEVICES_PATH = "etc/excluded-input-devices.xml";
     private static final String PORT_ASSOCIATIONS_PATH = "etc/input-port-associations.xml";
@@ -2675,6 +2675,7 @@ public class InputManagerService extends IInputManager.Stub
         }
 
         if (mUseDevInputEventForAudioJack && (switchMask & SW_JACK_BITS) != 0) {
+            Slog.d(TAG, "mUseDevInputEventForAudioJack && (switchMask & SW_JACK_BITS)");
             mWiredAccessoryCallbacks.notifyWiredAccessoryChanged(whenNanos, switchValues,
                     switchMask);
         }
-- 
2.17.1

