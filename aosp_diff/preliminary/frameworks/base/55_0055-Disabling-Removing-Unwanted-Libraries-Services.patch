From f632d7aa20be9cc311e514a40d8f6b66c4a19bc1 Mon Sep 17 00:00:00 2001
From: Ankit Agarwal <ankit.agarwal@intel.com>
Date: Wed, 17 Aug 2022 08:20:56 +0530
Subject: [PATCH] Disabling/Removing Unwanted Libraries & Services.

Removed Multiple services and binaries as these are not
required when running android on VM.
This have patches from below owner as well-:
Tanuj Tekriwal tanuj.tekriwal@intel.com

Tracked-On:
Signed-off-by: Ankit Agarwal <ankit.agarwal@intel.com>
---
 boot/hiddenapi/hiddenapi-unsupported.txt      |  19 --
 .../android/net/NetworkWatchlistManager.java  |  13 +-
 core/java/android/os/UpdateLock.java          |  12 +-
 .../server/am/ActivityManagerService.java     |  26 +-
 .../location/LocationManagerService.java      |   4 +-
 .../server/pm/PackageManagerService.java      |  11 +-
 .../android/server/pm/UserManagerService.java |   2 +-
 services/core/jni/Android.bp                  |  20 --
 services/core/jni/onload.cpp                  |   6 -
 .../DevicePolicyManagerService.java           |   2 +-
 .../java/com/android/server/SystemServer.java | 240 ++++++++++--------
 11 files changed, 182 insertions(+), 173 deletions(-)

diff --git a/boot/hiddenapi/hiddenapi-unsupported.txt b/boot/hiddenapi/hiddenapi-unsupported.txt
index 002d42dbf1dc..a794463486ee 100644
--- a/boot/hiddenapi/hiddenapi-unsupported.txt
+++ b/boot/hiddenapi/hiddenapi-unsupported.txt
@@ -258,25 +258,6 @@ Lcom/android/internal/statusbar/IStatusBar$Stub;->asInterface(Landroid/os/IBinde
 Lcom/android/internal/statusbar/IStatusBarService$Stub;-><init>()V
 Lcom/android/internal/statusbar/IStatusBarService$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/statusbar/IStatusBarService;
 Lcom/android/internal/telecom/ITelecomService$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telecom/ITelecomService;
-Lcom/android/internal/telephony/IIccPhoneBook$Stub$Proxy;->mRemote:Landroid/os/IBinder;
-Lcom/android/internal/telephony/IIccPhoneBook$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/IIccPhoneBook;
-Lcom/android/internal/telephony/IMms$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/IMms;
-Lcom/android/internal/telephony/IPhoneStateListener$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/IPhoneStateListener;
-Lcom/android/internal/telephony/IPhoneSubInfo$Stub$Proxy;-><init>(Landroid/os/IBinder;)V
-Lcom/android/internal/telephony/IPhoneSubInfo$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/IPhoneSubInfo;
-Lcom/android/internal/telephony/IPhoneSubInfo$Stub;->TRANSACTION_getDeviceId:I
-Lcom/android/internal/telephony/ISms$Stub;-><init>()V
-Lcom/android/internal/telephony/ISms$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/ISms;
-Lcom/android/internal/telephony/ISub$Stub$Proxy;-><init>(Landroid/os/IBinder;)V
-Lcom/android/internal/telephony/ISub$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/ISub;
-Lcom/android/internal/telephony/ITelephony$Stub$Proxy;-><init>(Landroid/os/IBinder;)V
-Lcom/android/internal/telephony/ITelephony$Stub$Proxy;->mRemote:Landroid/os/IBinder;
-Lcom/android/internal/telephony/ITelephony$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/ITelephony;
-Lcom/android/internal/telephony/ITelephony$Stub;->TRANSACTION_call:I
-Lcom/android/internal/telephony/ITelephony$Stub;->TRANSACTION_getDeviceId:I
-Lcom/android/internal/telephony/ITelephonyRegistry$Stub$Proxy;-><init>(Landroid/os/IBinder;)V
-Lcom/android/internal/telephony/ITelephonyRegistry$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/ITelephonyRegistry;
-Lcom/android/internal/telephony/IWapPushManager$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/telephony/IWapPushManager;
 Lcom/android/internal/textservice/ITextServicesManager$Stub$Proxy;-><init>(Landroid/os/IBinder;)V
 Lcom/android/internal/view/IInputMethodManager$Stub$Proxy;-><init>(Landroid/os/IBinder;)V
 Lcom/android/internal/view/IInputMethodManager$Stub;->asInterface(Landroid/os/IBinder;)Lcom/android/internal/view/IInputMethodManager;
diff --git a/core/java/android/net/NetworkWatchlistManager.java b/core/java/android/net/NetworkWatchlistManager.java
index da01dcb83de4..49e6df124e9a 100644
--- a/core/java/android/net/NetworkWatchlistManager.java
+++ b/core/java/android/net/NetworkWatchlistManager.java
@@ -23,6 +23,7 @@ import android.annotation.TestApi;
 import android.content.Context;
 import android.os.RemoteException;
 import android.os.ServiceManager;
+import android.os.ServiceManager.ServiceNotFoundException;
 import android.util.Log;
 
 import com.android.internal.net.INetworkWatchlistManager;
@@ -41,7 +42,7 @@ public class NetworkWatchlistManager {
     private static final String SHARED_MEMORY_TAG = "NETWORK_WATCHLIST_SHARED_MEMORY";
 
     private final Context mContext;
-    private final INetworkWatchlistManager mNetworkWatchlistManager;
+    private INetworkWatchlistManager mNetworkWatchlistManager = null;
 
     /**
      * @hide
@@ -56,9 +57,13 @@ public class NetworkWatchlistManager {
      */
     public NetworkWatchlistManager(Context context) {
         mContext = Preconditions.checkNotNull(context, "missing context");
-        mNetworkWatchlistManager = (INetworkWatchlistManager)
-                INetworkWatchlistManager.Stub.asInterface(
-                        ServiceManager.getService(Context.NETWORK_WATCHLIST_SERVICE));
+	try {
+            mNetworkWatchlistManager = (INetworkWatchlistManager)
+                    INetworkWatchlistManager.Stub.asInterface(
+                            ServiceManager.getService(Context.NETWORK_WATCHLIST_SERVICE));
+	} catch (Exception e) {
+            Log.e(TAG, "cannot find NETWORK_WATCHLIST_SERVICE");
+        }
     }
 
     /**
diff --git a/core/java/android/os/UpdateLock.java b/core/java/android/os/UpdateLock.java
index 5aa9401ddb27..eb8d52cd2fe7 100644
--- a/core/java/android/os/UpdateLock.java
+++ b/core/java/android/os/UpdateLock.java
@@ -162,11 +162,13 @@ public class UpdateLock {
             // if mHeld is true, sService must be non-null
             if (mHeld) {
                 Log.wtf(TAG, "UpdateLock finalized while still held");
-                try {
-                    sService.releaseUpdateLock(mToken);
-                } catch (RemoteException e) {
-                    Log.e(TAG, "Unable to contact service to release");
-                }
+		if (sService != null) {
+                    try {
+                        sService.releaseUpdateLock(mToken);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Unable to contact service to release");
+                    }
+		}
             }
         }
     }
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 32e7ec41992f..9f9f3a6d757b 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -1787,10 +1787,16 @@ public class ActivityManagerService extends IActivityManager.Stub
             ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true,
                     DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);
             ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);
-            ServiceManager.addService("meminfo", new MemBinder(this), /* allowIsolated= */ false,
-                    DUMP_FLAG_PRIORITY_HIGH);
-            ServiceManager.addService("gfxinfo", new GraphicsBinder(this));
-            ServiceManager.addService("dbinfo", new DbBinder(this));
+	    if (SystemProperties.getBoolean("enable.meminfo", false)) {
+                ServiceManager.addService("meminfo", new MemBinder(this), /* allowIsolated= */ false,
+                        DUMP_FLAG_PRIORITY_HIGH);
+	    }
+	    if (SystemProperties.getBoolean("enable.gfxinfo", false)) {
+                ServiceManager.addService("gfxinfo", new GraphicsBinder(this));
+	    }
+	    if (SystemProperties.getBoolean("enable.dbinfo", false)) {
+                ServiceManager.addService("dbinfo", new DbBinder(this));
+	    }
             mAppProfiler.setCpuInfoService();
             ServiceManager.addService("permission", new PermissionController(this));
             ServiceManager.addService("processinfo", new ProcessInfoService(this));
@@ -7529,11 +7535,13 @@ public class ActivityManagerService extends IActivityManager.Stub
             t.traceEnd();
         }
 
-        try {
-            sTheRealBuildSerial = IDeviceIdentifiersPolicyService.Stub.asInterface(
-                    ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE))
-                    .getSerial();
-        } catch (RemoteException e) {}
+	if (SystemProperties.getBoolean("enable.device_identifiers", false)) {
+            try {
+                sTheRealBuildSerial = IDeviceIdentifiersPolicyService.Stub.asInterface(
+                        ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE))
+                        .getSerial();
+            } catch (RemoteException e) {}
+	}
 
         t.traceBegin("killProcesses");
         ArrayList<ProcessRecord> procsToKill = null;
diff --git a/services/core/java/com/android/server/location/LocationManagerService.java b/services/core/java/com/android/server/location/LocationManagerService.java
index e6210b2a8cc9..c39f1563ad11 100644
--- a/services/core/java/com/android/server/location/LocationManagerService.java
+++ b/services/core/java/com/android/server/location/LocationManagerService.java
@@ -426,7 +426,7 @@ public class LocationManagerService extends ILocationManager.Stub implements
 
         // initialize gnss last because it has no awareness of boot phases and blindly assumes that
         // all other location providers are loaded at initialization
-        if (GnssNative.isSupported()) {
+        /*if (GnssNative.isSupported()) {
             GnssConfiguration gnssConfiguration = new GnssConfiguration(mContext);
             GnssNative gnssNative = GnssNative.create(mInjector, gnssConfiguration);
             mGnssManagerService = new GnssManagerService(mContext, mInjector, gnssNative);
@@ -435,7 +435,7 @@ public class LocationManagerService extends ILocationManager.Stub implements
             LocationProviderManager gnssManager = new LocationProviderManager(mContext, mInjector,
                     GPS_PROVIDER, mPassiveManager);
             addLocationProviderManager(gnssManager, mGnssManagerService.getGnssLocationProvider());
-        }
+        }*/
 
         // bind to geocoder provider
         mGeocodeProvider = GeocoderProxy.createAndRegister(mContext);
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index d03aaeea9845..70bf3f3c099d 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -8557,11 +8557,11 @@ public class PackageManagerService extends IPackageManager.Stub
         throw new RuntimeException("There must be exactly one verifier; found " + matches);
     }
 
-    private @NonNull String getRequiredSharedLibraryLPr(String name, int version) {
+    private String getRequiredSharedLibraryLPr(String name, int version) {
         synchronized (mLock) {
             SharedLibraryInfo libraryInfo = getSharedLibraryInfoLPr(name, version);
             if (libraryInfo == null) {
-                throw new IllegalStateException("Missing required shared library:" + name);
+                return null;
             }
             String packageName = libraryInfo.getPackageName();
             if (packageName == null) {
@@ -8599,11 +8599,11 @@ public class PackageManagerService extends IPackageManager.Stub
             }
             return matches.get(0).getComponentInfo().packageName;
         } else {
-            throw new RuntimeException("There must be exactly one installer; found " + matches);
+            return null;
         }
     }
 
-    private @NonNull String getRequiredUninstallerLPr() {
+    private String getRequiredUninstallerLPr() {
         final Intent intent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE);
         intent.addCategory(Intent.CATEGORY_DEFAULT);
         intent.setData(Uri.fromParts(PACKAGE_SCHEME, "foo.bar", null));
@@ -8613,8 +8613,7 @@ public class PackageManagerService extends IPackageManager.Stub
                 UserHandle.USER_SYSTEM);
         if (resolveInfo == null ||
                 mResolveActivity.name.equals(resolveInfo.getComponentInfo().name)) {
-            throw new RuntimeException("There must be exactly one uninstaller; found "
-                    + resolveInfo);
+            return null;
         }
         return resolveInfo.getComponentInfo().packageName;
     }
diff --git a/services/core/java/com/android/server/pm/UserManagerService.java b/services/core/java/com/android/server/pm/UserManagerService.java
index 09c6b50571d4..751c886c198e 100644
--- a/services/core/java/com/android/server/pm/UserManagerService.java
+++ b/services/core/java/com/android/server/pm/UserManagerService.java
@@ -3598,7 +3598,7 @@ public class UserManagerService extends IUserManager.Stub {
 
         DeviceStorageMonitorInternal dsm = LocalServices
                 .getService(DeviceStorageMonitorInternal.class);
-        if (dsm.isMemoryLow()) {
+        if (dsm != null && dsm.isMemoryLow()) {
             throwCheckedUserOperationException("Cannot add user. Not enough space on disk.",
                     UserManager.USER_OPERATION_ERROR_LOW_STORAGE);
         }
diff --git a/services/core/jni/Android.bp b/services/core/jni/Android.bp
index 53401fd47178..04acfb6a9235 100644
--- a/services/core/jni/Android.bp
+++ b/services/core/jni/Android.bp
@@ -30,10 +30,6 @@ cc_library_static {
         "BroadcastRadio/TunerCallback.cpp",
         "BroadcastRadio/convert.cpp",
         "BroadcastRadio/regions.cpp",
-        "gnss/GnssConfiguration.cpp",
-        "gnss/GnssMeasurement.cpp",
-        "gnss/GnssMeasurementCallback.cpp",
-        "gnss/Utils.cpp",
         "stats/SurfaceFlingerPuller.cpp",
         "com_android_server_adb_AdbDebuggingManager.cpp",
         "com_android_server_am_BatteryStatsService.cpp",
@@ -45,7 +41,6 @@ cc_library_static {
         "com_android_server_HardwarePropertiesManagerService.cpp",
         "com_android_server_input_InputManagerService.cpp",
         "com_android_server_lights_LightsService.cpp",
-        "com_android_server_location_GnssLocationProvider.cpp",
         "com_android_server_locksettings_SyntheticPasswordManager.cpp",
         "com_android_server_net_NetworkStatsService.cpp",
         "com_android_server_power_PowerManagerService.cpp",
@@ -65,8 +60,6 @@ cc_library_static {
         "com_android_server_UsbDescriptorParser.cpp",
         "com_android_server_UsbMidiDevice.cpp",
         "com_android_server_UsbHostManager.cpp",
-        "com_android_server_vibrator_VibratorController.cpp",
-        "com_android_server_vibrator_VibratorManagerService.cpp",
         "com_android_server_PersistentDataBlockService.cpp",
         "com_android_server_am_LowMemDetector.cpp",
         "com_android_server_pm_PackageManagerShellCommandDataLoader.cpp",
@@ -117,7 +110,6 @@ cc_defaults {
         "libprocessgroup",
         "libutils",
         "libui",
-        "libvibratorservice",
         "libinput",
         "libinputflinger",
         "libinputflinger_base",
@@ -149,13 +141,6 @@ cc_defaults {
         "android.hardware.broadcastradio@1.0",
         "android.hardware.broadcastradio@1.1",
         "android.hardware.contexthub@1.0",
-        "android.hardware.gnss-V1-cpp",
-        "android.hardware.gnss@1.0",
-        "android.hardware.gnss@1.1",
-        "android.hardware.gnss@2.0",
-        "android.hardware.gnss@2.1",
-        "android.hardware.gnss.measurement_corrections@1.0",
-        "android.hardware.gnss.visibility_control@1.0",
         "android.hardware.graphics.bufferqueue@1.0",
         "android.hardware.input.classifier@1.0",
         "android.hardware.ir@1.0",
@@ -168,11 +153,6 @@ cc_defaults {
         "android.hardware.power.stats-V1-ndk_platform",
         "android.hardware.thermal@1.0",
         "android.hardware.tv.input@1.0",
-        "android.hardware.vibrator-V2-cpp",
-        "android.hardware.vibrator@1.0",
-        "android.hardware.vibrator@1.1",
-        "android.hardware.vibrator@1.2",
-        "android.hardware.vibrator@1.3",
         "android.hardware.vr@1.0",
         "android.hidl.token@1.0-utils",
         "android.frameworks.schedulerservice@1.0",
diff --git a/services/core/jni/onload.cpp b/services/core/jni/onload.cpp
index ff61abc4ff7f..2e615133a742 100644
--- a/services/core/jni/onload.cpp
+++ b/services/core/jni/onload.cpp
@@ -39,9 +39,6 @@ int register_android_server_UsbDeviceManager(JNIEnv* env);
 int register_android_server_UsbMidiDevice(JNIEnv* env);
 int register_android_server_UsbHostManager(JNIEnv* env);
 int register_android_server_vr_VrManagerService(JNIEnv* env);
-int register_android_server_vibrator_VibratorController(JavaVM* vm, JNIEnv* env);
-int register_android_server_vibrator_VibratorManagerService(JavaVM* vm, JNIEnv* env);
-int register_android_server_location_GnssLocationProvider(JNIEnv* env);
 int register_android_server_connectivity_Vpn(JNIEnv* env);
 int register_android_server_devicepolicy_CryptoTestHelper(JNIEnv*);
 int register_android_server_tv_TvUinputBridge(JNIEnv* env);
@@ -91,10 +88,7 @@ extern "C" jint JNI_OnLoad(JavaVM* vm, void* /* reserved */)
     register_android_server_UsbAlsaJackDetector(env);
     register_android_server_UsbHostManager(env);
     register_android_server_vr_VrManagerService(env);
-    register_android_server_vibrator_VibratorController(vm, env);
-    register_android_server_vibrator_VibratorManagerService(vm, env);
     register_android_server_SystemServer(env);
-    register_android_server_location_GnssLocationProvider(env);
     register_android_server_connectivity_Vpn(env);
     register_android_server_devicepolicy_CryptoTestHelper(env);
     register_android_server_ConsumerIrService(env);
diff --git a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
index 0d604c834e3a..e778f508fe77 100644
--- a/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
+++ b/services/devicepolicy/java/com/android/server/devicepolicy/DevicePolicyManagerService.java
@@ -10546,7 +10546,7 @@ public class DevicePolicyManagerService extends BaseIDevicePolicyManager {
                 // UserManagerService.createUserInternalUnchecked.
                 DeviceStorageMonitorInternal deviceStorageMonitorInternal =
                         LocalServices.getService(DeviceStorageMonitorInternal.class);
-                if (deviceStorageMonitorInternal.isMemoryLow()) {
+                if (deviceStorageMonitorInternal != null && deviceStorageMonitorInternal.isMemoryLow()) {
                     if (targetSdkVersion >= Build.VERSION_CODES.P) {
                         throw new ServiceSpecificException(
                                 UserManager.USER_OPERATION_ERROR_LOW_STORAGE, "low device storage");
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 33e32393090e..c609b16534bf 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -1029,9 +1029,11 @@ public final class SystemServer implements Dumpable {
 
         // In some cases after launching an app we need to access device identifiers,
         // therefore register the device identifier policy before the activity manager.
-        t.traceBegin("DeviceIdentifiersPolicyService");
-        mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);
-        t.traceEnd();
+	if (SystemProperties.getBoolean("enable.device_identifiers", true)) {
+            t.traceBegin("DeviceIdentifiersPolicyService");
+            mSystemServiceManager.startService(DeviceIdentifiersPolicyService.class);
+            t.traceEnd();
+	}
 
         // Uri Grants Manager.
         t.traceBegin("UriGrantsManagerService");
@@ -1099,9 +1101,11 @@ public final class SystemServer implements Dumpable {
         t.traceEnd();
 
         // Bring up recovery system in case a rescue party needs a reboot
-        t.traceBegin("StartRecoverySystemService");
-        mSystemServiceManager.startService(RecoverySystemService.Lifecycle.class);
-        t.traceEnd();
+	if (SystemProperties.getBoolean("enable.recovery", true)) {
+            t.traceBegin("StartRecoverySystemService");
+            mSystemServiceManager.startService(RecoverySystemService.Lifecycle.class);
+            t.traceEnd();
+	}
 
         // Now that we have the bare essentials of the OS up and running, take
         // note that we just booted, which might send out a rescue party if
@@ -1286,9 +1290,11 @@ public final class SystemServer implements Dumpable {
         t.traceEnd();
 
         // Tracks cpu time spent in binder calls
-        t.traceBegin("StartBinderCallsStatsService");
-        mSystemServiceManager.startService(BinderCallsStatsService.LifeCycle.class);
-        t.traceEnd();
+	if (SystemProperties.getBoolean("enable.binder_calls_stats", true)) {
+            t.traceBegin("StartBinderCallsStatsService");
+            mSystemServiceManager.startService(BinderCallsStatsService.LifeCycle.class);
+            t.traceEnd();
+	}
 
         // Tracks time spent in handling messages in handlers.
         t.traceBegin("StartLooperStatsService");
@@ -1402,9 +1408,11 @@ public final class SystemServer implements Dumpable {
             ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
             t.traceEnd();
 
-            t.traceBegin("StartTelecomLoaderService");
-            mSystemServiceManager.startService(TelecomLoaderService.class);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.telecom", true)) {
+                t.traceBegin("StartTelecomLoaderService");
+                mSystemServiceManager.startService(TelecomLoaderService.class);
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartTelephonyRegistry");
             telephonyRegistry = new TelephonyRegistry(
@@ -1447,16 +1455,18 @@ public final class SystemServer implements Dumpable {
             mSystemServiceManager.startService(ROLE_SERVICE_CLASS);
             t.traceEnd();
 
-            t.traceBegin("StartVibratorManagerService");
-            mSystemServiceManager.startService(VibratorManagerService.Lifecycle.class);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.vibrator", true)) {
+                t.traceBegin("StartVibratorManagerService");
+                mSystemServiceManager.startService(VibratorManagerService.Lifecycle.class);
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartDynamicSystemService");
             dynamicSystem = new DynamicSystemService(context);
             ServiceManager.addService("dynamic_system", dynamicSystem);
             t.traceEnd();
 
-            if (!isWatch) {
+            if (!isWatch && SystemProperties.getBoolean("enable.consumer_ir", true)) {
                 t.traceBegin("StartConsumerIrService");
                 consumerIr = new ConsumerIrService(context);
                 ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
@@ -1541,13 +1551,17 @@ public final class SystemServer implements Dumpable {
             mSystemServiceManager.startService(IP_CONNECTIVITY_METRICS_CLASS);
             t.traceEnd();
 
-            t.traceBegin("NetworkWatchlistService");
-            mSystemServiceManager.startService(NetworkWatchlistService.Lifecycle.class);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.network_watchlist", true)) {
+                t.traceBegin("NetworkWatchlistService");
+                mSystemServiceManager.startService(NetworkWatchlistService.Lifecycle.class);
+                t.traceEnd();
+	    }
 
-            t.traceBegin("PinnerService");
-            mSystemServiceManager.startService(PinnerService.class);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.pinner", true)) {
+                t.traceBegin("PinnerService");
+                mSystemServiceManager.startService(PinnerService.class);
+                t.traceEnd();
+	    }
 
             t.traceBegin("IorapForwardingService");
             mSystemServiceManager.startService(IorapForwardingService.class);
@@ -1802,14 +1816,16 @@ public final class SystemServer implements Dumpable {
             t.traceEnd();
 
 
-            t.traceBegin("StartIpSecService");
-            try {
-                ipSecService = IpSecService.create(context);
-                ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService);
-            } catch (Throwable e) {
-                reportWtf("starting IpSec Service", e);
-            }
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.ipsec", true)) {
+                t.traceBegin("StartIpSecService");
+                try {
+                    ipSecService = IpSecService.create(context);
+                    ServiceManager.addService(Context.IPSEC_SERVICE, ipSecService);
+                } catch (Throwable e) {
+                    reportWtf("starting IpSec Service", e);
+                }
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartFontManagerService");
             mSystemServiceManager.startService(new FontManagerService.Lifecycle(context, safeMode));
@@ -1936,33 +1952,39 @@ public final class SystemServer implements Dumpable {
             }
             t.traceEnd();
 
-            t.traceBegin("StartNsdService");
-            try {
-                serviceDiscovery = NsdService.create(context);
-                ServiceManager.addService(
-                        Context.NSD_SERVICE, serviceDiscovery);
-            } catch (Throwable e) {
-                reportWtf("starting Service Discovery Service", e);
-            }
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.servicediscovery", true)) {
+                t.traceBegin("StartNsdService");
+                try {
+                    serviceDiscovery = NsdService.create(context);
+                    ServiceManager.addService(
+                            Context.NSD_SERVICE, serviceDiscovery);
+                } catch (Throwable e) {
+                    reportWtf("starting Service Discovery Service", e);
+                }
+                t.traceEnd();
+	    }
 
-            t.traceBegin("StartSystemUpdateManagerService");
-            try {
-                ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE,
-                        new SystemUpdateManagerService(context));
-            } catch (Throwable e) {
-                reportWtf("starting SystemUpdateManagerService", e);
-            }
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.system_update", true)) {
+                t.traceBegin("StartSystemUpdateManagerService");
+                try {
+                    ServiceManager.addService(Context.SYSTEM_UPDATE_SERVICE,
+                            new SystemUpdateManagerService(context));
+                } catch (Throwable e) {
+                    reportWtf("starting SystemUpdateManagerService", e);
+                }
+                t.traceEnd();
+	    }
 
-            t.traceBegin("StartUpdateLockService");
-            try {
-                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE,
-                        new UpdateLockService(context));
-            } catch (Throwable e) {
-                reportWtf("starting UpdateLockService", e);
-            }
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.update_lock", true)) {
+                t.traceBegin("StartUpdateLockService");
+                try {
+                    ServiceManager.addService(Context.UPDATE_LOCK_SERVICE,
+                            new UpdateLockService(context));
+                } catch (Throwable e) {
+                    reportWtf("starting UpdateLockService", e);
+                }
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartNotificationManager");
             mSystemServiceManager.startService(NotificationManagerService.class);
@@ -1972,22 +1994,26 @@ public final class SystemServer implements Dumpable {
                     ServiceManager.getService(Context.NOTIFICATION_SERVICE));
             t.traceEnd();
 
-            t.traceBegin("StartDeviceMonitor");
-            mSystemServiceManager.startService(DeviceStorageMonitorService.class);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.devicestoragemonitor", true)){
+                t.traceBegin("StartDeviceMonitor");
+                mSystemServiceManager.startService(DeviceStorageMonitorService.class);
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartLocationManagerService");
             mSystemServiceManager.startService(LocationManagerService.Lifecycle.class);
             t.traceEnd();
 
-            t.traceBegin("StartCountryDetectorService");
-            try {
-                countryDetector = new CountryDetectorService(context);
-                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
-            } catch (Throwable e) {
-                reportWtf("starting Country Detector", e);
-            }
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.country_detector", true)) {
+                t.traceBegin("StartCountryDetectorService");
+                try {
+                    countryDetector = new CountryDetectorService(context);
+                    ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
+                } catch (Throwable e) {
+                    reportWtf("starting Country Detector", e);
+                }
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartTimeDetectorService");
             try {
@@ -2065,9 +2091,11 @@ public final class SystemServer implements Dumpable {
                 t.traceEnd();
             }
 
-            t.traceBegin("StartDockObserver");
-            mSystemServiceManager.startService(DockObserver.class);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.DockObserver", true)) {
+                t.traceBegin("StartDockObserver");
+                mSystemServiceManager.startService(DockObserver.class);
+                t.traceEnd();
+	    }
 
             if (isWatch) {
                 t.traceBegin("StartThermalObserver");
@@ -2111,7 +2139,7 @@ public final class SystemServer implements Dumpable {
                 t.traceEnd();
             }
 
-            if (!isWatch) {
+            if (!isWatch && SystemProperties.getBoolean("enable.serial", true)) {
                 t.traceBegin("StartSerialService");
                 try {
                     // Serial port support
@@ -2123,15 +2151,17 @@ public final class SystemServer implements Dumpable {
                 t.traceEnd();
             }
 
-            t.traceBegin("StartHardwarePropertiesManagerService");
-            try {
-                hardwarePropertiesService = new HardwarePropertiesManagerService(context);
-                ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE,
-                        hardwarePropertiesService);
-            } catch (Throwable e) {
-                Slog.e(TAG, "Failure starting HardwarePropertiesManagerService", e);
-            }
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.hardware_properties", true)) {
+                t.traceBegin("StartHardwarePropertiesManagerService");
+                try {
+                    hardwarePropertiesService = new HardwarePropertiesManagerService(context);
+                    ServiceManager.addService(Context.HARDWARE_PROPERTIES_SERVICE,
+                            hardwarePropertiesService);
+                } catch (Throwable e) {
+                    Slog.e(TAG, "Failure starting HardwarePropertiesManagerService", e);
+                }
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartTwilightService");
             mSystemServiceManager.startService(TwilightService.class);
@@ -2146,9 +2176,11 @@ public final class SystemServer implements Dumpable {
             mSystemServiceManager.startService(JOB_SCHEDULER_SERVICE_CLASS);
             t.traceEnd();
 
-            t.traceBegin("StartSoundTrigger");
-            mSystemServiceManager.startService(SoundTriggerService.class);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.soundtrigger", true)) {
+                t.traceBegin("StartSoundTrigger");
+                mSystemServiceManager.startService(SoundTriggerService.class);
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartTrustManager");
             mSystemServiceManager.startService(TrustManagerService.class);
@@ -2171,9 +2203,11 @@ public final class SystemServer implements Dumpable {
             // FEATURE_VOICE_RECOGNIZERS feature is set, because it needs to take care
             // of initializing various settings.  It will internally modify its behavior
             // based on that feature.
-            t.traceBegin("StartVoiceRecognitionManager");
-            mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.voiceinteraction", true)) {
+                t.traceBegin("StartVoiceRecognitionManager");
+                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
+                t.traceEnd();
+	    }
 
             t.traceBegin("StartAppHibernationService");
             mSystemServiceManager.startService(APP_HIBERNATION_SERVICE_CLASS);
@@ -2188,19 +2222,21 @@ public final class SystemServer implements Dumpable {
             mSystemServiceManager.startService(SensorNotificationService.class);
             t.traceEnd();
 
-            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_CONTEXT_HUB)) {
+            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_CONTEXT_HUB) || SystemProperties.getBoolean("enable.contexthub", true)) {
                 t.traceBegin("StartContextHubSystemService");
                 mSystemServiceManager.startService(ContextHubSystemService.class);
                 t.traceEnd();
             }
 
-            t.traceBegin("StartDiskStatsService");
-            try {
-                ServiceManager.addService("diskstats", new DiskStatsService(context));
-            } catch (Throwable e) {
-                reportWtf("starting DiskStats Service", e);
-            }
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.diskstats", true)) {
+                t.traceBegin("StartDiskStatsService");
+                try {
+                    ServiceManager.addService("diskstats", new DiskStatsService(context));
+                } catch (Throwable e) {
+                    reportWtf("starting DiskStats Service", e);
+                }
+                t.traceEnd();
+	    }
 
             t.traceBegin("RuntimeService");
             try {
@@ -2258,10 +2294,12 @@ public final class SystemServer implements Dumpable {
             mSystemServiceManager.startService(DreamManagerService.class);
             t.traceEnd();
 
-            t.traceBegin("AddGraphicsStatsService");
-            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE,
-                    new GraphicsStatsService(context));
-            t.traceEnd();
+	    if (SystemProperties.getBoolean("enable.graphicsstats", true)) {
+                t.traceBegin("AddGraphicsStatsService");
+                ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE,
+                        new GraphicsStatsService(context));
+                t.traceEnd();
+	    }
 
             if (CoverageService.ENABLED) {
                 t.traceBegin("AddCoverageService");
@@ -2492,9 +2530,11 @@ public final class SystemServer implements Dumpable {
         }
 
         // MMS service broker
-        t.traceBegin("StartMmsService");
-        mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
-        t.traceEnd();
+	if (SystemProperties.getBoolean("enable.imms", true)) {
+            t.traceBegin("StartMmsService");
+            mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
+            t.traceEnd();
+	}
 
         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_AUTOFILL)) {
             t.traceBegin("StartAutoFillService");
-- 
2.17.1

