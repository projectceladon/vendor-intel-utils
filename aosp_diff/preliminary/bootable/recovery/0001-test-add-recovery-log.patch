From 21e79ce8c972fe3b5c187cbd0e7611e3cbba4241 Mon Sep 17 00:00:00 2001
From: "JianFeng,Zhou" <jianfeng.zhou@intel.com>
Date: Wed, 26 Feb 2020 08:56:50 +0800
Subject: [PATCH] [test] add recovery log

Tracked-On:
Signed-off-by: JianFeng,Zhou <jianfeng.zhou@intel.com>
---
 etc/init.rc       |  8 ++++----
 recovery_main.cpp | 44 ++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 46 insertions(+), 6 deletions(-)
 mode change 100644 => 100755 etc/init.rc
 mode change 100644 => 100755 recovery_main.cpp

diff --git a/etc/init.rc b/etc/init.rc
old mode 100644
new mode 100755
index 0822aba..97d9cf1
--- a/etc/init.rc
+++ b/etc/init.rc
@@ -173,10 +173,10 @@ on property:sys.usb.config=sideload && property:sys.usb.ffs.ready=1 && property:
     setprop sys.usb.state ${sys.usb.config}
 
 on property:sys.usb.config=adb && property:sys.usb.ffs.ready=1 && property:sys.usb.configfs=1
-    write /config/usb_gadget/g1/idProduct 0xD001
-    write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration "adb"
-    symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1
-    write /config/usb_gadget/g1/UDC ${sys.usb.controller}
+#    write /config/usb_gadget/g1/idProduct 0xD001
+#    write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration "adb"
+#    symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f1
+#    write /config/usb_gadget/g1/UDC ${sys.usb.controller}
     setprop sys.usb.state ${sys.usb.config}
 
 on property:sys.usb.config=fastboot && property:sys.usb.ffs.ready=1 && property:sys.usb.configfs=1
diff --git a/recovery_main.cpp b/recovery_main.cpp
old mode 100644
new mode 100755
index de8ac1f..caa54c9
--- a/recovery_main.cpp
+++ b/recovery_main.cpp
@@ -224,11 +224,38 @@ static void ListenRecoverySocket(RecoveryUI* ui, std::atomic<Device::BuiltinActi
   }
 }
 
-static void redirect_stdio(const char* filename) {
+#define TERMINAL "/dev/kmsg"  /* GP tty */
+#include <stdarg.h>
+void kmsg_printf(const char *format, ... )
+{
+        static int terminal_fd = -1;
+        va_list args;
+        int nBuf;
+        char szBuffer[0x800]= "##recy##: ";
+
+        va_start(args, format);
+
+        nBuf = strlen(szBuffer);
+        nBuf += vsnprintf(szBuffer+nBuf, sizeof(szBuffer)-nBuf, format, args);
+
+        if(terminal_fd < 0) {
+                terminal_fd = open(TERMINAL, O_WRONLY);
+        }
+
+        if(terminal_fd >=0)
+                write(terminal_fd, szBuffer, nBuf);
+        fprintf(stderr, "%s", szBuffer);
+//       ALOGE("%s", szBuffer);
+//        va_end(args);
+}
+
+
+void redirect_stdio(const char* filename) {
   android::base::unique_fd pipe_read, pipe_write;
   // Create a pipe that allows parent process sending logs over.
   if (!android::base::Pipe(&pipe_read, &pipe_write)) {
     PLOG(ERROR) << "Failed to create pipe for redirecting stdio";
+	kmsg_printf("Failed to create pipe for redirecting stdio\n");
 
     // Fall back to traditional logging mode without timestamps. If these fail, there's not really
     // anywhere to complain...
@@ -243,7 +270,7 @@ static void redirect_stdio(const char* filename) {
   pid_t pid = fork();
   if (pid == -1) {
     PLOG(ERROR) << "Failed to fork for redirecting stdio";
-
+	kmsg_printf("Failed to fork for redirecting stdio\n");
     // Fall back to traditional logging mode without timestamps. If these fail, there's not really
     // anywhere to complain...
     freopen(filename, "a", stdout);
@@ -264,12 +291,14 @@ static void redirect_stdio(const char* filename) {
     FILE* log_fp = fopen(filename, "ae");
     if (log_fp == nullptr) {
       PLOG(ERROR) << "fopen \"" << filename << "\" failed";
+	  kmsg_printf("fopen '%s' failed\n", filename);
       _exit(EXIT_FAILURE);
     }
 
     FILE* pipe_fp = android::base::Fdopen(std::move(pipe_read), "r");
     if (pipe_fp == nullptr) {
       PLOG(ERROR) << "fdopen failed";
+	  kmsg_printf("fdopen failed\n");
       check_and_fclose(log_fp, filename);
       _exit(EXIT_FAILURE);
     }
@@ -280,6 +309,13 @@ static void redirect_stdio(const char* filename) {
       auto now = std::chrono::steady_clock::now();
       double duration =
           std::chrono::duration_cast<std::chrono::duration<double>>(now - start).count();
+
+      if (line[0] == '\n') {
+        kmsg_printf("[%12.6lf]\n", duration);
+      } else {
+        kmsg_printf("[%12.6lf] %s", duration, line);
+      }
+
       if (line[0] == '\n') {
         fprintf(log_fp, "[%12.6lf]\n", duration);
       } else {
@@ -326,6 +362,10 @@ int main(int argc, char** argv) {
 
   time_t start = time(nullptr);
 
+printf("recovery_start_X ....\n");
+kmsg_printf("recovery start ....\n");
+kmsg_printf("recovery_start_y ....\n");
+
   // redirect_stdio should be called only in non-sideload mode. Otherwise we may have two logger
   // instances with different timestamps.
   redirect_stdio(Paths::Get().temporary_log_file().c_str());
-- 
2.7.4

