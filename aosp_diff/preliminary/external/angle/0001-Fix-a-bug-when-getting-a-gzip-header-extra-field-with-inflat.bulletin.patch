From 28cbea46466a8eb7d12a64a3b3547aeaca19276a Mon Sep 17 00:00:00 2001
From: Sadaf Ebrahimi <sadafebrahimi@google.com>
Date: Thu, 5 Jan 2023 05:02:31 +0000
Subject: [PATCH] Fix a bug when getting a gzip header extra field with
 inflate().

If the extra field was larger than the space the user provided with
inflateGetHeader(), and if multiple calls of inflate() delivered
the extra header data, then there could be a buffer overflow of the
provided space. This commit assures that provided space is not
exceeded.

Bug: http://b/242544249
Test: TreeHugger
Change-Id: I648db086d1e93b9f8b803dd106990afb8cbd2a85
(cherry picked from commit b8b2479b4456ff06b3d5496818b836af1dc88818)
Merged-In: I648db086d1e93b9f8b803dd106990afb8cbd2a85
---
 third_party/zlib/contrib/optimizations/inflate.c | 5 +++--
 third_party/zlib/inflate.c                       | 5 +++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/third_party/zlib/contrib/optimizations/inflate.c b/third_party/zlib/contrib/optimizations/inflate.c
index 81d558bd6..93776ac57 100644
--- a/third_party/zlib/contrib/optimizations/inflate.c
+++ b/third_party/zlib/contrib/optimizations/inflate.c
@@ -771,8 +771,9 @@ int flush;
                 if (copy > have) copy = have;
                 if (copy) {
                     if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
+                        state->head->extra != Z_NULL &&
+                        (len = state->head->extra_len - state->length) <
+                            state->head->extra_max) {
                         zmemcpy(state->head->extra + len, next,
                                 len + copy > state->head->extra_max ?
                                 state->head->extra_max - len : copy);
diff --git a/third_party/zlib/inflate.c b/third_party/zlib/inflate.c
index 68902e81b..9057a574b 100644
--- a/third_party/zlib/inflate.c
+++ b/third_party/zlib/inflate.c
@@ -760,8 +760,9 @@ int flush;
                 if (copy > have) copy = have;
                 if (copy) {
                     if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL) {
-                        len = state->head->extra_len - state->length;
+                        state->head->extra != Z_NULL &&
+                        (len = state->head->extra_len - state->length) <
+                            state->head->extra_max) {
                         zmemcpy(state->head->extra + len, next,
                                 len + copy > state->head->extra_max ?
                                 state->head->extra_max - len : copy);
-- 
2.39.1.456.gfc5497dd1b-goog

