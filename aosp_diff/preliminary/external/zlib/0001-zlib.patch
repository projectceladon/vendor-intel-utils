From 213e2efa4cd01c5daf031ea7defadabf1ce9660f Mon Sep 17 00:00:00 2001
From: jaishank <jaishankar.rajendran@intel.com>
Date: Fri, 18 Oct 2019 13:41:04 +0530
Subject: [PATCH] zlib

Tracked-On:
Signed-off-by: jaishank <jaishankar.rajendran@intel.com>
---
 src/deflate.c | 23 ++++++++++++++---------
 1 file changed, 14 insertions(+), 9 deletions(-)

diff --git a/src/deflate.c b/src/deflate.c
index 7f2c8a2..14a2d96 100644
--- a/src/deflate.c
+++ b/src/deflate.c
@@ -1243,6 +1243,7 @@ local uInt longest_match(s, cur_match)
     register int len;                           /* length of current match */
     int best_len = (int)s->prev_length;         /* best match length so far */
     int nice_match = s->nice_match;             /* stop if match long enough */
+    int flag;
     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
         s->strstart - (IPos)MAX_DIST(s) : NIL;
     /* Stop when cur_match becomes <= limit. To simplify the code,
@@ -1296,8 +1297,9 @@ local uInt longest_match(s, cur_match)
         /* This code assumes sizeof(unsigned short) == 2. Do not use
          * UNALIGNED_OK if your compiler uses a different size.
          */
-        if (*(ushf*)(match+best_len-1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
+        if (*(ushf*)match != scan_start ||
+            *(ushf*)(match+best_len-1) != scan_end
+            ) continue;
 
         /* It is not necessary to compare scan[2] and match[2] since they are
          * always equal when the other bytes match, given that the hash keys
@@ -1327,10 +1329,11 @@ local uInt longest_match(s, cur_match)
 
 #else /* UNALIGNED_OK */
 
-        if (match[best_len]   != scan_end  ||
-            match[best_len-1] != scan_end1 ||
-            *match            != *scan     ||
-            *++match          != scan[1])      continue;
+        if (*match            != *scan     ||
+            *++match          != scan[1]	 ||
+            match[best_len]   != scan_end  ||
+            match[best_len-1] != scan_end1
+            )      continue;
 
         /* The check at best_len-1 can be removed because it will be made
          * again later. (This heuristic is not always a win.)
@@ -1359,9 +1362,10 @@ local uInt longest_match(s, cur_match)
 #endif /* UNALIGNED_OK */
 
         if (len > best_len) {
+					  if (len >= nice_match) break;
             s->match_start = cur_match;
             best_len = len;
-            if (len >= nice_match) break;
+
 #ifdef UNALIGNED_OK
             scan_end = *(ushf*)(scan+best_len-1);
 #else
@@ -1369,9 +1373,10 @@ local uInt longest_match(s, cur_match)
             scan_end   = scan[best_len];
 #endif
         }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
+        flag = ((cur_match = prev[cur_match & wmask]) > limit);
+    } while (flag && --chain_length != 0);
 
+		best_len = len;
     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
     return s->lookahead;
 }
-- 
2.7.4

