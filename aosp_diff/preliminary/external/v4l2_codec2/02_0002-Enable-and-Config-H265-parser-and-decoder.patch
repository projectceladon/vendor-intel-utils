From 32ef582b895ad4f0b053d9dbd33a5fedfd2f02ac Mon Sep 17 00:00:00 2001
From: Shaofeng Tang <shaofeng.tang@intel.com>
Date: Tue, 12 Oct 2021 16:02:21 +0800
Subject: [PATCH 2/2] Enable and Config H265 parser and decoder

Add the parameter and max output delay for H265 decoder
And enable H265 decoder

Signed-off-by: Shaofeng Tang <shaofeng.tang@intel.com>
---
 common/V4L2ComponentCommon.cpp                |  4 +-
 common/VideoTypes.cpp                         |  2 +
 .../v4l2_codec2/common/V4L2ComponentCommon.h  |  2 +
 .../include/v4l2_codec2/common/VideoTypes.h   |  1 +
 components/V4L2DecodeComponent.cpp            | 98 +++++++++++++++----
 components/V4L2DecodeInterface.cpp            | 34 +++++++
 components/V4L2Decoder.cpp                    |  2 +
 store/V4L2ComponentStore.cpp                  |  2 +
 8 files changed, 127 insertions(+), 18 deletions(-)

diff --git a/common/V4L2ComponentCommon.cpp b/common/V4L2ComponentCommon.cpp
index 86448a8..ebac296 100644
--- a/common/V4L2ComponentCommon.cpp
+++ b/common/V4L2ComponentCommon.cpp
@@ -14,9 +14,11 @@ namespace android {
 const std::string V4L2ComponentName::kH264Encoder = "c2.v4l2.avc.encoder";
 
 const std::string V4L2ComponentName::kH264Decoder = "c2.v4l2.avc.decoder";
+const std::string V4L2ComponentName::kH265Decoder = "c2.v4l2.hevc.decoder";
 const std::string V4L2ComponentName::kVP8Decoder = "c2.v4l2.vp8.decoder";
 const std::string V4L2ComponentName::kVP9Decoder = "c2.v4l2.vp9.decoder";
 const std::string V4L2ComponentName::kH264SecureDecoder = "c2.v4l2.avc.decoder.secure";
+const std::string V4L2ComponentName::kH265SecureDecoder = "c2.v4l2.hevc.decoder.secure";
 const std::string V4L2ComponentName::kVP8SecureDecoder = "c2.v4l2.vp8.decoder.secure";
 const std::string V4L2ComponentName::kVP9SecureDecoder = "c2.v4l2.vp9.decoder.secure";
 
@@ -24,7 +26,7 @@ const std::string V4L2ComponentName::kVP9SecureDecoder = "c2.v4l2.vp9.decoder.se
 bool V4L2ComponentName::isValid(const char* name) {
     return name == kH264Encoder || name == kH264Decoder || name == kVP8Decoder ||
            name == kVP9Decoder || name == kH264SecureDecoder || name == kVP8SecureDecoder ||
-           name == kVP9SecureDecoder;
+           name == kVP9SecureDecoder || name == kH265Decoder || name == kH265SecureDecoder;
 }
 
 // static
diff --git a/common/VideoTypes.cpp b/common/VideoTypes.cpp
index 1ecceca..7afadd0 100644
--- a/common/VideoTypes.cpp
+++ b/common/VideoTypes.cpp
@@ -15,6 +15,8 @@ const char* VideoCodecToString(VideoCodec codec) {
     switch (codec) {
     case VideoCodec::H264:
         return "H264";
+    case VideoCodec::H265:
+        return "H265";
     case VideoCodec::VP8:
         return "VP8";
     case VideoCodec::VP9:
diff --git a/common/include/v4l2_codec2/common/V4L2ComponentCommon.h b/common/include/v4l2_codec2/common/V4L2ComponentCommon.h
index 6e3efa8..92c0b9f 100644
--- a/common/include/v4l2_codec2/common/V4L2ComponentCommon.h
+++ b/common/include/v4l2_codec2/common/V4L2ComponentCommon.h
@@ -14,9 +14,11 @@ struct V4L2ComponentName {
     static const std::string kH264Encoder;
 
     static const std::string kH264Decoder;
+    static const std::string kH265Decoder;
     static const std::string kVP8Decoder;
     static const std::string kVP9Decoder;
     static const std::string kH264SecureDecoder;
+    static const std::string kH265SecureDecoder;
     static const std::string kVP8SecureDecoder;
     static const std::string kVP9SecureDecoder;
 
diff --git a/common/include/v4l2_codec2/common/VideoTypes.h b/common/include/v4l2_codec2/common/VideoTypes.h
index a5130d2..5d51c52 100644
--- a/common/include/v4l2_codec2/common/VideoTypes.h
+++ b/common/include/v4l2_codec2/common/VideoTypes.h
@@ -15,6 +15,7 @@ namespace android {
 // Enumeration of supported video codecs.
 enum class VideoCodec {
     H264,
+    H265,
     VP8,
     VP9,
 };
diff --git a/components/V4L2DecodeComponent.cpp b/components/V4L2DecodeComponent.cpp
index 1ea9a7b..b72b88f 100644
--- a/components/V4L2DecodeComponent.cpp
+++ b/components/V4L2DecodeComponent.cpp
@@ -24,6 +24,8 @@
 #include <media/stagefright/foundation/ColorUtils.h>
 
 #include <h264_parser.h>
+#include <h265_parser.h>
+#include <h265_nalu_parser.h>
 #include <v4l2_codec2/common/VideoTypes.h>
 #include <v4l2_codec2/components/BitstreamBuffer.h>
 #include <v4l2_codec2/components/V4L2Decoder.h>
@@ -40,12 +42,7 @@ int32_t frameIndexToBitstreamId(c2_cntr64_t frameIndex) {
     return static_cast<int32_t>(frameIndex.peeku() & 0x3FFFFFFF);
 }
 
-bool parseCodedColorAspects(const C2ConstLinearBlock& input,
-                            C2StreamColorAspectsInfo::input* codedAspects) {
-    C2ReadView view = input.map().get();
-    const uint8_t* data = view.data();
-    const uint32_t size = view.capacity();
-
+bool parseAvcSPS(const uint8_t* data, const uint32_t size, const media::H264SPS* sps){
     std::unique_ptr<media::H264Parser> h264Parser = std::make_unique<media::H264Parser>();
     h264Parser->SetStream(data, static_cast<off_t>(size));
     media::H264NALU nalu;
@@ -65,17 +62,83 @@ bool parseCodedColorAspects(const C2ConstLinearBlock& input,
         ALOGE("H264 ParseSPS error: %d", static_cast<int>(parRes));
         return false;
     }
+    sps = h264Parser->GetSPS(spsId);
+    return true;
+}
+
+bool parseHevcSPS(const uint8_t* data, const uint32_t size, const media::H265SPS* sps){
+    std::unique_ptr<media::H265Parser> h265Parser = std::make_unique<media::H265Parser>();
+    h265Parser->SetStream(data, static_cast<off_t>(size));
+    media::H265NALU nalu;
+    media::H265Parser::Result parRes = h265Parser->AdvanceToNextNALU(&nalu);
+    if (parRes != media::H265Parser::kEOStream && parRes != media::H265Parser::kOk) {
+        ALOGE("H264 AdvanceToNextNALU error: %d", static_cast<int>(parRes));
+        return false;
+    }
+    if (nalu.nal_unit_type != media::H265NALU::SPS_NUT) {
+        ALOGV("NALU is not SPS");
+        return false;
+    }
+
+    int spsId;
+    parRes = h265Parser->ParseSPS(&spsId);
+    if (parRes != media::H265Parser::kEOStream && parRes != media::H265Parser::kOk) {
+        ALOGE("H265 ParseSPS error: %d", static_cast<int>(parRes));
+        return false;
+    }
+    sps = h265Parser->GetSPS(spsId);
+    return true;
+}
+
+bool getSPSParams(std::optional<VideoCodec> codec, const uint8_t* data, const uint32_t size,
+	          int32_t *primaries, int32_t *transfer, int32_t *coeffs, bool *fullRange){
+    if (codec == VideoCodec::H264) {
+	const media::H264SPS *sps = nullptr;
+	if (!parseAvcSPS(data, size, sps)) {
+            return false;
+	}
+	if (!sps->colour_description_present_flag) {
+	    ALOGV("No Color Description in SPS");
+            return false;
+        }
+        *primaries = sps->colour_primaries;
+        *transfer = sps->transfer_characteristics;
+        *coeffs = sps->matrix_coefficients;
+        *fullRange = sps->video_full_range_flag;
+    } else if (codec == VideoCodec::H265) {
+        const media::H265SPS *sps = nullptr;
+        if (!parseHevcSPS(data, size, sps)) {
+            return false;
+        }
+        if (!sps->vui_parameters.colour_description_present_flag) {
+            ALOGV("No Color Description in SPS");
+            return false;
+        }
+        *primaries = sps->vui_parameters.colour_primaries;
+        *transfer = sps->vui_parameters.transfer_characteristics;
+        *coeffs = sps->vui_parameters.matrix_coeffs;
+        *fullRange = sps->vui_parameters.video_full_range_flag;
+    }
+    return true;
+}
+
+bool parseCodedColorAspects(const C2ConstLinearBlock& input,
+                            C2StreamColorAspectsInfo::input* codedAspects,
+			    std::optional<VideoCodec> codec) {
+    C2ReadView view = input.map().get();
+    const uint8_t* data = view.data();
+    const uint32_t size = view.capacity();
+
+    // Parse ISO color aspects from H264/H265 SPS bitstream.
+    int32_t primaries = 0;
+    int32_t transfer = 0;
+    int32_t coeffs = 0;
+    bool fullRange = false;
 
-    // Parse ISO color aspects from H264 SPS bitstream.
-    const media::H264SPS* sps = h264Parser->GetSPS(spsId);
-    if (!sps->colour_description_present_flag) {
-        ALOGV("No Color Description in SPS");
+    if (!getSPSParams(codec, data, size, &primaries, &transfer, &coeffs, &fullRange)) {
+	ALOGV("Unable to get SPS from bitstream");
         return false;
     }
-    int32_t primaries = sps->colour_primaries;
-    int32_t transfer = sps->transfer_characteristics;
-    int32_t coeffs = sps->matrix_coefficients;
-    bool fullRange = sps->video_full_range_flag;
 
     // Convert ISO color aspects to ColorUtils::ColorAspects.
     ColorAspects colorAspects;
@@ -237,7 +300,7 @@ void V4L2DecodeComponent::startTask(c2_status_t* status) {
     }
 
     // Get default color aspects on start.
-    if (!mIsSecure && *codec == VideoCodec::H264) {
+    if (!mIsSecure && (*codec == VideoCodec::H264 || *codec == VideoCodec::H265)) {
         if (mIntfImpl->queryColorAspects(&mCurrentColorAspects) != C2_OK) return;
         mPendingColorAspectsChange = false;
     }
@@ -434,9 +497,10 @@ void V4L2DecodeComponent::pumpPendingWorks() {
             ALOG_ASSERT(linearBlock.size() > 0u, "Input buffer of work(%d) is empty.", bitstreamId);
 
             // Try to parse color aspects from bitstream for CSD work of non-secure H264 codec.
-            if (isCSDWork && !mIsSecure && (mIntfImpl->getVideoCodec() == VideoCodec::H264)) {
+            if (isCSDWork && !mIsSecure && (mIntfImpl->getVideoCodec() == VideoCodec::H264 ||
+				    mIntfImpl->getVideoCodec() == VideoCodec::H265)) {
                 C2StreamColorAspectsInfo::input codedAspects = {0u};
-                if (parseCodedColorAspects(linearBlock, &codedAspects)) {
+                if (parseCodedColorAspects(linearBlock, &codedAspects, mIntfImpl->getVideoCodec())) {
                     std::vector<std::unique_ptr<C2SettingResult>> failures;
                     c2_status_t status =
                             mIntfImpl->config({&codedAspects}, C2_MAY_BLOCK, &failures);
diff --git a/components/V4L2DecodeInterface.cpp b/components/V4L2DecodeInterface.cpp
index a09fcc4..3b0e736 100644
--- a/components/V4L2DecodeInterface.cpp
+++ b/components/V4L2DecodeInterface.cpp
@@ -30,6 +30,8 @@ constexpr size_t kInputBufferSizeFor4K = 4 * kInputBufferSizeFor1080p;
 std::optional<VideoCodec> getCodecFromComponentName(const std::string& name) {
     if (name == V4L2ComponentName::kH264Decoder || name == V4L2ComponentName::kH264SecureDecoder)
         return VideoCodec::H264;
+    if (name == V4L2ComponentName::kH265Decoder || name == V4L2ComponentName::kH265SecureDecoder)
+        return VideoCodec::H265;
     if (name == V4L2ComponentName::kVP8Decoder || name == V4L2ComponentName::kVP8SecureDecoder)
         return VideoCodec::VP8;
     if (name == V4L2ComponentName::kVP9Decoder || name == V4L2ComponentName::kVP9SecureDecoder)
@@ -58,6 +60,9 @@ uint32_t getOutputDelay(VideoCodec codec) {
         // codec2 framework that it should not stop queuing new work items until the maximum number
         // of frame reordering is reached, to avoid stalling the decoder.
         return 16;
+    case VideoCodec::H265:
+        // Set it as same as the max output delay in H265 soft, as same as H264
+        return 16;
     case VideoCodec::VP8:
         return 0;
     case VideoCodec::VP9:
@@ -167,6 +172,35 @@ V4L2DecodeInterface::V4L2DecodeInterface(const std::string& name,
                         .build());
         break;
 
+    case VideoCodec::H265:
+        inputMime = MEDIA_MIMETYPE_VIDEO_HEVC;
+        addParameter(
+                DefineParam(mProfileLevel, C2_PARAMKEY_PROFILE_LEVEL)
+                        .withDefault(new C2StreamProfileLevelInfo::input(
+                                0u, C2Config::PROFILE_HEVC_MAIN, C2Config::LEVEL_HEVC_MAIN_5_1))
+                        .withFields({C2F(mProfileLevel, profile)
+                                             .oneOf({C2Config::PROFILE_HEVC_MAIN,
+                                                     C2Config::PROFILE_HEVC_MAIN_STILL}),
+                                     C2F(mProfileLevel, level)
+                                             .oneOf({C2Config::LEVEL_HEVC_MAIN_1,
+                                                     C2Config::LEVEL_HEVC_MAIN_2,
+                                                     C2Config::LEVEL_HEVC_MAIN_2_1,
+                                                     C2Config::LEVEL_HEVC_MAIN_3,
+                                                     C2Config::LEVEL_HEVC_MAIN_3_1,
+                                                     C2Config::LEVEL_HEVC_MAIN_4,
+                                                     C2Config::LEVEL_HEVC_MAIN_4_1,
+                                                     C2Config::LEVEL_HEVC_MAIN_5,
+                                                     C2Config::LEVEL_HEVC_MAIN_5_1,
+                                                     C2Config::LEVEL_HEVC_MAIN_5_2,
+                                                     C2Config::LEVEL_HEVC_HIGH_4,
+                                                     C2Config::LEVEL_HEVC_HIGH_4_1,
+                                                     C2Config::LEVEL_HEVC_HIGH_5,
+                                                     C2Config::LEVEL_HEVC_HIGH_5_1,
+                                                     C2Config::LEVEL_HEVC_HIGH_5_2})})
+                        .withSetter(ProfileLevelSetter)
+                        .build());
+        break;
+
     case VideoCodec::VP8:
         inputMime = MEDIA_MIMETYPE_VIDEO_VP8;
         addParameter(DefineParam(mProfileLevel, C2_PARAMKEY_PROFILE_LEVEL)
diff --git a/components/V4L2Decoder.cpp b/components/V4L2Decoder.cpp
index d52bd6c..8bfbb05 100644
--- a/components/V4L2Decoder.cpp
+++ b/components/V4L2Decoder.cpp
@@ -31,6 +31,8 @@ uint32_t VideoCodecToV4L2PixFmt(VideoCodec codec) {
         return V4L2_PIX_FMT_VP8;
     case VideoCodec::VP9:
         return V4L2_PIX_FMT_VP9;
+    case VideoCodec::H265:
+        return V4L2_PIX_FMT_HEVC;
     }
 }
 
diff --git a/store/V4L2ComponentStore.cpp b/store/V4L2ComponentStore.cpp
index 8942866..dc2db87 100644
--- a/store/V4L2ComponentStore.cpp
+++ b/store/V4L2ComponentStore.cpp
@@ -110,7 +110,9 @@ std::vector<std::shared_ptr<const C2Component::Traits>> V4L2ComponentStore::list
     std::vector<std::shared_ptr<const C2Component::Traits>> ret;
     ret.push_back(GetTraits(V4L2ComponentName::kH264Encoder));
     ret.push_back(GetTraits(V4L2ComponentName::kH264Decoder));
+    ret.push_back(GetTraits(V4L2ComponentName::kH265Decoder));
     ret.push_back(GetTraits(V4L2ComponentName::kH264SecureDecoder));
+    ret.push_back(GetTraits(V4L2ComponentName::kH265SecureDecoder));
     ret.push_back(GetTraits(V4L2ComponentName::kVP8Decoder));
     ret.push_back(GetTraits(V4L2ComponentName::kVP8SecureDecoder));
     ret.push_back(GetTraits(V4L2ComponentName::kVP9Decoder));
-- 
2.29.2

