From 741e111bec9b889ee2f6646c60590f475f04a7be Mon Sep 17 00:00:00 2001
From: "wei, wushuangx" <wushuangx.wei@intel.com>
Date: Wed, 22 Jun 2022 18:24:30 +0800
Subject: [PATCH] Add dumpBuffer feature in drm-hwc

Enable dumpBuffer for debug purpose. when necessary, DumpBuffer() function is called to execute.
After "setenforce 0" is executed in the shell, dumpfiles will be generated in the /data/local/tarce directory

Tracked-On: OAM-102488
Signed-off-by: wei, wushuangx <wushuangx.wei@intel.com>
---
 bufferinfo/legacy/BufferInfoMinigbm.cpp | 90 ++++++++++++++++++++++++-
 bufferinfo/legacy/BufferInfoMinigbm.h   | 57 ++++++++++++++++
 2 files changed, 146 insertions(+), 1 deletion(-)

diff --git a/bufferinfo/legacy/BufferInfoMinigbm.cpp b/bufferinfo/legacy/BufferInfoMinigbm.cpp
index d030dff..c62ca78 100644
--- a/bufferinfo/legacy/BufferInfoMinigbm.cpp
+++ b/bufferinfo/legacy/BufferInfoMinigbm.cpp
@@ -55,4 +55,92 @@ int BufferInfoMinigbm::ConvertBoInfo(buffer_handle_t handle, hwc_drm_bo_t *bo) {
   return 0;
 }
 
-}  // namespace android
+void BufferInfoMinigbm::DumpBuffer(buffer_handle_t handle) {
+  if (NULL == handle)
+    return;
+  char dump_file[256] = {0};
+  cros_drm_handle *drm_handle = (cros_drm_handle *)handle;
+  buffer_handle_t handle_copy;
+  uint8_t* pixels = nullptr;
+
+  struct dri2_drm_display *dri_drm;
+  gralloc1_rect_t accessRegion;
+  hw_device_t *device;
+
+  dri_drm = (dri2_drm_display *)calloc(1, sizeof(*dri_drm));
+  if (!dri_drm)
+    return;
+
+  dri_drm->fd = -1;
+  int ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID,
+                      (const hw_module_t **)&dri_drm->gralloc);
+  if (ret) {
+    return;
+  }
+
+  dri_drm->gralloc_version = dri_drm->gralloc->common.module_api_version;
+  if (dri_drm->gralloc_version == HARDWARE_MODULE_API_VERSION(1, 0)) {
+    ret = dri_drm->gralloc->common.methods->open(&dri_drm->gralloc->common, GRALLOC_HARDWARE_MODULE_ID, &device);
+    if (ret) {
+      ALOGE("Failed to open device");
+      return;
+    } else {
+      dri_drm->gralloc1_dvc = (gralloc1_device_t *)device;
+      dri_drm->pfn_lock = (GRALLOC1_PFN_LOCK)dri_drm->gralloc1_dvc->getFunction(dri_drm->gralloc1_dvc, GRALLOC1_FUNCTION_LOCK);
+      dri_drm->pfn_importBuffer = (GRALLOC1_PFN_IMPORT_BUFFER)dri_drm->gralloc1_dvc->getFunction(dri_drm->gralloc1_dvc,GRALLOC1_FUNCTION_IMPORT_BUFFER);
+      dri_drm->pfn_release = (GRALLOC1_PFN_RELEASE)dri_drm->gralloc1_dvc->getFunction(dri_drm->gralloc1_dvc, GRALLOC1_FUNCTION_RELEASE);
+      dri_drm->pfn_unlock = (GRALLOC1_PFN_UNLOCK)dri_drm->gralloc1_dvc->getFunction(dri_drm->gralloc1_dvc, GRALLOC1_FUNCTION_UNLOCK);
+    }
+  }
+
+  if (!dri_drm->pfn_importBuffer) {
+    ALOGE("Gralloc does not support importBuffer");
+    return;
+  }
+  ret = dri_drm->pfn_importBuffer(dri_drm->gralloc1_dvc, handle, &handle_copy);
+  if (ret) {
+    ALOGE("Gralloc importBuffer failed");
+    return;
+  }
+
+  if (!dri_drm->pfn_lock) {
+    ALOGE("Gralloc does not support lock");
+    return;
+  }
+  ret = dri_drm->pfn_lock(dri_drm->gralloc1_dvc, handle_copy,
+                                    0, 0, &accessRegion, reinterpret_cast<void**>(&pixels), -1);
+  if (ret) {
+    ALOGE("gralloc->lock failed: %d", ret);
+    return;
+  } else {
+    char ctime[32];
+    time_t t = time(0);
+    static int i = 0;
+    if (i >= 1000)
+      i = 0;
+    strftime(ctime, sizeof(ctime), "%Y-%m-%d", localtime(&t));
+    sprintf(dump_file, "/data/local/traces/dump_%dx%d_0x%x_%s_%d", drm_handle->width, drm_handle->height, drm_handle->format, ctime,i++);
+    int file_fd = 0;
+    file_fd = open(dump_file, O_RDWR|O_CREAT, 0666);
+    if (file_fd == -1) {
+      ALOGE("Failed to open %s while dumping", dump_file);
+    } else {
+      write(file_fd, pixels, drm_handle->sizes[0]);
+      close(file_fd);
+    }
+
+    int outReleaseFence = 0;
+    dri_drm->pfn_unlock(dri_drm->gralloc1_dvc, handle_copy, &outReleaseFence);
+    if (!dri_drm->pfn_release) {
+      ALOGE("Gralloc does not support release");
+      return;
+    }
+    ret = dri_drm->pfn_release(dri_drm->gralloc1_dvc, handle_copy);
+    if (ret) {
+      ALOGE("Gralloc release failed");
+      return;
+    }
+  }
+}
+
+}  // namespace android
\ No newline at end of file
diff --git a/bufferinfo/legacy/BufferInfoMinigbm.h b/bufferinfo/legacy/BufferInfoMinigbm.h
index bff9d74..167e243 100644
--- a/bufferinfo/legacy/BufferInfoMinigbm.h
+++ b/bufferinfo/legacy/BufferInfoMinigbm.h
@@ -18,15 +18,72 @@
 #define BUFFERINFOMINIGBM_H_
 
 #include <hardware/gralloc.h>
+#include <hardware/gralloc1.h>
 
 #include "bufferinfo/BufferInfoGetter.h"
 
+#define DRV_MAX_PLANES 4
+#define DRV_MAX_FDS (DRV_MAX_PLANES + 1)
+
+struct cros_drm_handle {
+	native_handle_t base;
+	int32_t fds[DRV_MAX_FDS];
+	uint32_t strides[DRV_MAX_PLANES];
+	uint32_t offsets[DRV_MAX_PLANES];
+	uint32_t sizes[DRV_MAX_PLANES];
+	bool from_kms;
+	uint32_t id;
+	uint32_t width;
+	uint32_t height;
+	uint32_t format; /* DRM format */
+	uint64_t format_modifier;
+	uint64_t use_flags; /* Buffer creation flags */
+	uint32_t magic;
+	uint32_t pixel_stride;
+	int32_t droid_format;
+	int32_t usage; /* Android usage. */
+	uint32_t num_planes;
+	uint64_t reserved_region_size;
+	uint64_t total_size; /* Total allocation size */
+	uint32_t name_offset;
+#ifdef USE_GRALLOC1
+	uint32_t consumer_usage;
+	uint32_t producer_usage;
+	uint32_t yuv_color_range;   // YUV Color range.
+	uint32_t is_updated;        // frame updated flag
+	uint32_t is_encoded;        // frame encoded flag
+	uint32_t is_encrypted;
+	uint32_t is_key_frame;
+	uint32_t is_interlaced;
+	uint32_t is_mmc_capable;
+	uint32_t compression_mode;
+	uint32_t compression_hint;
+	uint32_t codec;
+	uint32_t tiling_mode;
+	uint32_t format_modifiers[2 * DRV_MAX_PLANES];
+#endif
+}__attribute__((packed));
+
+struct dri2_drm_display
+{
+   int fd;
+   const gralloc_module_t *gralloc;
+   uint16_t gralloc_version;
+   gralloc1_device_t *gralloc1_dvc;
+   GRALLOC1_PFN_LOCK pfn_lock;
+   GRALLOC1_PFN_GET_FORMAT pfn_getFormat;
+   GRALLOC1_PFN_UNLOCK pfn_unlock;
+   GRALLOC1_PFN_IMPORT_BUFFER pfn_importBuffer;
+   GRALLOC1_PFN_RELEASE pfn_release;
+};
+
 namespace android {
 
 class BufferInfoMinigbm : public LegacyBufferInfoGetter {
  public:
   using LegacyBufferInfoGetter::LegacyBufferInfoGetter;
   int ConvertBoInfo(buffer_handle_t handle, hwc_drm_bo_t *bo) override;
+  static void DumpBuffer(buffer_handle_t handle);
 };
 
 }  // namespace android
-- 
2.36.0

