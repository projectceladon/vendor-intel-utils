From 71c86f25d526e80567380e6bb66e69c32ef2e36f Mon Sep 17 00:00:00 2001
From: Grant Menke <grantmenke@google.com>
Date: Thu, 9 Jan 2025 14:32:14 -0800
Subject: [PATCH] Ensure ScheduledExecutor is not shutdown before scheduling
 timeout cleanup.

The scheduled executor in ConnectionServiceWrapper may be shutdown when calling createConference and createCall. This is infrequently causing a `RejectedExecutionException`. This CL adds a check that mScheduledExecutor is not shutdown before scheduling the cleanup.

Flag: EXEMPT Security High/Critical Severity CVE
Bug: 388588560
Test: manually using the provided apk + atest CallsManagerTest
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:dd63d318cf090ca2d458f772e2799614e6068006)
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:ef6f10655531a06d2814c3fad25eb7cd1e117581)
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:5f4dfa3ead83c0b1eb9999b0389468d28347d167)
Merged-In: I0aaa0f7f57b8dd137403b6ceb7068e7c99652e1f
Change-Id: I0aaa0f7f57b8dd137403b6ceb7068e7c99652e1f
---
 .../telecom/ConnectionServiceWrapper.java     | 42 ++++++++++++++-----
 1 file changed, 31 insertions(+), 11 deletions(-)

diff --git a/src/com/android/server/telecom/ConnectionServiceWrapper.java b/src/com/android/server/telecom/ConnectionServiceWrapper.java
index f1b059352..868af7be1 100755
--- a/src/com/android/server/telecom/ConnectionServiceWrapper.java
+++ b/src/com/android/server/telecom/ConnectionServiceWrapper.java
@@ -66,6 +66,7 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
@@ -777,7 +778,6 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
                         statusHints.setIcon(StatusHints.validateAccountIconUserBoundary(
                                 icon, callingUserHandle));
                     }
-                    Call call = mCallIdMapper.getCall(callId);
                     if (call != null) {
                         call.setStatusHints(statusHints);
                     }
@@ -1388,11 +1388,21 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
                         }
                     }
                 };
-                // Post cleanup to the executor service and cache the future, so we can cancel it if
-                // needed.
-                ScheduledFuture<?> future = mScheduledExecutor.schedule(r.getRunnableToCancel(),
-                        SERVICE_BINDING_TIMEOUT, TimeUnit.MILLISECONDS);
-                mScheduledFutureMap.put(call, future);
+                if (mScheduledExecutor != null && !mScheduledExecutor.isShutdown()) {
+                    try {
+                        // Post cleanup to the executor service and cache the future,
+                        // so we can cancel it if needed.
+                        ScheduledFuture<?> future = mScheduledExecutor.schedule(
+                                r.getRunnableToCancel(),SERVICE_BINDING_TIMEOUT,
+                                TimeUnit.MILLISECONDS);
+                        mScheduledFutureMap.put(call, future);
+                    } catch (RejectedExecutionException e) {
+                        Log.e(this, e, "createConference: mScheduledExecutor was "
+                                + "already shutdown");
+                    }
+                } else {
+                    Log.w(this, "createConference: Scheduled executor is null or shutdown");
+                }
                 try {
                     mServiceInterface.createConference(
                             call.getConnectionManagerPhoneAccount(),
@@ -1509,11 +1519,21 @@ public class ConnectionServiceWrapper extends ServiceBinder implements
                         }
                     }
                 };
-                // Post cleanup to the executor service and cache the future, so we can cancel it if
-                // needed.
-                ScheduledFuture<?> future = mScheduledExecutor.schedule(r.getRunnableToCancel(),
-                        SERVICE_BINDING_TIMEOUT, TimeUnit.MILLISECONDS);
-                mScheduledFutureMap.put(call, future);
+                if (mScheduledExecutor != null && !mScheduledExecutor.isShutdown()) {
+                    try {
+                        // Post cleanup to the executor service and cache the future,
+                        // so we can cancel it if needed.
+                        ScheduledFuture<?> future = mScheduledExecutor.schedule(
+                                r.getRunnableToCancel(),SERVICE_BINDING_TIMEOUT,
+                                TimeUnit.MILLISECONDS);
+                        mScheduledFutureMap.put(call, future);
+                    } catch (RejectedExecutionException e) {
+                        Log.e(this, e, "createConnection: mScheduledExecutor was "
+                                + "already shutdown");
+                    }
+                } else {
+                    Log.w(this, "createConnection: Scheduled executor is null or shutdown");
+                }
                 try {
                     mServiceInterface.createConnection(
                             call.getConnectionManagerPhoneAccount(),
-- 
2.34.1

