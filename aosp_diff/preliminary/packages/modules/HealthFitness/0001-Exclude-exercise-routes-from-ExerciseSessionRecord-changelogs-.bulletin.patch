From 178f4824574fdf33ed4ac584d092240d1c771b04 Mon Sep 17 00:00:00 2001
From: Roman Didukh <rdidukh@google.com>
Date: Mon, 9 Oct 2023 18:39:54 +0000
Subject: [PATCH] Exclude exercise routes from ExerciseSessionRecord
 changelogs.

Routes are directly accessible from changelogs only by
  - the app which wrote the route.
  - apps which hold READ_EXERCISE_ROUTE signature permission.

Bug: 303664370, 303871379
Test: Added unit and CTS tests. Tested manually.
(cherry picked from https://googleplex-android-review.googlesource.com/q/commit:69c320af3eff7e5b094c235a49e98d0e64fc26a3)
Merged-In: I5ab3835a2ff451ef4ed18863858bb86af6a455c8
Change-Id: I5ab3835a2ff451ef4ed18863858bb86af6a455c8
---
 .../recentaccess/RecentAccessViewModelTest.kt |   2 +-
 .../datatypes/ExerciseSessionRecord.java      |   1 +
 .../HealthConnectServiceImpl.java             |  42 +--
 .../permission/DataPermissionEnforcer.java    |  25 +-
 .../datatypehelpers/AppInfoHelper.java        |   5 +
 .../ExerciseSessionRecordHelper.java          |  66 +++--
 .../storage/datatypehelpers/RecordHelper.java |  21 +-
 .../request/ReadTransactionRequest.java       |  15 +-
 .../testhelper/HealthConnectUiTestHelper.kt   |   1 +
 .../cts/device/ExerciseRouteAccessTest.java   | 265 +++++++++++++++++-
 .../healthconnect/cts/lib/TestUtils.java      |   5 +-
 11 files changed, 381 insertions(+), 67 deletions(-)

diff --git a/apk/tests/src/com/android/healthconnect/controller/tests/recentaccess/RecentAccessViewModelTest.kt b/apk/tests/src/com/android/healthconnect/controller/tests/recentaccess/RecentAccessViewModelTest.kt
index c7f7107a..46f02003 100644
--- a/apk/tests/src/com/android/healthconnect/controller/tests/recentaccess/RecentAccessViewModelTest.kt
+++ b/apk/tests/src/com/android/healthconnect/controller/tests/recentaccess/RecentAccessViewModelTest.kt
@@ -419,7 +419,7 @@ class RecentAccessViewModelTest {
 
         fakeRecentAccessUseCase.updateList(accessLogs)
         viewModel.loadRecentAccessApps(timeSource = timeSource)
-        val actual = viewModel.recentAccessApps.getOrAwaitValue(time = 5, callsCount = 2)
+        val actual = viewModel.recentAccessApps.getOrAwaitValue(callsCount = 2)
         val expected =
             listOf(
                 RecentAccessEntry(
diff --git a/framework/java/android/health/connect/datatypes/ExerciseSessionRecord.java b/framework/java/android/health/connect/datatypes/ExerciseSessionRecord.java
index eaceb07f..9975479f 100644
--- a/framework/java/android/health/connect/datatypes/ExerciseSessionRecord.java
+++ b/framework/java/android/health/connect/datatypes/ExerciseSessionRecord.java
@@ -409,6 +409,7 @@ public final class ExerciseSessionRecord extends IntervalRecord {
             recordInternal.setTitle(getTitle().toString());
         }
 
+        recordInternal.setHasRoute(hasRoute());
         if (getRoute() != null) {
             recordInternal.setRoute(getRoute().toRouteInternal());
         }
diff --git a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java
index 3075d155..578db339 100644
--- a/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java
+++ b/service/java/com/android/server/healthconnect/HealthConnectServiceImpl.java
@@ -157,6 +157,7 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.Set;
+import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.stream.Collectors;
 
@@ -540,7 +541,7 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {
                                 Collections.unmodifiableMap(
                                         mDataPermissionEnforcer
                                                 .collectExtraReadPermissionToStateMapping(
-                                                        request.getRecordType(),
+                                                        Set.of(request.getRecordType()),
                                                         attributionSource));
 
                         Trace.traceBegin(TRACE_TAG_READ, TAG_READ);
@@ -846,9 +847,10 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {
             IChangeLogsResponseCallback callback) {
         final int uid = Binder.getCallingUid();
         final UserHandle userHandle = Binder.getCallingUserHandle();
+        final String callerPackageName = Objects.requireNonNull(attributionSource.getPackageName());
         final HealthConnectServiceLogger.Builder builder =
                 new HealthConnectServiceLogger.Builder(false, GET_CHANGES)
-                        .setPackageName(attributionSource.getPackageName());
+                        .setPackageName(callerPackageName);
 
         HealthConnectThreadScheduler.schedule(
                 mContext,
@@ -881,12 +883,22 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {
                                 ChangeLogsHelper.getInstance()
                                         .getChangeLogs(changeLogsTokenRequest, token);
 
+                        Map<Integer, List<UUID>> recordTypeToInsertedUuids =
+                                ChangeLogsHelper.getRecordTypeToInsertedUuids(
+                                        changeLogsResponse.getChangeLogsMap());
+
+                        Map<String, Boolean> extraReadPermsToGrantState =
+                                mDataPermissionEnforcer.collectExtraReadPermissionToStateMapping(
+                                        recordTypeToInsertedUuids.keySet(), attributionSource);
+
                         List<RecordInternal<?>> recordInternals =
                                 mTransactionManager.readRecords(
                                         new ReadTransactionRequest(
-                                                ChangeLogsHelper.getRecordTypeToInsertedUuids(
-                                                        changeLogsResponse.getChangeLogsMap()),
-                                                startDateAccess));
+                                                callerPackageName,
+                                                recordTypeToInsertedUuids,
+                                                startDateAccess,
+                                                extraReadPermsToGrantState));
+
                         List<DeletedLog> deletedLogs =
                                 ChangeLogsHelper.getDeletedLogs(
                                         changeLogsResponse.getChangeLogsMap());
@@ -1629,14 +1641,11 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {
         } catch (SecurityException | IllegalStateException e) {
             Log.e(TAG, "Exception encountered while staging", e);
             try {
-                @HealthConnectException.ErrorCode int errorCode =
-                        (e instanceof SecurityException) ? ERROR_SECURITY : ERROR_INTERNAL;
-                exceptionsByFileName.put("", new HealthConnectException(
-                        errorCode,
-                        e.getMessage()));
+                @HealthConnectException.ErrorCode
+                int errorCode = (e instanceof SecurityException) ? ERROR_SECURITY : ERROR_INTERNAL;
+                exceptionsByFileName.put("", new HealthConnectException(errorCode, e.getMessage()));
 
-                callback.onError(
-                        new StageRemoteDataException(exceptionsByFileName));
+                callback.onError(new StageRemoteDataException(exceptionsByFileName));
             } catch (RemoteException remoteException) {
                 Log.e(TAG, "Restore permission response could not be sent to the caller.", e);
             }
@@ -1744,15 +1753,12 @@ final class HealthConnectServiceImpl extends IHealthConnectService.Stub {
                     });
         } catch (SecurityException | IllegalStateException e) {
             Log.e(TAG, "getHealthConnectDataState: Exception encountered", e);
-            @HealthConnectException.ErrorCode int errorCode =
-                    (e instanceof SecurityException) ? ERROR_SECURITY
-                            : ERROR_INTERNAL;
+            @HealthConnectException.ErrorCode
+            int errorCode = (e instanceof SecurityException) ? ERROR_SECURITY : ERROR_INTERNAL;
             try {
                 callback.onError(
                         new HealthConnectExceptionParcel(
-                                new HealthConnectException(
-                                        errorCode,
-                                        e.getMessage())));
+                                new HealthConnectException(errorCode, e.getMessage())));
             } catch (RemoteException remoteException) {
                 Log.e(TAG, "getHealthConnectDataState error could not be sent", e);
             }
diff --git a/service/java/com/android/server/healthconnect/permission/DataPermissionEnforcer.java b/service/java/com/android/server/healthconnect/permission/DataPermissionEnforcer.java
index 2ea5c2cd..82b8c861 100644
--- a/service/java/com/android/server/healthconnect/permission/DataPermissionEnforcer.java
+++ b/service/java/com/android/server/healthconnect/permission/DataPermissionEnforcer.java
@@ -18,6 +18,8 @@ package com.android.server.healthconnect.permission;
 
 import static android.content.pm.PackageManager.PERMISSION_GRANTED;
 
+import static java.util.stream.Collectors.toMap;
+
 import android.annotation.NonNull;
 import android.content.AttributionSource;
 import android.content.Context;
@@ -36,6 +38,7 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Function;
 
 /**
  * Helper class to force caller of data apis to hold api required permissions.
@@ -150,18 +153,16 @@ public class DataPermissionEnforcer {
      * doesn't have corresponding permission.
      */
     public Map<String, Boolean> collectExtraReadPermissionToStateMapping(
-            int recordTypeId, AttributionSource attributionSource) {
-        RecordHelper<?> recordHelper =
-                RecordHelperProvider.getInstance().getRecordHelper(recordTypeId);
-        if (recordHelper.getExtraReadPermissions().isEmpty()) {
-            return Collections.emptyMap();
-        }
-
-        Map<String, Boolean> mapping = new ArrayMap<>();
-        for (String permissionName : recordHelper.getExtraReadPermissions()) {
-            mapping.put(permissionName, isPermissionGranted(permissionName, attributionSource));
-        }
-        return mapping;
+            Set<Integer> recordTypeIds, AttributionSource attributionSource) {
+        RecordHelperProvider recordHelperProvider = RecordHelperProvider.getInstance();
+        return recordTypeIds.stream()
+                .map(recordHelperProvider::getRecordHelper)
+                .flatMap(recordHelper -> recordHelper.getExtraReadPermissions().stream())
+                .distinct()
+                .collect(
+                        toMap(
+                                Function.identity(),
+                                permission -> isPermissionGranted(permission, attributionSource)));
     }
 
     public Map<String, Boolean> collectExtraWritePermissionStateMapping(
diff --git a/service/java/com/android/server/healthconnect/storage/datatypehelpers/AppInfoHelper.java b/service/java/com/android/server/healthconnect/storage/datatypehelpers/AppInfoHelper.java
index 56bd1ae9..7dc25c1c 100644
--- a/service/java/com/android/server/healthconnect/storage/datatypehelpers/AppInfoHelper.java
+++ b/service/java/com/android/server/healthconnect/storage/datatypehelpers/AppInfoHelper.java
@@ -100,6 +100,7 @@ public final class AppInfoHelper {
      * <p>TO HAVE THREAD SAFETY DON'T USE THESE VARIABLES DIRECTLY, INSTEAD USE ITS GETTER
      */
     private volatile ConcurrentHashMap<Long, String> mIdPackageNameMap;
+
     /**
      * Map to store application package-name -> AppInfo mapping (such as packageName -> appName,
      * icon, rowId in the DB etc.)
@@ -222,6 +223,10 @@ public final class AppInfoHelper {
      * @return id of {@code packageName} or {@link Constants#DEFAULT_LONG} if the id is not found
      */
     public long getAppInfoId(String packageName) {
+        if (packageName == null) {
+            return DEFAULT_LONG;
+        }
+
         AppInfoInternal appInfo = getAppInfoMap().getOrDefault(packageName, null);
 
         if (appInfo == null) {
diff --git a/service/java/com/android/server/healthconnect/storage/datatypehelpers/ExerciseSessionRecordHelper.java b/service/java/com/android/server/healthconnect/storage/datatypehelpers/ExerciseSessionRecordHelper.java
index 0c2516a6..eac95de6 100644
--- a/service/java/com/android/server/healthconnect/storage/datatypehelpers/ExerciseSessionRecordHelper.java
+++ b/service/java/com/android/server/healthconnect/storage/datatypehelpers/ExerciseSessionRecordHelper.java
@@ -90,6 +90,10 @@ public final class ExerciseSessionRecordHelper
     private static final String TITLE_COLUMN_NAME = "title";
     private static final String HAS_ROUTE_COLUMN_NAME = "has_route";
 
+    private static final int ROUTE_READ_ACCESS_TYPE_NONE = 0;
+    private static final int ROUTE_READ_ACCESS_TYPE_OWN = 1;
+    private static final int ROUTE_READ_ACCESS_TYPE_ALL = 2;
+
     public ExerciseSessionRecordHelper() {
         super(RecordTypeIdentifier.RECORD_TYPE_EXERCISE_SESSION);
     }
@@ -245,25 +249,17 @@ public final class ExerciseSessionRecordHelper
             String packageName,
             long startDateAccess,
             Map<String, Boolean> extraPermsState) {
-        if (!isExerciseRouteFeatureEnabled()) {
-            return Collections.emptyList();
-        }
+        int routeAccessType = getExerciseRouteReadAccessType(packageName, extraPermsState);
 
-        boolean canReadAnyRoute = extraPermsState.get(READ_EXERCISE_ROUTE);
-        if (!canReadAnyRoute
-                && AppInfoHelper.getInstance().getAppInfoId(packageName) == DEFAULT_LONG) {
-            // If the package doesn't have app info and cannot read any route,
-            // then no route is accessible for it.
+        if (routeAccessType == ROUTE_READ_ACCESS_TYPE_NONE) {
             return Collections.emptyList();
         }
 
-        WhereClauses whereClause =
-                getReadTableWhereClause(
-                        request,
-                        packageName,
-                        /* enforceSelfRead= */ !canReadAnyRoute,
-                        startDateAccess);
-        return List.of(getRouteReadRequest(whereClause));
+        boolean enforceSelfRead = routeAccessType == ROUTE_READ_ACCESS_TYPE_OWN;
+
+        WhereClauses sessionsWithAccessibleRouteClause =
+                getReadTableWhereClause(request, packageName, enforceSelfRead, startDateAccess);
+        return List.of(getRouteReadRequest(sessionsWithAccessibleRouteClause));
     }
 
     @Override
@@ -315,17 +311,30 @@ public final class ExerciseSessionRecordHelper
     }
 
     @Override
-    List<ReadTableRequest> getExtraDataReadRequests(List<UUID> uuids, long startDateAccess) {
-        if (!isExerciseRouteFeatureEnabled()) {
+    List<ReadTableRequest> getExtraDataReadRequests(
+            String packageName,
+            List<UUID> uuids,
+            long startDateAccess,
+            Map<String, Boolean> extraPermsState) {
+        int routeAccessType = getExerciseRouteReadAccessType(packageName, extraPermsState);
+
+        if (routeAccessType == ROUTE_READ_ACCESS_TYPE_NONE) {
             return Collections.emptyList();
         }
 
-        WhereClauses whereClause =
+        WhereClauses sessionsWithAccessibleRouteClause =
                 new WhereClauses()
                         .addWhereInClauseWithoutQuotes(
-                                UUID_COLUMN_NAME, StorageUtils.getListOfHexString(uuids));
-        whereClause.addWhereLaterThanTimeClause(getStartTimeColumnName(), startDateAccess);
-        return List.of(getRouteReadRequest(whereClause));
+                                UUID_COLUMN_NAME, StorageUtils.getListOfHexString(uuids))
+                        .addWhereLaterThanTimeClause(getStartTimeColumnName(), startDateAccess);
+
+        if (routeAccessType == ROUTE_READ_ACCESS_TYPE_OWN) {
+            long appId = AppInfoHelper.getInstance().getAppInfoId(packageName);
+            sessionsWithAccessibleRouteClause.addWhereInLongsClause(
+                    APP_INFO_ID_COLUMN_NAME, List.of(appId));
+        }
+
+        return List.of(getRouteReadRequest(sessionsWithAccessibleRouteClause));
     }
 
     @Override
@@ -408,4 +417,19 @@ public final class ExerciseSessionRecordHelper
         routeReadRequest.setWhereClause(inClause);
         return routeReadRequest;
     }
+
+    private int getExerciseRouteReadAccessType(
+            String packageName, Map<String, Boolean> extraPermsState) {
+        if (!isExerciseRouteFeatureEnabled()) {
+            return ROUTE_READ_ACCESS_TYPE_NONE;
+        }
+
+        if (extraPermsState.getOrDefault(READ_EXERCISE_ROUTE, false)) {
+            return ROUTE_READ_ACCESS_TYPE_ALL;
+        }
+
+        long appId = AppInfoHelper.getInstance().getAppInfoId(packageName);
+
+        return appId == DEFAULT_LONG ? ROUTE_READ_ACCESS_TYPE_NONE : ROUTE_READ_ACCESS_TYPE_OWN;
+    }
 }
diff --git a/service/java/com/android/server/healthconnect/storage/datatypehelpers/RecordHelper.java b/service/java/com/android/server/healthconnect/storage/datatypehelpers/RecordHelper.java
index ec9f0a30..9fba3e57 100644
--- a/service/java/com/android/server/healthconnect/storage/datatypehelpers/RecordHelper.java
+++ b/service/java/com/android/server/healthconnect/storage/datatypehelpers/RecordHelper.java
@@ -298,10 +298,7 @@ public abstract class RecordHelper<T extends RecordInternal<?>> {
         }
     }
 
-    /**
-     * Returns ReadSingleTableRequest for {@code request} and package name {@code packageName}
-     *
-     */
+    /** Returns ReadSingleTableRequest for {@code request} and package name {@code packageName} */
     public ReadTableRequest getReadTableRequest(
             ReadRecordsRequestParcel request,
             String packageName,
@@ -344,7 +341,11 @@ public abstract class RecordHelper<T extends RecordInternal<?>> {
     }
 
     /** Returns ReadTableRequest for {@code uuids} */
-    public ReadTableRequest getReadTableRequest(List<UUID> uuids, long startDateAccess) {
+    public ReadTableRequest getReadTableRequest(
+            String packageName,
+            List<UUID> uuids,
+            long startDateAccess,
+            Map<String, Boolean> extraPermsState) {
         return new ReadTableRequest(getMainTableName())
                 .setJoinClause(getJoinForReadRequest())
                 .setWhereClause(
@@ -354,7 +355,9 @@ public abstract class RecordHelper<T extends RecordInternal<?>> {
                                 .addWhereLaterThanTimeClause(
                                         getStartTimeColumnName(), startDateAccess))
                 .setRecordHelper(this)
-                .setExtraReadRequests(getExtraDataReadRequests(uuids, startDateAccess));
+                .setExtraReadRequests(
+                        getExtraDataReadRequests(
+                                packageName, uuids, startDateAccess, extraPermsState));
     }
 
     /**
@@ -373,7 +376,11 @@ public abstract class RecordHelper<T extends RecordInternal<?>> {
      * Returns list if ReadSingleTableRequest for {@code uuids} to populate extra data. Called in
      * change logs read requests.
      */
-    List<ReadTableRequest> getExtraDataReadRequests(List<UUID> uuids, long startDateAccess) {
+    List<ReadTableRequest> getExtraDataReadRequests(
+            String packageName,
+            List<UUID> uuids,
+            long startDateAccess,
+            Map<String, Boolean> extraPermsState) {
         return Collections.emptyList();
     }
 
diff --git a/service/java/com/android/server/healthconnect/storage/request/ReadTransactionRequest.java b/service/java/com/android/server/healthconnect/storage/request/ReadTransactionRequest.java
index a6fb737f..e289a8e4 100644
--- a/service/java/com/android/server/healthconnect/storage/request/ReadTransactionRequest.java
+++ b/service/java/com/android/server/healthconnect/storage/request/ReadTransactionRequest.java
@@ -45,7 +45,7 @@ public class ReadTransactionRequest {
             ReadRecordsRequestParcel request,
             long startDateAccess,
             boolean enforceSelfRead,
-            Map<String, Boolean> extraReadPermsMapping) {
+            Map<String, Boolean> extraPermsState) {
         RecordHelper<?> recordHelper =
                 RecordHelperProvider.getInstance().getRecordHelper(request.getRecordType());
         mReadTableRequests =
@@ -55,18 +55,25 @@ public class ReadTransactionRequest {
                                 packageName,
                                 enforceSelfRead,
                                 startDateAccess,
-                                extraReadPermsMapping));
+                                extraPermsState));
     }
 
     public ReadTransactionRequest(
-            Map<Integer, List<UUID>> recordTypeToUuids, long startDateAccess) {
+            String packageName,
+            Map<Integer, List<UUID>> recordTypeToUuids,
+            long startDateAccess,
+            Map<String, Boolean> extraPermsState) {
         mReadTableRequests = new ArrayList<>();
         recordTypeToUuids.forEach(
                 (recordType, uuids) ->
                         mReadTableRequests.add(
                                 RecordHelperProvider.getInstance()
                                         .getRecordHelper(recordType)
-                                        .getReadTableRequest(uuids, startDateAccess)));
+                                        .getReadTableRequest(
+                                                packageName,
+                                                uuids,
+                                                startDateAccess,
+                                                extraPermsState)));
     }
 
     @NonNull
diff --git a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectUiTestHelper.kt b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectUiTestHelper.kt
index 3ec5ca62..bc08b2e1 100644
--- a/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectUiTestHelper.kt
+++ b/tests/cts/hostsidetests/healthconnect/HealthConnectTestHelper/src/android/healthconnect/cts/testhelper/HealthConnectUiTestHelper.kt
@@ -92,6 +92,7 @@ class HealthConnectUiTestHelper {
                 TestHelperUtils.getStepsRecord()),
             mHealthConnectManager)
         context.launchMainActivity {
+            UiTestUtils.skipOnboardingIfAppears()
             UiTestUtils.waitDisplayed(By.text("Data and access"))
             UiTestUtils.clickOnText("Data and access")
 
diff --git a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/ExerciseRouteAccessTest.java b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/ExerciseRouteAccessTest.java
index ba78d087..89179e19 100644
--- a/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/ExerciseRouteAccessTest.java
+++ b/tests/cts/hostsidetests/healthconnect/device/src/android/healthconnect/cts/device/ExerciseRouteAccessTest.java
@@ -18,15 +18,23 @@ package android.healthconnect.cts.device;
 
 import static android.health.connect.HealthPermissions.WRITE_EXERCISE_ROUTE;
 import static android.healthconnect.cts.device.HealthConnectDeviceTest.APP_A_WITH_READ_WRITE_PERMS;
+import static android.healthconnect.cts.lib.TestUtils.READ_EXERCISE_ROUTE_PERMISSION;
 import static android.healthconnect.cts.lib.TestUtils.READ_RECORDS_SIZE;
+import static android.healthconnect.cts.lib.TestUtils.RECORD_IDS;
 import static android.healthconnect.cts.lib.TestUtils.SUCCESS;
 import static android.healthconnect.cts.lib.TestUtils.deleteAllStagedRemoteData;
+import static android.healthconnect.cts.lib.TestUtils.getChangeLogToken;
+import static android.healthconnect.cts.lib.TestUtils.getChangeLogs;
+import static android.healthconnect.cts.lib.TestUtils.getExerciseSessionRecord;
 import static android.healthconnect.cts.lib.TestUtils.insertRecordAs;
+import static android.healthconnect.cts.lib.TestUtils.insertRecords;
 import static android.healthconnect.cts.lib.TestUtils.insertSessionNoRouteAs;
 import static android.healthconnect.cts.lib.TestUtils.readRecords;
 import static android.healthconnect.cts.lib.TestUtils.readRecordsAs;
 import static android.healthconnect.cts.lib.TestUtils.updateRouteAs;
 
+import static androidx.test.core.app.ApplicationProvider.getApplicationContext;
+
 import static com.android.compatibility.common.util.FeatureUtil.AUTOMOTIVE_FEATURE;
 import static com.android.compatibility.common.util.FeatureUtil.hasSystemFeature;
 
@@ -35,7 +43,12 @@ import static com.google.common.truth.Truth.assertThat;
 import android.app.UiAutomation;
 import android.health.connect.HealthConnectException;
 import android.health.connect.ReadRecordsRequestUsingFilters;
+import android.health.connect.ReadRecordsRequestUsingIds;
+import android.health.connect.changelog.ChangeLogTokenRequest;
+import android.health.connect.changelog.ChangeLogsRequest;
+import android.health.connect.changelog.ChangeLogsResponse;
 import android.health.connect.datatypes.ExerciseSessionRecord;
+import android.healthconnect.cts.lib.TestUtils.RecordTypeAndRecordIds;
 import android.os.Bundle;
 
 import androidx.test.platform.app.InstrumentationRegistry;
@@ -47,7 +60,11 @@ import org.junit.Before;
 import org.junit.Test;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
 
 public class ExerciseRouteAccessTest {
 
@@ -63,7 +80,7 @@ public class ExerciseRouteAccessTest {
     }
 
     @After
-    public void tearDown() {
+    public void tearDown() throws InterruptedException {
         deleteAllStagedRemoteData();
 
         mAutomation.grantRuntimePermission(
@@ -71,7 +88,7 @@ public class ExerciseRouteAccessTest {
     }
 
     @Test
-    public void testRouteRead_cannotAccessOtherAppRoute() throws Exception {
+    public void readRecords_usingFilters_cannotAccessOtherAppRoute() throws Exception {
         assertThat(insertRecordAs(APP_A_WITH_READ_WRITE_PERMS).getBoolean(SUCCESS)).isTrue();
 
         List<ExerciseSessionRecord> records =
@@ -85,6 +102,225 @@ public class ExerciseRouteAccessTest {
         assertThat(records.get(0).getRoute()).isNull();
     }
 
+    @Test
+    public void readRecords_usingFilters_withReadExerciseRoutePermission_canAccessOtherAppRoute()
+            throws Exception {
+        assertThat(insertRecordAs(APP_A_WITH_READ_WRITE_PERMS).getBoolean(SUCCESS)).isTrue();
+        mAutomation.adoptShellPermissionIdentity(READ_EXERCISE_ROUTE_PERMISSION);
+
+        List<ExerciseSessionRecord> records =
+                readRecords(
+                        new ReadRecordsRequestUsingFilters.Builder<>(ExerciseSessionRecord.class)
+                                .build());
+
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(1);
+        assertThat(records.get(0).hasRoute()).isTrue();
+        assertThat(records.get(0).getRoute()).isNotNull();
+    }
+
+    @Test
+    public void readRecords_usingFilters_canAccessOwnRoute() throws Exception {
+        ExerciseSessionRecord record =
+                getExerciseSessionRecord(
+                        getApplicationContext().getPackageName(), 0.0, /* withRoute= */ true);
+        insertRecords(List.of(record), getApplicationContext());
+
+        List<ExerciseSessionRecord> records =
+                readRecords(
+                        new ReadRecordsRequestUsingFilters.Builder<>(ExerciseSessionRecord.class)
+                                .build());
+
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(1);
+        assertThat(records.get(0).hasRoute()).isTrue();
+        assertThat(records.get(0).getRoute()).isEqualTo(record.getRoute());
+    }
+
+    @Test
+    public void readRecords_usingFilters_mixedOwnAndOtherAppSession() throws Exception {
+        Bundle bundle = insertRecordAs(APP_A_WITH_READ_WRITE_PERMS);
+        assertThat(bundle.getBoolean(SUCCESS)).isTrue();
+        String otherAppSessionId = getInsertedSessionId(bundle);
+        ExerciseSessionRecord ownSession =
+                getExerciseSessionRecord(
+                        getApplicationContext().getPackageName(), 0.0, /* withRoute= */ true);
+        String ownSessionId =
+                insertRecords(List.of(ownSession), getApplicationContext())
+                        .get(0)
+                        .getMetadata()
+                        .getId();
+
+        List<ExerciseSessionRecord> records =
+                readRecords(
+                        new ReadRecordsRequestUsingFilters.Builder<>(ExerciseSessionRecord.class)
+                                .build());
+
+        Map<String, ExerciseSessionRecord> idToRecordMap =
+                records.stream()
+                        .collect(
+                                Collectors.toMap(
+                                        record -> record.getMetadata().getId(),
+                                        Function.identity()));
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(2);
+        assertThat(idToRecordMap.get(otherAppSessionId).hasRoute()).isTrue();
+        assertThat(idToRecordMap.get(otherAppSessionId).getRoute()).isNull();
+        assertThat(idToRecordMap.get(ownSessionId).hasRoute()).isTrue();
+        assertThat(idToRecordMap.get(ownSessionId).getRoute()).isEqualTo(ownSession.getRoute());
+    }
+
+    @Test
+    public void readRecords_usingIds_cannotAccessOtherAppRoute() throws Exception {
+        Bundle bundle = insertRecordAs(APP_A_WITH_READ_WRITE_PERMS);
+        assertThat(bundle.getBoolean(SUCCESS)).isTrue();
+        String sessionId = getInsertedSessionId(bundle);
+
+        List<ExerciseSessionRecord> records =
+                readRecords(
+                        new ReadRecordsRequestUsingIds.Builder<>(ExerciseSessionRecord.class)
+                                .addId(sessionId)
+                                .build());
+
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(1);
+        assertThat(records.get(0).hasRoute()).isTrue();
+        assertThat(records.get(0).getRoute()).isNull();
+    }
+
+    @Test
+    public void readRecords_usingIds_withReadExerciseRoutePermission_canAccessOtherAppRoute()
+            throws Exception {
+        Bundle bundle = insertRecordAs(APP_A_WITH_READ_WRITE_PERMS);
+        assertThat(bundle.getBoolean(SUCCESS)).isTrue();
+        String sessionId = getInsertedSessionId(bundle);
+        mAutomation.adoptShellPermissionIdentity(READ_EXERCISE_ROUTE_PERMISSION);
+
+        List<ExerciseSessionRecord> records =
+                readRecords(
+                        new ReadRecordsRequestUsingIds.Builder<>(ExerciseSessionRecord.class)
+                                .addId(sessionId)
+                                .build());
+
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(1);
+        assertThat(records.get(0).hasRoute()).isTrue();
+        assertThat(records.get(0).getRoute()).isNotNull();
+    }
+
+    @Test
+    public void readRecords_usingIds_canAccessOwnRoute() throws Exception {
+        ExerciseSessionRecord record =
+                getExerciseSessionRecord(
+                        getApplicationContext().getPackageName(), 0.0, /* withRoute= */ true);
+        String sessionId =
+                insertRecords(List.of(record), getApplicationContext())
+                        .get(0)
+                        .getMetadata()
+                        .getId();
+
+        List<ExerciseSessionRecord> records =
+                readRecords(
+                        new ReadRecordsRequestUsingIds.Builder<>(ExerciseSessionRecord.class)
+                                .addId(sessionId)
+                                .build());
+
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(1);
+        assertThat(records.get(0).hasRoute()).isTrue();
+        assertThat(records.get(0).getRoute()).isEqualTo(record.getRoute());
+    }
+
+    @Test
+    public void readRecords_usingIds__mixedOwnAndOtherAppSession() throws Exception {
+        Bundle bundle = insertRecordAs(APP_A_WITH_READ_WRITE_PERMS);
+        assertThat(bundle.getBoolean(SUCCESS)).isTrue();
+        String otherAppSessionId = getInsertedSessionId(bundle);
+        ExerciseSessionRecord ownSession =
+                getExerciseSessionRecord(
+                        getApplicationContext().getPackageName(), 0.0, /* withRoute= */ true);
+        String ownSessionId =
+                insertRecords(List.of(ownSession), getApplicationContext())
+                        .get(0)
+                        .getMetadata()
+                        .getId();
+
+        List<ExerciseSessionRecord> records =
+                readRecords(
+                        new ReadRecordsRequestUsingIds.Builder<>(ExerciseSessionRecord.class)
+                                .addId(otherAppSessionId)
+                                .addId(ownSessionId)
+                                .build());
+
+        Map<String, ExerciseSessionRecord> idToRecordMap =
+                records.stream()
+                        .collect(
+                                Collectors.toMap(
+                                        record -> record.getMetadata().getId(),
+                                        Function.identity()));
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(2);
+        assertThat(idToRecordMap.get(otherAppSessionId).hasRoute()).isTrue();
+        assertThat(idToRecordMap.get(otherAppSessionId).getRoute()).isNull();
+        assertThat(idToRecordMap.get(ownSessionId).hasRoute()).isTrue();
+        assertThat(idToRecordMap.get(ownSessionId).getRoute()).isEqualTo(ownSession.getRoute());
+    }
+
+    @Test
+    public void getChangelogs_withReadExerciseRoutePermission_canAccessOtherAppRoute()
+            throws Exception {
+        String token =
+                getChangeLogToken(
+                                new ChangeLogTokenRequest.Builder()
+                                        .addRecordType(ExerciseSessionRecord.class)
+                                        .build(),
+                                getApplicationContext())
+                        .getToken();
+        assertThat(insertRecordAs(APP_A_WITH_READ_WRITE_PERMS).getBoolean(SUCCESS)).isTrue();
+        mAutomation.adoptShellPermissionIdentity(READ_EXERCISE_ROUTE_PERMISSION);
+
+        ChangeLogsResponse response =
+                getChangeLogs(
+                        new ChangeLogsRequest.Builder(token).build(), getApplicationContext());
+
+        List<ExerciseSessionRecord> records =
+                response.getUpsertedRecords().stream()
+                        .map(ExerciseSessionRecord.class::cast)
+                        .toList();
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(1);
+        assertThat(records.get(0).hasRoute()).isTrue();
+        assertThat(records.get(0).getRoute()).isNotNull();
+    }
+
+    @Test
+    public void getChangelogs_canAccessOwnRoute() throws Exception {
+        String token =
+                getChangeLogToken(
+                                new ChangeLogTokenRequest.Builder()
+                                        .addRecordType(ExerciseSessionRecord.class)
+                                        .build(),
+                                getApplicationContext())
+                        .getToken();
+        ExerciseSessionRecord record =
+                getExerciseSessionRecord(
+                        getApplicationContext().getPackageName(), 0.0, /* withRoute= */ true);
+        insertRecords(List.of(record), getApplicationContext());
+
+        ChangeLogsResponse response =
+                getChangeLogs(
+                        new ChangeLogsRequest.Builder(token).build(), getApplicationContext());
+
+        List<ExerciseSessionRecord> records =
+                response.getUpsertedRecords().stream()
+                        .map(ExerciseSessionRecord.class::cast)
+                        .toList();
+        assertThat(records).isNotNull();
+        assertThat(records).hasSize(1);
+        assertThat(records.get(0).hasRoute()).isTrue();
+        assertThat(records.get(0).getRoute()).isEqualTo(record.getRoute());
+    }
+
     @Test
     public void testRouteInsert_cannotInsertRouteWithoutPerm() throws Exception {
         mAutomation.revokeRuntimePermission(
@@ -103,11 +339,17 @@ public class ExerciseRouteAccessTest {
 
     @Test
     public void testRouteUpdate_updateRouteWithPerm_noRouteAfterUpdate() throws Exception {
-        assertThat(insertRecordAs(APP_A_WITH_READ_WRITE_PERMS).getBoolean(SUCCESS)).isTrue();
         List<ExerciseSessionRecord> records =
                 readRecords(
                         new ReadRecordsRequestUsingFilters.Builder<>(ExerciseSessionRecord.class)
                                 .build());
+        assertThat(records).isEmpty();
+
+        assertThat(insertRecordAs(APP_A_WITH_READ_WRITE_PERMS).getBoolean(SUCCESS)).isTrue();
+        records =
+                readRecords(
+                        new ReadRecordsRequestUsingFilters.Builder<>(ExerciseSessionRecord.class)
+                                .build());
         assertThat(records).isNotNull();
         assertThat(records).hasSize(1);
         assertThat(records.get(0).hasRoute()).isTrue();
@@ -181,4 +423,21 @@ public class ExerciseRouteAccessTest {
         assertThat(records).hasSize(1);
         assertThat(records.get(0).hasRoute()).isFalse();
     }
+
+    private static String getInsertedSessionId(Bundle bundle) {
+        List<String> ids =
+                ((List<RecordTypeAndRecordIds>) bundle.getSerializable(RECORD_IDS))
+                        .stream()
+                                .filter(
+                                        it ->
+                                                it.getRecordType()
+                                                        .equals(
+                                                                ExerciseSessionRecord.class
+                                                                        .getName()))
+                                .map(RecordTypeAndRecordIds::getRecordIds)
+                                .flatMap(Collection::stream)
+                                .toList();
+        assertThat(ids).hasSize(1);
+        return ids.get(0);
+    }
 }
diff --git a/tests/cts/hostsidetests/healthconnect/libs/HealthConnectTestLib/src/android/healthconnect/cts/lib/TestUtils.java b/tests/cts/hostsidetests/healthconnect/libs/HealthConnectTestLib/src/android/healthconnect/cts/lib/TestUtils.java
index 557df94c..56aace8c 100644
--- a/tests/cts/hostsidetests/healthconnect/libs/HealthConnectTestLib/src/android/healthconnect/cts/lib/TestUtils.java
+++ b/tests/cts/hostsidetests/healthconnect/libs/HealthConnectTestLib/src/android/healthconnect/cts/lib/TestUtils.java
@@ -58,6 +58,7 @@ import com.android.cts.install.lib.TestApp;
 import java.io.Serializable;
 import java.time.Instant;
 import java.time.ZoneOffset;
+import java.time.temporal.ChronoUnit;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -72,6 +73,8 @@ import java.util.concurrent.atomic.AtomicReference;
 
 public class TestUtils {
     static final String TAG = "HealthConnectTest";
+    public static final String READ_EXERCISE_ROUTE_PERMISSION =
+            "android.permission.health.READ_EXERCISE_ROUTE";
     public static final String QUERY_TYPE = "android.healthconnect.cts.queryType";
     public static final String INTENT_EXTRA_CALLING_PKG = "android.healthconnect.cts.calling_pkg";
     public static final String APP_PKG_NAME_USED_IN_DATA_ORIGIN =
@@ -352,7 +355,7 @@ public class TestUtils {
 
     public static ExerciseSessionRecord getExerciseSessionRecord(
             String packageName, double clientId, boolean withRoute) {
-        Instant startTime = Instant.now().minusSeconds(3000);
+        Instant startTime = Instant.now().minusSeconds(3000).truncatedTo(ChronoUnit.MILLIS);
         Instant endTime = Instant.now();
         ExerciseSessionRecord.Builder builder =
                 new ExerciseSessionRecord.Builder(
-- 
2.43.0.594.gd9cf4e227d-goog

