From f2f93792165c1e2749368968cd40e69ae90b343c Mon Sep 17 00:00:00 2001
From: Xu Bing <bing.xu@intel.com>
Date: Thu, 13 Feb 2025 13:52:55 +0800
Subject: [PATCH] base debug patch,not merge

Tracked-On: OAM-129624
Signed-off-by: Xu Bing <bing.xu@intel.com>
---
 core/java/android/hardware/input/InputManager.java |  5 +++--
 .../android/hardware/input/InputManagerGlobal.java |  4 ++--
 .../inputmethodservice/IInputMethodWrapper.java    |  1 +
 .../inputmethodservice/InputMethodService.java     |  3 ++-
 .../java/android/view/ImeInsetsSourceConsumer.java |  4 +++-
 core/java/android/view/InputDevice.java            | 10 +++++++++-
 core/java/android/view/InputEventReceiver.java     |  8 +++++++-
 core/java/android/view/InputEventSender.java       |  4 +++-
 core/java/android/view/inputmethod/ImeTracker.java |  2 +-
 .../view/inputmethod/InputMethodManager.java       | 12 ++++++++++--
 .../InputMethodPrivilegedOperations.java           |  1 +
 .../android/server/input/InputManagerService.java  |  8 +++++++-
 .../inputmethod/InputMethodManagerService.java     | 14 +++++++++++---
 .../android/server/policy/PhoneWindowManager.java  |  8 ++++++--
 14 files changed, 66 insertions(+), 18 deletions(-)

diff --git a/core/java/android/hardware/input/InputManager.java b/core/java/android/hardware/input/InputManager.java
index a0cceae98ba9..01c2e5a63063 100644
--- a/core/java/android/hardware/input/InputManager.java
+++ b/core/java/android/hardware/input/InputManager.java
@@ -65,9 +65,9 @@ import java.util.concurrent.Executor;
  */
 @SystemService(Context.INPUT_SERVICE)
 public final class InputManager {
-    private static final String TAG = "InputManager";
+    private static final String TAG = "SB1 InputManager";
     // To enable these logs, run: 'adb shell setprop log.tag.InputManager DEBUG' (requires restart)
-    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
+    private static final boolean DEBUG = true;
 
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
     private final IInputManager mIm;
@@ -287,6 +287,7 @@ public final class InputManager {
      */
     @Nullable
     public InputDevice getInputDevice(int id) {
+        Log.e(TAG, "getInputDevice deviceid: " + id);
         return mGlobal.getInputDevice(id);
     }
 
diff --git a/core/java/android/hardware/input/InputManagerGlobal.java b/core/java/android/hardware/input/InputManagerGlobal.java
index c0877d3ad8e2..ff4bc497319d 100644
--- a/core/java/android/hardware/input/InputManagerGlobal.java
+++ b/core/java/android/hardware/input/InputManagerGlobal.java
@@ -68,10 +68,10 @@ import java.util.concurrent.Executor;
  * @hide
  */
 public final class InputManagerGlobal {
-    private static final String TAG = "InputManagerGlobal";
+    private static final String TAG = "XB1 InputManagerGlobal";
     // To enable these logs, run: 'adb shell setprop log.tag.InputManagerGlobal DEBUG'
     // (requires restart)
-    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
+    private static final boolean DEBUG = true;
 
     @GuardedBy("mInputDeviceListeners")
     @Nullable private SparseArray<InputDevice> mInputDevices;
diff --git a/core/java/android/inputmethodservice/IInputMethodWrapper.java b/core/java/android/inputmethodservice/IInputMethodWrapper.java
index b99996ff83c8..1e512a0cfec9 100644
--- a/core/java/android/inputmethodservice/IInputMethodWrapper.java
+++ b/core/java/android/inputmethodservice/IInputMethodWrapper.java
@@ -443,6 +443,7 @@ class IInputMethodWrapper extends IInputMethod.Stub
     @Override
     public void hideSoftInput(IBinder hideInputToken, @Nullable ImeTracker.Token statsToken,
             int flags, ResultReceiver resultReceiver) {
+        new Exception("XB inputmethodwrapper").printStackTrace();
         ImeTracker.forLogging().onProgress(statsToken, ImeTracker.PHASE_IME_WRAPPER);
         mCaller.executeOrSendMessage(mCaller.obtainMessageIOOO(DO_HIDE_SOFT_INPUT,
                 flags, hideInputToken, resultReceiver, statsToken));
diff --git a/core/java/android/inputmethodservice/InputMethodService.java b/core/java/android/inputmethodservice/InputMethodService.java
index 8f653b3808c1..d02dcd73160a 100644
--- a/core/java/android/inputmethodservice/InputMethodService.java
+++ b/core/java/android/inputmethodservice/InputMethodService.java
@@ -328,7 +328,7 @@ import java.util.OptionalInt;
 @UiContext
 public class InputMethodService extends AbstractInputMethodService {
     static final String TAG = "InputMethodService";
-    static final boolean DEBUG = false;
+    static final boolean DEBUG = true;
 
     /**
      * Key for a boolean value that tells whether {@link InputMethodService} is responsible for
@@ -906,6 +906,7 @@ public class InputMethodService extends AbstractInputMethodService {
         public void hideSoftInput(int flags, ResultReceiver resultReceiver) {
             ImeTracker.forLogging().onProgress(
                     mCurStatsToken, ImeTracker.PHASE_IME_HIDE_SOFT_INPUT);
+            //new Exception("XB inputmethodservice").printStackTrace();
             if (DEBUG) Log.v(TAG, "hideSoftInput()");
             if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.R
                     && !mSystemCallingHideSoftInput) {
diff --git a/core/java/android/view/ImeInsetsSourceConsumer.java b/core/java/android/view/ImeInsetsSourceConsumer.java
index 4a3b8ac65aa4..79c95c6f8560 100644
--- a/core/java/android/view/ImeInsetsSourceConsumer.java
+++ b/core/java/android/view/ImeInsetsSourceConsumer.java
@@ -25,6 +25,7 @@ import android.annotation.Nullable;
 import android.os.IBinder;
 import android.os.Process;
 import android.os.Trace;
+import android.util.Log;
 import android.util.proto.ProtoOutputStream;
 import android.view.SurfaceControl.Transaction;
 import android.view.inputmethod.ImeTracker;
@@ -71,6 +72,7 @@ public final class ImeInsetsSourceConsumer extends InsetsSourceConsumer {
             mIsRequestedVisibleAwaitingControl = false;
             if (!running && !mHasPendingRequest) {
                 notifyHidden(null /* statsToken */);
+                Log.v("ImeInsetsSourceConsumer input", "onAnimationStateChanged running: " + running);
                 removeSurface();
             }
         }
@@ -170,7 +172,7 @@ public final class ImeInsetsSourceConsumer extends InsetsSourceConsumer {
                     ImeTracker.ORIGIN_CLIENT_HIDE_SOFT_INPUT,
                     SoftInputShowHideReason.HIDE_SOFT_INPUT_BY_INSETS_API);
         }
-
+        new Exception("XB input Imeinsets").printStackTrace();
         ImeTracker.forLogging().onProgress(statsToken,
                 ImeTracker.PHASE_CLIENT_INSETS_CONSUMER_NOTIFY_HIDDEN);
 
diff --git a/core/java/android/view/InputDevice.java b/core/java/android/view/InputDevice.java
index a436e08a0a2d..a7348c945a3e 100644
--- a/core/java/android/view/InputDevice.java
+++ b/core/java/android/view/InputDevice.java
@@ -34,6 +34,7 @@ import android.icu.util.ULocale;
 import android.os.Build;
 import android.os.NullVibrator;
 import android.os.Parcel;
+import android.util.Slog;
 import android.os.Parcelable;
 import android.os.Vibrator;
 import android.os.VibratorManager;
@@ -63,6 +64,7 @@ import java.util.List;
  * </p>
  */
 public final class InputDevice implements Parcelable {
+    static final String TAG = "XB1 InputDevice";
     private final int mId;
     private final int mGeneration;
     private final int mControllerNumber;
@@ -474,6 +476,7 @@ public final class InputDevice implements Parcelable {
             boolean hasButtonUnderPad, boolean hasSensor, boolean hasBattery, int usiVersionMajor,
             int usiVersionMinor, int associatedDisplayId) {
         mId = id;
+        Slog.d(TAG, "InputDevice deviceId : " + mId );
         mGeneration = generation;
         mControllerNumber = controllerNumber;
         mName = name;
@@ -507,6 +510,7 @@ public final class InputDevice implements Parcelable {
     private InputDevice(Parcel in) {
         mKeyCharacterMap = KeyCharacterMap.CREATOR.createFromParcel(in);
         mId = in.readInt();
+        Slog.d(TAG, "InputDevice Parcel deviceId : " + mId );
         mGeneration = in.readInt();
         mControllerNumber = in.readInt();
         mName = in.readString();
@@ -571,6 +575,7 @@ public final class InputDevice implements Parcelable {
         /** @see InputDevice#getId() */
         public Builder setId(int id) {
             mId = id;
+            Slog.d(TAG, "setId deviceId : " + mId );
             return this;
         }
 
@@ -589,6 +594,7 @@ public final class InputDevice implements Parcelable {
         /** @see InputDevice#getName() */
         public Builder setName(String name) {
             mName = name;
+              Slog.d(TAG, "setName mName : " + mName );
             return this;
         }
 
@@ -720,7 +726,7 @@ public final class InputDevice implements Parcelable {
                     mUsiVersionMajor,
                     mUsiVersionMinor,
                     mAssociatedDisplayId);
-
+Slog.d(TAG, "build deviceId : " + mId );
             final int numRanges = mMotionRanges.size();
             for (int i = 0; i < numRanges; i++) {
                 final MotionRange range = mMotionRanges.get(i);
@@ -745,6 +751,7 @@ public final class InputDevice implements Parcelable {
      */
     @Nullable
     public static InputDevice getDevice(int id) {
+        Slog.d(TAG, "getDevice deviceId : " + id );
         return InputManagerGlobal.getInstance().getInputDevice(id);
     }
 
@@ -769,6 +776,7 @@ public final class InputDevice implements Parcelable {
      * @return The input device id.
      */
     public int getId() {
+        Slog.d(TAG, "getId deviceId : " + mId );
         return mId;
     }
 
diff --git a/core/java/android/view/InputEventReceiver.java b/core/java/android/view/InputEventReceiver.java
index 492c9384a969..a497705c13c3 100644
--- a/core/java/android/view/InputEventReceiver.java
+++ b/core/java/android/view/InputEventReceiver.java
@@ -36,7 +36,7 @@ import java.lang.ref.WeakReference;
  * @hide
  */
 public abstract class InputEventReceiver {
-    private static final String TAG = "InputEventReceiver";
+    private static final String TAG = "XB1 InputEventReceiver";
 
     private final CloseGuard mCloseGuard = CloseGuard.get();
 
@@ -199,6 +199,10 @@ public abstract class InputEventReceiver {
      * @param handled True if the event was handled.
      */
     public final void finishInputEvent(InputEvent event, boolean handled) {
+
+        Log.w(TAG, "finishInputEvent deviceid:  "+ event.getDeviceId()+", source :  "
+        +event.getSource()+", device :  "+event.getDevice()+", displayid :  "+event.getDisplayId());
+
         if (event == null) {
             throw new IllegalArgumentException("event must not be null");
         }
@@ -264,6 +268,8 @@ public abstract class InputEventReceiver {
     @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
     private void dispatchInputEvent(int seq, InputEvent event) {
         mSeqMap.put(event.getSequenceNumber(), seq);
+         Log.w(TAG, "dispatchInputEvent deviceid:  "
+                    + event.getDeviceId());
         onInputEvent(event);
     }
 
diff --git a/core/java/android/view/InputEventSender.java b/core/java/android/view/InputEventSender.java
index 64f62c75199e..5e5070b4fc7d 100644
--- a/core/java/android/view/InputEventSender.java
+++ b/core/java/android/view/InputEventSender.java
@@ -31,7 +31,7 @@ import java.lang.ref.WeakReference;
  * @hide
  */
 public abstract class InputEventSender {
-    private static final String TAG = "InputEventSender";
+    private static final String TAG = "XB1 InputEventSender";
 
     private final CloseGuard mCloseGuard = CloseGuard.get();
 
@@ -131,6 +131,8 @@ public abstract class InputEventSender {
      * if the input channel buffer filled before all samples were dispatched.
      */
     public final boolean sendInputEvent(int seq, InputEvent event) {
+        Log.w(TAG, "sendInputEvent deviceid:  "
+                    + event.getDeviceId());
         if (event == null) {
             throw new IllegalArgumentException("event must not be null");
         }
diff --git a/core/java/android/view/inputmethod/ImeTracker.java b/core/java/android/view/inputmethod/ImeTracker.java
index 03d1cd8f89e3..a3d3c7672f1a 100644
--- a/core/java/android/view/inputmethod/ImeTracker.java
+++ b/core/java/android/view/inputmethod/ImeTracker.java
@@ -463,7 +463,7 @@ public interface ImeTracker {
             final var tag = getTag(component);
             final var token = IInputMethodManagerGlobalInvoker.onRequestHide(tag, uid, origin,
                     reason);
-
+            new Exception("XB input").printStackTrace();
             Log.i(TAG, token.mTag + ": onRequestHide at " + Debug.originToString(origin)
                     + " reason " + InputMethodDebug.softInputDisplayReasonToString(reason));
 
diff --git a/core/java/android/view/inputmethod/InputMethodManager.java b/core/java/android/view/inputmethod/InputMethodManager.java
index 31abac855090..f2ab7ec239c7 100644
--- a/core/java/android/view/inputmethod/InputMethodManager.java
+++ b/core/java/android/view/inputmethod/InputMethodManager.java
@@ -85,6 +85,7 @@ import android.util.Pools.Pool;
 import android.util.Pools.SimplePool;
 import android.util.PrintWriterPrinter;
 import android.util.Printer;
+import android.util.Slog;
 import android.util.SparseArray;
 import android.util.proto.ProtoOutputStream;
 import android.view.Display;
@@ -285,8 +286,8 @@ import java.util.function.Consumer;
 @SystemService(Context.INPUT_METHOD_SERVICE)
 @RequiresFeature(PackageManager.FEATURE_INPUT_METHODS)
 public final class InputMethodManager {
-    private static final boolean DEBUG = false;
-    private static final String TAG = "InputMethodManager";
+    private static final boolean DEBUG = true;
+    private static final String TAG = "XB1 InputMethodManager";
 
     private static final String PENDING_EVENT_COUNTER = "aq:imm";
 
@@ -2269,6 +2270,7 @@ public final class InputMethodManager {
      * as returned by {@link View#getWindowToken() View.getWindowToken()}.
      */
     public boolean hideSoftInputFromWindow(IBinder windowToken, @HideFlags int flags) {
+        Slog.w(TAG, "hideSoftInputFromWindow windowToken " + windowToken);
         return hideSoftInputFromWindow(windowToken, flags, null);
     }
 
@@ -2309,6 +2311,7 @@ public final class InputMethodManager {
                 ImeTracker.ORIGIN_CLIENT_HIDE_SOFT_INPUT, reason);
         ImeTracker.forLatency().onRequestHide(statsToken, ImeTracker.ORIGIN_CLIENT_HIDE_SOFT_INPUT,
                 reason, ActivityThread::currentApplication);
+        Slog.w(TAG, "hideSoftInputFromWindow reason " + reason);
         ImeTracing.getInstance().triggerClientDump("InputMethodManager#hideSoftInputFromWindow",
                 this, null /* icProto */);
         checkFocus();
@@ -2318,6 +2321,7 @@ public final class InputMethodManager {
                 ImeTracker.forLogging().onFailed(statsToken, ImeTracker.PHASE_CLIENT_VIEW_SERVED);
                 ImeTracker.forLatency().onHideFailed(statsToken,
                         ImeTracker.PHASE_CLIENT_VIEW_SERVED, ActivityThread::currentApplication);
+                Slog.w(TAG, "hideSoftInputFromWindow not hide reason " + reason);
                 return false;
             }
 
@@ -3169,6 +3173,7 @@ public final class InputMethodManager {
                     Process.myUid(), ImeTracker.ORIGIN_CLIENT_HIDE_SOFT_INPUT,
                     SoftInputShowHideReason.HIDE_SOFT_INPUT_BY_INSETS_API);
         }
+        Log.v(TAG, "notifyImeHidden statsToken: " + statsToken);
         ImeTracker.forLatency().onRequestHide(statsToken, ImeTracker.ORIGIN_CLIENT_HIDE_SOFT_INPUT,
                 SoftInputShowHideReason.HIDE_SOFT_INPUT_BY_INSETS_API,
                 ActivityThread::currentApplication);
@@ -3180,6 +3185,7 @@ public final class InputMethodManager {
                 ImeTracker.forLogging().onFailed(statsToken, ImeTracker.PHASE_CLIENT_VIEW_SERVED);
                 ImeTracker.forLatency().onHideFailed(statsToken,
                         ImeTracker.PHASE_CLIENT_VIEW_SERVED, ActivityThread::currentApplication);
+                Log.v(TAG, "notifyImeHidden onHideFailed : " + statsToken);
                 return;
             }
 
@@ -3717,6 +3723,8 @@ public final class InputMethodManager {
             }
 
             p = mPendingEvents.valueAt(index);
+            Log.w(TAG, "finishedInputEvent deviceid:  "
+                        +  p.mEvent.getDeviceId());
             mPendingEvents.removeAt(index);
             Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size());
 
diff --git a/core/java/com/android/internal/inputmethod/InputMethodPrivilegedOperations.java b/core/java/com/android/internal/inputmethod/InputMethodPrivilegedOperations.java
index 30ebbe2bb111..38a5c906bb25 100644
--- a/core/java/com/android/internal/inputmethod/InputMethodPrivilegedOperations.java
+++ b/core/java/com/android/internal/inputmethod/InputMethodPrivilegedOperations.java
@@ -260,6 +260,7 @@ public final class InputMethodPrivilegedOperations {
     public void hideMySoftInput(@InputMethodManager.HideFlags int flags,
             @SoftInputShowHideReason int reason) {
         final IInputMethodPrivilegedOperations ops = mOps.getAndWarnIfNull();
+        new Exception("XB input").printStackTrace();
         if (ops == null) {
             return;
         }
diff --git a/services/core/java/com/android/server/input/InputManagerService.java b/services/core/java/com/android/server/input/InputManagerService.java
index ff69719c9497..09100ac2039e 100644
--- a/services/core/java/com/android/server/input/InputManagerService.java
+++ b/services/core/java/com/android/server/input/InputManagerService.java
@@ -141,7 +141,7 @@ import java.util.function.Consumer;
 /** The system implementation of {@link IInputManager} that manages input devices. */
 public class InputManagerService extends IInputManager.Stub
         implements Watchdog.Monitor {
-    static final String TAG = "InputManager";
+    static final String TAG = "XB1 InputManagerService";
     // To enable these logs, run: 'adb shell setprop log.tag.InputManager DEBUG' (requires restart)
     private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
 
@@ -612,6 +612,7 @@ public class InputManagerService extends IInputManager.Stub
      * @return The key state.
      */
     public int getKeyCodeState(int deviceId, int sourceMask, int keyCode) {
+        Slog.d(TAG, "getKeyCodeState deviceId: " + deviceId);
         return mNative.getKeyCodeState(deviceId, sourceMask, keyCode);
     }
 
@@ -625,6 +626,7 @@ public class InputManagerService extends IInputManager.Stub
      * @return The key state.
      */
     public int getScanCodeState(int deviceId, int sourceMask, int scanCode) {
+        Slog.d(TAG, "getScanCodeState deviceId: " + deviceId);
         return mNative.getScanCodeState(deviceId, sourceMask, scanCode);
     }
 
@@ -638,6 +640,7 @@ public class InputManagerService extends IInputManager.Stub
      * @return The switch state.
      */
     public int getSwitchState(int deviceId, int sourceMask, int switchCode) {
+        Slog.d(TAG, "getSwitchState deviceId: " + deviceId);
         return mNative.getSwitchState(deviceId, sourceMask, switchCode);
     }
 
@@ -657,6 +660,7 @@ public class InputManagerService extends IInputManager.Stub
     public boolean hasKeys(int deviceId, int sourceMask, int[] keyCodes, boolean[] keyExists) {
         Objects.requireNonNull(keyCodes, "keyCodes must not be null");
         Objects.requireNonNull(keyExists, "keyExists must not be null");
+        Slog.d(TAG, "hasKeys deviceId: " + deviceId);
         if (keyExists.length < keyCodes.length) {
             throw new IllegalArgumentException("keyExists must be at least as large as keyCodes");
         }
@@ -948,6 +952,7 @@ public class InputManagerService extends IInputManager.Stub
         synchronized (mInputDevicesLock) {
             for (final InputDevice inputDevice : mInputDevices) {
                 if (inputDevice.getId() == deviceId) {
+                    Slog.d(TAG, "getInputDevice deviceId: " + deviceId);
                     return inputDevice;
                 }
             }
@@ -2649,6 +2654,7 @@ public class InputManagerService extends IInputManager.Stub
      * @return True if the device could dispatch to the given display, false otherwise.
      */
     public boolean canDispatchToDisplay(int deviceId, int displayId) {
+         Slog.d(TAG, "canDispatchToDisplay deviceId: " + deviceId);
         return mNative.canDispatchToDisplay(deviceId, displayId);
     }
 
diff --git a/services/core/java/com/android/server/inputmethod/InputMethodManagerService.java b/services/core/java/com/android/server/inputmethod/InputMethodManagerService.java
index 999e30a72f7a..1a94b3c98150 100644
--- a/services/core/java/com/android/server/inputmethod/InputMethodManagerService.java
+++ b/services/core/java/com/android/server/inputmethod/InputMethodManagerService.java
@@ -216,8 +216,8 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
         implements Handler.Callback {
     // Virtual device id for test.
     private static final Integer VIRTUAL_STYLUS_ID_FOR_TEST = 999999;
-    static final boolean DEBUG = false;
-    static final String TAG = "InputMethodManagerService";
+    static final boolean DEBUG = true;
+    static final String TAG = "XB1 InputMethodManagerService";
     public static final String PROTO_ARG = "--proto";
 
     @Retention(SOURCE)
@@ -3655,6 +3655,7 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
         int uid = Binder.getCallingUid();
         ImeTracing.getInstance().triggerManagerServiceDump(
                 "InputMethodManagerService#hideSoftInput");
+        Slog.v(TAG, "hideSoftInput....");
         synchronized (ImfLock.class) {
             if (!canInteractWithImeLocked(uid, client, "hideSoftInput", statsToken)) {
                 if (isInputShown()) {
@@ -3688,7 +3689,7 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
             statsToken = createStatsTokenForFocusedClient(false /* show */,
                     ImeTracker.ORIGIN_SERVER_HIDE_INPUT, reason);
         }
-
+        Slog.v(TAG, "hideCurrentInputLocked....");
         if (!mVisibilityStateComputer.canHideIme(statsToken, flags)) {
             return false;
         }
@@ -4485,6 +4486,7 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
             @Override
             public void onInputDeviceAdded(int deviceId) {
                 InputDevice device = im.getInputDevice(deviceId);
+                Slog.d(TAG, "onInputDeviceAdded deviceId : " + deviceId );
                 if (device != null && isStylusDevice(device)) {
                     add(deviceId);
                 }
@@ -4492,12 +4494,14 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
 
             @Override
             public void onInputDeviceRemoved(int deviceId) {
+                Slog.d(TAG, "onInputDeviceRemoved deviceId : " + deviceId );
                 remove(deviceId);
             }
 
             @Override
             public void onInputDeviceChanged(int deviceId) {
                 InputDevice device = im.getInputDevice(deviceId);
+                Slog.d(TAG, "onInputDeviceChanged deviceId : " + deviceId );
                 if (device == null) {
                     return;
                 }
@@ -4510,12 +4514,14 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
 
             private void add(int deviceId) {
                 synchronized (ImfLock.class) {
+                    Slog.d(TAG, "add deviceId : " + deviceId );
                     addStylusDeviceIdLocked(deviceId);
                 }
             }
 
             private void remove(int deviceId) {
                 synchronized (ImfLock.class) {
+                    Slog.d(TAG, "remove deviceId : " + deviceId );
                     removeStylusDeviceIdLocked(deviceId);
                 }
             }
@@ -4856,6 +4862,7 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
     @GuardedBy("ImfLock.class")
     void onShowHideSoftInputRequested(boolean show, IBinder requestImeToken,
             @SoftInputShowHideReason int reason, @Nullable ImeTracker.Token statsToken) {
+        Slog.v(TAG, "onShowHideSoftInputRequested....");
         final IBinder requestToken = mVisibilityStateComputer.getWindowTokenFrom(requestImeToken);
         final WindowManagerInternal.ImeTargetInfo info =
                 mWindowManagerInternal.onToggleImeRequested(
@@ -4877,6 +4884,7 @@ public final class InputMethodManagerService extends IInputMethodManager.Stub
         try {
             Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, "IMMS.hideMySoftInput");
             synchronized (ImfLock.class) {
+                Slog.v(TAG, "hideMySoftInput....");
                 if (!calledWithValidTokenLocked(token)) {
                     return;
                 }
diff --git a/services/core/java/com/android/server/policy/PhoneWindowManager.java b/services/core/java/com/android/server/policy/PhoneWindowManager.java
index 339428260800..0862c351a493 100644
--- a/services/core/java/com/android/server/policy/PhoneWindowManager.java
+++ b/services/core/java/com/android/server/policy/PhoneWindowManager.java
@@ -4741,11 +4741,13 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         if ((policyFlags & FLAG_WAKE) != 0) {
             if (wakeUp(whenNanos / 1000000, mAllowTheaterModeWakeFromMotion,
                     PowerManager.WAKE_REASON_WAKE_MOTION, "android.policy:MOTION")) {
-                return 0;
+               Slog.d(TAG, "XB interceptMotionBeforeQueueingNonInteractive1.....displayid:  " + displayId);
+                return ACTION_PASS_TO_USER;
             }
         }
 
         if (shouldDispatchInputWhenNonInteractive(displayId, KEYCODE_UNKNOWN)) {
+            Slog.d(TAG, "XB interceptMotionBeforeQueueingNonInteractive2.....displayid:  " + displayId);
             return ACTION_PASS_TO_USER;
         }
 
@@ -4753,10 +4755,12 @@ public class PhoneWindowManager implements WindowManagerPolicy {
         // there will be no dream to intercept the touch and wake into ambient.  The device should
         // wake up in this case.
         if (isTheaterModeEnabled() && (policyFlags & FLAG_WAKE) != 0) {
+            Slog.d(TAG, "XB interceptMotionBeforeQueueingNonInteractive3.....displayid:  " + displayId);
             wakeUp(whenNanos / 1000000, mAllowTheaterModeWakeFromMotionWhenNotDreaming,
                     PowerManager.WAKE_REASON_WAKE_MOTION, "android.policy:MOTION");
+            return ACTION_PASS_TO_USER;
         }
-
+        Slog.d(TAG, "XB interceptMotionBeforeQueueingNonInteractive4.....displayid:  " + displayId);
         return 0;
     }
 
-- 
2.34.1

