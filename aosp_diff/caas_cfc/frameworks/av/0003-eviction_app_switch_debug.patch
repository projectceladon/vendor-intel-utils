From ed811f0750397b8798eb16f8417917ddca4412ec Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Sun, 20 Feb 2022 10:54:06 +0530
Subject: [PATCH] eviction debug

Signed-off-by: shivasku82 <shiva.kumara.rudrappa@intel.com>
---
 .../camera/libcameraservice/CameraService.cpp | 75 ++++++++++++-------
 1 file changed, 50 insertions(+), 25 deletions(-)

diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index ed64d4ccc8..30e2865b1a 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -16,7 +16,7 @@
 
 #define LOG_TAG "CameraService"
 #define ATRACE_TAG ATRACE_TAG_CAMERA
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <algorithm>
 #include <climits>
@@ -137,7 +137,7 @@ const String8 CameraService::kOfflineDevice("offline-");
 
 Mutex CameraService::sProxyMutex;
 sp<hardware::ICameraServiceProxy> CameraService::sCameraServiceProxy;
-
+std::vector<CameraService::DescriptorPtr> evictedClients;
 CameraService::CameraService() :
         mEventLog(DEFAULT_EVENT_LOG_LENGTH),
         mNumberOfCameras(0),
@@ -145,6 +145,7 @@ CameraService::CameraService() :
         mSoundRef(0), mInitialized(false),
         mAudioRestriction(hardware::camera2::ICameraDeviceUser::AUDIO_RESTRICTION_NONE) {
     ALOGI("CameraService started (pid=%d)", getpid());
+    evictedClients.clear();
     mServiceLockWrapper = std::make_shared<WaitableMutexWrapper>(&mServiceLock);
 }
 
@@ -495,8 +496,9 @@ void CameraService::onDeviceStatusChanged(const String8& id,
 }
 
 void CameraService::disconnectClient(const String8& id, sp<BasicClient> clientToDisconnect) {
+
     if (clientToDisconnect.get() != nullptr) {
-        ALOGI("%s: Client for camera ID %s evicted due to device status change from HAL",
+        ALOGI("Shiva %s: Client for camera ID %s evicted due to device status change from HAL",
                 __FUNCTION__, id.string());
         // Notify the client of disconnection
         clientToDisconnect->disconnect();
@@ -1243,6 +1245,7 @@ void CameraService::finishConnectLocked(const sp<BasicClient>& client,
         const CameraService::DescriptorPtr& desc) {
 
     // Make a descriptor for the incoming client
+ALOGE("Shiva finishConnectLocked called");
     auto clientDescriptor = CameraService::CameraClientManager::makeClientDescriptor(client, desc);
     auto evicted = mActiveClientManager.addAndEvict(clientDescriptor);
 
@@ -1252,7 +1255,7 @@ void CameraService::finishConnectLocked(const sp<BasicClient>& client,
     if (evicted.size() > 0) {
         // This should never happen - clients should already have been removed in disconnect
         for (auto& i : evicted) {
-            ALOGE("%s: Invalid state: Client for camera %s was not removed in disconnect",
+            ALOGE("Shiva %s: Invalid state: Client for camera %s was not removed in disconnect",
                     __FUNCTION__, i->getKey().string());
         }
 
@@ -1277,8 +1280,9 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
         sp<BasicClient>* client,
         std::shared_ptr<resource_policy::ClientDescriptor<String8, sp<BasicClient>>>* partial) {
     ATRACE_CALL();
+    ALOGE("Shiva handleEvictionsLocked called %s", packageName.string());
     status_t ret = NO_ERROR;
-    std::vector<DescriptorPtr> evictedClients;
+    
     DescriptorPtr clientDescriptor;
     {
         if (effectiveApiLevel == API_1) {
@@ -1290,10 +1294,12 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
                 auto clientSp = current->getValue();
                 if (clientSp.get() != nullptr) { // should never be needed
                     if (!clientSp->canCastToApiClient(effectiveApiLevel)) {
-                        ALOGW("CameraService connect called from same client, but with a different"
+                        ALOGW("Shiva CameraService connect called from same client, but with a different"
                                 " API level, evicting prior client...");
+			                //return -EBUSY; // CAMERA_IN_USE
+
                     } else if (clientSp->getRemote() == remoteCallback) {
-                        ALOGI("CameraService::connect X (PID %d) (second call from same"
+                        ALOGI("Shiva CameraService::connect X (PID %d) (second call from same"
                                 " app binder, returning the same client)", clientPid);
                         *client = clientSp;
                         return NO_ERROR;
@@ -1304,6 +1310,8 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
 
         // Get current active client PIDs
         std::vector<int> ownerPids(mActiveClientManager.getAllOwners());
+        ALOGE("Shiva handleEvictionsLocked client pid %d", clientPid);
+
         ownerPids.push_back(clientPid);
 
         std::vector<int> priorityScores(ownerPids.size());
@@ -1319,7 +1327,9 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
             return err;
         }
 
-        // Update all active clients' priorities
+        // Update all active clients
+	ALOGE("Shiva handleEvictionsLocked called 1");
+	 
         std::map<int,resource_policy::ClientPriority> pidToPriorityMap;
         for (size_t i = 0; i < ownerPids.size() - 1; i++) {
             pidToPriorityMap.emplace(ownerPids[i],
@@ -1330,6 +1340,7 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
 
         // Get state for the given cameraId
         auto state = getCameraState(cameraId);
+	ALOGE("shiva camera state ");
         if (state == nullptr) {
             ALOGE("CameraService::connect X (PID %d) rejected (no camera device with ID %s)",
                 clientPid, cameraId.string());
@@ -1349,11 +1360,12 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
 
         // Find clients that would be evicted
         auto evicted = mActiveClientManager.wouldEvict(clientDescriptor);
+        ALOGE("Shiva handleEvictionsLocked called 2 evicted %d", (unsigned int) evicted.size());
 
         // If the incoming client was 'evicted,' higher priority clients have the camera in the
         // background, so we cannot do evictions
         if (std::find(evicted.begin(), evicted.end(), clientDescriptor) != evicted.end()) {
-            ALOGE("CameraService::connect X (PID %d) rejected (existing client(s) with higher"
+            ALOGE("Shiva CameraService::connect X (PID %d) rejected (existing client(s) with higher"
                     " priority).", clientPid);
 
             sp<BasicClient> clientSp = clientDescriptor->getValue();
@@ -1373,7 +1385,7 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
                         String8{i->getValue()->getPackageName()}.string(),
                         i->getOwnerId(), i->getPriority().getScore(),
                         i->getPriority().getState());
-                ALOGE("   Conflicts with: Device %s, client package %s (PID %"
+                ALOGE("Shiva   Conflicts with: Device %s, client package %s (PID %"
                         PRId32 ", score %" PRId32 ", state %" PRId32 ")", i->getKey().string(),
                         String8{i->getValue()->getPackageName()}.string(), i->getOwnerId(),
                         i->getPriority().getScore(), i->getPriority().getState());
@@ -1384,6 +1396,8 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
             mEventLog.add(msg);
 
             auto current = mActiveClientManager.get(cameraId);
+	            ALOGE("Shiva handleEvictionsLocked called 3 current ");
+
             if (current != nullptr) {
                 return -EBUSY; // CAMERA_IN_USE
             } else {
@@ -1394,7 +1408,7 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
         for (auto& i : evicted) {
             sp<BasicClient> clientSp = i->getValue();
             if (clientSp.get() == nullptr) {
-                ALOGE("%s: Invalid state: Null client in active client list.", __FUNCTION__);
+                ALOGE("Shiva %s: Invalid state: Null client in active client list.", __FUNCTION__);
 
                 // TODO: Remove this
                 LOG_ALWAYS_FATAL("%s: Invalid state for CameraService, null client in active list",
@@ -1403,7 +1417,7 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
                 continue;
             }
 
-            ALOGE("CameraService::connect evicting conflicting client for camera ID %s",
+            ALOGE("Shiva CameraService::connect evicting conflicting client for camera ID %s",
                     i->getKey().string());
             evictedClients.push_back(i);
 
@@ -1439,11 +1453,11 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
     CameraThreadState::restoreCallingIdentity(token);
 
     for (const auto& i : evictedClients) {
-        ALOGV("%s: Waiting for disconnect to complete for client for device %s (PID %" PRId32 ")",
+        ALOGV("Shiva %s: Waiting for disconnect to complete for client for device %s (PID %" PRId32 ")",
                 __FUNCTION__, i->getKey().string(), i->getOwnerId());
         ret = mActiveClientManager.waitUntilRemoved(i, DEFAULT_DISCONNECT_TIMEOUT_NS);
         if (ret == TIMED_OUT) {
-            ALOGE("%s: Timed out waiting for client for device %s to disconnect, "
+            ALOGE("Shiva %s: Timed out waiting for client for device %s to disconnect, "
                     "current clients:\n%s", __FUNCTION__, i->getKey().string(),
                     mActiveClientManager.toString().string());
             return -EBUSY;
@@ -1456,7 +1470,7 @@ status_t CameraService::handleEvictionsLocked(const String8& cameraId, int clien
         }
     }
 
-    evictedClients.clear();
+    //evictedClients.clear();
 
     // Once clients have been disconnected, relock
     mServiceLock.lock();
@@ -1630,7 +1644,7 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
 
     int originalClientPid = 0;
 
-    ALOGI("CameraService::connect call (PID %d \"%s\", camera ID %s) for HAL version %s and "
+    ALOGI("Shiva CameraService::connect call (PID %d \"%s\", camera ID %s) for HAL version %s and "
             "Camera API version %d", clientPid, clientName8.string(), cameraId.string(),
             (halVersion == -1) ? "default" : std::to_string(halVersion).c_str(),
             static_cast<int>(effectiveApiLevel));
@@ -1642,7 +1656,7 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
                 AutoConditionLock::waitAndAcquire(mServiceLockWrapper, DEFAULT_CONNECT_TIMEOUT_NS);
 
         if (lock == nullptr) {
-            ALOGE("CameraService::connect (PID %d) rejected (too many other clients connecting)."
+            ALOGE("Shiva CameraService::connect (PID %d) rejected (too many other clients connecting)."
                     , clientPid);
             return STATUS_ERROR_FMT(ERROR_MAX_CAMERAS_IN_USE,
                     "Cannot open camera %s for \"%s\" (PID %d): Too many other clients connecting",
@@ -1761,7 +1775,7 @@ Status CameraService::connectHelper(const sp<CALLBACK>& cameraCb, const String8&
             if (cameraState != nullptr) {
                 cameraState->setShimParams(params);
             } else {
-                ALOGE("%s: Cannot update shim parameters for camera %s, no such device exists.",
+                ALOGE("Shiva %s: Cannot update shim parameters for camera %s, no such device exists.",
                         __FUNCTION__, cameraId.string());
             }
         }
@@ -1834,9 +1848,10 @@ status_t CameraService::addOfflineClient(String8 cameraId, sp<BasicClient> offli
         }
 
         auto evicted = mActiveClientManager.addAndEvict(offlineClientDesc);
-        if (evicted.size() > 0) {
+        ALOGE("Shiva addand evict %u",(unsigned int)evicted.size());
+		if (evicted.size() > 0) {
             for (auto& i : evicted) {
-                ALOGE("%s: Invalid state: Offline client for camera %s was not removed ",
+                ALOGE("Shiva %s: Invalid state: Offline client for camera %s was not removed ",
                         __FUNCTION__, i->getKey().string());
             }
 
@@ -2398,6 +2413,7 @@ void CameraService::removeByClient(const BasicClient* client) {
 bool CameraService::evictClientIdByRemote(const wp<IBinder>& remote) {
     bool ret = false;
     {
+	ALOGE("shiva evictClientIdByRemote called");
         // Acquire mServiceLock and prevent other clients from connecting
         std::unique_ptr<AutoConditionLock> lock =
                 AutoConditionLock::waitAndAcquire(mServiceLockWrapper);
@@ -2460,7 +2476,7 @@ sp<CameraService::BasicClient> CameraService::removeClientLocked(const String8&
     // Remove from active clients list
     auto clientDescriptorPtr = mActiveClientManager.remove(cameraId);
     if (clientDescriptorPtr == nullptr) {
-        ALOGW("%s: Could not evict client, no client for camera ID %s", __FUNCTION__,
+        ALOGW("Shiva %s: Could not evict client, no client for camera ID %s", __FUNCTION__,
                 cameraId.string());
         return sp<BasicClient>{nullptr};
     }
@@ -2472,7 +2488,7 @@ void CameraService::doUserSwitch(const std::vector<int32_t>& newUserIds) {
     // Acquire mServiceLock and prevent other clients from connecting
     std::unique_ptr<AutoConditionLock> lock =
             AutoConditionLock::waitAndAcquire(mServiceLockWrapper);
-
+ALOGE("Shiva doUserSwitch called");
     std::set<userid_t> newAllowedUsers;
     for (size_t i = 0; i < newUserIds.size(); i++) {
         if (newUserIds[i] < 0) {
@@ -2514,7 +2530,7 @@ void CameraService::doUserSwitch(const std::vector<int32_t>& newUserIds) {
 
         String8 curTime = getFormattedCurrentTime();
 
-        ALOGE("Evicting conflicting client for camera ID %s due to user change",
+        ALOGE("Shiva Evicting conflicting client for camera ID %s due to user change",
                 i->getKey().string());
 
         // Log the clients evicted
@@ -2552,6 +2568,7 @@ void CameraService::logEvent(const char* event) {
 
 void CameraService::logDisconnected(const char* cameraId, int clientPid,
         const char* clientPackage) {
+		ALOGE("Shiva logDisconnected called evicted client count %d", (unsigned int)evictedClients.size());
     // Log the clients evicted
     logEvent(String8::format("DISCONNECT device %s client for package %s (PID %d)", cameraId,
             clientPackage, clientPid));
@@ -2559,6 +2576,7 @@ void CameraService::logDisconnected(const char* cameraId, int clientPid,
 
 void CameraService::logDisconnectedOffline(const char* cameraId, int clientPid,
         const char* clientPackage) {
+		ALOGE("Shiva logDisconnectedOffline called");
     // Log the clients evicted
     logEvent(String8::format("DISCONNECT offline device %s client for package %s (PID %d)",
                 cameraId, clientPackage, clientPid));
@@ -2566,6 +2584,7 @@ void CameraService::logDisconnectedOffline(const char* cameraId, int clientPid,
 
 void CameraService::logConnected(const char* cameraId, int clientPid,
         const char* clientPackage) {
+				ALOGE("Shiva logConnected called");
     // Log the clients evicted
     logEvent(String8::format("CONNECT device %s client for package %s (PID %d)", cameraId,
             clientPackage, clientPid));
@@ -2573,6 +2592,7 @@ void CameraService::logConnected(const char* cameraId, int clientPid,
 
 void CameraService::logConnectedOffline(const char* cameraId, int clientPid,
         const char* clientPackage) {
+						ALOGE("Shiva logConnectedOffline called");
     // Log the clients evicted
     logEvent(String8::format("CONNECT offline device %s client for package %s (PID %d)", cameraId,
             clientPackage, clientPid));
@@ -2580,6 +2600,7 @@ void CameraService::logConnectedOffline(const char* cameraId, int clientPid,
 
 void CameraService::logRejected(const char* cameraId, int clientPid,
         const char* clientPackage, const char* reason) {
+								ALOGE("Shiva logRejected called");
     // Log the client rejected
     logEvent(String8::format("REJECT device %s client for package %s (PID %d), reason: (%s)",
             cameraId, clientPackage, clientPid, reason));
@@ -2593,6 +2614,7 @@ void CameraService::logTorchEvent(const char* cameraId, const char *torchState,
 
 void CameraService::logUserSwitch(const std::set<userid_t>& oldUserIds,
         const std::set<userid_t>& newUserIds) {
+					ALOGE("Shiva logUserSwitch called");
     String8 newUsers = toString(newUserIds);
     String8 oldUsers = toString(oldUserIds);
     if (oldUsers.size() == 0) {
@@ -2605,16 +2627,19 @@ void CameraService::logUserSwitch(const std::set<userid_t>& oldUserIds,
 
 void CameraService::logDeviceRemoved(const char* cameraId, const char* reason) {
     // Log the device removal
+					ALOGE("Shiva logDeviceRemoved called");
     logEvent(String8::format("REMOVE device %s, reason: (%s)", cameraId, reason));
 }
 
 void CameraService::logDeviceAdded(const char* cameraId, const char* reason) {
     // Log the device removal
+						ALOGE("Shiva logDeviceAdded called");
     logEvent(String8::format("ADD device %s, reason: (%s)", cameraId, reason));
 }
 
 void CameraService::logClientDied(int clientPid, const char* reason) {
     // Log the device removal
+							ALOGE("Shiva logClientDied called");
     logEvent(String8::format("DIED client(s) with PID %d, reason: (%s)", clientPid, reason));
 }
 
@@ -3727,10 +3752,10 @@ void CameraService::handleTorchClientBinderDied(const wp<IBinder> &who) {
 
     // check torch client
     handleTorchClientBinderDied(who);
-
+							ALOGE("Shiva binderDied called");
     // check camera device client
     if(!evictClientIdByRemote(who)) {
-        ALOGV("%s: Java client's binder death already cleaned up (normal case)", __FUNCTION__);
+        ALOGV("Shiva %s: Java client's binder death already cleaned up (normal case)", __FUNCTION__);
         return;
     }
 
-- 
2.32.0

