From b912dc25ef7e14d4c2aa55205924da9a47724d3f Mon Sep 17 00:00:00 2001
From: "M, Kumar K" <kumar.k.m@intel.com>
Date: Thu, 8 Aug 2019 15:48:22 +0530
Subject: [PATCH] Handle HDMI audio in wiredaccessory mgr

Change-Id: Ie63e44d67fa74c528b19028924b164db2a2ee7a3
Tracked-On:
Signed-off-by: M, Kumar K <kumar.k.m@intel.com>
---
 .../com/android/server/WiredAccessoryManager.java  | 81 ++++++++++++++--------
 1 file changed, 52 insertions(+), 29 deletions(-)
 mode change 100644 => 100755 services/core/java/com/android/server/WiredAccessoryManager.java

diff --git a/services/core/java/com/android/server/WiredAccessoryManager.java b/services/core/java/com/android/server/WiredAccessoryManager.java
old mode 100644
new mode 100755
index 9bbc315..b93110e
--- a/services/core/java/com/android/server/WiredAccessoryManager.java
+++ b/services/core/java/com/android/server/WiredAccessoryManager.java
@@ -55,7 +55,7 @@ import java.util.Locale;
  */
 final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     private static final String TAG = WiredAccessoryManager.class.getSimpleName();
-    private static final boolean LOG = false;
+    private static final boolean LOG = true;
 
     private static final int BIT_HEADSET = (1 << 0);
     private static final int BIT_HEADSET_NO_MIC = (1 << 1);
@@ -107,15 +107,16 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
     private void onSystemReady() {
         if (mUseDevInputEventForAudioJack) {
             int switchValues = 0;
-            if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_HEADPHONE_INSERT)
-                    == 1) {
+            if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_HEADPHONE_INSERT) == 1) {
+		Log.v(TAG, " SW_HEADPHONE_INSERT ");
                 switchValues |= SW_HEADPHONE_INSERT_BIT;
             }
-            if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_MICROPHONE_INSERT)
-                    == 1) {
-                switchValues |= SW_MICROPHONE_INSERT_BIT;
+            if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_MICROPHONE_INSERT) == 1) {
+                 Log.v(TAG, " SW_MICROPHONE_INSERT");
+		switchValues |= SW_MICROPHONE_INSERT_BIT;
             }
             if (mInputManager.getSwitchState(-1, InputDevice.SOURCE_ANY, SW_LINEOUT_INSERT) == 1) {
+		 Log.v(TAG,"SW_LINEOUT_INSERT #######");
                 switchValues |= SW_LINEOUT_INSERT_BIT;
             }
             notifyWiredAccessoryChanged(0, switchValues,
@@ -136,11 +137,14 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
     @Override
     public void notifyWiredAccessoryChanged(long whenNanos, int switchValues, int switchMask) {
-        if (LOG) {
-            Slog.v(TAG, "notifyWiredAccessoryChanged: when=" + whenNanos
-                    + " bits=" + switchCodeToString(switchValues, switchMask)
-                    + " mask=" + Integer.toHexString(switchMask));
-        }
+        Log.e(TAG, "notifyWiredAccessoryChanged: when=" + whenNanos
+                + " bits=" + switchCodeToString(switchValues, switchMask)
+                + " mask=" + Integer.toHexString(switchMask));
+
+  Log.e(TAG, " notifyWiredAccessoryChanged: when=" + whenNanos
+                + " bits=" + switchCodeToString(switchValues, switchMask)
+                + " mask=" + Integer.toHexString(switchMask));
+
 
         synchronized (mLock) {
             int headset;
@@ -148,26 +152,37 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             switch (mSwitchValues &
                     (SW_HEADPHONE_INSERT_BIT | SW_MICROPHONE_INSERT_BIT | SW_LINEOUT_INSERT_BIT)) {
                 case 0:
+			Log.v(TAG," case-0");
                     headset = 0;
                     break;
 
                 case SW_HEADPHONE_INSERT_BIT:
+			Log.v(TAG," case:SW_HEADPHONE_INSERT_BIT");
                     headset = BIT_HEADSET_NO_MIC;
                     break;
 
                 case SW_LINEOUT_INSERT_BIT:
+			Log.v(TAG," case:SW_LINEOUT_INSERT_BIT");
                     headset = BIT_LINEOUT;
                     break;
 
                 case SW_HEADPHONE_INSERT_BIT | SW_MICROPHONE_INSERT_BIT:
+			Log.v(TAG," case: SW_HEADPHONE_INSERT_BIT| SW_MICROPHONE_INSERT_BIT ");
                     headset = BIT_HEADSET;
                     break;
 
                 case SW_MICROPHONE_INSERT_BIT:
+			Log.v(TAG," case:SW_MICROPHONE_INSERT_BIT");
+                    headset = BIT_HEADSET;
+                    break;
+                
+                case SW_HEADPHONE_INSERT_BIT | SW_LINEOUT_INSERT_BIT:
+			Log.v(TAG," case : SW_HEADPHONE_INSERT_BIT | SW_LINEOUT_INSERT_BIT");
                     headset = BIT_HEADSET;
                     break;
 
                 default:
+			Log.v(TAG," case :default");
                     headset = 0;
                     break;
             }
@@ -204,12 +219,10 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
         int h2w_headset = headsetState & (BIT_HEADSET | BIT_HEADSET_NO_MIC | BIT_LINEOUT);
         boolean h2wStateChange = true;
         boolean usbStateChange = true;
-        if (LOG) {
-            Slog.v(TAG, "newName=" + newName
-                    + " newState=" + newState
-                    + " headsetState=" + headsetState
-                    + " prev headsetState=" + mHeadsetState);
-        }
+        Log.e(TAG, " newName=" + newName
+                + " newState=" + newState
+                + " headsetState=" + headsetState
+                + " prev headsetState=" + mHeadsetState);
 
         if (mHeadsetState == headsetState) {
             Log.e(TAG, "No state change.");
@@ -280,6 +293,8 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             int inDevice = 0;
             int state;
 
+            Log.v(TAG," headset = " + headset);
+
             if ((headsetState & headset) != 0) {
                 state = 1;
             } else {
@@ -287,12 +302,15 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             }
 
             if (headset == BIT_HEADSET) {
+		Log.v(TAG," inside AudioManager.DEVICE_OUT_WIRED_HEADSET");
                 outDevice = AudioManager.DEVICE_OUT_WIRED_HEADSET;
                 inDevice = AudioManager.DEVICE_IN_WIRED_HEADSET;
             } else if (headset == BIT_HEADSET_NO_MIC) {
                 outDevice = AudioManager.DEVICE_OUT_WIRED_HEADPHONE;
             } else if (headset == BIT_LINEOUT) {
                 outDevice = AudioManager.DEVICE_OUT_LINE;
+		Log.v(TAG," inside BIT_LINEOUT");
+//		outDevice = AudioManager.DEVICE_OUT_HDMI;
             } else if (headset == BIT_USB_HEADSET_ANLG) {
                 outDevice = AudioManager.DEVICE_OUT_ANLG_DOCK_HEADSET;
             } else if (headset == BIT_USB_HEADSET_DGTL) {
@@ -300,12 +318,12 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             } else if (headset == BIT_HDMI_AUDIO) {
                 outDevice = AudioManager.DEVICE_OUT_HDMI;
             } else {
-                Slog.e(TAG, "setDeviceState() invalid headset type: " + headset);
+                Log.e(TAG, "setDeviceState() invalid headset type: "+headset);
                 return;
             }
 
             if (LOG) {
-                Slog.v(TAG, "headsetName: " + headsetName +
+                Log.e(TAG, "headsetName: " + headsetName +
                         (state == 1 ? " connected" : " disconnected"));
             }
 
@@ -382,18 +400,20 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             if (!mUseDevInputEventForAudioJack) {
                 uei = new UEventInfo(NAME_H2W, BIT_HEADSET, BIT_HEADSET_NO_MIC, BIT_LINEOUT);
                 if (uei.checkSwitchExists()) {
+			Log.v(TAG, "## inside H2W, Headset, : ");
                     retVal.add(uei);
                 } else {
-                    Slog.w(TAG, "This kernel does not have wired headset support");
+                    Log.v(TAG, "This kernel does not have wired headset support");
                 }
             }
 
             // Monitor USB
             uei = new UEventInfo(NAME_USB_AUDIO, BIT_USB_HEADSET_ANLG, BIT_USB_HEADSET_DGTL, 0);
             if (uei.checkSwitchExists()) {
+		Log.v(TAG, "## inside USB switch: USB");
                 retVal.add(uei);
             } else {
-                Slog.w(TAG, "This kernel does not have usb audio support");
+                Log.v(TAG, "This kernel does not have usb audio support");
             }
 
             // Monitor HDMI
@@ -404,15 +424,18 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
             //
             // If the kernel does not have an "hdmi_audio" switch, just fall back on the older
             // "hdmi" switch instead.
-            uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, 0, 0);
+            //uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, BIT_LINEOUT, 0);
+		uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, BIT_LINEOUT, 0);
             if (uei.checkSwitchExists()) {
+		Log.v(TAG, "inside switch-1: NAME_HDMI_AUDIO");
                 retVal.add(uei);
             } else {
-                uei = new UEventInfo(NAME_HDMI, BIT_HDMI_AUDIO, 0, 0);
+                uei = new UEventInfo(NAME_HDMI, BIT_HDMI_AUDIO, BIT_LINEOUT, 0);
+		Log.e(TAG, " inside switch-2: NAME_HDMI");
                 if (uei.checkSwitchExists()) {
                     retVal.add(uei);
                 } else {
-                    Slog.w(TAG, "This kernel does not have HDMI audio support");
+                    Log.e(TAG, " This kernel does not have HDMI audio support");
                 }
             }
 
@@ -421,7 +444,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
 
         @Override
         public void onUEvent(UEventObserver.UEvent event) {
-            if (LOG) Slog.v(TAG, "Headset UEVENT: " + event.toString());
+             Log.v(TAG, "Headset UEVENT: " + event.toString());
 
             try {
                 String devPath = event.get("DEVPATH");
@@ -431,7 +454,7 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                     updateStateLocked(devPath, name, state);
                 }
             } catch (NumberFormatException e) {
-                Slog.e(TAG, "Could not parse switch state from event " + event);
+                Log.e(TAG, "Could not parse switch state from event " + event);
             }
         }
 
@@ -458,9 +481,9 @@ final class WiredAccessoryManager implements WiredAccessoryCallbacks {
                 mStateNbits = stateNbits;
             }
 
-            public String getDevName() {
-                return mDevName;
-            }
+            public String getDevName() { 
+		Log.v(" mDevName = %s", mDevName);
+		return mDevName; }
 
             public String getDevPath() {
                 return String.format(Locale.US, "/devices/virtual/switch/%s", mDevName);
-- 
1.9.1

