From 645b908dbad34251b5216c92d86650cae67d1109 Mon Sep 17 00:00:00 2001
From: android-build-team Robot <android-build-team-robot@google.com>
Date: Wed, 14 Aug 2019 23:26:47 +0000
Subject: [PATCH] debug

Change-Id: I9122c637770bde51648e02a80adf1c2542338595
---
 .../internal/os/BatteryStatsHelper.java       | 31 +++++-
 .../android/internal/os/BatteryStatsImpl.java | 96 ++++++++++++++-----
 .../internal/os/CpuPowerCalculator.java       |  4 +-
 .../internal/os/KernelCpuSpeedReader.java     |  3 +-
 .../internal/os/KernelCpuUidTimeReader.java   | 11 ++-
 .../com/android/internal/os/PowerProfile.java | 31 ++++++
 .../server/am/BatteryStatsService.java        | 30 ++++--
 .../server/stats/StatsCompanionService.java   |  8 ++
 8 files changed, 173 insertions(+), 41 deletions(-)

diff --git a/core/java/com/android/internal/os/BatteryStatsHelper.java b/core/java/com/android/internal/os/BatteryStatsHelper.java
index e85508ed789..49d482aacfd 100644
--- a/core/java/com/android/internal/os/BatteryStatsHelper.java
+++ b/core/java/com/android/internal/os/BatteryStatsHelper.java
@@ -64,7 +64,8 @@ import java.util.Locale;
  * onAttach() for Fragment), call create() in onCreate() and call destroy() in onDestroy().
  */
 public class BatteryStatsHelper {
-    static final boolean DEBUG = false;
+    private final Object mLock = new Object();
+    static final boolean DEBUG = true;
 
     private static final String TAG = BatteryStatsHelper.class.getSimpleName();
 
@@ -265,6 +266,7 @@ public class BatteryStatsHelper {
 
     @UnsupportedAppUsage
     public BatteryStats getStats() {
+        Log.w(TAG, "sun_getStats() " + mStats);
         if (mStats == null) {
             load();
         }
@@ -290,6 +292,8 @@ public class BatteryStatsHelper {
 
     @UnsupportedAppUsage
     public void create(Bundle icicle) {
+        Log.w(TAG, "sun_create() icicle");
+        Log.w(TAG, "sun_create() sStatsXfer " + sStatsXfer + " sBatteryBroadcastXfer " + sBatteryBroadcastXfer);
         if (icicle != null) {
             mStats = sStatsXfer;
             mBatteryBroadcast = sBatteryBroadcastXfer;
@@ -297,6 +301,7 @@ public class BatteryStatsHelper {
         mBatteryInfo = IBatteryStats.Stub.asInterface(
                 ServiceManager.getService(BatteryStats.SERVICE_NAME));
         mPowerProfile = new PowerProfile(mContext);
+        Log.w(TAG, "sun_create() mBatteryInfo " + mBatteryInfo + " mPowerProfile " + mPowerProfile);
     }
 
     @UnsupportedAppUsage
@@ -348,6 +353,7 @@ public class BatteryStatsHelper {
      */
     @UnsupportedAppUsage
     public void refreshStats(int statsType, List<UserHandle> asUsers) {
+        Log.w(TAG, "sun_refreshStats1");
         final int n = asUsers.size();
         SparseArray<UserHandle> users = new SparseArray<>(n);
         for (int i = 0; i < n; ++i) {
@@ -362,6 +368,7 @@ public class BatteryStatsHelper {
      */
     @UnsupportedAppUsage
     public void refreshStats(int statsType, SparseArray<UserHandle> asUsers) {
+        Log.w(TAG, "sun_refreshStats2");
         refreshStats(statsType, asUsers, SystemClock.elapsedRealtime() * 1000,
                 SystemClock.uptimeMillis() * 1000);
     }
@@ -373,6 +380,7 @@ public class BatteryStatsHelper {
                     + "STATS_SINCE_CHARGED is supported. Using STATS_SINCE_CHARGED instead.");
         }
 
+        Log.w(TAG, "sun_refreshStats " + mStats);
         // Initialize mStats if necessary.
         getStats();
 
@@ -387,6 +395,7 @@ public class BatteryStatsHelper {
         mUserSippers.clear();
         mMobilemsppList.clear();
 
+        Log.w(TAG, "sun_refreshStats " + mStats);
         if (mStats == null) {
             return;
         }
@@ -474,6 +483,7 @@ public class BatteryStatsHelper {
         mMaxDrainedPower = (mStats.getHighDischargeAmountSinceCharge()
                 * mPowerProfile.getBatteryCapacity()) / 100;
 
+        Log.w(TAG, "sun_refreshStats processAppUsage");
         processAppUsage(asUsers);
 
         // Before aggregating apps in to users, collect all apps to sort by their ms per packet.
@@ -552,9 +562,11 @@ public class BatteryStatsHelper {
         // Smear it!
         final double hiddenPowerMah = removeHiddenBatterySippers(mUsageList);
         final double totalRemainingPower = getTotalPower() - hiddenPowerMah;
+        Log.w(TAG, "sun_refreshStats totalRemainingPower " + totalRemainingPower);
         if (Math.abs(totalRemainingPower) > 1e-3) {
             for (int i = 0, size = mUsageList.size(); i < size; i++) {
                 final BatterySipper sipper = mUsageList.get(i);
+            Log.w(TAG, "sun_refreshStats uid " + sipper.getUid() + " sipper.shouldHide " + sipper.shouldHide);
                 if (!sipper.shouldHide) {
                     sipper.proportionalSmearMah = hiddenPowerMah
                             * ((sipper.totalPowerMah + sipper.screenPowerMah)
@@ -572,6 +584,7 @@ public class BatteryStatsHelper {
         BatterySipper osSipper = null;
         final SparseArray<? extends Uid> uidStats = mStats.getUidStats();
         final int NU = uidStats.size();
+        Log.d(TAG, String.format("sun_ uidStats.size %d", NU));
         for (int iu = 0; iu < NU; iu++) {
             final Uid u = uidStats.valueAt(iu);
             final BatterySipper app = new BatterySipper(BatterySipper.DrainType.APP, u, 0);
@@ -590,10 +603,10 @@ public class BatteryStatsHelper {
             mMediaPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);
 
             final double totalPower = app.sumPower();
-            if (DEBUG && totalPower != 0) {
+            //if (DEBUG && totalPower != 0) {
                 Log.d(TAG, String.format("UID %d: total power=%s", u.getUid(),
                         makemAh(totalPower)));
-            }
+            //}
 
             // Add the app to the list if it is consuming power.
             if (totalPower != 0 || u.getUid() == 0) {
@@ -609,6 +622,7 @@ public class BatteryStatsHelper {
                 } else if (!forAllUsers && asUsers.get(userId) == null
                         && UserHandle.getAppId(uid) >= Process.FIRST_APPLICATION_UID) {
                     // We are told to just report this user's apps as one large entry.
+                Log.d(TAG, "processAppUsage");
                     List<BatterySipper> list = mUserSippers.get(userId);
                     if (list == null) {
                         list = new ArrayList<>();
@@ -616,6 +630,7 @@ public class BatteryStatsHelper {
                     }
                     list.add(app);
                 } else {
+                Log.d(TAG, "processAppUsage2 app.getUid" + app.getUid() + " userId " + app.userId);
                     mUsageList.add(app);
                 }
 
@@ -806,6 +821,12 @@ public class BatteryStatsHelper {
 
     @UnsupportedAppUsage
     public List<BatterySipper> getUsageList() {
+        Log.d(TAG, "sun_getUsageList");
+            final int usageListCount = mUsageList.size();
+            for (int i = 0; i < usageListCount; i++) {
+                Log.d(TAG, "sun_getUsageList " +  mUsageList.get(i).getUid());
+                Log.d(TAG, "sun_getUsageList " +  mUsageList.get(i).userId + " " +  mUsageList.get(i).totalPowerMah);
+            }
         return mUsageList;
     }
 
@@ -1043,6 +1064,7 @@ public class BatteryStatsHelper {
 
     @UnsupportedAppUsage
     private void load() {
+        Log.w(TAG, "sun_load mBatteryInfo " + mBatteryInfo);
         if (mBatteryInfo == null) {
             return;
         }
@@ -1054,6 +1076,7 @@ public class BatteryStatsHelper {
     }
 
     private static BatteryStatsImpl getStats(IBatteryStats service) {
+        Log.w(TAG, "sun_getStats() service " + service);
         try {
             ParcelFileDescriptor pfd = service.getStatisticsStream();
             if (pfd != null) {
@@ -1066,8 +1089,10 @@ public class BatteryStatsHelper {
                     Parcel parcel = Parcel.obtain();
                     parcel.unmarshall(data, 0, data.length);
                     parcel.setDataPosition(0);
+                    Log.w(TAG, "sun_getStats() createFromParcel");
                     BatteryStatsImpl stats = com.android.internal.os.BatteryStatsImpl.CREATOR
                             .createFromParcel(parcel);
+                    Log.w(TAG, "sun_getStats() createFromParcel stats" + stats);
                     return stats;
                 } catch (IOException e) {
                     Log.w(TAG, "Unable to read statistics stream", e);
diff --git a/core/java/com/android/internal/os/BatteryStatsImpl.java b/core/java/com/android/internal/os/BatteryStatsImpl.java
index 3a7caa4c2fc..27c96d019f1 100644
--- a/core/java/com/android/internal/os/BatteryStatsImpl.java
+++ b/core/java/com/android/internal/os/BatteryStatsImpl.java
@@ -132,12 +132,13 @@ import java.util.concurrent.locks.ReentrantLock;
  */
 public class BatteryStatsImpl extends BatteryStats {
     private static final String TAG = "BatteryStatsImpl";
-    private static final boolean DEBUG = false;
-    public static final boolean DEBUG_ENERGY = false;
+    private static final boolean DEBUG = true;
+    private static final boolean NDEBUG = false;
+    public static final boolean DEBUG_ENERGY = true;
     private static final boolean DEBUG_ENERGY_CPU = DEBUG_ENERGY;
-    private static final boolean DEBUG_MEMORY = false;
-    private static final boolean DEBUG_HISTORY = false;
-    private static final boolean USE_OLD_HISTORY = false;   // for debugging.
+    private static final boolean DEBUG_MEMORY = true;
+    private static final boolean DEBUG_HISTORY = true;
+    private static final boolean USE_OLD_HISTORY = true;   // for debugging.
 
     // TODO: remove "tcp" from network methods, since we measure total stats.
 
@@ -1569,12 +1570,14 @@ public class BatteryStatsImpl extends BatteryStats {
         private long mCount;
 
         public LongSamplingCounter(TimeBase timeBase, Parcel in) {
+            Slog.i(TAG, "new time base #1");
             mTimeBase = timeBase;
             mCount = in.readLong();
             timeBase.add(this);
         }
 
         public LongSamplingCounter(TimeBase timeBase) {
+            Slog.i(TAG, "new time base #2");
             mTimeBase = timeBase;
             timeBase.add(this);
         }
@@ -3254,21 +3257,21 @@ public class BatteryStatsImpl extends BatteryStats {
             firstToken |= DELTA_BATTERY_CHARGE_FLAG;
         }
         dest.writeInt(firstToken);
-        if (DEBUG) Slog.i(TAG, "WRITE DELTA: firstToken=0x" + Integer.toHexString(firstToken)
+        if (NDEBUG) Slog.i(TAG, "WRITE DELTA: firstToken=0x" + Integer.toHexString(firstToken)
                 + " deltaTime=" + deltaTime);
 
         if (deltaTimeToken >= DELTA_TIME_INT) {
             if (deltaTimeToken == DELTA_TIME_INT) {
-                if (DEBUG) Slog.i(TAG, "WRITE DELTA: int deltaTime=" + (int)deltaTime);
+                if (NDEBUG) Slog.i(TAG, "WRITE DELTA: int deltaTime=" + (int)deltaTime);
                 dest.writeInt((int)deltaTime);
             } else {
-                if (DEBUG) Slog.i(TAG, "WRITE DELTA: long deltaTime=" + deltaTime);
+                if (NDEBUG) Slog.i(TAG, "WRITE DELTA: long deltaTime=" + deltaTime);
                 dest.writeLong(deltaTime);
             }
         }
         if (batteryLevelIntChanged) {
             dest.writeInt(batteryLevelInt);
-            if (DEBUG) Slog.i(TAG, "WRITE DELTA: batteryToken=0x"
+            if (NDEBUG) Slog.i(TAG, "WRITE DELTA: batteryToken=0x"
                     + Integer.toHexString(batteryLevelInt)
                     + " batteryLevel=" + cur.batteryLevel
                     + " batteryTemp=" + cur.batteryTemperature
@@ -3276,7 +3279,7 @@ public class BatteryStatsImpl extends BatteryStats {
         }
         if (stateIntChanged) {
             dest.writeInt(stateInt);
-            if (DEBUG) Slog.i(TAG, "WRITE DELTA: stateToken=0x"
+            if (NDEBUG) Slog.i(TAG, "WRITE DELTA: stateToken=0x"
                     + Integer.toHexString(stateInt)
                     + " batteryStatus=" + cur.batteryStatus
                     + " batteryHealth=" + cur.batteryHealth
@@ -3285,7 +3288,7 @@ public class BatteryStatsImpl extends BatteryStats {
         }
         if (state2IntChanged) {
             dest.writeInt(cur.states2);
-            if (DEBUG) Slog.i(TAG, "WRITE DELTA: states2=0x"
+            if (NDEBUG) Slog.i(TAG, "WRITE DELTA: states2=0x"
                     + Integer.toHexString(cur.states2));
         }
         if (cur.wakelockTag != null || cur.wakeReasonTag != null) {
@@ -3293,14 +3296,14 @@ public class BatteryStatsImpl extends BatteryStats {
             int wakeReasonIndex;
             if (cur.wakelockTag != null) {
                 wakeLockIndex = writeHistoryTag(cur.wakelockTag);
-                if (DEBUG) Slog.i(TAG, "WRITE DELTA: wakelockTag=#" + cur.wakelockTag.poolIdx
+                if (NDEBUG) Slog.i(TAG, "WRITE DELTA: wakelockTag=#" + cur.wakelockTag.poolIdx
                     + " " + cur.wakelockTag.uid + ":" + cur.wakelockTag.string);
             } else {
                 wakeLockIndex = 0xffff;
             }
             if (cur.wakeReasonTag != null) {
                 wakeReasonIndex = writeHistoryTag(cur.wakeReasonTag);
-                if (DEBUG) Slog.i(TAG, "WRITE DELTA: wakeReasonTag=#" + cur.wakeReasonTag.poolIdx
+                if (NDEBUG) Slog.i(TAG, "WRITE DELTA: wakeReasonTag=#" + cur.wakeReasonTag.poolIdx
                     + " " + cur.wakeReasonTag.uid + ":" + cur.wakeReasonTag.string);
             } else {
                 wakeReasonIndex = 0xffff;
@@ -3311,7 +3314,7 @@ public class BatteryStatsImpl extends BatteryStats {
             int index = writeHistoryTag(cur.eventTag);
             int codeAndIndex = (cur.eventCode&0xffff) | (index<<16);
             dest.writeInt(codeAndIndex);
-            if (DEBUG) Slog.i(TAG, "WRITE DELTA: event=" + cur.eventCode + " tag=#"
+            if (NDEBUG) Slog.i(TAG, "WRITE DELTA: event=" + cur.eventCode + " tag=#"
                     + cur.eventTag.poolIdx + " " + cur.eventTag.uid + ":"
                     + cur.eventTag.string);
         }
@@ -3474,7 +3477,7 @@ public class BatteryStatsImpl extends BatteryStats {
         int deltaTimeToken = firstToken&DELTA_TIME_MASK;
         cur.cmd = HistoryItem.CMD_UPDATE;
         cur.numReadInts = 1;
-        if (DEBUG) Slog.i(TAG, "READ DELTA: firstToken=0x" + Integer.toHexString(firstToken)
+        if (NDEBUG) Slog.i(TAG, "READ DELTA: firstToken=0x" + Integer.toHexString(firstToken)
                 + " deltaTimeToken=" + deltaTimeToken);
 
         if (deltaTimeToken < DELTA_TIME_ABS) {
@@ -3482,17 +3485,17 @@ public class BatteryStatsImpl extends BatteryStats {
         } else if (deltaTimeToken == DELTA_TIME_ABS) {
             cur.time = src.readLong();
             cur.numReadInts += 2;
-            if (DEBUG) Slog.i(TAG, "READ DELTA: ABS time=" + cur.time);
+            if (NDEBUG) Slog.i(TAG, "READ DELTA: ABS time=" + cur.time);
             cur.readFromParcel(src);
             return;
         } else if (deltaTimeToken == DELTA_TIME_INT) {
             int delta = src.readInt();
             cur.time += delta;
             cur.numReadInts += 1;
-            if (DEBUG) Slog.i(TAG, "READ DELTA: time delta=" + delta + " new time=" + cur.time);
+            if (NDEBUG) Slog.i(TAG, "READ DELTA: time delta=" + delta + " new time=" + cur.time);
         } else {
             long delta = src.readLong();
-            if (DEBUG) Slog.i(TAG, "READ DELTA: time delta=" + delta + " new time=" + cur.time);
+            if (NDEBUG) Slog.i(TAG, "READ DELTA: time delta=" + delta + " new time=" + cur.time);
             cur.time += delta;
             cur.numReadInts += 2;
         }
@@ -3502,7 +3505,7 @@ public class BatteryStatsImpl extends BatteryStats {
             batteryLevelInt = src.readInt();
             readBatteryLevelInt(batteryLevelInt, cur);
             cur.numReadInts += 1;
-            if (DEBUG) Slog.i(TAG, "READ DELTA: batteryToken=0x"
+            if (NDEBUG) Slog.i(TAG, "READ DELTA: batteryToken=0x"
                     + Integer.toHexString(batteryLevelInt)
                     + " batteryLevel=" + cur.batteryLevel
                     + " batteryTemp=" + cur.batteryTemperature
@@ -3532,7 +3535,7 @@ public class BatteryStatsImpl extends BatteryStats {
                     break;
             }
             cur.numReadInts += 1;
-            if (DEBUG) Slog.i(TAG, "READ DELTA: stateToken=0x"
+            if (NDEBUG) Slog.i(TAG, "READ DELTA: stateToken=0x"
                     + Integer.toHexString(stateInt)
                     + " batteryStatus=" + cur.batteryStatus
                     + " batteryHealth=" + cur.batteryHealth
@@ -3544,7 +3547,7 @@ public class BatteryStatsImpl extends BatteryStats {
 
         if ((firstToken&DELTA_STATE2_FLAG) != 0) {
             cur.states2 = src.readInt();
-            if (DEBUG) Slog.i(TAG, "READ DELTA: states2=0x"
+            if (NDEBUG) Slog.i(TAG, "READ DELTA: states2=0x"
                     + Integer.toHexString(cur.states2));
         }
 
@@ -3555,7 +3558,7 @@ public class BatteryStatsImpl extends BatteryStats {
             if (wakeLockIndex != 0xffff) {
                 cur.wakelockTag = cur.localWakelockTag;
                 readHistoryTag(wakeLockIndex, cur.wakelockTag);
-                if (DEBUG) Slog.i(TAG, "READ DELTA: wakelockTag=#" + cur.wakelockTag.poolIdx
+                if (NDEBUG) Slog.i(TAG, "READ DELTA: wakelockTag=#" + cur.wakelockTag.poolIdx
                     + " " + cur.wakelockTag.uid + ":" + cur.wakelockTag.string);
             } else {
                 cur.wakelockTag = null;
@@ -3563,7 +3566,7 @@ public class BatteryStatsImpl extends BatteryStats {
             if (wakeReasonIndex != 0xffff) {
                 cur.wakeReasonTag = cur.localWakeReasonTag;
                 readHistoryTag(wakeReasonIndex, cur.wakeReasonTag);
-                if (DEBUG) Slog.i(TAG, "READ DELTA: wakeReasonTag=#" + cur.wakeReasonTag.poolIdx
+                if (NDEBUG) Slog.i(TAG, "READ DELTA: wakeReasonTag=#" + cur.wakeReasonTag.poolIdx
                     + " " + cur.wakeReasonTag.uid + ":" + cur.wakeReasonTag.string);
             } else {
                 cur.wakeReasonTag = null;
@@ -3581,7 +3584,7 @@ public class BatteryStatsImpl extends BatteryStats {
             final int index = ((codeAndIndex>>16)&0xffff);
             readHistoryTag(index, cur.eventTag);
             cur.numReadInts += 1;
-            if (DEBUG) Slog.i(TAG, "READ DELTA: event=" + cur.eventCode + " tag=#"
+            if (NDEBUG) Slog.i(TAG, "READ DELTA: event=" + cur.eventCode + " tag=#"
                     + cur.eventTag.poolIdx + " " + cur.eventTag.uid + ":"
                     + cur.eventTag.string);
         } else {
@@ -3615,6 +3618,7 @@ public class BatteryStatsImpl extends BatteryStats {
     }
 
     void addHistoryBufferLocked(long elapsedRealtimeMs, HistoryItem cur) {
+            Slog.i(TAG, "sun_addHistoryBufferLocked");
         if (!mHaveBatteryLevel || !mRecordingHistory) {
             return;
         }
@@ -7636,6 +7640,7 @@ public class BatteryStatsImpl extends BatteryStats {
 
         @Override
         public long getTimeAtCpuSpeed(int cluster, int step, int which) {
+            Slog.i(TAG, "getTimeAtCpuSpeed " + mCpuClusterSpeedTimesUs);
             if (mCpuClusterSpeedTimesUs != null) {
                 if (cluster >= 0 && cluster < mCpuClusterSpeedTimesUs.length) {
                     final LongSamplingCounter[] cpuSpeedTimesUs = mCpuClusterSpeedTimesUs[cluster];
@@ -7643,6 +7648,7 @@ public class BatteryStatsImpl extends BatteryStats {
                         if (step >= 0 && step < cpuSpeedTimesUs.length) {
                             final LongSamplingCounter c = cpuSpeedTimesUs[step];
                             if (c != null) {
+                                Slog.i(TAG, "cluster " + cluster + "step " + step + "which " + which);
                                 return c.getCountLocked(which);
                             }
                         }
@@ -8033,6 +8039,7 @@ public class BatteryStatsImpl extends BatteryStats {
         }
 
         void writeToParcelLocked(Parcel out, long uptimeUs, long elapsedRealtimeUs) {
+            Slog.i(TAG, "sun_writeToParcelLocked 8041");
             mOnBatteryBackgroundTimeBase.writeToParcel(out, uptimeUs, elapsedRealtimeUs);
             mOnBatteryScreenOffBackgroundTimeBase.writeToParcel(out, uptimeUs, elapsedRealtimeUs);
 
@@ -8311,6 +8318,7 @@ public class BatteryStatsImpl extends BatteryStats {
             } else {
                 out.writeInt(0);
             }
+            Slog.i(TAG, "sun_writeToParcelLocked end");
         }
 
         void readJobCompletionsFromParcelLocked(Parcel in) {
@@ -8332,6 +8340,7 @@ public class BatteryStatsImpl extends BatteryStats {
         }
 
         void readFromParcelLocked(TimeBase timeBase, TimeBase screenOffTimeBase, Parcel in) {
+            Slog.i(TAG, "sun_readFromParcelLocked 8341");
             mOnBatteryBackgroundTimeBase.readFromParcel(in);
             mOnBatteryScreenOffBackgroundTimeBase.readFromParcel(in);
 
@@ -8571,6 +8580,7 @@ public class BatteryStatsImpl extends BatteryStats {
             mUserCpuTime = new LongSamplingCounter(mBsi.mOnBatteryTimeBase, in);
             mSystemCpuTime = new LongSamplingCounter(mBsi.mOnBatteryTimeBase, in);
 
+            Slog.i(TAG, "sun_readFromParcelLocked Line8583");
             if (in.readInt() != 0) {
                 int numCpuClusters = in.readInt();
                 if (mBsi.mPowerProfile != null && mBsi.mPowerProfile.getNumCpuClusters() != numCpuClusters) {
@@ -8578,6 +8588,7 @@ public class BatteryStatsImpl extends BatteryStats {
                 }
 
                 mCpuClusterSpeedTimesUs = new LongSamplingCounter[numCpuClusters][];
+                Slog.i(TAG, "sun_readFromParcelLocked Line8587 " + mCpuClusterSpeedTimesUs);
                 for (int cluster = 0; cluster < numCpuClusters; cluster++) {
                     if (in.readInt() != 0) {
                         int numSpeeds = in.readInt();
@@ -8600,6 +8611,7 @@ public class BatteryStatsImpl extends BatteryStats {
                 }
             } else {
                 mCpuClusterSpeedTimesUs = null;
+                Slog.i(TAG, "sun_readFromParcelLocked Line8610 " + mCpuClusterSpeedTimesUs);
             }
 
             mCpuFreqTimeMs = LongSamplingCounterArray.readFromParcel(in, mBsi.mOnBatteryTimeBase);
@@ -11579,7 +11591,9 @@ public class BatteryStatsImpl extends BatteryStats {
         }
 
         if (DEBUG_ENERGY_CPU) {
-            Slog.d(TAG, "!Cpu updating!");
+            Slog.d(TAG, "!Cpu updating!" + onBattery + onBatteryScreenOff);
+    //        onBattery = true;
+    //        onBatteryScreenOff = true;
         }
 
         if (mCpuFreqs == null) {
@@ -11631,7 +11645,9 @@ public class BatteryStatsImpl extends BatteryStats {
         // freqs, so no need to approximate these values.
         if (updatedUids != null) {
             updateClusterSpeedTimes(updatedUids, onBattery);
-        }
+            Slog.d(TAG, "HZ: updatedUids is not NULL" + updatedUids);
+        } else
+            Slog.d(TAG, "HZ: updatedUids is NULL");
         readKernelUidCpuFreqTimesLocked(partialTimersToConsider, onBattery, onBatteryScreenOff);
         mNumAllUidCpuTimeReads += 2;
         if (mConstants.TRACK_CPU_ACTIVE_CLUSTER_TIME) {
@@ -11678,6 +11694,7 @@ public class BatteryStatsImpl extends BatteryStats {
      */
     @VisibleForTesting
     public void updateClusterSpeedTimes(@NonNull SparseLongArray updatedUids, boolean onBattery) {
+                    Slog.i(TAG, "sun_updateClusterSpeedTimes");
         long totalCpuClustersTimeMs = 0;
         // Read the time spent for each cluster at various cpu frequencies.
         final long[][] clusterSpeedTimesMs = new long[mKernelCpuSpeedReaders.length][];
@@ -11689,6 +11706,7 @@ public class BatteryStatsImpl extends BatteryStats {
                 }
             }
         }
+        Slog.d(TAG, "HZ: totalCpuClustersTimeMs is " + totalCpuClustersTimeMs);
         if (totalCpuClustersTimeMs != 0) {
             // We have cpu times per freq aggregated over all uids but we need the times per uid.
             // So, we distribute total time spent by an uid to different cpu freqs based on the
@@ -11702,6 +11720,7 @@ public class BatteryStatsImpl extends BatteryStats {
                 if (u.mCpuClusterSpeedTimesUs == null ||
                         u.mCpuClusterSpeedTimesUs.length != numClusters) {
                     u.mCpuClusterSpeedTimesUs = new LongSamplingCounter[numClusters][];
+                    Slog.i(TAG, "sun_updateClusterSpeedTimes Line11715 " + u.mCpuClusterSpeedTimesUs);
                 }
 
                 for (int cluster = 0; cluster < clusterSpeedTimesMs.length; cluster++) {
@@ -11710,6 +11729,7 @@ public class BatteryStatsImpl extends BatteryStats {
                             u.mCpuClusterSpeedTimesUs[cluster].length) {
                         u.mCpuClusterSpeedTimesUs[cluster]
                                 = new LongSamplingCounter[speedsInCluster];
+                    Slog.i(TAG, "sun_updateClusterSpeedTimes Line11715 " + u.mCpuClusterSpeedTimesUs);
                     }
 
                     final LongSamplingCounter[] cpuSpeeds = u.mCpuClusterSpeedTimesUs[cluster];
@@ -11847,6 +11867,7 @@ public class BatteryStatsImpl extends BatteryStats {
     @VisibleForTesting
     public void readKernelUidCpuFreqTimesLocked(@Nullable ArrayList<StopwatchTimer> partialTimers,
             boolean onBattery, boolean onBatteryScreenOff) {
+        Slog.i(TAG, "sun_readKernelUidCpuFreqTimesLocked");
         final boolean perClusterTimesAvailable =
                 mCpuUidFreqTimeReader.perClusterTimesAvailable();
         final int numWakelocks = partialTimers == null ? 0 : partialTimers.size();
@@ -11884,6 +11905,7 @@ public class BatteryStatsImpl extends BatteryStats {
                         u.mCpuClusterSpeedTimesUs.length != numClusters) {
                     detachIfNotNull(u.mCpuClusterSpeedTimesUs);
                     u.mCpuClusterSpeedTimesUs = new LongSamplingCounter[numClusters][];
+                    Slog.i(TAG, "sun_readKernelUidCpuFreqTimesLocked Line11900 " + u.mCpuClusterSpeedTimesUs);
                 }
                 if (numWakelocks > 0 && mWakeLockAllocationsUs == null) {
                     mWakeLockAllocationsUs = new long[numClusters][];
@@ -11897,6 +11919,7 @@ public class BatteryStatsImpl extends BatteryStats {
                         detachIfNotNull(u.mCpuClusterSpeedTimesUs[cluster]);
                         u.mCpuClusterSpeedTimesUs[cluster]
                                 = new LongSamplingCounter[speedsInCluster];
+                    Slog.i(TAG, "sun_readKernelUidCpuFreqTimesLocked Line11914 " + u.mCpuClusterSpeedTimesUs);
                     }
                     if (numWakelocks > 0 && mWakeLockAllocationsUs[cluster] == null) {
                         mWakeLockAllocationsUs[cluster] = new long[speedsInCluster];
@@ -11934,6 +11957,7 @@ public class BatteryStatsImpl extends BatteryStats {
                         u.mCpuClusterSpeedTimesUs.length != numClusters) {
                     detachIfNotNull(u.mCpuClusterSpeedTimesUs);
                     u.mCpuClusterSpeedTimesUs = new LongSamplingCounter[numClusters][];
+                    Slog.i(TAG, "sun_readKernelUidCpuFreqTimesLocked Line11952 " + u.mCpuClusterSpeedTimesUs);
                 }
 
                 for (int cluster = 0; cluster < numClusters; ++cluster) {
@@ -11943,6 +11967,7 @@ public class BatteryStatsImpl extends BatteryStats {
                         detachIfNotNull(u.mCpuClusterSpeedTimesUs[cluster]);
                         u.mCpuClusterSpeedTimesUs[cluster]
                                 = new LongSamplingCounter[speedsInCluster];
+                    Slog.i(TAG, "sun_readKernelUidCpuFreqTimesLocked Line11962 " + u.mCpuClusterSpeedTimesUs);
                     }
                     final LongSamplingCounter[] cpuTimeUs = u.mCpuClusterSpeedTimesUs[cluster];
                     for (int speed = 0; speed < speedsInCluster; ++speed) {
@@ -12042,6 +12067,7 @@ public class BatteryStatsImpl extends BatteryStats {
     @GuardedBy("this")
     protected void setOnBatteryLocked(final long mSecRealtime, final long mSecUptime,
             final boolean onBattery, final int oldStatus, final int level, final int chargeUAh) {
+            Slog.i(TAG, "sun_setOnBatteryLocked");
         boolean doWrite = false;
         Message m = mHandler.obtainMessage(MSG_REPORT_POWER_CHANGE);
         m.arg1 = onBattery ? 1 : 0;
@@ -12216,6 +12242,7 @@ public class BatteryStatsImpl extends BatteryStats {
     public void setBatteryStateLocked(final int status, final int health, final int plugType,
             final int level, /* not final */ int temp, final int volt, final int chargeUAh,
             final int chargeFullUAh) {
+            Slog.i(TAG, "sun_setBatteryStateLocked");
         // Temperature is encoded without the signed bit, so clamp any negative temperatures to 0.
         temp = Math.max(0, temp);
 
@@ -13257,6 +13284,7 @@ public class BatteryStatsImpl extends BatteryStats {
     }
 
     void writeHistoryLocked(boolean sync) {
+            Slog.i(TAG, "sun_writeHistoryBuffer");
         if (mBatteryStatsHistory.getActiveFile() == null) {
             Slog.w(TAG,
                     "writeHistoryLocked: no history file associated with this instance");
@@ -13469,6 +13497,7 @@ public class BatteryStatsImpl extends BatteryStats {
     }
 
     void writeHistoryBuffer(Parcel out, boolean inclData, boolean andOldHistory) {
+            Slog.i(TAG, "sun_writeHistoryBuffer");
         if (DEBUG_HISTORY) {
             StringBuilder sb = new StringBuilder(128);
             sb.append("****************** WRITING mHistoryBaseTime: ");
@@ -13508,6 +13537,7 @@ public class BatteryStatsImpl extends BatteryStats {
     }
 
     public void readSummaryFromParcel(Parcel in) throws ParcelFormatException {
+        Slog.i(TAG, "sun_readSummaryFromParcel");
         final int version = in.readInt();
         if (version != VERSION) {
             Slog.w("BatteryStats", "readFromParcel: version got " + version
@@ -13823,6 +13853,7 @@ public class BatteryStatsImpl extends BatteryStats {
                 }
                 detachIfNotNull(u.mCpuClusterSpeedTimesUs);
                 u.mCpuClusterSpeedTimesUs = new LongSamplingCounter[numClusters][];
+                    Slog.i(TAG, "sun_readSummaryFromParcel Line13843 " + u.mCpuClusterSpeedTimesUs);
                 for (int cluster = 0; cluster < numClusters; cluster++) {
                     if (in.readInt() != 0) {
                         final int NSB = in.readInt();
@@ -13833,6 +13864,7 @@ public class BatteryStatsImpl extends BatteryStats {
                         }
 
                         u.mCpuClusterSpeedTimesUs[cluster] = new LongSamplingCounter[NSB];
+                    Slog.i(TAG, "sun_readSummaryFromParcel Line13854 " + u.mCpuClusterSpeedTimesUs);
                         for (int speed = 0; speed < NSB; speed++) {
                             if (in.readInt() != 0) {
                                 u.mCpuClusterSpeedTimesUs[cluster][speed] = new LongSamplingCounter(
@@ -13842,11 +13874,13 @@ public class BatteryStatsImpl extends BatteryStats {
                         }
                     } else {
                         u.mCpuClusterSpeedTimesUs[cluster] = null;
+                    Slog.i(TAG, "sun_readSummaryFromParcel Line13864 " + u.mCpuClusterSpeedTimesUs);
                     }
                 }
             } else {
                 detachIfNotNull(u.mCpuClusterSpeedTimesUs);
                 u.mCpuClusterSpeedTimesUs = null;
+                    Slog.i(TAG, "sun_readSummaryFromParcel Line13870 " + u.mCpuClusterSpeedTimesUs);
             }
 
             detachIfNotNull(u.mCpuFreqTimeMs);
@@ -14012,6 +14046,7 @@ public class BatteryStatsImpl extends BatteryStats {
      * @param out the Parcel to be written to.
      */
     public void writeSummaryToParcel(Parcel out, boolean inclHistory) {
+        Slog.i(TAG, "sun_writeSummaryToParcel");
         pullPendingStateUpdatesLocked();
 
         // Pull the clock time.  This may update the time and make a new history entry
@@ -14368,12 +14403,14 @@ public class BatteryStatsImpl extends BatteryStats {
                 out.writeInt(0);
             }
 
+            Slog.i(TAG, "sun_u.mCpuFreqTimeMs " + u.mCpuFreqTimeMs + " u.mScreenOffCpuFreqTimeMs " + u.mScreenOffCpuFreqTimeMs);
             LongSamplingCounterArray.writeSummaryToParcelLocked(out, u.mCpuFreqTimeMs);
             LongSamplingCounterArray.writeSummaryToParcelLocked(out, u.mScreenOffCpuFreqTimeMs);
 
             u.mCpuActiveTimeMs.writeSummaryFromParcelLocked(out);
             u.mCpuClusterTimesMs.writeSummaryToParcelLocked(out);
 
+            Slog.i(TAG, "sun_u.mProcStateTimeMs " + u.mProcStateTimeMs);
             if (u.mProcStateTimeMs != null) {
                 out.writeInt(u.mProcStateTimeMs.length);
                 for (LongSamplingCounterArray counters : u.mProcStateTimeMs) {
@@ -14496,6 +14533,7 @@ public class BatteryStatsImpl extends BatteryStats {
 
             NP = u.mPackageStats.size();
             out.writeInt(NP);
+            Slog.i(TAG, "sun_writeSummaryToParcel NP " + NP);
             if (NP > 0) {
                 for (Map.Entry<String, BatteryStatsImpl.Uid.Pkg> ent
                     : u.mPackageStats.entrySet()) {
@@ -14521,6 +14559,7 @@ public class BatteryStatsImpl extends BatteryStats {
                 }
             }
         }
+        Slog.i(TAG, "sun_writeSummaryToParcel end");
     }
 
     public void readFromParcel(Parcel in) {
@@ -14729,10 +14768,12 @@ public class BatteryStatsImpl extends BatteryStats {
         mCameraTurnedOnTimers.clear();
 
         int numUids = in.readInt();
+        Slog.i(TAG, "sun_readFromParcelLocked Line14761 numUids" + numUids);
         mUidStats.clear();
         for (int i = 0; i < numUids; i++) {
             int uid = in.readInt();
             Uid u = new Uid(this, uid);
+        Slog.i(TAG, "sun_readFromParcelLocked Line14761 uid" + uid);
             u.readFromParcelLocked(mOnBatteryTimeBase, mOnBatteryScreenOffTimeBase, in);
             mUidStats.append(uid, u);
         }
@@ -14748,6 +14789,7 @@ public class BatteryStatsImpl extends BatteryStats {
 
     @SuppressWarnings("unused")
     void writeToParcelLocked(Parcel out, boolean inclUids, int flags) {
+        Slog.i(TAG, "sun_writeToParcelLocked line14792");
         // Need to update with current kernel wake lock counts.
         pullPendingStateUpdatesLocked();
 
@@ -14924,9 +14966,11 @@ public class BatteryStatsImpl extends BatteryStats {
         if (inclUids) {
             int size = mUidStats.size();
             out.writeInt(size);
+        Slog.i(TAG, "sun_writeToParcelLocked uid size" + size);
             for (int i = 0; i < size; i++) {
                 out.writeInt(mUidStats.keyAt(i));
                 Uid uid = mUidStats.valueAt(i);
+        Slog.i(TAG, "sun_writeToParcelLocked uid " + uid);
 
                 uid.writeToParcelLocked(out, uSecUptime, uSecRealtime);
             }
diff --git a/core/java/com/android/internal/os/CpuPowerCalculator.java b/core/java/com/android/internal/os/CpuPowerCalculator.java
index 101c321ab2c..e831026df99 100644
--- a/core/java/com/android/internal/os/CpuPowerCalculator.java
+++ b/core/java/com/android/internal/os/CpuPowerCalculator.java
@@ -21,7 +21,7 @@ import android.util.Log;
 
 public class CpuPowerCalculator extends PowerCalculator {
     private static final String TAG = "CpuPowerCalculator";
-    private static final boolean DEBUG = BatteryStatsHelper.DEBUG;
+    private static final boolean DEBUG = true;
     private static final long MICROSEC_IN_HR = (long) 60 * 60 * 1000 * 1000;
     private final PowerProfile mProfile;
 
@@ -42,6 +42,7 @@ public class CpuPowerCalculator extends PowerCalculator {
                 final long timeUs = u.getTimeAtCpuSpeed(cluster, speed, statsType);
                 final double cpuSpeedStepPower = timeUs *
                         mProfile.getAveragePowerForCpuCore(cluster, speed);
+                Log.d(TAG, "getAveragePowerForCpuCore" + mProfile.getAveragePowerForCpuCore(cluster, speed));
                 if (DEBUG) {
                     Log.d(TAG, "UID " + u.getUid() + ": CPU cluster #" + cluster + " step #"
                             + speed + " timeUs=" + timeUs + " power="
@@ -52,6 +53,7 @@ public class CpuPowerCalculator extends PowerCalculator {
         }
         cpuPowerMaUs += u.getCpuActiveTime() * 1000 * mProfile.getAveragePower(
                 PowerProfile.POWER_CPU_ACTIVE);
+        Log.d(TAG, "u.getCpuActiveTime() " + u.getCpuActiveTime() + " mProfile.getAveragePower(" + PowerProfile.POWER_CPU_ACTIVE + ") " + mProfile.getAveragePower(PowerProfile.POWER_CPU_ACTIVE));
         long[] cpuClusterTimes = u.getCpuClusterTimes();
         if (cpuClusterTimes != null) {
             if (cpuClusterTimes.length == numClusters) {
diff --git a/core/java/com/android/internal/os/KernelCpuSpeedReader.java b/core/java/com/android/internal/os/KernelCpuSpeedReader.java
index 98fea010e09..f143d7f4387 100644
--- a/core/java/com/android/internal/os/KernelCpuSpeedReader.java
+++ b/core/java/com/android/internal/os/KernelCpuSpeedReader.java
@@ -86,7 +86,8 @@ public class KernelCpuSpeedReader {
             }
         } catch (IOException e) {
             Slog.e(TAG, "Failed to read cpu-freq: " + e.getMessage());
-            Arrays.fill(mDeltaSpeedTimesMs, 0);
+            Slog.e(TAG, "HZ: Failed to read cpu-freq: force set to not null");
+            Arrays.fill(mDeltaSpeedTimesMs, 20);
         } finally {
             StrictMode.setThreadPolicy(policy);
         }
diff --git a/core/java/com/android/internal/os/KernelCpuUidTimeReader.java b/core/java/com/android/internal/os/KernelCpuUidTimeReader.java
index e6d044f4722..878c2e64116 100644
--- a/core/java/com/android/internal/os/KernelCpuUidTimeReader.java
+++ b/core/java/com/android/internal/os/KernelCpuUidTimeReader.java
@@ -50,7 +50,7 @@ import java.nio.file.Paths;
  * @param <T> The type of CPU time for the callback.
  */
 public abstract class KernelCpuUidTimeReader<T> {
-    protected static final boolean DEBUG = false;
+    protected static final boolean DEBUG = true;
     private static final long DEFAULT_MIN_TIME_BETWEEN_READ = 1000L; // In milliseconds
 
     final String mTag = this.getClass().getSimpleName();
@@ -364,24 +364,31 @@ public abstract class KernelCpuUidTimeReader<T> {
         public long[] readFreqs(@NonNull PowerProfile powerProfile) {
             checkNotNull(powerProfile);
             if (mCpuFreqs != null) {
+            	Slog.i(mTag, "readFreqs from profile");
                 // No need to read cpu freqs more than once.
                 return mCpuFreqs;
             }
             if (!mAllUidTimesAvailable) {
+            	Slog.i(mTag, "readFreqs from profile-2");
                 return null;
             }
             final int oldMask = StrictMode.allowThreadDiskReadsMask();
             try (BufferedReader reader = Files.newBufferedReader(mProcFilePath)) {
+            	Slog.i(mTag, "readFreqs from profile-3a");
                 if (readFreqs(reader.readLine()) == null) {
+            		Slog.i(mTag, "readFreqs from profile-3b");
                     return null;
                 }
             } catch (IOException e) {
                 if (++mErrors >= MAX_ERROR_COUNT) {
+            		Slog.i(mTag, "readFreqs from profile-4a");
                     mAllUidTimesAvailable = false;
                 }
+            	Slog.i(mTag, "readFreqs from profile-4b");
                 Slog.e(mTag, "Failed to read " + UID_TIMES_PROC_FILE + ": " + e);
                 return null;
             } finally {
+            	Slog.i(mTag, "readFreqs from profile-5");
                 StrictMode.setThreadPolicyMask(oldMask);
             }
             // Check if the freqs in the proc file correspond to per-cluster freqs.
@@ -392,10 +399,12 @@ public abstract class KernelCpuUidTimeReader<T> {
                 for (int i = 0; i < numClusters; ++i) {
                     if (numClusterFreqs.get(i) != powerProfile.getNumSpeedStepsInCpuCluster(i)) {
                         mPerClusterTimesAvailable = false;
+            		Slog.i(mTag, "readFreqs from profile-6");
                         break;
                     }
                 }
             } else {
+            	Slog.i(mTag, "readFreqs from profile-7");
                 mPerClusterTimesAvailable = false;
             }
             Slog.i(mTag, "mPerClusterTimesAvailable=" + mPerClusterTimesAvailable);
diff --git a/core/java/com/android/internal/os/PowerProfile.java b/core/java/com/android/internal/os/PowerProfile.java
index 8338d78af3a..861fe85b28a 100644
--- a/core/java/com/android/internal/os/PowerProfile.java
+++ b/core/java/com/android/internal/os/PowerProfile.java
@@ -22,6 +22,7 @@ import android.content.Context;
 import android.content.res.Resources;
 import android.content.res.XmlResourceParser;
 import android.util.proto.ProtoOutputStream;
+import android.util.Log;
 
 import com.android.internal.annotations.VisibleForTesting;
 import com.android.internal.util.XmlUtils;
@@ -278,6 +279,7 @@ public class PowerProfile {
 
                 if (parsingArray && !element.equals(TAG_ARRAYITEM)) {
                     // Finish array
+        Log.e("PowerProfile", "readPowerValuesFromXml sPowerArrayMap.put(" + arrayName + ") array.size " + array.size());
                     sPowerArrayMap.put(arrayName, array.toArray(new Double[array.size()]));
                     parsingArray = false;
                 }
@@ -285,6 +287,7 @@ public class PowerProfile {
                     parsingArray = true;
                     array.clear();
                     arrayName = parser.getAttributeValue(null, ATTR_NAME);
+        Log.e("PowerProfile", "readPowerValuesFromXml arrayName " + arrayName);
                 } else if (element.equals(TAG_ITEM) || element.equals(TAG_ARRAYITEM)) {
                     String name = null;
                     if (!parsingArray) name = parser.getAttributeValue(null, ATTR_NAME);
@@ -296,15 +299,18 @@ public class PowerProfile {
                         } catch (NumberFormatException nfe) {
                         }
                         if (element.equals(TAG_ITEM)) {
+        Log.e("PowerProfile", "readPowerValuesFromXml sPowerItemMap.put(" + name + ", " + value + ")");
                             sPowerItemMap.put(name, value);
                         } else if (parsingArray) {
                             array.add(value);
+        Log.e("PowerProfile", "readPowerValuesFromXml array.add(" + value + ")");
                         }
                     }
                 }
             }
             if (parsingArray) {
                 sPowerArrayMap.put(arrayName, array.toArray(new Double[array.size()]));
+        Log.e("PowerProfile", "readPowerValuesFromXml parsingArray "+ parsingArray +" sPowerArrayMap.put(" + arrayName + ") array.size " + array.size());
             }
         } catch (XmlPullParserException e) {
             throw new RuntimeException(e);
@@ -339,6 +345,7 @@ public class PowerProfile {
             int value = resources.getInteger(configResIds[i]);
             if (value > 0) {
                 sPowerItemMap.put(key, (double) value);
+        Log.e("PowerProfile", "readPowerValuesFromXml sPowerItemMap.put1(" + key + ", " + value + ")");
             }
         }
     }
@@ -351,24 +358,32 @@ public class PowerProfile {
     private static final String CPU_CORE_POWER_PREFIX = "cpu.core_power.cluster";
 
     private void initCpuClusters() {
+        Log.e("PowerProfile", "initCpuClusters");
         if (sPowerArrayMap.containsKey(CPU_PER_CLUSTER_CORE_COUNT)) {
+        Log.e("PowerProfile", "init sPowerArrayMap.containsKey" + CPU_PER_CLUSTER_CORE_COUNT);
             final Double[] data = sPowerArrayMap.get(CPU_PER_CLUSTER_CORE_COUNT);
+        Log.e("PowerProfile", "init data length " + data.length);
             mCpuClusters = new CpuClusterKey[data.length];
             for (int cluster = 0; cluster < data.length; cluster++) {
                 int numCpusInCluster = (int) Math.round(data[cluster]);
+        Log.e("PowerProfile", "init cluster " + cluster + " numCpusInCluster " + numCpusInCluster);
                 mCpuClusters[cluster] = new CpuClusterKey(
                         CPU_CORE_SPEED_PREFIX + cluster, CPU_CLUSTER_POWER_COUNT + cluster,
                         CPU_CORE_POWER_PREFIX + cluster, numCpusInCluster);
+        Log.e("PowerProfile", "init  mCpuClusters[0] corePowerKey" + mCpuClusters[0].corePowerKey);
             }
         } else {
+        Log.e("PowerProfile", "init null");
             // Default to single.
             mCpuClusters = new CpuClusterKey[1];
             int numCpus = 1;
             if (sPowerItemMap.containsKey(CPU_PER_CLUSTER_CORE_COUNT)) {
+        Log.e("PowerProfile", "init sPowerItemMap.containsKey" + CPU_PER_CLUSTER_CORE_COUNT);
                 numCpus = (int) Math.round(sPowerItemMap.get(CPU_PER_CLUSTER_CORE_COUNT));
             }
             mCpuClusters[0] = new CpuClusterKey(CPU_CORE_SPEED_PREFIX + 0,
                     CPU_CLUSTER_POWER_COUNT + 0, CPU_CORE_POWER_PREFIX + 0, numCpus);
+        Log.e("PowerProfile", "init  mCpuClusters[0] corePowerKey" + mCpuClusters[0].corePowerKey);
         }
     }
 
@@ -415,7 +430,9 @@ public class PowerProfile {
     }
 
     public double getAveragePowerForCpuCore(int cluster, int step) {
+        Log.e("PowerProfile", "getAveragePowerForCpuCore mCpuClusters.length " + mCpuClusters.length);
         if (cluster >= 0 && cluster < mCpuClusters.length) {
+        Log.e("PowerProfile", "getAveragePowerForCpuCore() mCpuClusters[" + cluster + "].corePowerKey " + mCpuClusters[cluster].corePowerKey);
             return getAveragePower(mCpuClusters[cluster].corePowerKey, step);
         }
         return 0;
@@ -445,11 +462,15 @@ public class PowerProfile {
      * @return the average current in milliAmps.
      */
     public double getAveragePowerOrDefault(String type, double defaultValue) {
+        Log.e("PowerProfile", "getAveragePowerOrDefault " + type);
         if (sPowerItemMap.containsKey(type)) {
+        Log.e("PowerProfile", "getAveragePowerOrDefault sPowerItemMap.containsKey");
             return sPowerItemMap.get(type);
         } else if (sPowerArrayMap.containsKey(type)) {
+        Log.e("PowerProfile", "getAveragePowerOrDefault sPowerArrayMap.containsKey");
             return sPowerArrayMap.get(type)[0];
         } else {
+        Log.e("PowerProfile", "getAveragePowerOrDefault not found");
             return defaultValue;
         }
     }
@@ -462,6 +483,7 @@ public class PowerProfile {
      */
     @UnsupportedAppUsage
     public double getAveragePower(String type) {
+        Log.e("PowerProfile", "getAveragePower " + type);
         return getAveragePowerOrDefault(type, 0);
     }
 
@@ -476,18 +498,25 @@ public class PowerProfile {
      */
     @UnsupportedAppUsage
     public double getAveragePower(String type, int level) {
+        Log.e("PowerProfile", "getAveragePower " + type);
         if (sPowerItemMap.containsKey(type)) {
+        Log.e("PowerProfile", "sPowerItemMap.get(type) " + sPowerItemMap.get(type));
             return sPowerItemMap.get(type);
         } else if (sPowerArrayMap.containsKey(type)) {
+        Log.e("PowerProfile", "sPowerArrayMap.containsKey(type)");
             final Double[] values = sPowerArrayMap.get(type);
             if (values.length > level && level >= 0) {
+        Log.e("PowerProfile", "values[level]" + values[level]);
                 return values[level];
             } else if (level < 0 || values.length == 0) {
+        Log.e("PowerProfile", "values[" + level +"].length = 0");
                 return 0;
             } else {
+        Log.e("PowerProfile", "values[values.length - 1]" + values[values.length - 1]);
                 return values[values.length - 1];
             }
         } else {
+        Log.e("PowerProfile", "not found");
             return 0;
         }
     }
@@ -507,6 +536,7 @@ public class PowerProfile {
      * Dump power constants into PowerProfileProto
      */
     public void writeToProto(ProtoOutputStream proto) {
+        Log.e("PowerProfile", "writeToProto");
         // cpu.suspend
         writePowerConstantToProto(proto, POWER_CPU_SUSPEND, PowerProfileProto.CPU_SUSPEND);
 
@@ -662,6 +692,7 @@ public class PowerProfile {
         // battery.capacity
         writePowerConstantToProto(proto, POWER_BATTERY_CAPACITY,
                 PowerProfileProto.BATTERY_CAPACITY);
+        Log.e("PowerProfile", "writeToProto end");
     }
 
     // Writes items in sPowerItemMap to proto if exists.
diff --git a/services/core/java/com/android/server/am/BatteryStatsService.java b/services/core/java/com/android/server/am/BatteryStatsService.java
index e2b59b45e1e..6cc8a017d46 100644
--- a/services/core/java/com/android/server/am/BatteryStatsService.java
+++ b/services/core/java/com/android/server/am/BatteryStatsService.java
@@ -88,7 +88,7 @@ public final class BatteryStatsService extends IBatteryStats.Stub
         BatteryStatsImpl.PlatformIdleStateCallback,
         BatteryStatsImpl.RailEnergyDataCallback {
     static final String TAG = "BatteryStatsService";
-    static final boolean DBG = false;
+    static final boolean DBG = true;
 
     private static IBatteryStats sService;
 
@@ -402,17 +402,20 @@ public final class BatteryStatsService extends IBatteryStats.Stub
     }
 
     public ParcelFileDescriptor getStatisticsStream() {
+        Slog.d(TAG, "sun_getStatisticsStream");
         mContext.enforceCallingPermission(
                 android.Manifest.permission.BATTERY_STATS, null);
         //Slog.i("foo", "SENDING BATTERY INFO:");
         //mStats.dumpLocked(new LogPrinter(Log.INFO, "foo", Log.LOG_ID_SYSTEM));
         Parcel out = Parcel.obtain();
         syncStats("get-stats", BatteryExternalStatsWorker.UPDATE_ALL);
+        Slog.d(TAG, "sun_getStatisticsStream before writeToParcel");
         synchronized (mStats) {
             mStats.writeToParcel(out, 0);
         }
+        Slog.d(TAG, "sun_getStatisticsStream after writeToParcel");
         byte[] data = out.marshall();
-        if (DBG) Slog.d(TAG, "getStatisticsStream parcel size is:" + data.length);
+        Slog.d(TAG, "getStatisticsStream parcel size is:" + data.length);
         out.recycle();
         try {
             return ParcelFileDescriptor.fromData(data, "battery-stats");
@@ -1326,7 +1329,7 @@ public final class BatteryStatsService extends IBatteryStats.Stub
     @Override
     protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
         if (!DumpUtils.checkDumpAndUsageStatsPermission(mContext, TAG, pw)) return;
-
+        Slog.w(TAG, "\nwzj start dump\n");
         int flags = 0;
         boolean useCheckinFormat = false;
         boolean toProto = false;
@@ -1336,6 +1339,7 @@ public final class BatteryStatsService extends IBatteryStats.Stub
         long historyStart = -1;
         int reqUid = -1;
         if (args != null) {
+            Slog.w(TAG, "\nwzj get date from args\n");
             for (int i=0; i<args.length; i++) {
                 String arg = args[i];
                 if ("--checkin".equals(arg)) {
@@ -1449,13 +1453,19 @@ public final class BatteryStatsService extends IBatteryStats.Stub
 
         long ident = Binder.clearCallingIdentity();
         try {
+            Slog.w(TAG, "\nwzj BatteryStatsHelper.checkWifiOnly start\n");
             if (BatteryStatsHelper.checkWifiOnly(mContext)) {
                 flags |= BatteryStats.DUMP_DEVICE_WIFI_ONLY;
             }
+            Slog.w(TAG, "\nwzj BatteryStatsHelper.checkWifiOnly end\n");
             // Fetch data from external sources and update the BatteryStatsImpl object with them.
+            Slog.w(TAG, "\nwzj syncStats(BatteryExternalStatsWorker.UPDATE_ALL) start\n");
             syncStats("dump", BatteryExternalStatsWorker.UPDATE_ALL);
+            Slog.w(TAG, "\nwzj syncStats(BatteryExternalStatsWorker.UPDATE_ALL) end\n");
         } finally {
+            Slog.w(TAG, "\nwzj Binder.restoreCallingIdentity(ident) start\n");
             Binder.restoreCallingIdentity(ident);
+            Slog.w(TAG, "\nwzj Binder.restoreCallingIdentity(ident) end\n");
         }
 
         if (reqUid >= 0) {
@@ -1472,6 +1482,7 @@ public final class BatteryStatsService extends IBatteryStats.Stub
             List<ApplicationInfo> apps = mContext.getPackageManager().getInstalledApplications(
                     PackageManager.MATCH_ANY_USER | PackageManager.MATCH_ALL);
             if (isRealCheckin) {
+                Slog.w(TAG, "\nwzj prefer to use the last complete checkin\n");
                 // For a real checkin, first we want to prefer to use the last complete checkin
                 // file if there is one.
                 synchronized (mStats.mCheckinFile) {
@@ -1499,14 +1510,14 @@ public final class BatteryStatsService extends IBatteryStats.Stub
                     }
                 }
             }
-            if (DBG) Slog.d(TAG, "begin dumpProtoLocked from UID " + Binder.getCallingUid());
+            Slog.w(TAG, "wzj begin dumpProtoLocked from UID " + Binder.getCallingUid());
             synchronized (mStats) {
                 mStats.dumpProtoLocked(mContext, fd, apps, flags, historyStart);
                 if (writeData) {
                     mStats.writeAsyncLocked();
                 }
             }
-            if (DBG) Slog.d(TAG, "end dumpProtoLocked");
+            Slog.w(TAG, "wzj end dumpProtoLocked");
         } else if (useCheckinFormat) {
             List<ApplicationInfo> apps = mContext.getPackageManager().getInstalledApplications(
                     PackageManager.MATCH_ANY_USER | PackageManager.MATCH_ALL);
@@ -1538,24 +1549,25 @@ public final class BatteryStatsService extends IBatteryStats.Stub
                     }
                 }
             }
-            if (DBG) Slog.d(TAG, "begin dumpCheckinLocked from UID " + Binder.getCallingUid());
+            Slog.w(TAG, "wzj begin dumpCheckinLocked from UID " + Binder.getCallingUid());
             synchronized (mStats) {
                 mStats.dumpCheckinLocked(mContext, pw, apps, flags, historyStart);
                 if (writeData) {
                     mStats.writeAsyncLocked();
                 }
             }
-            if (DBG) Slog.d(TAG, "end dumpCheckinLocked");
+            Slog.w(TAG, "end dumpCheckinLocked");
         } else {
-            if (DBG) Slog.d(TAG, "begin dumpLocked from UID " + Binder.getCallingUid());
+            Slog.d(TAG, "wzj begin dumpLocked from UID " + Binder.getCallingUid());
             synchronized (mStats) {
                 mStats.dumpLocked(mContext, pw, flags, reqUid, historyStart);
                 if (writeData) {
                     mStats.writeAsyncLocked();
                 }
             }
-            if (DBG) Slog.d(TAG, "end dumpLocked");
+            Slog.w(TAG, "wzj end dumpLocked");
         }
+    Slog.w(TAG, "wzj dump end");
     }
 
     /**
diff --git a/services/core/java/com/android/server/stats/StatsCompanionService.java b/services/core/java/com/android/server/stats/StatsCompanionService.java
index c76bbb05a35..b4fb1717884 100644
--- a/services/core/java/com/android/server/stats/StatsCompanionService.java
+++ b/services/core/java/com/android/server/stats/StatsCompanionService.java
@@ -1707,6 +1707,7 @@ public class StatsCompanionService extends IStatsCompanionService.Stub {
     }
 
     private BatteryStatsHelper getBatteryStatsHelper() {
+        Slog.w(TAG, "sun_getBatteryStatsHelper " + mBatteryStatsHelper);
         if (mBatteryStatsHelper == null) {
             final long callingToken = Binder.clearCallingIdentity();
             try {
@@ -1717,11 +1718,14 @@ public class StatsCompanionService extends IStatsCompanionService.Stub {
             }
             mBatteryStatsHelper.create((Bundle) null);
         }
+        Slog.w(TAG, "sun_getBatteryStatsHelper2 " + mBatteryStatsHelper);
         long currentTime = SystemClock.elapsedRealtime();
         if (currentTime - mBatteryStatsHelperTimestampMs >= MAX_BATTERY_STATS_HELPER_FREQUENCY_MS) {
+            Slog.w(TAG, "sun_refreshStats");
             // Load BatteryStats and do all the calculations.
             mBatteryStatsHelper.refreshStats(BatteryStats.STATS_SINCE_CHARGED, UserHandle.USER_ALL);
             // Calculations are done so we don't need to save the raw BatteryStats data in RAM.
+            Slog.w(TAG, "sun_clearStats");
             mBatteryStatsHelper.clearStats();
             mBatteryStatsHelperTimestampMs = currentTime;
         }
@@ -1743,19 +1747,23 @@ public class StatsCompanionService extends IStatsCompanionService.Stub {
 
     private void pullDeviceCalculatedPowerBlameUid(int tagId,
             long elapsedNanos, final long wallClockNanos, List<StatsLogEventWrapper> pulledData) {
+        Slog.w(TAG, "sun_pullDeviceCalculatedPowerBlameUid");
         final List<BatterySipper> sippers = getBatteryStatsHelper().getUsageList();
         if (sippers == null) {
             return;
         }
         for (BatterySipper bs : sippers) {
             if (bs.drainType != bs.drainType.APP) {
+        Slog.w(TAG, "sun_continue");
                 continue;
             }
             StatsLogEventWrapper e = new StatsLogEventWrapper(tagId, elapsedNanos, wallClockNanos);
             e.writeInt(bs.uidObj.getUid());
             e.writeLong(milliAmpHrsToNanoAmpSecs(bs.totalPowerMah));
+            Slog.w(TAG, "sun_pullDeviceCalculatedPowerBlameUid uid " + bs.uidObj.getUid() + " bs.totalPowerMah " + bs.totalPowerMah);
             pulledData.add(e);
         }
+        Slog.w(TAG, "sun_pullDeviceCalculatedPowerBlameUid end");
     }
 
     private void pullDeviceCalculatedPowerBlameOther(int tagId,
-- 
2.23.0

