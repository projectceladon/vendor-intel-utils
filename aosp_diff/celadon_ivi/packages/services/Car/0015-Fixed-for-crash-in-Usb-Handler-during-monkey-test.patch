From e6d7355eab2e59fdbcf13f15eb1de95494e8f7d8 Mon Sep 17 00:00:00 2001
From: Ankit Agrawal <ankit.agarwal@intel.com>
Date: Thu, 17 Aug 2023 19:25:27 +0530
Subject: [PATCH] Fixed for crash in Usb Handler during monkey test.

Using locked mechanism in code block instead of syncronized method.

Crash log snippet looks like below:
Getting below crash when running monkey test-:
java.lang.RuntimeException: Unable to resume activity
{android.car.usb.handler/android.car.usb.handler.UsbHostManagementActivity}
: java.lang.IllegalStateException: Cannot perform this operation
because the connection pool has been closed.

Tracked-On: OAM-111150
Signed-off-by: Ankit Agrawal <ankit.agarwal@intel.com>
---
 .../car/usb/handler/UsbHostController.java    | 48 ++++++++++++-------
 1 file changed, 30 insertions(+), 18 deletions(-)

diff --git a/car-usb-handler/src/android/car/usb/handler/UsbHostController.java b/car-usb-handler/src/android/car/usb/handler/UsbHostController.java
index 0da71ac5f..84de20fba 100644
--- a/car-usb-handler/src/android/car/usb/handler/UsbHostController.java
+++ b/car-usb-handler/src/android/car/usb/handler/UsbHostController.java
@@ -82,7 +82,9 @@ public final class UsbHostController
         }
     };
 
-    @GuardedBy("this")
+    private final Object mLock = new Object();
+
+    @GuardedBy("mLock")
     private UsbDevice mActiveDevice;
 
     public UsbHostController(Context context, UsbHostControllerCallbacks callbacks) {
@@ -98,35 +100,45 @@ public final class UsbHostController
         context.registerReceiver(mUsbBroadcastReceiver, filter);
     }
 
-    private synchronized void setActiveDeviceIfMatch(UsbDevice device) {
-        if (mActiveDevice != null && device != null
-                && UsbUtil.isDevicesMatching(device, mActiveDevice)) {
-            mActiveDevice = device;
+    private void setActiveDeviceIfMatch(UsbDevice device) {
+        synchronized (mLock) {
+            if (mActiveDevice != null && device != null
+                    && UsbUtil.isDevicesMatching(device, mActiveDevice)) {
+                mActiveDevice = device;
+            }
         }
     }
 
-    private synchronized void unsetActiveDeviceIfMatch(UsbDevice device) {
+    private void unsetActiveDeviceIfMatch(UsbDevice device) {
         mHandler.requestDeviceRemoved();
-        if (mActiveDevice != null && device != null
-                && UsbUtil.isDevicesMatching(device, mActiveDevice)) {
-            mActiveDevice = null;
+        synchronized (mLock) {
+            if (mActiveDevice != null && device != null
+                    && UsbUtil.isDevicesMatching(device, mActiveDevice)) {
+                mActiveDevice = null;
+            }
         }
     }
 
-    private synchronized boolean startDeviceProcessingIfNull(UsbDevice device) {
-        if (mActiveDevice == null) {
-            mActiveDevice = device;
-            return true;
+    private boolean startDeviceProcessingIfNull(UsbDevice device) {
+        synchronized (mLock) {
+            if (mActiveDevice == null) {
+                mActiveDevice = device;
+                return true;
+            }
+            return false;
         }
-        return false;
     }
 
-    private synchronized void stopDeviceProcessing() {
-        mActiveDevice = null;
+    private void stopDeviceProcessing() {
+        synchronized (mLock) {
+            mActiveDevice = null;
+        }
     }
 
-    private synchronized UsbDevice getActiveDevice() {
-        return mActiveDevice;
+    private UsbDevice getActiveDevice() {
+        synchronized (mLock) {
+            return mActiveDevice;
+        }
     }
 
     private boolean deviceMatchedActiveDevice(UsbDevice device) {
-- 
2.17.1

