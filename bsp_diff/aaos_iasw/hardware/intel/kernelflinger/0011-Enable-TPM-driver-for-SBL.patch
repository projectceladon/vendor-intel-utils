From 7fa3ee1e2885866e6a533a54c80271aaf1b12411 Mon Sep 17 00:00:00 2001
From: "Chen, Gang G" <gang.g.chen@intel.com>
Date: Sat, 24 Jun 2023 10:54:39 +0800
Subject: [PATCH 11/54] Enable TPM driver for SBL

UEFI provides TPM boot time services for kernerlflinger. But SBL
doesn't provide such services. So TPM driver is required to communicate
to TPM hardware module for SBL.

TPM driver is ported from SBL firmware which is BSD-2 license.

Tracked-On: OAM-110881
Signed-off-by: Chen, Gang G <gang.g.chen@intel.com>
---
 libedk2_tpm/Android.mk                        |   11 +-
 libedk2_tpm/IoLib.c                           |  354 +
 libedk2_tpm/RegisterFilterLibNull.c           |  272 +
 libedk2_tpm/Tpm2Ptp.c                         |  578 ++
 libedk2_tpm/Tpm2Tis.c                         |  377 +
 libedk2_tpm/include/Base.h                    | 1325 +++
 .../include/BaseIoLibIntrinsicInternal.h      |   21 +
 libedk2_tpm/include/BaseLib.h                 | 7656 +++++++++++++++++
 libedk2_tpm/include/BaseTypes.h               |  308 +
 libedk2_tpm/include/IndustryStandard/Acpi.h   |   16 +
 libedk2_tpm/include/IndustryStandard/Acpi10.h |  666 ++
 libedk2_tpm/include/IndustryStandard/Acpi20.h |  539 ++
 libedk2_tpm/include/IndustryStandard/Acpi30.h |  723 ++
 libedk2_tpm/include/IndustryStandard/Acpi40.h | 1303 +++
 libedk2_tpm/include/IndustryStandard/Acpi50.h | 2119 +++++
 libedk2_tpm/include/IndustryStandard/Acpi51.h | 2139 +++++
 libedk2_tpm/include/IndustryStandard/Acpi60.h | 2392 +++++
 libedk2_tpm/include/IndustryStandard/Acpi61.h | 2424 ++++++
 libedk2_tpm/include/IndustryStandard/Acpi62.h | 2960 +++++++
 libedk2_tpm/include/IndustryStandard/Acpi63.h | 2960 +++++++
 libedk2_tpm/include/IndustryStandard/Acpi64.h | 3148 +++++++
 .../include/IndustryStandard/AcpiAml.h        |  184 +
 libedk2_tpm/include/IndustryStandard/Atapi.h  |  851 ++
 .../include/IndustryStandard/Bluetooth.h      |   56 +
 libedk2_tpm/include/IndustryStandard/Bmp.h    |   42 +
 .../DmaRemappingReportingTable.h              |  291 +
 .../include/IndustryStandard/ElTorito.h       |  141 +
 libedk2_tpm/include/IndustryStandard/Emmc.h   |  291 +
 .../HighPrecisionEventTimerTable.h            |   62 +
 .../IndustryStandard/LowPowerIdleTable.h      |   76 +
 libedk2_tpm/include/IndustryStandard/Mbr.h    |   54 +
 ...emoryMappedConfigurationSpaceAccessTable.h |   49 +
 libedk2_tpm/include/IndustryStandard/Nvme.h   |  942 ++
 libedk2_tpm/include/IndustryStandard/Pci.h    |   15 +
 libedk2_tpm/include/IndustryStandard/Pci22.h  |  861 ++
 libedk2_tpm/include/IndustryStandard/Pci23.h  |  127 +
 libedk2_tpm/include/IndustryStandard/Pci30.h  |   73 +
 .../include/IndustryStandard/PciCodeId.h      |   94 +
 .../include/IndustryStandard/PciExpress21.h   |  715 ++
 .../include/IndustryStandard/PciExpress30.h   |   51 +
 .../include/IndustryStandard/PciExpress31.h   |   72 +
 .../include/IndustryStandard/PciExpress40.h   |  111 +
 .../include/IndustryStandard/PciExpress50.h   |  136 +
 .../include/IndustryStandard/PeImage.h        |  762 ++
 libedk2_tpm/include/IndustryStandard/Scsi.h   |  426 +
 libedk2_tpm/include/IndustryStandard/Sd.h     |  175 +
 libedk2_tpm/include/IndustryStandard/SmBios.h | 2724 ++++++
 libedk2_tpm/include/IndustryStandard/SmBus.h  |   74 +
 libedk2_tpm/include/IndustryStandard/Tpm12.h  | 2167 +++++
 libedk2_tpm/include/IndustryStandard/Tpm20.h  | 1814 ++++
 .../include/IndustryStandard/Tpm2Acpi.h       |   66 +
 libedk2_tpm/include/IndustryStandard/TpmPtp.h |  517 ++
 libedk2_tpm/include/IndustryStandard/TpmTis.h |  181 +
 .../IndustryStandard/UefiTcgPlatform.h        |  498 ++
 libedk2_tpm/include/IndustryStandard/Usb.h    |  380 +
 libedk2_tpm/include/IoLib.h                   | 2808 ++++++
 libedk2_tpm/include/PcdLib.h                  | 1734 ++++
 libedk2_tpm/include/ProcessorBind.h           |  323 +
 libedk2_tpm/include/RegisterFilterLib.h       |  243 +
 libedk2_tpm/include/Tpm12.h                   |    3 +
 60 files changed, 52479 insertions(+), 1 deletion(-)
 create mode 100644 libedk2_tpm/IoLib.c
 create mode 100644 libedk2_tpm/RegisterFilterLibNull.c
 create mode 100644 libedk2_tpm/Tpm2Ptp.c
 create mode 100644 libedk2_tpm/Tpm2Tis.c
 create mode 100644 libedk2_tpm/include/Base.h
 create mode 100644 libedk2_tpm/include/BaseIoLibIntrinsicInternal.h
 create mode 100755 libedk2_tpm/include/BaseLib.h
 create mode 100644 libedk2_tpm/include/BaseTypes.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi10.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi20.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi30.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi40.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi50.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi51.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi60.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi61.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi62.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi63.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Acpi64.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/AcpiAml.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Atapi.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Bluetooth.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Bmp.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/DmaRemappingReportingTable.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/ElTorito.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Emmc.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/HighPrecisionEventTimerTable.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/LowPowerIdleTable.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Mbr.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/MemoryMappedConfigurationSpaceAccessTable.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Nvme.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Pci.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Pci22.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Pci23.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Pci30.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/PciCodeId.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/PciExpress21.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/PciExpress30.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/PciExpress31.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/PciExpress40.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/PciExpress50.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/PeImage.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Scsi.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Sd.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/SmBios.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/SmBus.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Tpm12.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Tpm20.h
 create mode 100755 libedk2_tpm/include/IndustryStandard/Tpm2Acpi.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/TpmPtp.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/TpmTis.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/UefiTcgPlatform.h
 create mode 100644 libedk2_tpm/include/IndustryStandard/Usb.h
 create mode 100644 libedk2_tpm/include/IoLib.h
 create mode 100644 libedk2_tpm/include/PcdLib.h
 create mode 100644 libedk2_tpm/include/ProcessorBind.h
 create mode 100644 libedk2_tpm/include/RegisterFilterLib.h

diff --git a/libedk2_tpm/Android.mk b/libedk2_tpm/Android.mk
index 11be88e..fe0469a 100644
--- a/libedk2_tpm/Android.mk
+++ b/libedk2_tpm/Android.mk
@@ -15,7 +15,6 @@ LOCAL_STATIC_LIBRARIES := libgnuefi \
 LOCAL_SRC_FILES := \
         Tpm2NVStorage.c \
         Tpm2Random.c \
-        Tpm2DeviceLib.c \
         Tpm2Help.c \
         Tpm2Context.c \
         Tpm2EnhancedAuthorization.c \
@@ -25,6 +24,16 @@ LOCAL_SRC_FILES := \
         Tpm2Session.c \
         Tpm2Capability.c
 
+ifeq ($(TARGET_USE_SBL),true)
+LOCAL_SRC_FILES += \
+       RegisterFilterLibNull.c \
+       Tpm2Ptp.c \
+       IoLib.c \
+       Tpm2Tis.c
+else
+LOCAL_SRC_FILES += Tpm2DeviceLib.c
+endif
+
 LOCAL_C_INCLUDES := $(LOCAL_PATH)/include \
                     $(LOCAL_PATH)/../include/libkernelflinger \
                     $(res_intermediates)
diff --git a/libedk2_tpm/IoLib.c b/libedk2_tpm/IoLib.c
new file mode 100644
index 0000000..36c9c74
--- /dev/null
+++ b/libedk2_tpm/IoLib.c
@@ -0,0 +1,354 @@
+/** @file
+  Common I/O Library routines.
+
+  Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include "Base.h"
+#include "BaseIoLibIntrinsicInternal.h"
+
+/**
+  Reads a 64-bit I/O port.
+
+  Reads the 64-bit I/O port specified by Port. The 64-bit read value is returned.
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to read.
+
+  @return The value read.
+
+**/
+UINT64
+EFIAPI
+IoRead64 (
+__attribute__((__unused__))  IN      UINTN                     Port
+  )
+{
+  ASSERT (FALSE);
+  return 0;
+}
+
+/**
+  Writes a 64-bit I/O port.
+
+  Writes the 64-bit I/O port specified by Port with the value specified by Value
+  and returns Value. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to write.
+  @param  Value The value to write to the I/O port.
+
+  @return The value written the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoWrite64 (
+__attribute__((__unused__))  IN      UINTN                     Port,
+__attribute__((__unused__))  IN      UINT64                    Value
+  )
+{
+  ASSERT (FALSE);
+  return 0;
+}
+
+
+/**
+  Reads an 8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address. The 8-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT8
+EFIAPI
+MmioRead8 (
+  IN      UINTN                     Address
+  )
+{
+  UINT8                             Value;
+  BOOLEAN                           Flag;
+
+  Flag = FilterBeforeMmIoRead1 (FilterWidth8, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    Value = *(volatile UINT8*)Address;
+    MemoryFence ();
+  }
+  FilterAfterMmIoRead1 (FilterWidth8, Address, &Value);
+
+  return Value;
+}
+
+/**
+  Writes an 8-bit MMIO register.
+
+  Writes the 8-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+  @return Value.
+
+**/
+UINT8
+EFIAPI
+MmioWrite8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     Value
+  )
+{
+  BOOLEAN                           Flag;
+
+  Flag = FilterBeforeMmIoWrite1 (FilterWidth8, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    *(volatile UINT8*)Address = Value;
+    MemoryFence ();
+  }
+  FilterAfterMmIoWrite1 (FilterWidth8, Address, &Value);
+
+  return Value;
+}
+
+/**
+  Reads a 16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address. The 16-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT16
+EFIAPI
+MmioRead16_1 (
+  IN      UINTN                     Address
+  )
+{
+  UINT16                            Value;
+  BOOLEAN                           Flag;
+
+  ASSERT ((Address & 1) == 0);
+  Flag = FilterBeforeMmIoRead1 (FilterWidth16, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    Value = *(volatile UINT16*)Address;
+    MemoryFence ();
+  }
+  FilterAfterMmIoRead1 (FilterWidth16, Address, &Value);
+
+  return Value;
+}
+
+/**
+  Writes a 16-bit MMIO register.
+
+  Writes the 16-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+  @return Value.
+
+**/
+UINT16
+EFIAPI
+MmioWrite16_1 (
+  IN      UINTN                     Address,
+  IN      UINT16                    Value
+  )
+{
+  BOOLEAN                           Flag;
+
+  ASSERT ((Address & 1) == 0);
+
+  Flag = FilterBeforeMmIoWrite1 (FilterWidth16, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    *(volatile UINT16*)Address = Value;
+    MemoryFence ();
+  }
+  FilterAfterMmIoWrite1 (FilterWidth16, Address, &Value);
+
+  return Value;
+}
+
+/**
+  Reads a 32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address. The 32-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT32
+EFIAPI
+MmioRead32 (
+  IN      UINTN                     Address
+  )
+{
+  UINT32                            Value;
+  BOOLEAN                           Flag;
+
+  ASSERT ((Address & 3) == 0);
+
+  Flag = FilterBeforeMmIoRead1 (FilterWidth32, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    Value = *(volatile UINT32*)Address;
+    MemoryFence ();
+  }
+  FilterAfterMmIoRead1 (FilterWidth32, Address, &Value);
+
+  return Value;
+}
+
+/**
+  Writes a 32-bit MMIO register.
+
+  Writes the 32-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+  @return Value.
+
+**/
+UINT32
+EFIAPI
+MmioWrite32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    Value
+  )
+{
+  BOOLEAN                           Flag;
+
+  ASSERT ((Address & 3) == 0);
+
+  Flag = FilterBeforeMmIoWrite1 (FilterWidth32, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    *(volatile UINT32*)Address = Value;
+    MemoryFence ();
+  }
+  FilterAfterMmIoWrite1 (FilterWidth32, Address, &Value);
+
+  return Value;
+}
+
+/**
+  Reads a 64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address. The 64-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT64
+EFIAPI
+MmioRead64 (
+  IN      UINTN                     Address
+  )
+{
+  UINT64                            Value;
+  BOOLEAN                           Flag;
+
+  ASSERT ((Address & 7) == 0);
+
+  Flag = FilterBeforeMmIoRead1 (FilterWidth64, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    Value = *(volatile UINT64*)Address;
+    MemoryFence ();
+  }
+  FilterAfterMmIoRead1 (FilterWidth64, Address, &Value);
+
+  return Value;
+}
+
+/**
+  Writes a 64-bit MMIO register.
+
+  Writes the 64-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioWrite64 (
+  IN      UINTN                     Address,
+  IN      UINT64                    Value
+  )
+{
+  BOOLEAN                           Flag;
+
+  ASSERT ((Address & 7) == 0);
+
+  Flag = FilterBeforeMmIoWrite1 (FilterWidth64, Address, &Value);
+  if (Flag) {
+    MemoryFence ();
+    *(volatile UINT64*)Address = Value;
+    MemoryFence ();
+  }
+  FilterAfterMmIoWrite1 (FilterWidth64, Address, &Value);
+
+  return Value;
+}
diff --git a/libedk2_tpm/RegisterFilterLibNull.c b/libedk2_tpm/RegisterFilterLibNull.c
new file mode 100644
index 0000000..fc211f6
--- /dev/null
+++ b/libedk2_tpm/RegisterFilterLibNull.c
@@ -0,0 +1,272 @@
+/** @file
+  Null instance of RegisterFilterLib.
+
+  Copyright (c) 2021 Intel Corporation. All rights reserved.<BR>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+#include <efi.h>
+#include <efiapi.h>
+#include <RegisterFilterLib.h>
+
+/**
+  Filter IO read operation before read IO port.
+  It is used to filter IO read operation.
+
+  It will return the flag to decide whether require read real IO port.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in,out]   Buffer   The destination buffer to store the results.
+
+  @retval TRUE         Need to excute the IO read.
+  @retval FALSE        Skip the IO read.
+
+**/
+
+BOOLEAN
+EFIAPI
+FilterBeforeIoRead1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN OUT VOID         *Buffer
+  )
+{
+  return TRUE;
+}
+
+/**
+  Trace IO read operation after read IO port.
+  It is used to trace IO operation.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in]       Buffer   The destination buffer to store the results.
+
+**/
+VOID
+EFIAPI
+FilterAfterIoRead1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN VOID             *Buffer
+  )
+{
+  return;
+}
+
+/**
+  Filter IO Write operation before wirte IO port.
+  It is used to filter IO operation.
+
+  It will return the flag to decide whether require read write IO port.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in]       Buffer   The source buffer from which to write data.
+
+  @retval TRUE         Need to excute the IO write.
+  @retval FALSE        Skip the IO write.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeIoWrite1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN VOID             *Buffer
+  )
+{
+  return TRUE;
+}
+
+  /**
+  Trace IO Write operation after wirte IO port.
+  It is used to trace IO operation.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in]       Buffer   The source buffer from which to Write data.
+
+**/
+VOID
+EFIAPI
+FilterAfterIoWrite1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN VOID             *Buffer
+  )
+{
+  return;
+}
+
+/**
+  Filter memory IO before Read operation.
+
+  It will return the flag to decide whether require read real MMIO.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in,out]   Buffer   The destination buffer to store the results.
+
+  @retval TRUE         Need to excute the MMIO read.
+  @retval FALSE        Skip the MMIO read.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMmIoRead1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN OUT VOID         *Buffer
+  )
+{
+  return TRUE;
+}
+
+/**
+  Tracer memory IO after read operation.
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in]       Buffer   The destination buffer to store the results.
+
+**/
+VOID
+EFIAPI
+FilterAfterMmIoRead1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN VOID             *Buffer
+  )
+{
+  return;
+}
+
+/**
+  Filter memory IO before write operation.
+
+  It will return the flag to decide whether require wirte real MMIO.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in]       Buffer   The source buffer from which to write data.
+
+  @retval TRUE         Need to excute the MMIO write.
+  @retval FALSE        Skip the MMIO write.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMmIoWrite1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN VOID             *Buffer
+  )
+{
+  return TRUE;
+}
+
+/**
+  Tracer memory IO after write operation.
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in]       Buffer   The source buffer from which to write data.
+
+**/
+VOID
+EFIAPI
+FilterAfterMmIoWrite1 (
+__attribute__((__unused__))  IN FILTER_IO_WIDTH  Width,
+__attribute__((__unused__))  IN UINTN            Address,
+__attribute__((__unused__))  IN VOID             *Buffer
+  )
+{
+  return;
+}
+
+/**
+  Filter MSR before read operation.
+
+  It will return the flag to decide whether require read real MSR.
+  It can be used for emulation environment.
+
+  @param  Index                     The Register index of the MSR.
+  @param  Value                     Point to the data will be read from the MSR.
+
+  @retval TRUE         Need to excute the MSR read.
+  @retval FALSE        Skip the MSR read.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMsrRead1 (
+__attribute__((__unused__))  IN UINT32        Index,
+__attribute__((__unused__))  IN OUT UINT64    *Value
+  )
+{
+  return TRUE;
+}
+
+/**
+  Trace MSR after read operation.
+
+  @param  Index                     The Register index of the MSR.
+  @param  Value                     Point to the data has been be read from the MSR.
+
+**/
+VOID
+EFIAPI
+FilterAfterMsrRead1 (
+__attribute__((__unused__))  IN UINT32    Index,
+__attribute__((__unused__))  IN UINT64    *Value
+  )
+{
+  return;
+}
+
+/**
+  Filter MSR before write operation.
+
+  It will return the flag to decide whether require write real MSR.
+  It can be used for emulation environment.
+
+  @param  Index                     The Register index of the MSR.
+  @param  Value                     Point to the data want to be written to the MSR.
+
+  @retval TRUE         Need to excute the MSR write.
+  @retval FALSE        Skip the MSR write.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMsrWrite1 (
+__attribute__((__unused__))  IN UINT32    Index,
+__attribute__((__unused__))  IN UINT64    *Value
+  )
+{
+  return TRUE;
+}
+
+/**
+  Trace MSR after write operation.
+
+  @param  Index                     The Register index of the MSR.
+  @param  Value                     Point to the data has been be written to the MSR.
+
+**/
+VOID
+EFIAPI
+FilterAfterMsrWrite1 (
+__attribute__((__unused__))  IN UINT32    Index,
+__attribute__((__unused__))  IN UINT64    *Value
+  )
+{
+  return;
+}
diff --git a/libedk2_tpm/Tpm2Ptp.c b/libedk2_tpm/Tpm2Ptp.c
new file mode 100644
index 0000000..ded5c86
--- /dev/null
+++ b/libedk2_tpm/Tpm2Ptp.c
@@ -0,0 +1,578 @@
+/** @file
+  PTP (Platform TPM Profile) CRB (Command Response Buffer) interface used by dTPM2.0 library.
+
+  Copyright (c) 2015 - 2016, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+#include <Tpm12.h>
+#include <Tpm20.h>
+#include <Tcg2Protocol.h>
+#include <Tpm2DeviceLib.h>
+#include <UefiTcgPlatform.h>
+#include <Tpm2CommandLib.h>
+#include <Tpm2Help.h>
+#include <PcdLib.h>
+
+#include <IndustryStandard/TpmPtp.h>
+#include <IndustryStandard/TpmTis.h>
+#include <IndustryStandard/Tpm2Acpi.h>
+#include <IoLib.h>
+#include <RegisterFilterLib.h>
+
+typedef enum {
+  PtpInterfaceTis,
+  PtpInterfaceFifo,
+  PtpInterfaceCrb,
+  PtpInterfaceMax,
+} PTP_INTERFACE_TYPE;
+
+//
+// Execution of the command may take from several seconds to minutes for certain
+// commands, such as key generation.
+//
+#define PTP_TIMEOUT_MAX             (90000 * 1000)  // 90s
+
+//
+// Max TPM command/reponse length
+//
+#define TPMCMDBUFLENGTH             0x500
+
+/**
+  Check whether TPM PTP register exist.
+
+  @param[in] Reg  Pointer to PTP register.
+
+  @retval    TRUE    TPM PTP exists.
+  @retval    FALSE   TPM PTP is not found.
+**/
+BOOLEAN
+Tpm2IsPtpPresence (
+  IN VOID *Reg
+  )
+{
+  UINT8                             RegRead;
+
+  RegRead = MmioRead8 ((UINTN)Reg);
+  if (RegRead == 0xFF) {
+    //
+    // No TPM chip
+    //
+    return FALSE;
+  }
+  return TRUE;
+}
+
+/**
+  Check whether the value of a TPM chip register satisfies the input BIT setting.
+
+  @param[in]  Register     Address port of register to be checked.
+  @param[in]  BitSet       Check these data bits are set.
+  @param[in]  BitClear     Check these data bits are clear.
+  @param[in]  TimeOut      The max wait time (unit MicroSecond) when checking register.
+
+  @retval     EFI_SUCCESS  The register satisfies the check bit.
+  @retval     EFI_TIMEOUT  The register can't run into the expected status in time.
+**/
+EFI_STATUS
+PtpCrbWaitRegisterBits (
+  IN      UINT32                    *Register,
+  IN      UINT32                    BitSet,
+  IN      UINT32                    BitClear,
+  IN      UINT32                    TimeOut
+  )
+{
+  UINT32                            RegRead;
+  UINT32                            WaitTime;
+
+  for (WaitTime = 0; WaitTime < TimeOut; WaitTime += 30) {
+    RegRead = MmioRead32 ((UINTN)Register);
+    if ((RegRead & BitSet) == BitSet && (RegRead & BitClear) == 0) {
+      return EFI_SUCCESS;
+    }
+    //todo
+    //MicroSecondDelay (30);
+  }
+  return EFI_TIMEOUT;
+}
+
+/**
+  Get the control of TPM chip.
+
+  @param[in] CrbReg                Pointer to CRB register.
+
+  @retval    EFI_SUCCESS           Get the control of TPM chip.
+  @retval    EFI_INVALID_PARAMETER CrbReg is NULL.
+  @retval    EFI_NOT_FOUND         TPM chip doesn't exit.
+  @retval    EFI_TIMEOUT           Can't get the TPM control in time.
+**/
+EFI_STATUS
+PtpCrbRequestUseTpm (
+  IN      PTP_CRB_REGISTERS_PTR      CrbReg
+  )
+{
+  EFI_STATUS                        Status;
+  UINT32                            LocalityState;
+
+  if (!Tpm2IsPtpPresence (CrbReg)) {
+    return EFI_NOT_FOUND;
+  }
+
+  // Check if Locality 0 is assigned
+  LocalityState = MmioRead32 ((UINTN)&CrbReg->LocalityState);
+
+  if ((((LocalityState & PTP_CRB_LOCALITY_STATE_ACTIVE_LOCALITY_MASK) >> 2) == 0) &&
+      ((LocalityState & PTP_CRB_LOCALITY_STATE_LOCALITY_ASSIGNED) != 0)) {
+    DEBUG ((DEBUG_VERBOSE, "TPM2: Locality 0 already assigned. LocalityState: 0x%08x \n ", LocalityState));
+    return EFI_SUCCESS;
+  }
+  MmioWrite32 ((UINTN)&CrbReg->LocalityControl, PTP_CRB_LOCALITY_CONTROL_REQUEST_ACCESS);
+  Status = PtpCrbWaitRegisterBits (
+             &CrbReg->LocalityStatus,
+             PTP_CRB_LOCALITY_STATUS_GRANTED,
+             0,
+             PTP_TIMEOUT_A
+             );
+  return Status;
+}
+
+/**
+  Send a command to TPM for execution and return response data.
+
+  @param[in]      CrbReg        TPM register space base address.
+  @param[in]      BufferIn      Buffer for command data.
+  @param[in]      SizeIn        Size of command data.
+  @param[in, out] BufferOut     Buffer for response data.
+  @param[in, out] SizeOut       Size of response data.
+
+  @retval EFI_SUCCESS           Operation completed successfully.
+  @retval EFI_BUFFER_TOO_SMALL  Response data buffer is too small.
+  @retval EFI_DEVICE_ERROR      Unexpected device behavior.
+  @retval EFI_UNSUPPORTED       Unsupported TPM version
+
+**/
+EFI_STATUS
+PtpCrbTpmCommand (
+  IN     PTP_CRB_REGISTERS_PTR      CrbReg,
+  IN     UINT8                      *BufferIn,
+  IN     UINT32                     SizeIn,
+  IN OUT UINT8                      *BufferOut,
+  IN OUT UINT32                     *SizeOut
+  )
+{
+  EFI_STATUS                        Status;
+  UINT32                            Index;
+  UINT32                            TpmOutSize;
+  UINT16                            Data16;
+  UINT32                            Data32;
+
+  TpmOutSize = 0;
+
+  //
+  // STEP 0:
+  // Ready is any time the TPM is ready to receive a command, following a write
+  // of 1 by software to Request.cmdReady, as indicated by the Status field
+  // being cleared to 0.
+  //
+  MmioWrite32 ((UINTN)&CrbReg->CrbControlRequest, PTP_CRB_CONTROL_AREA_REQUEST_COMMAND_READY);
+  Status = PtpCrbWaitRegisterBits (
+             &CrbReg->CrbControlRequest,
+             0,
+             PTP_CRB_CONTROL_AREA_REQUEST_COMMAND_READY,
+             PTP_TIMEOUT_C
+             );
+  if (EFI_ERROR (Status)) {
+    Status = EFI_DEVICE_ERROR;
+    goto Exit;
+  }
+  Status = PtpCrbWaitRegisterBits (
+             &CrbReg->CrbControlStatus,
+             0,
+             PTP_CRB_CONTROL_AREA_STATUS_TPM_IDLE,
+             PTP_TIMEOUT_C
+             );
+  if (EFI_ERROR (Status)) {
+    Status = EFI_DEVICE_ERROR;
+    goto Exit;
+  }
+
+  //
+  // STEP 1:
+  // Command Reception occurs following a Ready state between the write of the
+  // first byte of a command to the Command Buffer and the receipt of a write
+  // of 1 to Start.
+  //
+  for (Index = 0; Index < SizeIn; Index++) {
+    MmioWrite8 ((UINTN)&CrbReg->CrbDataBuffer[Index], BufferIn[Index]);
+  }
+  MmioWrite32 ((UINTN)&CrbReg->CrbControlCommandAddressHigh, (UINT32)RShiftU64 ((UINTN)CrbReg->CrbDataBuffer, 32));
+  MmioWrite32 ((UINTN)&CrbReg->CrbControlCommandAddressLow, (UINT32) (UINTN)CrbReg->CrbDataBuffer);
+  MmioWrite32 ((UINTN)&CrbReg->CrbControlCommandSize, sizeof (CrbReg->CrbDataBuffer));
+
+  MmioWrite64 ((UINTN)&CrbReg->CrbControlResponseAddrss, (UINT32) (UINTN)CrbReg->CrbDataBuffer);
+  MmioWrite32 ((UINTN)&CrbReg->CrbControlResponseSize, sizeof (CrbReg->CrbDataBuffer));
+
+  //
+  // STEP 2:
+  // Command Execution occurs after receipt of a 1 to Start and the TPM
+  // clearing Start to 0.
+  //
+  MmioWrite32 ((UINTN)&CrbReg->CrbControlStart, PTP_CRB_CONTROL_START);
+  Status = PtpCrbWaitRegisterBits (
+             &CrbReg->CrbControlStart,
+             0,
+             PTP_CRB_CONTROL_START,
+             PTP_TIMEOUT_MAX
+             );
+  if (EFI_ERROR (Status)) {
+    Status = EFI_DEVICE_ERROR;
+    goto Exit;
+  }
+
+  //
+  // STEP 3:
+  // Command Completion occurs after completion of a command (indicated by the
+  // TPM clearing TPM_CRB_CTRL_Start_x to 0) and before a write of a 1 by the
+  // software to Request.goIdle.
+  //
+
+  //
+  // Get response data header
+  //
+  for (Index = 0; Index < sizeof (TPM2_RESPONSE_HEADER); Index++) {
+    BufferOut[Index] = MmioRead8 ((UINTN)&CrbReg->CrbDataBuffer[Index]);
+  }
+  //
+  // Check the reponse data header (tag, parasize and returncode)
+  //
+  CopyMem (&Data16, BufferOut, sizeof (UINT16));
+  // TPM2 should not use this RSP_COMMAND
+  if (SwapBytes16 (Data16) == TPM_ST_RSP_COMMAND) {
+    DEBUG ((DEBUG_ERROR, "TPM2: TPM_ST_RSP error - %x\n", TPM_ST_RSP_COMMAND));
+    Status = EFI_UNSUPPORTED;
+    goto Exit;
+  }
+
+  CopyMem (&Data32, (BufferOut + 2), sizeof (UINT32));
+  TpmOutSize  = SwapBytes32 (Data32);
+  if (*SizeOut < TpmOutSize) {
+    Status = EFI_BUFFER_TOO_SMALL;
+    goto Exit;
+  }
+  *SizeOut = TpmOutSize;
+  //
+  // Continue reading the remaining data
+  //
+  for (Index = sizeof (TPM2_RESPONSE_HEADER); Index < TpmOutSize; Index++) {
+    BufferOut[Index] = MmioRead8 ((UINTN)&CrbReg->CrbDataBuffer[Index]);
+  }
+Exit:
+
+  //
+  // STEP 4:
+  // Idle is any time TPM_CRB_CTRL_STS_x.Status.goIdle is 1.
+  //
+  // Older versions of Linux kernel tpm_crb driver does not wake the TPM before mapping
+  // the memory and therefore fail.
+  // Avoid going idle.
+  // MmioWrite32((UINTN)&CrbReg->CrbControlRequest, PTP_CRB_CONTROL_AREA_REQUEST_GO_IDLE);
+  return Status;
+}
+
+/**
+  Send a command to TPM for execution and return response data.
+
+  @param[in]      TisReg        TPM register space base address.
+  @param[in]      BufferIn      Buffer for command data.
+  @param[in]      SizeIn        Size of command data.
+  @param[in, out] BufferOut     Buffer for response data.
+  @param[in, out] SizeOut       Size of response data.
+
+  @retval EFI_SUCCESS           Operation completed successfully.
+  @retval EFI_BUFFER_TOO_SMALL  Response data buffer is too small.
+  @retval EFI_DEVICE_ERROR      Unexpected device behavior.
+  @retval EFI_UNSUPPORTED       Unsupported TPM version
+
+**/
+EFI_STATUS
+Tpm2TisTpmCommand (
+  IN     TIS_PC_REGISTERS_PTR       TisReg,
+  IN     UINT8                      *BufferIn,
+  IN     UINT32                     SizeIn,
+  IN OUT UINT8                      *BufferOut,
+  IN OUT UINT32                     *SizeOut
+  );
+
+/**
+  Get the control of TPM chip by sending requestUse command TIS_PC_ACC_RQUUSE
+  to ACCESS Register in the time of default TIS_TIMEOUT_A.
+
+  @param[in] TisReg                Pointer to TIS register.
+
+  @retval    EFI_SUCCESS           Get the control of TPM chip.
+  @retval    EFI_INVALID_PARAMETER TisReg is NULL.
+  @retval    EFI_NOT_FOUND         TPM chip doesn't exit.
+  @retval    EFI_TIMEOUT           Can't get the TPM control in time.
+**/
+EFI_STATUS
+TisPcRequestUseTpm (
+  IN     TIS_PC_REGISTERS_PTR       TisReg
+  );
+
+/**
+  Return PTP interface type.
+
+  @param[in] Register                Pointer to PTP register.
+
+  @return PTP interface type.
+**/
+PTP_INTERFACE_TYPE
+Tpm2GetPtpInterface (
+  IN VOID *Register
+  )
+{
+  PTP_CRB_INTERFACE_IDENTIFIER  InterfaceId;
+  PTP_FIFO_INTERFACE_CAPABILITY InterfaceCapability;
+
+  if (!Tpm2IsPtpPresence (Register)) {
+    return PtpInterfaceMax;
+  }
+  //
+  // Check interface id
+  //
+  InterfaceId.Uint32 = MmioRead32 ((UINTN) & ((PTP_CRB_REGISTERS *)Register)->InterfaceId);
+  InterfaceCapability.Uint32 = MmioRead32 ((UINTN) & ((PTP_FIFO_REGISTERS *)Register)->InterfaceCapability);
+
+  if ((InterfaceId.Bits.InterfaceType == PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_CRB) &&
+      (InterfaceId.Bits.InterfaceVersion == PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_CRB) &&
+      (InterfaceId.Bits.CapCRB != 0)) {
+    return PtpInterfaceCrb;
+  }
+  if ((InterfaceId.Bits.InterfaceType == PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_FIFO) &&
+      (InterfaceId.Bits.InterfaceVersion == PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_FIFO) &&
+      (InterfaceId.Bits.CapFIFO != 0) &&
+      (InterfaceCapability.Bits.InterfaceVersion == INTERFACE_CAPABILITY_INTERFACE_VERSION_PTP)) {
+    return PtpInterfaceFifo;
+  }
+  return PtpInterfaceTis;
+}
+
+/**
+  Dump PTP register information.
+
+  @param[in] Register                Pointer to PTP register.
+**/
+VOID
+DumpPtpInfo (
+  IN VOID *Register
+  )
+{
+  PTP_CRB_INTERFACE_IDENTIFIER  InterfaceId;
+  PTP_FIFO_INTERFACE_CAPABILITY InterfaceCapability;
+  UINT8                         StatusEx;
+  UINT16                        Vid;
+  UINT16                        Did;
+  UINT8                         Rid;
+  PTP_INTERFACE_TYPE            PtpInterface;
+
+  if (!Tpm2IsPtpPresence (Register)) {
+    return ;
+  }
+
+  InterfaceId.Uint32 = MmioRead32 ((UINTN) & ((PTP_CRB_REGISTERS *)Register)->InterfaceId);
+  InterfaceCapability.Uint32 = MmioRead32 ((UINTN) & ((PTP_FIFO_REGISTERS *)Register)->InterfaceCapability);
+  StatusEx = MmioRead8 ((UINTN) & ((PTP_FIFO_REGISTERS *)Register)->StatusEx);
+
+  //
+  // Dump InterfaceId Register for PTP
+  //
+  DEBUG ((DEBUG_INFO, "InterfaceId - 0x%08x\n", InterfaceId.Uint32));
+  DEBUG ((DEBUG_INFO, "  InterfaceType    - 0x%02x\n", InterfaceId.Bits.InterfaceType));
+  if (InterfaceId.Bits.InterfaceType != PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_TIS) {
+    DEBUG ((DEBUG_INFO, "  InterfaceVersion - 0x%02x\n", InterfaceId.Bits.InterfaceVersion));
+    DEBUG ((DEBUG_INFO, "  CapFIFO          - 0x%x\n", InterfaceId.Bits.CapFIFO));
+    DEBUG ((DEBUG_INFO, "  CapCRB           - 0x%x\n", InterfaceId.Bits.CapCRB));
+  }
+
+  //
+  // Dump Capability Register for TIS and FIFO
+  //
+  DEBUG ((DEBUG_INFO, "InterfaceCapability - 0x%08x\n", InterfaceCapability.Uint32));
+  if ((InterfaceId.Bits.InterfaceType == PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_TIS) ||
+      (InterfaceId.Bits.InterfaceType == PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_FIFO)) {
+    DEBUG ((DEBUG_INFO, "  InterfaceVersion - 0x%x\n", InterfaceCapability.Bits.InterfaceVersion));
+  }
+
+  //
+  // Dump StatusEx Register for PTP FIFO
+  //
+  DEBUG ((DEBUG_INFO, "StatusEx - 0x%02x\n", StatusEx));
+  if (InterfaceCapability.Bits.InterfaceVersion == INTERFACE_CAPABILITY_INTERFACE_VERSION_PTP) {
+    DEBUG ((DEBUG_INFO, "  TpmFamily - 0x%x\n",
+            (StatusEx & PTP_FIFO_STS_EX_TPM_FAMILY) >> PTP_FIFO_STS_EX_TPM_FAMILY_OFFSET));
+  }
+
+  Vid = 0xFFFF;
+  Did = 0xFFFF;
+  Rid = 0xFF;
+  PtpInterface = Tpm2GetPtpInterface (Register);
+  DEBUG ((DEBUG_INFO, "PtpInterface - %x\n", PtpInterface));
+  switch (PtpInterface) {
+  case PtpInterfaceCrb:
+    Vid = MmioRead16_1 ((UINTN) & ((PTP_CRB_REGISTERS *)Register)->Vid);
+    Did = MmioRead16_1 ((UINTN) & ((PTP_CRB_REGISTERS *)Register)->Did);
+    Rid = (UINT8)InterfaceId.Bits.Rid;
+    break;
+  case PtpInterfaceFifo:
+  case PtpInterfaceTis:
+    Vid = MmioRead16_1 ((UINTN) & ((PTP_FIFO_REGISTERS *)Register)->Vid);
+    Did = MmioRead16_1 ((UINTN) & ((PTP_FIFO_REGISTERS *)Register)->Did);
+    Rid = MmioRead8 ((UINTN) & ((PTP_FIFO_REGISTERS *)Register)->Rid);
+    break;
+  default:
+    break;
+  }
+  DEBUG ((DEBUG_INFO, "VID - 0x%04x\n", Vid));
+  DEBUG ((DEBUG_INFO, "DID - 0x%04x\n", Did));
+  DEBUG ((DEBUG_INFO, "RID - 0x%02x\n", Rid));
+}
+
+/**
+  This service enables the sending of commands to the TPM2.
+
+  @param[in]      InputParameterBlockSize  Size of the TPM2 input parameter block.
+  @param[in]      InputParameterBlock      Pointer to the TPM2 input parameter block.
+  @param[in,out]  OutputParameterBlockSize Size of the TPM2 output parameter block.
+  @param[in]      OutputParameterBlock     Pointer to the TPM2 output parameter block.
+
+  @retval EFI_SUCCESS            The command byte stream was successfully sent to the device and a response was successfully received.
+  @retval EFI_DEVICE_ERROR       The command was not successfully sent to the device or a response was not successfully received from the device.
+  @retval EFI_BUFFER_TOO_SMALL   The output parameter block is too small.
+**/
+EFI_STATUS
+EFIAPI
+Tpm2SubmitCommand (
+  IN UINT32            InputParameterBlockSize,
+  IN UINT8             *InputParameterBlock,
+  IN OUT UINT32        *OutputParameterBlockSize,
+  IN UINT8             *OutputParameterBlock
+  )
+{
+  PTP_INTERFACE_TYPE  PtpInterface;
+
+  PtpInterface = Tpm2GetPtpInterface ((VOID *) (UINTN) PcdGet64 (PcdTpmBaseAddress));
+  switch (PtpInterface) {
+  case PtpInterfaceCrb:
+    return PtpCrbTpmCommand (
+             (PTP_CRB_REGISTERS_PTR) (UINTN) PcdGet64 (PcdTpmBaseAddress),
+             InputParameterBlock,
+             InputParameterBlockSize,
+             OutputParameterBlock,
+             OutputParameterBlockSize
+             );
+  case PtpInterfaceFifo:
+  case PtpInterfaceTis:
+    return Tpm2TisTpmCommand (
+             (TIS_PC_REGISTERS_PTR) (UINTN) PcdGet64 (PcdTpmBaseAddress),
+             InputParameterBlock,
+             InputParameterBlockSize,
+             OutputParameterBlock,
+             OutputParameterBlockSize
+             );
+  default:
+    return EFI_NOT_FOUND;
+  }
+}
+
+/**
+  This service requests use TPM2.
+
+  @retval EFI_SUCCESS      Get the control of TPM2 chip.
+  @retval EFI_NOT_FOUND    TPM2 not found.
+  @retval EFI_DEVICE_ERROR Unexpected device behavior.
+**/
+EFI_STATUS
+EFIAPI
+Tpm2RequestUseTpm (
+  VOID
+  )
+{
+  PTP_INTERFACE_TYPE  PtpInterface;
+
+  PtpInterface = Tpm2GetPtpInterface ((VOID *) (UINTN) PcdGet64 (PcdTpmBaseAddress));
+  switch (PtpInterface) {
+  case PtpInterfaceCrb:
+    return PtpCrbRequestUseTpm ((PTP_CRB_REGISTERS_PTR) (UINTN) PcdGet64 (PcdTpmBaseAddress));
+  case PtpInterfaceFifo:
+  case PtpInterfaceTis:
+    return TisPcRequestUseTpm ((TIS_PC_REGISTERS_PTR) (UINTN) PcdGet64 (PcdTpmBaseAddress));
+  default:
+    return EFI_NOT_FOUND;
+  }
+}
+
+/**
+  This service checks for TPM device.
+
+  @retval EFI_SUCCESS      Supported TPM2 is present.
+  @retval EFI_NOT_FOUND    TPM2 not found.
+**/
+EFI_STATUS
+EFIAPI
+IsSupportedTpmPresent (
+  VOID
+  )
+{
+  PTP_INTERFACE_TYPE  PtpInterface;
+
+  PtpInterface = Tpm2GetPtpInterface ((VOID *) (UINTN) PcdGet64 (PcdTpmBaseAddress));
+  switch (PtpInterface) {
+  case PtpInterfaceCrb:
+  case PtpInterfaceFifo:
+  case PtpInterfaceTis:
+    return EFI_SUCCESS;
+  default:
+    return EFI_NOT_FOUND;
+  }
+}
+
+
+/**
+  Update TPM ACPI table with interface information.
+
+  @param[in]      Tpm2Acpi           Pointer to Tpm2 ACPI table.
+
+  @retval RETURN_SUCCESS             Tpm2 table updated successfully.
+  @retval EFI_NOT_FOUND              The request could not be executed successfully.
+
+**/
+EFI_STATUS
+EFIAPI
+UpdateAcpiInterfaceInfo (
+  IN EFI_TPM2_ACPI_TABLE *Tpm2Acpi
+  )
+{
+  PTP_INTERFACE_TYPE              PtpInterface;
+  EFI_TPM2_ACPI_CONTROL_AREA     *ControlArea;
+
+  PtpInterface = Tpm2GetPtpInterface ((VOID *) (UINTN) PcdGet64 (PcdTpmBaseAddress));
+  switch (PtpInterface) {
+  case PtpInterfaceCrb:
+    Tpm2Acpi->StartMethod = EFI_TPM2_ACPI_TABLE_START_METHOD_COMMAND_RESPONSE_BUFFER_INTERFACE;
+    Tpm2Acpi->AddressOfControlArea = PcdGet64 (PcdTpmBaseAddress) + 0x40;
+    ControlArea = (EFI_TPM2_ACPI_CONTROL_AREA *) (UINTN)Tpm2Acpi->AddressOfControlArea;
+    ControlArea->CommandSize  = 0xF80;
+    ControlArea->ResponseSize = 0xF80;
+    ControlArea->Command      = PcdGet64 (PcdTpmBaseAddress) + 0x80;
+    ControlArea->Response     = PcdGet64 (PcdTpmBaseAddress) + 0x80;
+
+    return EFI_SUCCESS;
+    break;
+  case PtpInterfaceFifo:
+  case PtpInterfaceTis:
+
+    return EFI_SUCCESS;
+  default:
+    return EFI_NOT_FOUND;
+  }
+}
diff --git a/libedk2_tpm/Tpm2Tis.c b/libedk2_tpm/Tpm2Tis.c
new file mode 100644
index 0000000..b1bec97
--- /dev/null
+++ b/libedk2_tpm/Tpm2Tis.c
@@ -0,0 +1,377 @@
+/** @file
+  TIS (TPM Interface Specification) functions used by dTPM2.0 library.
+
+  Copyright (c) 2013 - 2016, Intel Corporation. All rights reserved.<BR>
+  (C) Copyright 2015 Hewlett Packard Enterprise Development LP<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#include <Tpm20.h>
+#include <Tpm2Help.h>
+#include <IoLib.h>
+#include <Tpm2DeviceLib.h>
+#include <PcdLib.h>
+
+#include <IndustryStandard/TpmTis.h>
+
+#define TIS_TIMEOUT_MAX             (90000 * 1000)  // 90s
+
+//
+// Max TPM command/reponse length
+//
+#define TPMCMDBUFLENGTH             0x500
+
+/**
+  Check whether TPM chip exist.
+
+  @param[in] TisReg  Pointer to TIS register.
+
+  @retval    TRUE    TPM chip exists.
+  @retval    FALSE   TPM chip is not found.
+**/
+BOOLEAN
+TisPcPresenceCheck (
+  IN      TIS_PC_REGISTERS_PTR      TisReg
+  )
+{
+  UINT8                             RegRead;
+
+  RegRead = MmioRead8 ((UINTN)&TisReg->Access);
+  return (BOOLEAN) (RegRead != (UINT8) - 1);
+}
+
+/**
+  Check whether the value of a TPM chip register satisfies the input BIT setting.
+
+  @param[in]  Register     Address port of register to be checked.
+  @param[in]  BitSet       Check these data bits are set.
+  @param[in]  BitClear     Check these data bits are clear.
+  @param[in]  TimeOut      The max wait time (unit MicroSecond) when checking register.
+
+  @retval     EFI_SUCCESS  The register satisfies the check bit.
+  @retval     EFI_TIMEOUT  The register can't run into the expected status in time.
+**/
+EFI_STATUS
+TisPcWaitRegisterBits (
+  IN      UINT8                     *Register,
+  IN      UINT8                     BitSet,
+  IN      UINT8                     BitClear,
+  IN      UINT32                    TimeOut
+  )
+{
+  UINT8                             RegRead;
+  UINT32                            WaitTime;
+
+  for (WaitTime = 0; WaitTime < TimeOut; WaitTime += 30) {
+    RegRead = MmioRead8 ((UINTN)Register);
+    if ((RegRead & BitSet) == BitSet && (RegRead & BitClear) == 0) {
+      return EFI_SUCCESS;
+    }
+    //MicroSecondDelay (30);
+  }
+  return EFI_TIMEOUT;
+}
+
+/**
+  Get BurstCount by reading the burstCount field of a TIS regiger
+  in the time of default TIS_TIMEOUT_D.
+
+  @param[in]  TisReg                Pointer to TIS register.
+  @param[out] BurstCount            Pointer to a buffer to store the got BurstConut.
+
+  @retval     EFI_SUCCESS           Get BurstCount.
+  @retval     EFI_INVALID_PARAMETER TisReg is NULL or BurstCount is NULL.
+  @retval     EFI_TIMEOUT           BurstCount can't be got in time.
+**/
+EFI_STATUS
+TisPcReadBurstCount (
+  IN      TIS_PC_REGISTERS_PTR      TisReg,
+  OUT  UINT16                    *BurstCount
+  )
+{
+  UINT32                            WaitTime;
+  UINT8                             DataByte0;
+  UINT8                             DataByte1;
+
+  if (BurstCount == NULL || TisReg == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  WaitTime = 0;
+  do {
+    //
+    // TIS_PC_REGISTERS_PTR->burstCount is UINT16, but it is not 2bytes aligned,
+    // so it needs to use MmioRead8 to read two times
+    //
+    DataByte0   = MmioRead8 ((UINTN)&TisReg->BurstCount);
+    DataByte1   = MmioRead8 ((UINTN)&TisReg->BurstCount + 1);
+    *BurstCount = (UINT16) ((DataByte1 << 8) + DataByte0);
+    if (*BurstCount != 0) {
+      return EFI_SUCCESS;
+    }
+   // MicroSecondDelay (30);
+    WaitTime += 30;
+  } while (WaitTime < TIS_TIMEOUT_D);
+
+  return EFI_TIMEOUT;
+}
+
+/**
+  Set TPM chip to ready state by sending ready command TIS_PC_STS_READY
+  to Status Register in time.
+
+  @param[in] TisReg                Pointer to TIS register.
+
+  @retval    EFI_SUCCESS           TPM chip enters into ready state.
+  @retval    EFI_INVALID_PARAMETER TisReg is NULL.
+  @retval    EFI_TIMEOUT           TPM chip can't be set to ready state in time.
+**/
+EFI_STATUS
+TisPcPrepareCommand (
+  IN      TIS_PC_REGISTERS_PTR      TisReg
+  )
+{
+  EFI_STATUS                        Status;
+
+  if (TisReg == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  MmioWrite8 ((UINTN)&TisReg->Status, TIS_PC_STS_READY);
+  Status = TisPcWaitRegisterBits (
+             &TisReg->Status,
+             TIS_PC_STS_READY,
+             0,
+             TIS_TIMEOUT_B
+             );
+  return Status;
+}
+
+/**
+  Get the control of TPM chip by sending requestUse command TIS_PC_ACC_RQUUSE
+  to ACCESS Register in the time of default TIS_TIMEOUT_A.
+
+  @param[in] TisReg                Pointer to TIS register.
+
+  @retval    EFI_SUCCESS           Get the control of TPM chip.
+  @retval    EFI_INVALID_PARAMETER TisReg is NULL.
+  @retval    EFI_NOT_FOUND         TPM chip doesn't exit.
+  @retval    EFI_TIMEOUT           Can't get the TPM control in time.
+**/
+EFI_STATUS
+TisPcRequestUseTpm (
+  IN      TIS_PC_REGISTERS_PTR      TisReg
+  )
+{
+  EFI_STATUS                        Status;
+
+  if (TisReg == NULL) {
+    return EFI_INVALID_PARAMETER;
+  }
+
+  if (!TisPcPresenceCheck (TisReg)) {
+    return EFI_NOT_FOUND;
+  }
+
+  MmioWrite8 ((UINTN)&TisReg->Access, TIS_PC_ACC_RQUUSE);
+  Status = TisPcWaitRegisterBits (
+             &TisReg->Access,
+             (UINT8) (TIS_PC_ACC_ACTIVE | TIS_PC_VALID),
+             0,
+             TIS_TIMEOUT_A
+             );
+  return Status;
+}
+
+/**
+  Send a command to TPM for execution and return response data.
+
+  @param[in]      TisReg        TPM register space base address.
+  @param[in]      BufferIn      Buffer for command data.
+  @param[in]      SizeIn        Size of command data.
+  @param[in, out] BufferOut     Buffer for response data.
+  @param[in, out] SizeOut       Size of response data.
+
+  @retval EFI_SUCCESS           Operation completed successfully.
+  @retval EFI_BUFFER_TOO_SMALL  Response data buffer is too small.
+  @retval EFI_DEVICE_ERROR      Unexpected device behavior.
+  @retval EFI_UNSUPPORTED       Unsupported TPM version
+
+**/
+EFI_STATUS
+Tpm2TisTpmCommand (
+  IN     TIS_PC_REGISTERS_PTR       TisReg,
+  IN     UINT8                      *BufferIn,
+  IN     UINT32                     SizeIn,
+  IN OUT UINT8                      *BufferOut,
+  IN OUT UINT32                     *SizeOut
+  )
+{
+  EFI_STATUS                        Status;
+  UINT16                            BurstCount;
+  UINT32                            Index;
+  UINT32                            TpmOutSize;
+  UINT16                            Data16;
+  UINT32                            Data32;
+
+  TpmOutSize = 0;
+
+  Status = TisPcPrepareCommand (TisReg);
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Tpm2 is not ready for command!\n"));
+    return EFI_DEVICE_ERROR;
+  }
+  //
+  // Send the command data to Tpm
+  //
+  Index = 0;
+  while (Index < SizeIn) {
+    Status = TisPcReadBurstCount (TisReg, &BurstCount);
+    if (EFI_ERROR (Status)) {
+      Status = EFI_DEVICE_ERROR;
+      goto Exit;
+    }
+    for (; BurstCount > 0 && Index < SizeIn; BurstCount--) {
+      MmioWrite8 ((UINTN)&TisReg->DataFifo, * (BufferIn + Index));
+      Index++;
+    }
+  }
+  //
+  // Check the Tpm status STS_EXPECT change from 1 to 0
+  //
+  Status = TisPcWaitRegisterBits (
+             &TisReg->Status,
+             (UINT8) TIS_PC_VALID,
+             TIS_PC_STS_EXPECT,
+             TIS_TIMEOUT_C
+             );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Tpm2 The send buffer too small!\n"));
+    Status = EFI_BUFFER_TOO_SMALL;
+    goto Exit;
+  }
+  //
+  // Executed the TPM command and waiting for the response data ready
+  //
+  MmioWrite8 ((UINTN)&TisReg->Status, TIS_PC_STS_GO);
+
+  //
+  // NOTE: That may take many seconds to minutes for certain commands, such as key generation.
+  //
+  Status = TisPcWaitRegisterBits (
+             &TisReg->Status,
+             (UINT8) (TIS_PC_VALID | TIS_PC_STS_DATA),
+             0,
+             TIS_TIMEOUT_MAX
+             );
+  if (EFI_ERROR (Status)) {
+    DEBUG ((DEBUG_ERROR, "Wait for Tpm2 response data time out!!\n"));
+    Status = EFI_DEVICE_ERROR;
+    goto Exit;
+  }
+  //
+  // Get response data header
+  //
+  Index = 0;
+  BurstCount = 0;
+  while (Index < sizeof (TPM2_RESPONSE_HEADER)) {
+    Status = TisPcReadBurstCount (TisReg, &BurstCount);
+    if (EFI_ERROR (Status)) {
+      Status = EFI_DEVICE_ERROR;
+      goto Exit;
+    }
+    for (; BurstCount > 0; BurstCount--) {
+      * (BufferOut + Index) = MmioRead8 ((UINTN)&TisReg->DataFifo);
+      Index++;
+      if (Index == sizeof (TPM2_RESPONSE_HEADER)) {
+        break;
+      }
+    }
+  }
+  //
+  // Check the reponse data header (tag,parasize and returncode )
+  //
+  CopyMem (&Data16, BufferOut, sizeof (UINT16));
+  // TPM2 should not use this RSP_COMMAND
+  if (SwapBytes16 (Data16) == TPM_ST_RSP_COMMAND) {
+    DEBUG ((DEBUG_ERROR, "TPM2: TPM_ST_RSP error - %x\n", TPM_ST_RSP_COMMAND));
+    Status = EFI_UNSUPPORTED;
+    goto Exit;
+  }
+
+  CopyMem (&Data32, (BufferOut + 2), sizeof (UINT32));
+  TpmOutSize  = SwapBytes32 (Data32);
+  if (*SizeOut < TpmOutSize) {
+    Status = EFI_BUFFER_TOO_SMALL;
+    goto Exit;
+  }
+  *SizeOut = TpmOutSize;
+  //
+  // Continue reading the remaining data
+  //
+  while ( Index < TpmOutSize ) {
+    for (; BurstCount > 0; BurstCount--) {
+      * (BufferOut + Index) = MmioRead8 ((UINTN)&TisReg->DataFifo);
+      Index++;
+      if (Index == TpmOutSize) {
+        Status = EFI_SUCCESS;
+        goto Exit;
+      }
+    }
+    Status = TisPcReadBurstCount (TisReg, &BurstCount);
+    if (EFI_ERROR (Status)) {
+      Status = EFI_DEVICE_ERROR;
+      goto Exit;
+    }
+  }
+Exit:
+  MmioWrite8 ((UINTN)&TisReg->Status, TIS_PC_STS_READY);
+  return Status;
+}
+
+/**
+  This service enables the sending of commands to the TPM2.
+
+  @param[in]      InputParameterBlockSize  Size of the TPM2 input parameter block.
+  @param[in]      InputParameterBlock      Pointer to the TPM2 input parameter block.
+  @param[in,out]  OutputParameterBlockSize Size of the TPM2 output parameter block.
+  @param[in]      OutputParameterBlock     Pointer to the TPM2 output parameter block.
+
+  @retval EFI_SUCCESS            The command byte stream was successfully sent to the device and a response was successfully received.
+  @retval EFI_DEVICE_ERROR       The command was not successfully sent to the device or a response was not successfully received from the device.
+  @retval EFI_BUFFER_TOO_SMALL   The output parameter block is too small.
+**/
+EFI_STATUS
+EFIAPI
+DTpm2TisSubmitCommand (
+  IN UINT32            InputParameterBlockSize,
+  IN UINT8             *InputParameterBlock,
+  IN OUT UINT32        *OutputParameterBlockSize,
+  IN UINT8             *OutputParameterBlock
+  )
+{
+  return Tpm2TisTpmCommand (
+           (TIS_PC_REGISTERS_PTR) (UINTN) PcdGet64 (PcdTpmBaseAddress),
+           InputParameterBlock,
+           InputParameterBlockSize,
+           OutputParameterBlock,
+           OutputParameterBlockSize
+           );
+}
+
+/**
+  This service requests use TPM2.
+
+  @retval EFI_SUCCESS      Get the control of TPM2 chip.
+  @retval EFI_NOT_FOUND    TPM2 not found.
+  @retval EFI_DEVICE_ERROR Unexpected device behavior.
+**/
+EFI_STATUS
+EFIAPI
+DTpm2TisRequestUseTpm (
+  VOID
+  )
+{
+  return TisPcRequestUseTpm ((TIS_PC_REGISTERS_PTR) (UINTN) PcdGet64 (PcdTpmBaseAddress));
+}
diff --git a/libedk2_tpm/include/Base.h b/libedk2_tpm/include/Base.h
new file mode 100644
index 0000000..6f0ff21
--- /dev/null
+++ b/libedk2_tpm/include/Base.h
@@ -0,0 +1,1325 @@
+/** @file
+  Root include file for Mde Package Base type modules
+
+  This is the include file for any module of type base. Base modules only use
+  types defined via this include file and can be ported easily to any
+  environment. There are a set of base libraries in the Mde Package that can
+  be used to implement base modules.
+
+Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
+Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __BASE_H__
+#define __BASE_H__
+
+//
+// Include processor specific binding
+//
+#include <ProcessorBind.h>
+
+#define _PCD_TOKEN_PcdTpmBaseAddress  0U
+#define _PCD_SIZE_PcdTpmBaseAddress 8
+#define _PCD_GET_MODE_SIZE_PcdTpmBaseAddress  _PCD_SIZE_PcdTpmBaseAddress
+#define _PCD_VALUE_PcdTpmBaseAddress  0xFED40000ULL
+#define _gPcd_FixedAtBuild_PcdTpmBaseAddress  _PCD_VALUE_PcdTpmBaseAddress
+#define _PCD_GET_MODE_64_PcdTpmBaseAddress  _gPcd_FixedAtBuild_PcdTpmBaseAddress
+#define _PCD_TOKEN_PcdTpmBaseAddress  0U
+#define _PCD_SIZE_PcdTpmBaseAddress 8
+#define _PCD_GET_MODE_SIZE_PcdTpmBaseAddress  _PCD_SIZE_PcdTpmBaseAddress
+#define _PCD_VALUE_PcdTpmBaseAddress  0xFED40000ULL
+
+#if defined(_MSC_EXTENSIONS)
+//
+// Disable warning when last field of data structure is a zero sized array.
+//
+#pragma warning ( disable : 4200 )
+#endif
+
+//
+// The Microsoft* C compiler can removed references to unreferenced data items
+//  if the /OPT:REF linker option is used. We defined a macro as this is a
+//  a non standard extension
+//
+#if defined(_MSC_VER) && _MSC_VER < 1800 && !defined (MDE_CPU_EBC)
+  ///
+  /// Remove global variable from the linked image if there are no references to
+  /// it after all compiler and linker optimizations have been performed.
+  ///
+  ///
+  #define GLOBAL_REMOVE_IF_UNREFERENCED __declspec(selectany)
+#else
+  ///
+  /// Remove the global variable from the linked image if there are no references
+  ///  to it after all compiler and linker optimizations have been performed.
+  ///
+  ///
+  #define GLOBAL_REMOVE_IF_UNREFERENCED
+#endif
+
+//
+// Should be used in combination with NORETURN to avoid 'noreturn' returns
+// warnings.
+//
+#ifndef UNREACHABLE
+  #ifdef __GNUC__
+    ///
+    /// Signal compilers and analyzers that this call is not reachable.  It is
+    /// up to the compiler to remove any code past that point.
+    ///
+    #define UNREACHABLE()  __builtin_unreachable ()
+  #elif defined (__has_feature)
+    #if __has_builtin (__builtin_unreachable)
+      ///
+      /// Signal compilers and analyzers that this call is not reachable.  It is
+      /// up to the compiler to remove any code past that point.
+      ///
+      #define UNREACHABLE()  __builtin_unreachable ()
+    #endif
+  #endif
+
+  #ifndef UNREACHABLE
+    ///
+    /// Signal compilers and analyzers that this call is not reachable.  It is
+    /// up to the compiler to remove any code past that point.
+    ///
+    #define UNREACHABLE()
+  #endif
+#endif
+
+//
+// Signaling compilers and analyzers that a certain function cannot return may
+// remove all following code and thus lead to better optimization and less
+// false positives.
+//
+#ifndef NORETURN
+  #if defined (__GNUC__) || defined (__clang__)
+    ///
+    /// Signal compilers and analyzers that the function cannot return.
+    /// It is up to the compiler to remove any code past a call to functions
+    /// flagged with this attribute.
+    ///
+    #define NORETURN  __attribute__((noreturn))
+  #elif defined(_MSC_EXTENSIONS) && !defined(MDE_CPU_EBC)
+    ///
+    /// Signal compilers and analyzers that the function cannot return.
+    /// It is up to the compiler to remove any code past a call to functions
+    /// flagged with this attribute.
+    ///
+    #define NORETURN  __declspec(noreturn)
+  #else
+    ///
+    /// Signal compilers and analyzers that the function cannot return.
+    /// It is up to the compiler to remove any code past a call to functions
+    /// flagged with this attribute.
+    ///
+    #define NORETURN
+  #endif
+#endif
+
+//
+// Should be used in combination with ANALYZER_NORETURN to avoid 'noreturn'
+// returns warnings.
+//
+#ifndef ANALYZER_UNREACHABLE
+  #ifdef __clang_analyzer__
+    #if __has_builtin (__builtin_unreachable)
+      ///
+      /// Signal the analyzer that this call is not reachable.
+      /// This excludes compilers.
+      ///
+      #define ANALYZER_UNREACHABLE()  __builtin_unreachable ()
+    #endif
+  #endif
+
+  #ifndef ANALYZER_UNREACHABLE
+    ///
+    /// Signal the analyzer that this call is not reachable.
+    /// This excludes compilers.
+    ///
+    #define ANALYZER_UNREACHABLE()
+  #endif
+#endif
+
+//
+// Static Analyzers may issue errors about potential NULL-dereferences when
+// dereferencing a pointer, that has been checked before, outside of a
+// NULL-check.  This may lead to false positives, such as when using ASSERT()
+// for verification.
+//
+#ifndef ANALYZER_NORETURN
+  #ifdef __has_feature
+    #if __has_feature (attribute_analyzer_noreturn)
+      ///
+      /// Signal analyzers that the function cannot return.
+      /// This excludes compilers.
+      ///
+      #define ANALYZER_NORETURN  __attribute__((analyzer_noreturn))
+    #endif
+  #endif
+
+  #ifndef ANALYZER_NORETURN
+    ///
+    /// Signal the analyzer that the function cannot return.
+    /// This excludes compilers.
+    ///
+    #define ANALYZER_NORETURN
+  #endif
+#endif
+
+///
+/// Tell the code optimizer that the function will return twice.
+/// This prevents wrong optimizations which can cause bugs.
+///
+#ifndef RETURNS_TWICE
+  #if defined (__GNUC__) || defined (__clang__)
+    ///
+    /// Tell the code optimizer that the function will return twice.
+    /// This prevents wrong optimizations which can cause bugs.
+    ///
+    #define RETURNS_TWICE  __attribute__((returns_twice))
+  #else
+    ///
+    /// Tell the code optimizer that the function will return twice.
+    /// This prevents wrong optimizations which can cause bugs.
+    ///
+    #define RETURNS_TWICE
+  #endif
+#endif
+
+//
+// For symbol name in assembly code, an extra "_" is sometimes necessary
+//
+
+///
+/// Private worker functions for ASM_PFX()
+///
+#define _CONCATENATE(a, b)  __CONCATENATE(a, b)
+#define __CONCATENATE(a, b) a ## b
+
+///
+/// The __USER_LABEL_PREFIX__ macro predefined by GNUC represents the prefix
+/// on symbols in assembly language.
+///
+#define ASM_PFX(name) _CONCATENATE (__USER_LABEL_PREFIX__, name)
+
+#ifdef __APPLE__
+  //
+  // Apple extension that is used by the linker to optimize code size
+  // with assembly functions. Put at the end of your .S files
+  //
+  #define ASM_FUNCTION_REMOVE_IF_UNREFERENCED  .subsections_via_symbols
+#else
+  #define ASM_FUNCTION_REMOVE_IF_UNREFERENCED
+#endif
+
+#ifdef __CC_ARM
+  //
+  // Older RVCT ARM compilers don't fully support #pragma pack and require __packed
+  // as a prefix for the structure.
+  //
+  #define PACKED  __packed
+#else
+  #define PACKED
+#endif
+
+///
+/// 128 bit buffer containing a unique identifier value.
+/// Unless otherwise specified, aligned on a 64 bit boundary.
+///
+typedef struct {
+  UINT32  Data1;
+  UINT16  Data2;
+  UINT16  Data3;
+  UINT8   Data4[8];
+} GUID;
+
+///
+/// 4-byte buffer. An IPv4 internet protocol address.
+///
+typedef struct {
+  UINT8 Addr[4];
+} IPv4_ADDRESS;
+
+///
+/// 16-byte buffer. An IPv6 internet protocol address.
+///
+typedef struct {
+  UINT8 Addr[16];
+} IPv6_ADDRESS;
+
+//
+// 8-bytes unsigned value that represents a physical system address.
+//
+typedef UINT64 PHYSICAL_ADDRESS;
+
+///
+/// LIST_ENTRY structure definition.
+///
+typedef struct _LIST_ENTRY LIST_ENTRY;
+
+///
+/// _LIST_ENTRY structure definition.
+///
+//struct _LIST_ENTRY {
+//  LIST_ENTRY  *ForwardLink;
+//  LIST_ENTRY  *BackLink;
+//};
+
+//
+// Modifiers to abstract standard types to aid in debug of problems
+//
+
+///
+/// Datum is read-only.
+///
+#define CONST     const
+
+///
+/// Datum is scoped to the current file or function.
+///
+#define STATIC    static
+
+///
+/// Undeclared type.
+///
+#define VOID      void
+
+//
+// Modifiers for Data Types used to self document code.
+// This concept is borrowed for UEFI specification.
+//
+
+///
+/// Datum is passed to the function.
+///
+#define IN
+
+///
+/// Datum is returned from the function.
+///
+#define OUT
+
+///
+/// Passing the datum to the function is optional, and a NULL
+/// is passed if the value is not supplied.
+///
+#define OPTIONAL
+
+//
+//  UEFI specification claims 1 and 0. We are concerned about the
+//  compiler portability so we did it this way.
+//
+
+///
+/// Boolean true value.  UEFI Specification defines this value to be 1,
+/// but this form is more portable.
+///
+#define TRUE  ((BOOLEAN)(1==1))
+
+///
+/// Boolean false value.  UEFI Specification defines this value to be 0,
+/// but this form is more portable.
+///
+#define FALSE ((BOOLEAN)(0==1))
+
+///
+/// NULL pointer (VOID *)
+///
+#define NULL  ((VOID *) 0)
+
+//
+// Null character
+//
+#define CHAR_NULL             0x0000
+
+///
+/// Maximum values for common UEFI Data Types
+///
+#define MAX_INT8    ((INT8)0x7F)
+#define MAX_UINT8   ((UINT8)0xFF)
+#define MAX_INT16   ((INT16)0x7FFF)
+#define MAX_UINT16  ((UINT16)0xFFFF)
+#define MAX_INT32   ((INT32)0x7FFFFFFF)
+#define MAX_UINT32  ((UINT32)0xFFFFFFFF)
+#define MAX_INT64   ((INT64)0x7FFFFFFFFFFFFFFFULL)
+#define MAX_UINT64  ((UINT64)0xFFFFFFFFFFFFFFFFULL)
+
+///
+/// Minimum values for the signed UEFI Data Types
+///
+#define MIN_INT8   (((INT8)  -127) - 1)
+#define MIN_INT16  (((INT16) -32767) - 1)
+#define MIN_INT32  (((INT32) -2147483647) - 1)
+#define MIN_INT64  (((INT64) -9223372036854775807LL) - 1)
+
+#define  BIT0     0x00000001
+#define  BIT1     0x00000002
+#define  BIT2     0x00000004
+#define  BIT3     0x00000008
+#define  BIT4     0x00000010
+#define  BIT5     0x00000020
+#define  BIT6     0x00000040
+#define  BIT7     0x00000080
+#define  BIT8     0x00000100
+#define  BIT9     0x00000200
+#define  BIT10    0x00000400
+#define  BIT11    0x00000800
+#define  BIT12    0x00001000
+#define  BIT13    0x00002000
+#define  BIT14    0x00004000
+#define  BIT15    0x00008000
+#define  BIT16    0x00010000
+#define  BIT17    0x00020000
+#define  BIT18    0x00040000
+#define  BIT19    0x00080000
+#define  BIT20    0x00100000
+#define  BIT21    0x00200000
+#define  BIT22    0x00400000
+#define  BIT23    0x00800000
+#define  BIT24    0x01000000
+#define  BIT25    0x02000000
+#define  BIT26    0x04000000
+#define  BIT27    0x08000000
+#define  BIT28    0x10000000
+#define  BIT29    0x20000000
+#define  BIT30    0x40000000
+#define  BIT31    0x80000000
+#define  BIT32    0x0000000100000000ULL
+#define  BIT33    0x0000000200000000ULL
+#define  BIT34    0x0000000400000000ULL
+#define  BIT35    0x0000000800000000ULL
+#define  BIT36    0x0000001000000000ULL
+#define  BIT37    0x0000002000000000ULL
+#define  BIT38    0x0000004000000000ULL
+#define  BIT39    0x0000008000000000ULL
+#define  BIT40    0x0000010000000000ULL
+#define  BIT41    0x0000020000000000ULL
+#define  BIT42    0x0000040000000000ULL
+#define  BIT43    0x0000080000000000ULL
+#define  BIT44    0x0000100000000000ULL
+#define  BIT45    0x0000200000000000ULL
+#define  BIT46    0x0000400000000000ULL
+#define  BIT47    0x0000800000000000ULL
+#define  BIT48    0x0001000000000000ULL
+#define  BIT49    0x0002000000000000ULL
+#define  BIT50    0x0004000000000000ULL
+#define  BIT51    0x0008000000000000ULL
+#define  BIT52    0x0010000000000000ULL
+#define  BIT53    0x0020000000000000ULL
+#define  BIT54    0x0040000000000000ULL
+#define  BIT55    0x0080000000000000ULL
+#define  BIT56    0x0100000000000000ULL
+#define  BIT57    0x0200000000000000ULL
+#define  BIT58    0x0400000000000000ULL
+#define  BIT59    0x0800000000000000ULL
+#define  BIT60    0x1000000000000000ULL
+#define  BIT61    0x2000000000000000ULL
+#define  BIT62    0x4000000000000000ULL
+#define  BIT63    0x8000000000000000ULL
+
+#define  SIZE_1KB    0x00000400
+#define  SIZE_2KB    0x00000800
+#define  SIZE_4KB    0x00001000
+#define  SIZE_8KB    0x00002000
+#define  SIZE_16KB   0x00004000
+#define  SIZE_32KB   0x00008000
+#define  SIZE_64KB   0x00010000
+#define  SIZE_128KB  0x00020000
+#define  SIZE_256KB  0x00040000
+#define  SIZE_512KB  0x00080000
+#define  SIZE_1MB    0x00100000
+#define  SIZE_2MB    0x00200000
+#define  SIZE_4MB    0x00400000
+#define  SIZE_8MB    0x00800000
+#define  SIZE_16MB   0x01000000
+#define  SIZE_32MB   0x02000000
+#define  SIZE_64MB   0x04000000
+#define  SIZE_128MB  0x08000000
+#define  SIZE_256MB  0x10000000
+#define  SIZE_512MB  0x20000000
+#define  SIZE_1GB    0x40000000
+#define  SIZE_2GB    0x80000000
+#define  SIZE_4GB    0x0000000100000000ULL
+#define  SIZE_8GB    0x0000000200000000ULL
+#define  SIZE_16GB   0x0000000400000000ULL
+#define  SIZE_32GB   0x0000000800000000ULL
+#define  SIZE_64GB   0x0000001000000000ULL
+#define  SIZE_128GB  0x0000002000000000ULL
+#define  SIZE_256GB  0x0000004000000000ULL
+#define  SIZE_512GB  0x0000008000000000ULL
+#define  SIZE_1TB    0x0000010000000000ULL
+#define  SIZE_2TB    0x0000020000000000ULL
+#define  SIZE_4TB    0x0000040000000000ULL
+#define  SIZE_8TB    0x0000080000000000ULL
+#define  SIZE_16TB   0x0000100000000000ULL
+#define  SIZE_32TB   0x0000200000000000ULL
+#define  SIZE_64TB   0x0000400000000000ULL
+#define  SIZE_128TB  0x0000800000000000ULL
+#define  SIZE_256TB  0x0001000000000000ULL
+#define  SIZE_512TB  0x0002000000000000ULL
+#define  SIZE_1PB    0x0004000000000000ULL
+#define  SIZE_2PB    0x0008000000000000ULL
+#define  SIZE_4PB    0x0010000000000000ULL
+#define  SIZE_8PB    0x0020000000000000ULL
+#define  SIZE_16PB   0x0040000000000000ULL
+#define  SIZE_32PB   0x0080000000000000ULL
+#define  SIZE_64PB   0x0100000000000000ULL
+#define  SIZE_128PB  0x0200000000000000ULL
+#define  SIZE_256PB  0x0400000000000000ULL
+#define  SIZE_512PB  0x0800000000000000ULL
+#define  SIZE_1EB    0x1000000000000000ULL
+#define  SIZE_2EB    0x2000000000000000ULL
+#define  SIZE_4EB    0x4000000000000000ULL
+#define  SIZE_8EB    0x8000000000000000ULL
+
+#define  BASE_1KB    0x00000400
+#define  BASE_2KB    0x00000800
+#define  BASE_4KB    0x00001000
+#define  BASE_8KB    0x00002000
+#define  BASE_16KB   0x00004000
+#define  BASE_32KB   0x00008000
+#define  BASE_64KB   0x00010000
+#define  BASE_128KB  0x00020000
+#define  BASE_256KB  0x00040000
+#define  BASE_512KB  0x00080000
+#define  BASE_1MB    0x00100000
+#define  BASE_2MB    0x00200000
+#define  BASE_4MB    0x00400000
+#define  BASE_8MB    0x00800000
+#define  BASE_16MB   0x01000000
+#define  BASE_32MB   0x02000000
+#define  BASE_64MB   0x04000000
+#define  BASE_128MB  0x08000000
+#define  BASE_256MB  0x10000000
+#define  BASE_512MB  0x20000000
+#define  BASE_1GB    0x40000000
+#define  BASE_2GB    0x80000000
+#define  BASE_4GB    0x0000000100000000ULL
+#define  BASE_8GB    0x0000000200000000ULL
+#define  BASE_16GB   0x0000000400000000ULL
+#define  BASE_32GB   0x0000000800000000ULL
+#define  BASE_64GB   0x0000001000000000ULL
+#define  BASE_128GB  0x0000002000000000ULL
+#define  BASE_256GB  0x0000004000000000ULL
+#define  BASE_512GB  0x0000008000000000ULL
+#define  BASE_1TB    0x0000010000000000ULL
+#define  BASE_2TB    0x0000020000000000ULL
+#define  BASE_4TB    0x0000040000000000ULL
+#define  BASE_8TB    0x0000080000000000ULL
+#define  BASE_16TB   0x0000100000000000ULL
+#define  BASE_32TB   0x0000200000000000ULL
+#define  BASE_64TB   0x0000400000000000ULL
+#define  BASE_128TB  0x0000800000000000ULL
+#define  BASE_256TB  0x0001000000000000ULL
+#define  BASE_512TB  0x0002000000000000ULL
+#define  BASE_1PB    0x0004000000000000ULL
+#define  BASE_2PB    0x0008000000000000ULL
+#define  BASE_4PB    0x0010000000000000ULL
+#define  BASE_8PB    0x0020000000000000ULL
+#define  BASE_16PB   0x0040000000000000ULL
+#define  BASE_32PB   0x0080000000000000ULL
+#define  BASE_64PB   0x0100000000000000ULL
+#define  BASE_128PB  0x0200000000000000ULL
+#define  BASE_256PB  0x0400000000000000ULL
+#define  BASE_512PB  0x0800000000000000ULL
+#define  BASE_1EB    0x1000000000000000ULL
+#define  BASE_2EB    0x2000000000000000ULL
+#define  BASE_4EB    0x4000000000000000ULL
+#define  BASE_8EB    0x8000000000000000ULL
+
+//
+//  Support for variable argument lists in freestanding edk2 modules.
+//
+//  For modules that use the ISO C library interfaces for variable
+//  argument lists, refer to "StdLib/Include/stdarg.h".
+//
+//  VA_LIST  - typedef for argument list.
+//  VA_START (VA_LIST Marker, argument before the ...) - Init Marker for use.
+//  VA_END (VA_LIST Marker) - Clear Marker
+//  VA_ARG (VA_LIST Marker, var arg type) - Use Marker to get an argument from
+//    the ... list. You must know the type and pass it in this macro.  Type
+//    must be compatible with the type of the actual next argument (as promoted
+//    according to the default argument promotions.)
+//  VA_COPY (VA_LIST Dest, VA_LIST Start) - Initialize Dest as a copy of Start.
+//
+//  Example:
+//
+//  UINTN
+//  EFIAPI
+//  ExampleVarArg (
+//    IN UINTN  NumberOfArgs,
+//    ...
+//    )
+//  {
+//    VA_LIST Marker;
+//    UINTN   Index;
+//    UINTN   Result;
+//
+//    //
+//    // Initialize the Marker
+//    //
+//    VA_START (Marker, NumberOfArgs);
+//    for (Index = 0, Result = 0; Index < NumberOfArgs; Index++) {
+//      //
+//      // The ... list is a series of UINTN values, so sum them up.
+//      //
+//      Result += VA_ARG (Marker, UINTN);
+//    }
+//
+//    VA_END (Marker);
+//    return Result;
+//  }
+//
+//  Notes:
+//  - Functions that call VA_START() / VA_END() must have a variable
+//    argument list and must be declared EFIAPI.
+//  - Functions that call VA_COPY() / VA_END() must be declared EFIAPI.
+//  - Functions that only use VA_LIST and VA_ARG() need not be EFIAPI.
+//
+
+/**
+  Return the size of argument that has been aligned to sizeof (UINTN).
+
+  @param  n    The parameter size to be aligned.
+
+  @return The aligned size.
+**/
+#define _INT_SIZE_OF(n) ((sizeof (n) + sizeof (UINTN) - 1) &~(sizeof (UINTN) - 1))
+
+#if defined(__CC_ARM)
+//
+// RVCT ARM variable argument list support.
+//
+
+///
+/// Variable used to traverse the list of arguments. This type can vary by
+/// implementation and could be an array or structure.
+///
+#ifdef __APCS_ADSABI
+  typedef int         *va_list[1];
+  #define VA_LIST     va_list
+#else
+  typedef struct __va_list { void *__ap; } va_list;
+  #define VA_LIST                          va_list
+#endif
+
+#define VA_START(Marker, Parameter)   __va_start(Marker, Parameter)
+
+#define VA_ARG(Marker, TYPE)          __va_arg(Marker, TYPE)
+
+#define VA_END(Marker)                ((void)0)
+
+// For some ARM RVCT compilers, __va_copy is not defined
+#ifndef __va_copy
+  #define __va_copy(dest, src) ((void)((dest) = (src)))
+#endif
+
+#define VA_COPY(Dest, Start)          __va_copy (Dest, Start)
+
+#elif defined(_M_ARM) || defined(_M_ARM64)
+//
+// MSFT ARM variable argument list support.
+//
+
+typedef char* VA_LIST;
+
+#define VA_START(Marker, Parameter)     __va_start (&Marker, &Parameter, _INT_SIZE_OF (Parameter), __alignof(Parameter), &Parameter)
+#define VA_ARG(Marker, TYPE)            (*(TYPE *) ((Marker += _INT_SIZE_OF (TYPE) + ((-(INTN)Marker) & (sizeof(TYPE) - 1))) - _INT_SIZE_OF (TYPE)))
+#define VA_END(Marker)                  (Marker = (VA_LIST) 0)
+#define VA_COPY(Dest, Start)            ((void)((Dest) = (Start)))
+
+#elif defined(__GNUC__) || defined(__clang__)
+
+#if defined(MDE_CPU_X64) && !defined(NO_MSABI_VA_FUNCS)
+//
+// X64 only. Use MS ABI version of GCC built-in macros for variable argument lists.
+//
+///
+/// Both GCC and LLVM 3.8 for X64 support new variable argument intrinsics for Microsoft ABI
+///
+
+///
+/// Variable used to traverse the list of arguments. This type can vary by
+/// implementation and could be an array or structure.
+///
+typedef __builtin_ms_va_list VA_LIST;
+
+#define VA_START(Marker, Parameter)  __builtin_ms_va_start (Marker, Parameter)
+
+#define VA_ARG(Marker, TYPE)         ((sizeof (TYPE) < sizeof (UINTN)) ? (TYPE)(__builtin_va_arg (Marker, UINTN)) : (TYPE)(__builtin_va_arg (Marker, TYPE)))
+
+#define VA_END(Marker)               __builtin_ms_va_end (Marker)
+
+#define VA_COPY(Dest, Start)         __builtin_ms_va_copy (Dest, Start)
+
+#else
+//
+// Use GCC built-in macros for variable argument lists.
+//
+
+///
+/// Variable used to traverse the list of arguments. This type can vary by
+/// implementation and could be an array or structure.
+///
+typedef __builtin_va_list VA_LIST;
+
+#define VA_START(Marker, Parameter)  __builtin_va_start (Marker, Parameter)
+
+#define VA_ARG(Marker, TYPE)         ((sizeof (TYPE) < sizeof (UINTN)) ? (TYPE)(__builtin_va_arg (Marker, UINTN)) : (TYPE)(__builtin_va_arg (Marker, TYPE)))
+
+#define VA_END(Marker)               __builtin_va_end (Marker)
+
+#define VA_COPY(Dest, Start)         __builtin_va_copy (Dest, Start)
+
+#endif
+
+#else
+///
+/// Variable used to traverse the list of arguments. This type can vary by
+/// implementation and could be an array or structure.
+///
+typedef CHAR8 *VA_LIST;
+
+/**
+  Retrieves a pointer to the beginning of a variable argument list, based on
+  the name of the parameter that immediately precedes the variable argument list.
+
+  This function initializes Marker to point to the beginning of the variable
+  argument list that immediately follows Parameter.  The method for computing the
+  pointer to the next argument in the argument list is CPU-specific following the
+  EFIAPI ABI.
+
+  @param   Marker       The VA_LIST used to traverse the list of arguments.
+  @param   Parameter    The name of the parameter that immediately precedes
+                        the variable argument list.
+
+  @return  A pointer to the beginning of a variable argument list.
+
+**/
+#define VA_START(Marker, Parameter) (Marker = (VA_LIST) ((UINTN) & (Parameter) + _INT_SIZE_OF (Parameter)))
+
+/**
+  Returns an argument of a specified type from a variable argument list and updates
+  the pointer to the variable argument list to point to the next argument.
+
+  This function returns an argument of the type specified by TYPE from the beginning
+  of the variable argument list specified by Marker.  Marker is then updated to point
+  to the next argument in the variable argument list.  The method for computing the
+  pointer to the next argument in the argument list is CPU-specific following the EFIAPI ABI.
+
+  @param   Marker   VA_LIST used to traverse the list of arguments.
+  @param   TYPE     The type of argument to retrieve from the beginning
+                    of the variable argument list.
+
+  @return  An argument of the type specified by TYPE.
+
+**/
+#define VA_ARG(Marker, TYPE)   (*(TYPE *) ((Marker += _INT_SIZE_OF (TYPE)) - _INT_SIZE_OF (TYPE)))
+
+/**
+  Terminates the use of a variable argument list.
+
+  This function initializes Marker so it can no longer be used with VA_ARG().
+  After this macro is used, the only way to access the variable argument list is
+  by using VA_START() again.
+
+  @param   Marker   VA_LIST used to traverse the list of arguments.
+
+**/
+#define VA_END(Marker)      (Marker = (VA_LIST) 0)
+
+/**
+  Initializes a VA_LIST as a copy of an existing VA_LIST.
+
+  This macro initializes Dest as a copy of Start, as if the VA_START macro had been applied to Dest
+  followed by the same sequence of uses of the VA_ARG macro as had previously been used to reach
+  the present state of Start.
+
+  @param   Dest   VA_LIST used to traverse the list of arguments.
+  @param   Start  VA_LIST used to traverse the list of arguments.
+
+**/
+#define VA_COPY(Dest, Start)  ((void)((Dest) = (Start)))
+
+#endif
+
+///
+/// Pointer to the start of a variable argument list stored in a memory buffer. Same as UINT8 *.
+///
+typedef UINTN  *BASE_LIST;
+
+/**
+  Returns the size of a data type in sizeof(UINTN) units rounded up to the nearest UINTN boundary.
+
+  @param  TYPE  The date type to determine the size of.
+
+  @return The size of TYPE in sizeof (UINTN) units rounded up to the nearest UINTN boundary.
+**/
+#define _BASE_INT_SIZE_OF(TYPE) ((sizeof (TYPE) + sizeof (UINTN) - 1) / sizeof (UINTN))
+
+/**
+  Returns an argument of a specified type from a variable argument list and updates
+  the pointer to the variable argument list to point to the next argument.
+
+  This function returns an argument of the type specified by TYPE from the beginning
+  of the variable argument list specified by Marker.  Marker is then updated to point
+  to the next argument in the variable argument list.  The method for computing the
+  pointer to the next argument in the argument list is CPU specific following the EFIAPI ABI.
+
+  @param   Marker   The pointer to the beginning of a variable argument list.
+  @param   TYPE     The type of argument to retrieve from the beginning
+                    of the variable argument list.
+
+  @return  An argument of the type specified by TYPE.
+
+**/
+#define BASE_ARG(Marker, TYPE)   (*(TYPE *) ((Marker += _BASE_INT_SIZE_OF (TYPE)) - _BASE_INT_SIZE_OF (TYPE)))
+
+/**
+  The macro that returns the byte offset of a field in a data structure.
+
+  This function returns the offset, in bytes, of field specified by Field from the
+  beginning of the  data structure specified by TYPE. If TYPE does not contain Field,
+  the module will not compile.
+
+  @param   TYPE     The name of the data structure that contains the field specified by Field.
+  @param   Field    The name of the field in the data structure.
+
+  @return  Offset, in bytes, of field.
+
+**/
+#if (defined(__GNUC__) && __GNUC__ >= 4) || defined(__clang__)
+#define OFFSET_OF(TYPE, Field) ((UINTN) __builtin_offsetof(TYPE, Field))
+#endif
+
+#ifndef OFFSET_OF
+#define OFFSET_OF(TYPE, Field) ((UINTN) &(((TYPE *)0)->Field))
+#endif
+
+/**
+  Portable definition for compile time assertions.
+  Equivalent to C11 static_assert macro from assert.h.
+
+  @param  Expression  Boolean expression.
+  @param  Message     Raised compiler diagnostic message when expression is false.
+
+**/
+#ifdef MDE_CPU_EBC
+  #define STATIC_ASSERT(Expression, Message)
+#elif defined(_MSC_EXTENSIONS)
+  #define STATIC_ASSERT static_assert
+#else
+  #define STATIC_ASSERT _Static_assert
+#endif
+
+//
+// Verify that ProcessorBind.h produced UEFI Data Types that are compliant with
+// Section 2.3.1 of the UEFI 2.3 Specification.
+//
+
+STATIC_ASSERT (sizeof (BOOLEAN) == 1, "sizeof (BOOLEAN) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (INT8)    == 1, "sizeof (INT8) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (UINT8)   == 1, "sizeof (UINT8) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (INT16)   == 2, "sizeof (INT16) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (UINT16)  == 2, "sizeof (UINT16) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (INT32)   == 4, "sizeof (INT32) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (UINT32)  == 4, "sizeof (UINT32) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (INT64)   == 8, "sizeof (INT64) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (UINT64)  == 8, "sizeof (UINT64) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (CHAR8)   == 1, "sizeof (CHAR8) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (CHAR16)  == 2, "sizeof (CHAR16) does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (L'A')    == 2, "sizeof (L'A') does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (L"A")    == 4, "sizeof (L\"A\") does not meet UEFI Specification Data Type requirements");
+
+//
+// The following three enum types are used to verify that the compiler
+// configuration for enum types is compliant with Section 2.3.1 of the
+// UEFI 2.3 Specification. These enum types and enum values are not
+// intended to be used. A prefix of '__' is used avoid conflicts with
+// other types.
+//
+typedef enum {
+  __VerifyUint8EnumValue = 0xff
+} __VERIFY_UINT8_ENUM_SIZE;
+
+typedef enum {
+  __VerifyUint16EnumValue = 0xffff
+} __VERIFY_UINT16_ENUM_SIZE;
+
+typedef enum {
+  __VerifyUint32EnumValue = 0xffffffff
+} __VERIFY_UINT32_ENUM_SIZE;
+
+STATIC_ASSERT (sizeof (__VERIFY_UINT8_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (__VERIFY_UINT16_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
+STATIC_ASSERT (sizeof (__VERIFY_UINT32_ENUM_SIZE) == 4, "Size of enum does not meet UEFI Specification Data Type requirements");
+
+/**
+  Macro that returns a pointer to the data structure that contains a specified field of
+  that data structure.  This is a lightweight method to hide information by placing a
+  public data structure inside a larger private data structure and using a pointer to
+  the public data structure to retrieve a pointer to the private data structure.
+
+  This function computes the offset, in bytes, of field specified by Field from the beginning
+  of the  data structure specified by TYPE.  This offset is subtracted from Record, and is
+  used to return a pointer to a data structure of the type specified by TYPE. If the data type
+  specified by TYPE does not contain the field specified by Field, then the module will not compile.
+
+  @param   Record   Pointer to the field specified by Field within a data structure of type TYPE.
+  @param   TYPE     The name of the data structure type to return.  This data structure must
+                    contain the field specified by Field.
+  @param   Field    The name of the field in the data structure specified by TYPE to which Record points.
+
+  @return  A pointer to the structure from one of it's elements.
+
+**/
+#define BASE_CR(Record, TYPE, Field)  ((TYPE *) ((CHAR8 *) (Record) - OFFSET_OF (TYPE, Field)))
+
+/**
+  Rounds a value up to the next boundary using a specified alignment.
+
+  This function rounds Value up to the next boundary using the specified Alignment.
+  This aligned value is returned.
+
+  @param   Value      The value to round up.
+  @param   Alignment  The alignment boundary used to return the aligned value.
+
+  @return  A value up to the next boundary.
+
+**/
+#define ALIGN_VALUE(Value, Alignment) ((Value) + (((Alignment) - (Value)) & ((Alignment) - 1)))
+
+/**
+  Adjust a pointer by adding the minimum offset required for it to be aligned on
+  a specified alignment boundary.
+
+  This function rounds the pointer specified by Pointer to the next alignment boundary
+  specified by Alignment. The pointer to the aligned address is returned.
+
+  @param   Pointer    The pointer to round up.
+  @param   Alignment  The alignment boundary to use to return an aligned pointer.
+
+  @return  Pointer to the aligned address.
+
+**/
+#define ALIGN_POINTER(Pointer, Alignment) ((VOID *) (ALIGN_VALUE ((UINTN)(Pointer), (Alignment))))
+
+/**
+  Rounds a value up to the next natural boundary for the current CPU.
+  This is 4-bytes for 32-bit CPUs and 8-bytes for 64-bit CPUs.
+
+  This function rounds the value specified by Value up to the next natural boundary for the
+  current CPU. This rounded value is returned.
+
+  @param   Value      The value to round up.
+
+  @return  Rounded value specified by Value.
+
+**/
+#define ALIGN_VARIABLE(Value)  ALIGN_VALUE ((Value), sizeof (UINTN))
+
+
+/**
+  Return the maximum of two operands.
+
+  This macro returns the maximum of two operand specified by a and b.
+  Both a and b must be the same numerical types, signed or unsigned.
+
+  @param   a        The first operand with any numerical type.
+  @param   b        The second operand. Can be any numerical type as long as is
+                    the same type as a.
+
+  @return  Maximum of two operands.
+
+**/
+#define MAX(a, b)                       \
+  (((a) > (b)) ? (a) : (b))
+
+/**
+  Return the minimum of two operands.
+
+  This macro returns the minimal of two operand specified by a and b.
+  Both a and b must be the same numerical types, signed or unsigned.
+
+  @param   a        The first operand with any numerical type.
+  @param   b        The second operand. It should be the same any numerical type with a.
+
+  @return  Minimum of two operands.
+
+**/
+#define MIN(a, b)                       \
+  (((a) < (b)) ? (a) : (b))
+
+/**
+  Return the absolute value of a signed operand.
+
+  This macro returns the absolute value of the signed operand specified by a.
+
+  @param   a        The signed operand.
+
+  @return  The absolute value of the signed operand.
+
+**/
+#define ABS(a)                          \
+  (((a) < 0) ? (-(a)) : (a))
+
+//
+// Status codes common to all execution phases
+//
+typedef UINTN RETURN_STATUS;
+
+/**
+  Produces a RETURN_STATUS code with the highest bit set.
+
+  @param  StatusCode    The status code value to convert into a warning code.
+                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.
+
+  @return The value specified by StatusCode with the highest bit set.
+
+**/
+#define ENCODE_ERROR(StatusCode)     ((RETURN_STATUS)(MAX_BIT | (StatusCode)))
+
+/**
+  Produces a RETURN_STATUS code with the highest bit clear.
+
+  @param  StatusCode    The status code value to convert into a warning code.
+                        StatusCode must be in the range 0x00000000..0x7FFFFFFF.
+
+  @return The value specified by StatusCode with the highest bit clear.
+
+**/
+#define ENCODE_WARNING(StatusCode)   ((RETURN_STATUS)(StatusCode))
+
+/**
+  Returns TRUE if a specified RETURN_STATUS code is an error code.
+
+  This function returns TRUE if StatusCode has the high bit set.  Otherwise, FALSE is returned.
+
+  @param  StatusCode    The status code value to evaluate.
+
+  @retval TRUE          The high bit of StatusCode is set.
+  @retval FALSE         The high bit of StatusCode is clear.
+
+**/
+#define RETURN_ERROR(StatusCode)     (((INTN)(RETURN_STATUS)(StatusCode)) < 0)
+
+///
+/// The operation completed successfully.
+///
+#define RETURN_SUCCESS               0
+
+///
+/// The image failed to load.
+///
+#define RETURN_LOAD_ERROR            ENCODE_ERROR (1)
+
+///
+/// The parameter was incorrect.
+///
+#define RETURN_INVALID_PARAMETER     ENCODE_ERROR (2)
+
+///
+/// The operation is not supported.
+///
+#define RETURN_UNSUPPORTED           ENCODE_ERROR (3)
+
+///
+/// The buffer was not the proper size for the request.
+///
+#define RETURN_BAD_BUFFER_SIZE       ENCODE_ERROR (4)
+
+///
+/// The buffer was not large enough to hold the requested data.
+/// The required buffer size is returned in the appropriate
+/// parameter when this error occurs.
+///
+#define RETURN_BUFFER_TOO_SMALL      ENCODE_ERROR (5)
+
+///
+/// There is no data pending upon return.
+///
+#define RETURN_NOT_READY             ENCODE_ERROR (6)
+
+///
+/// The physical device reported an error while attempting the
+/// operation.
+///
+#define RETURN_DEVICE_ERROR          ENCODE_ERROR (7)
+
+///
+/// The device can not be written to.
+///
+#define RETURN_WRITE_PROTECTED       ENCODE_ERROR (8)
+
+///
+/// The resource has run out.
+///
+#define RETURN_OUT_OF_RESOURCES      ENCODE_ERROR (9)
+
+///
+/// An inconsistency was detected on the file system causing the
+/// operation to fail.
+///
+#define RETURN_VOLUME_CORRUPTED      ENCODE_ERROR (10)
+
+///
+/// There is no more space on the file system.
+///
+#define RETURN_VOLUME_FULL           ENCODE_ERROR (11)
+
+///
+/// The device does not contain any medium to perform the
+/// operation.
+///
+#define RETURN_NO_MEDIA              ENCODE_ERROR (12)
+
+///
+/// The medium in the device has changed since the last
+/// access.
+///
+#define RETURN_MEDIA_CHANGED         ENCODE_ERROR (13)
+
+///
+/// The item was not found.
+///
+#define RETURN_NOT_FOUND             ENCODE_ERROR (14)
+
+///
+/// Access was denied.
+///
+#define RETURN_ACCESS_DENIED         ENCODE_ERROR (15)
+
+///
+/// The server was not found or did not respond to the request.
+///
+#define RETURN_NO_RESPONSE           ENCODE_ERROR (16)
+
+///
+/// A mapping to the device does not exist.
+///
+#define RETURN_NO_MAPPING            ENCODE_ERROR (17)
+
+///
+/// A timeout time expired.
+///
+#define RETURN_TIMEOUT               ENCODE_ERROR (18)
+
+///
+/// The protocol has not been started.
+///
+#define RETURN_NOT_STARTED           ENCODE_ERROR (19)
+
+///
+/// The protocol has already been started.
+///
+#define RETURN_ALREADY_STARTED       ENCODE_ERROR (20)
+
+///
+/// The operation was aborted.
+///
+#define RETURN_ABORTED               ENCODE_ERROR (21)
+
+///
+/// An ICMP error occurred during the network operation.
+///
+#define RETURN_ICMP_ERROR            ENCODE_ERROR (22)
+
+///
+/// A TFTP error occurred during the network operation.
+///
+#define RETURN_TFTP_ERROR            ENCODE_ERROR (23)
+
+///
+/// A protocol error occurred during the network operation.
+///
+#define RETURN_PROTOCOL_ERROR        ENCODE_ERROR (24)
+
+///
+/// A function encountered an internal version that was
+/// incompatible with a version requested by the caller.
+///
+#define RETURN_INCOMPATIBLE_VERSION  ENCODE_ERROR (25)
+
+///
+/// The function was not performed due to a security violation.
+///
+#define RETURN_SECURITY_VIOLATION    ENCODE_ERROR (26)
+
+///
+/// A CRC error was detected.
+///
+#define RETURN_CRC_ERROR             ENCODE_ERROR (27)
+
+///
+/// The beginning or end of media was reached.
+///
+#define RETURN_END_OF_MEDIA          ENCODE_ERROR (28)
+
+///
+/// The end of the file was reached.
+///
+#define RETURN_END_OF_FILE           ENCODE_ERROR (31)
+
+///
+/// The language specified was invalid.
+///
+#define RETURN_INVALID_LANGUAGE      ENCODE_ERROR (32)
+
+///
+/// The security status of the data is unknown or compromised
+/// and the data must be updated or replaced to restore a valid
+/// security status.
+///
+#define RETURN_COMPROMISED_DATA      ENCODE_ERROR (33)
+
+///
+/// A HTTP error occurred during the network operation.
+///
+#define RETURN_HTTP_ERROR            ENCODE_ERROR (35)
+
+///
+/// The string contained one or more characters that
+/// the device could not render and were skipped.
+///
+#define RETURN_WARN_UNKNOWN_GLYPH    ENCODE_WARNING (1)
+
+///
+/// The handle was closed, but the file was not deleted.
+///
+#define RETURN_WARN_DELETE_FAILURE   ENCODE_WARNING (2)
+
+///
+/// The handle was closed, but the data to the file was not
+/// flushed properly.
+///
+#define RETURN_WARN_WRITE_FAILURE    ENCODE_WARNING (3)
+
+///
+/// The resulting buffer was too small, and the data was
+/// truncated to the buffer size.
+///
+#define RETURN_WARN_BUFFER_TOO_SMALL ENCODE_WARNING (4)
+
+///
+/// The data has not been updated within the timeframe set by
+/// local policy for this type of data.
+///
+#define RETURN_WARN_STALE_DATA       ENCODE_WARNING (5)
+
+///
+/// The resulting buffer contains UEFI-compliant file system.
+///
+#define RETURN_WARN_FILE_SYSTEM      ENCODE_WARNING (6)
+
+
+/**
+  Returns a 16-bit signature built from 2 ASCII characters.
+
+  This macro returns a 16-bit value built from the two ASCII characters specified
+  by A and B.
+
+  @param  A    The first ASCII character.
+  @param  B    The second ASCII character.
+
+  @return A 16-bit value built from the two ASCII characters specified by A and B.
+
+**/
+#define SIGNATURE_16(A, B)        ((A) | (B << 8))
+
+/**
+  Returns a 32-bit signature built from 4 ASCII characters.
+
+  This macro returns a 32-bit value built from the four ASCII characters specified
+  by A, B, C, and D.
+
+  @param  A    The first ASCII character.
+  @param  B    The second ASCII character.
+  @param  C    The third ASCII character.
+  @param  D    The fourth ASCII character.
+
+  @return A 32-bit value built from the two ASCII characters specified by A, B,
+          C and D.
+
+**/
+#define SIGNATURE_32(A, B, C, D)  (SIGNATURE_16 (A, B) | (SIGNATURE_16 (C, D) << 16))
+
+/**
+  Returns a 64-bit signature built from 8 ASCII characters.
+
+  This macro returns a 64-bit value built from the eight ASCII characters specified
+  by A, B, C, D, E, F, G,and H.
+
+  @param  A    The first ASCII character.
+  @param  B    The second ASCII character.
+  @param  C    The third ASCII character.
+  @param  D    The fourth ASCII character.
+  @param  E    The fifth ASCII character.
+  @param  F    The sixth ASCII character.
+  @param  G    The seventh ASCII character.
+  @param  H    The eighth ASCII character.
+
+  @return A 64-bit value built from the two ASCII characters specified by A, B,
+          C, D, E, F, G and H.
+
+**/
+#define SIGNATURE_64(A, B, C, D, E, F, G, H) \
+    (SIGNATURE_32 (A, B, C, D) | ((UINT64) (SIGNATURE_32 (E, F, G, H)) << 32))
+
+#if defined(_MSC_EXTENSIONS) && !defined (__INTEL_COMPILER) && !defined (MDE_CPU_EBC)
+  void * _ReturnAddress(void);
+  #pragma intrinsic(_ReturnAddress)
+  /**
+    Get the return address of the calling function.
+
+    Based on intrinsic function _ReturnAddress that provides the address of
+    the instruction in the calling function that will be executed after
+    control returns to the caller.
+
+    @param L    Return Level.
+
+    @return The return address of the calling function or 0 if L != 0.
+
+  **/
+  #define RETURN_ADDRESS(L)     ((L == 0) ? _ReturnAddress() : (VOID *) 0)
+#elif defined (__GNUC__) || defined (__clang__)
+  /**
+    Get the return address of the calling function.
+
+    Based on built-in Function __builtin_return_address that returns
+    the return address of the current function, or of one of its callers.
+
+    @param L    Return Level.
+
+    @return The return address of the calling function.
+
+  **/
+  #define RETURN_ADDRESS(L)     __builtin_return_address (L)
+#else
+  /**
+    Get the return address of the calling function.
+
+    @param L    Return Level.
+
+    @return 0 as compilers don't support this feature.
+
+  **/
+  #define RETURN_ADDRESS(L)     ((VOID *) 0)
+#endif
+
+/**
+  Return the number of elements in an array.
+
+  @param  Array  An object of array type. Array is only used as an argument to
+                 the sizeof operator, therefore Array is never evaluated. The
+                 caller is responsible for ensuring that Array's type is not
+                 incomplete; that is, Array must have known constant size.
+
+  @return The number of elements in Array. The result has type UINTN.
+
+**/
+#define ARRAY_SIZE(Array) (sizeof (Array) / sizeof ((Array)[0]))
+#define ASSERT(Expression)    do { if (!(Expression)) for (;;); } while (FALSE)
+#endif
diff --git a/libedk2_tpm/include/BaseIoLibIntrinsicInternal.h b/libedk2_tpm/include/BaseIoLibIntrinsicInternal.h
new file mode 100644
index 0000000..0c3f298
--- /dev/null
+++ b/libedk2_tpm/include/BaseIoLibIntrinsicInternal.h
@@ -0,0 +1,21 @@
+/** @file
+  Common header file shared by all source files.
+
+  This file includes package header files, dependent library classes.
+
+  Copyright (c) 2007 - 2021, Intel Corporation. All rights reserved.<BR>
+   SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef __BASEIOLIB_INTRINSIC_INTERNAL_H_
+#define __BASEIOLIB_INTRINSIC_INTERNAL_H_
+
+
+
+#include <Base.h>
+
+#include <IoLib.h>
+#include <BaseLib.h>
+#include <RegisterFilterLib.h>
+
+#endif
diff --git a/libedk2_tpm/include/BaseLib.h b/libedk2_tpm/include/BaseLib.h
new file mode 100755
index 0000000..9eb6ff9
--- /dev/null
+++ b/libedk2_tpm/include/BaseLib.h
@@ -0,0 +1,7656 @@
+/** @file
+  Provides string functions, linked list functions, math functions, synchronization
+  functions, file path functions, and CPU architecture-specific functions.
+
+Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
+Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
+Copyright (c) Microsoft Corporation.<BR>
+Portions Copyright (c) 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
+
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __BASE_LIB__
+#define __BASE_LIB__
+
+//
+// Definitions for architecture-specific types
+//
+#if   defined (MDE_CPU_IA32)
+///
+/// The IA-32 architecture context buffer used by SetJump() and LongJump().
+///
+typedef struct {
+  UINT32                            Ebx;
+  UINT32                            Esi;
+  UINT32                            Edi;
+  UINT32                            Ebp;
+  UINT32                            Esp;
+  UINT32                            Eip;
+  UINT32                            Ssp;
+} BASE_LIBRARY_JUMP_BUFFER;
+
+#define BASE_LIBRARY_JUMP_BUFFER_ALIGNMENT 4
+
+#endif // defined (MDE_CPU_IA32)
+
+#if defined (MDE_CPU_X64)
+///
+/// The x64 architecture context buffer used by SetJump() and LongJump().
+///
+typedef struct {
+  UINT64                            Rbx;
+  UINT64                            Rsp;
+  UINT64                            Rbp;
+  UINT64                            Rdi;
+  UINT64                            Rsi;
+  UINT64                            R12;
+  UINT64                            R13;
+  UINT64                            R14;
+  UINT64                            R15;
+  UINT64                            Rip;
+  UINT64                            MxCsr;
+  UINT8                             XmmBuffer[160]; ///< XMM6-XMM15.
+  UINT64                            Ssp;
+} BASE_LIBRARY_JUMP_BUFFER;
+
+#define BASE_LIBRARY_JUMP_BUFFER_ALIGNMENT 8
+
+#endif // defined (MDE_CPU_X64)
+
+#if defined (MDE_CPU_EBC)
+///
+/// The EBC context buffer used by SetJump() and LongJump().
+///
+typedef struct {
+  UINT64                            R0;
+  UINT64                            R1;
+  UINT64                            R2;
+  UINT64                            R3;
+  UINT64                            IP;
+} BASE_LIBRARY_JUMP_BUFFER;
+
+#define BASE_LIBRARY_JUMP_BUFFER_ALIGNMENT 8
+
+#endif // defined (MDE_CPU_EBC)
+
+#if defined (MDE_CPU_ARM)
+
+typedef struct {
+  UINT32    R3;  ///< A copy of R13.
+  UINT32    R4;
+  UINT32    R5;
+  UINT32    R6;
+  UINT32    R7;
+  UINT32    R8;
+  UINT32    R9;
+  UINT32    R10;
+  UINT32    R11;
+  UINT32    R12;
+  UINT32    R14;
+} BASE_LIBRARY_JUMP_BUFFER;
+
+#define BASE_LIBRARY_JUMP_BUFFER_ALIGNMENT 4
+
+#endif  // defined (MDE_CPU_ARM)
+
+#if defined (MDE_CPU_AARCH64)
+typedef struct {
+  // GP regs
+  UINT64    X19;
+  UINT64    X20;
+  UINT64    X21;
+  UINT64    X22;
+  UINT64    X23;
+  UINT64    X24;
+  UINT64    X25;
+  UINT64    X26;
+  UINT64    X27;
+  UINT64    X28;
+  UINT64    FP;
+  UINT64    LR;
+  UINT64    IP0;
+
+  // FP regs
+  UINT64    D8;
+  UINT64    D9;
+  UINT64    D10;
+  UINT64    D11;
+  UINT64    D12;
+  UINT64    D13;
+  UINT64    D14;
+  UINT64    D15;
+} BASE_LIBRARY_JUMP_BUFFER;
+
+#define BASE_LIBRARY_JUMP_BUFFER_ALIGNMENT 8
+
+#endif  // defined (MDE_CPU_AARCH64)
+
+#if defined (MDE_CPU_RISCV64)
+///
+/// The RISC-V architecture context buffer used by SetJump() and LongJump().
+///
+typedef struct {
+  UINT64                            RA;
+  UINT64                            S0;
+  UINT64                            S1;
+  UINT64                            S2;
+  UINT64                            S3;
+  UINT64                            S4;
+  UINT64                            S5;
+  UINT64                            S6;
+  UINT64                            S7;
+  UINT64                            S8;
+  UINT64                            S9;
+  UINT64                            S10;
+  UINT64                            S11;
+  UINT64                            SP;
+} BASE_LIBRARY_JUMP_BUFFER;
+
+#define BASE_LIBRARY_JUMP_BUFFER_ALIGNMENT 8
+
+#endif // defined (MDE_CPU_RISCV64)
+
+//
+// String Services
+//
+
+
+/**
+  Returns the length of a Null-terminated Unicode string.
+
+  This function is similar as strlen_s defined in C11.
+
+  If String is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  String   A pointer to a Null-terminated Unicode string.
+  @param  MaxSize  The maximum number of Destination Unicode
+                   char, including terminating null char.
+
+  @retval 0        If String is NULL.
+  @retval MaxSize  If there is no null character in the first MaxSize characters of String.
+  @return The number of characters that percede the terminating null character.
+
+**/
+UINTN
+EFIAPI
+StrnLenS (
+  IN CONST CHAR16              *String,
+  IN UINTN                     MaxSize
+  );
+
+/**
+  Returns the size of a Null-terminated Unicode string in bytes, including the
+  Null terminator.
+
+  This function returns the size of the Null-terminated Unicode string
+  specified by String in bytes, including the Null terminator.
+
+  If String is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  String   A pointer to a Null-terminated Unicode string.
+  @param  MaxSize  The maximum number of Destination Unicode
+                   char, including the Null terminator.
+
+  @retval 0  If String is NULL.
+  @retval (sizeof (CHAR16) * (MaxSize + 1))
+             If there is no Null terminator in the first MaxSize characters of
+             String.
+  @return The size of the Null-terminated Unicode string in bytes, including
+          the Null terminator.
+
+**/
+UINTN
+EFIAPI
+StrnSizeS (
+  IN CONST CHAR16              *String,
+  IN UINTN                     MaxSize
+  );
+
+/**
+  Copies the string pointed to by Source (including the terminating null char)
+  to the array pointed to by Destination.
+
+  This function is similar as strcpy_s defined in C11.
+
+  If Destination is not aligned on a 16-bit boundary, then ASSERT().
+  If Source is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Unicode string.
+  @param  DestMax                  The maximum number of Destination Unicode
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Unicode string.
+
+  @retval RETURN_SUCCESS           String is copied.
+  @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumUnicodeStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+StrCpyS (
+  OUT CHAR16       *Destination,
+  IN  UINTN        DestMax,
+  IN  CONST CHAR16 *Source
+  );
+
+/**
+  Copies not more than Length successive char from the string pointed to by
+  Source to the array pointed to by Destination. If no null char is copied from
+  Source, then Destination[Length] is always set to null.
+
+  This function is similar as strncpy_s defined in C11.
+
+  If Length > 0 and Destination is not aligned on a 16-bit boundary, then ASSERT().
+  If Length > 0 and Source is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Unicode string.
+  @param  DestMax                  The maximum number of Destination Unicode
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Unicode string.
+  @param  Length                   The maximum number of Unicode characters to copy.
+
+  @retval RETURN_SUCCESS           String is copied.
+  @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than
+                                   MIN(StrLen(Source), Length).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumUnicodeStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+StrnCpyS (
+  OUT CHAR16       *Destination,
+  IN  UINTN        DestMax,
+  IN  CONST CHAR16 *Source,
+  IN  UINTN        Length
+  );
+
+/**
+  Appends a copy of the string pointed to by Source (including the terminating
+  null char) to the end of the string pointed to by Destination.
+
+  This function is similar as strcat_s defined in C11.
+
+  If Destination is not aligned on a 16-bit boundary, then ASSERT().
+  If Source is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Unicode string.
+  @param  DestMax                  The maximum number of Destination Unicode
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Unicode string.
+
+  @retval RETURN_SUCCESS           String is appended.
+  @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than
+                                   StrLen(Destination).
+  @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT
+                                   greater than StrLen(Source).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumUnicodeStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+StrCatS (
+  IN OUT CHAR16       *Destination,
+  IN     UINTN        DestMax,
+  IN     CONST CHAR16 *Source
+  );
+
+/**
+  Appends not more than Length successive char from the string pointed to by
+  Source to the end of the string pointed to by Destination. If no null char is
+  copied from Source, then Destination[StrLen(Destination) + Length] is always
+  set to null.
+
+  This function is similar as strncat_s defined in C11.
+
+  If Destination is not aligned on a 16-bit boundary, then ASSERT().
+  If Source is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Unicode string.
+  @param  DestMax                  The maximum number of Destination Unicode
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Unicode string.
+  @param  Length                   The maximum number of Unicode characters to copy.
+
+  @retval RETURN_SUCCESS           String is appended.
+  @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than
+                                   StrLen(Destination).
+  @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT
+                                   greater than MIN(StrLen(Source), Length).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumUnicodeStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+StrnCatS (
+  IN OUT CHAR16       *Destination,
+  IN     UINTN        DestMax,
+  IN     CONST CHAR16 *Source,
+  IN     UINTN        Length
+  );
+
+/**
+  Convert a Null-terminated Unicode decimal string to a value of type UINTN.
+
+  This function outputs a value of type UINTN by interpreting the contents of
+  the Unicode string specified by String as a decimal number. The format of the
+  input Unicode string String is:
+
+                  [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The function will
+  ignore the pad space, which includes spaces or tab characters, before
+  [decimal digits]. The running zero in the beginning of [decimal digits] will
+  be ignored. Then, the function stops at the first character that is a not a
+  valid decimal character or a Null-terminator, whichever one comes first.
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  If String has no valid decimal digits in the above format, then 0 is stored
+  at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINTN, then
+  MAX_UINTN is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  decimal digits right after the optional pad spaces, the value of String is
+  stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumUnicodeStringLength is not
+                                   zero, and String contains more than
+                                   PcdMaximumUnicodeStringLength Unicode
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINTN.
+
+**/
+RETURN_STATUS
+EFIAPI
+StrDecimalToUintnS (
+  IN  CONST CHAR16             *String,
+  OUT       CHAR16             **EndPointer,  OPTIONAL
+  OUT       UINTN              *Data
+  );
+
+/**
+  Convert a Null-terminated Unicode decimal string to a value of type UINT64.
+
+  This function outputs a value of type UINT64 by interpreting the contents of
+  the Unicode string specified by String as a decimal number. The format of the
+  input Unicode string String is:
+
+                  [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The function will
+  ignore the pad space, which includes spaces or tab characters, before
+  [decimal digits]. The running zero in the beginning of [decimal digits] will
+  be ignored. Then, the function stops at the first character that is a not a
+  valid decimal character or a Null-terminator, whichever one comes first.
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  If String has no valid decimal digits in the above format, then 0 is stored
+  at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINT64, then
+  MAX_UINT64 is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  decimal digits right after the optional pad spaces, the value of String is
+  stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumUnicodeStringLength is not
+                                   zero, and String contains more than
+                                   PcdMaximumUnicodeStringLength Unicode
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINT64.
+
+**/
+RETURN_STATUS
+EFIAPI
+StrDecimalToUint64S (
+  IN  CONST CHAR16             *String,
+  OUT       CHAR16             **EndPointer,  OPTIONAL
+  OUT       UINT64             *Data
+  );
+
+/**
+  Convert a Null-terminated Unicode hexadecimal string to a value of type
+  UINTN.
+
+  This function outputs a value of type UINTN by interpreting the contents of
+  the Unicode string specified by String as a hexadecimal number. The format of
+  the input Unicode string String is:
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix.
+  If "x" appears in the input string, it must be prefixed with at least one 0.
+  The function will ignore the pad space, which includes spaces or tab
+  characters, before [zeros], [x] or [hexadecimal digit]. The running zero
+  before [x] or [hexadecimal digit] will be ignored. Then, the decoding starts
+  after [x] or the first valid hexadecimal digit. Then, the function stops at
+  the first character that is a not a valid hexadecimal character or NULL,
+  whichever one comes first.
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  If String has no valid hexadecimal digits in the above format, then 0 is
+  stored at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINTN, then
+  MAX_UINTN is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  hexadecimal digits right after the optional pad spaces, the value of String
+  is stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumUnicodeStringLength is not
+                                   zero, and String contains more than
+                                   PcdMaximumUnicodeStringLength Unicode
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINTN.
+
+**/
+RETURN_STATUS
+EFIAPI
+StrHexToUintnS (
+  IN  CONST CHAR16             *String,
+  OUT       CHAR16             **EndPointer,  OPTIONAL
+  OUT       UINTN              *Data
+  );
+
+/**
+  Convert a Null-terminated Unicode hexadecimal string to a value of type
+  UINT64.
+
+  This function outputs a value of type UINT64 by interpreting the contents of
+  the Unicode string specified by String as a hexadecimal number. The format of
+  the input Unicode string String is:
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix.
+  If "x" appears in the input string, it must be prefixed with at least one 0.
+  The function will ignore the pad space, which includes spaces or tab
+  characters, before [zeros], [x] or [hexadecimal digit]. The running zero
+  before [x] or [hexadecimal digit] will be ignored. Then, the decoding starts
+  after [x] or the first valid hexadecimal digit. Then, the function stops at
+  the first character that is a not a valid hexadecimal character or NULL,
+  whichever one comes first.
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  If String has no valid hexadecimal digits in the above format, then 0 is
+  stored at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINT64, then
+  MAX_UINT64 is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  hexadecimal digits right after the optional pad spaces, the value of String
+  is stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumUnicodeStringLength is not
+                                   zero, and String contains more than
+                                   PcdMaximumUnicodeStringLength Unicode
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINT64.
+
+**/
+RETURN_STATUS
+EFIAPI
+StrHexToUint64S (
+  IN  CONST CHAR16             *String,
+  OUT       CHAR16             **EndPointer,  OPTIONAL
+  OUT       UINT64             *Data
+  );
+
+/**
+  Returns the length of a Null-terminated Ascii string.
+
+  This function is similar as strlen_s defined in C11.
+
+  @param  String   A pointer to a Null-terminated Ascii string.
+  @param  MaxSize  The maximum number of Destination Ascii
+                   char, including terminating null char.
+
+  @retval 0        If String is NULL.
+  @retval MaxSize  If there is no null character in the first MaxSize characters of String.
+  @return The number of characters that percede the terminating null character.
+
+**/
+UINTN
+EFIAPI
+AsciiStrnLenS (
+  IN CONST CHAR8               *String,
+  IN UINTN                     MaxSize
+  );
+
+/**
+  Returns the size of a Null-terminated Ascii string in bytes, including the
+  Null terminator.
+
+  This function returns the size of the Null-terminated Ascii string specified
+  by String in bytes, including the Null terminator.
+
+  @param  String   A pointer to a Null-terminated Ascii string.
+  @param  MaxSize  The maximum number of Destination Ascii
+                   char, including the Null terminator.
+
+  @retval 0  If String is NULL.
+  @retval (sizeof (CHAR8) * (MaxSize + 1))
+             If there is no Null terminator in the first MaxSize characters of
+             String.
+  @return The size of the Null-terminated Ascii string in bytes, including the
+          Null terminator.
+
+**/
+UINTN
+EFIAPI
+AsciiStrnSizeS (
+  IN CONST CHAR8               *String,
+  IN UINTN                     MaxSize
+  );
+
+/**
+  Copies the string pointed to by Source (including the terminating null char)
+  to the array pointed to by Destination.
+
+  This function is similar as strcpy_s defined in C11.
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Ascii string.
+  @param  DestMax                  The maximum number of Destination Ascii
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Ascii string.
+
+  @retval RETURN_SUCCESS           String is copied.
+  @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrCpyS (
+  OUT CHAR8        *Destination,
+  IN  UINTN        DestMax,
+  IN  CONST CHAR8  *Source
+  );
+
+/**
+  Copies not more than Length successive char from the string pointed to by
+  Source to the array pointed to by Destination. If no null char is copied from
+  Source, then Destination[Length] is always set to null.
+
+  This function is similar as strncpy_s defined in C11.
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Ascii string.
+  @param  DestMax                  The maximum number of Destination Ascii
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Ascii string.
+  @param  Length                   The maximum number of Ascii characters to copy.
+
+  @retval RETURN_SUCCESS           String is copied.
+  @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than
+                                   MIN(StrLen(Source), Length).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrnCpyS (
+  OUT CHAR8        *Destination,
+  IN  UINTN        DestMax,
+  IN  CONST CHAR8  *Source,
+  IN  UINTN        Length
+  );
+
+/**
+  Appends a copy of the string pointed to by Source (including the terminating
+  null char) to the end of the string pointed to by Destination.
+
+  This function is similar as strcat_s defined in C11.
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Ascii string.
+  @param  DestMax                  The maximum number of Destination Ascii
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Ascii string.
+
+  @retval RETURN_SUCCESS           String is appended.
+  @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than
+                                   StrLen(Destination).
+  @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT
+                                   greater than StrLen(Source).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrCatS (
+  IN OUT CHAR8        *Destination,
+  IN     UINTN        DestMax,
+  IN     CONST CHAR8  *Source
+  );
+
+/**
+  Appends not more than Length successive char from the string pointed to by
+  Source to the end of the string pointed to by Destination. If no null char is
+  copied from Source, then Destination[StrLen(Destination) + Length] is always
+  set to null.
+
+  This function is similar as strncat_s defined in C11.
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Destination              A pointer to a Null-terminated Ascii string.
+  @param  DestMax                  The maximum number of Destination Ascii
+                                   char, including terminating null char.
+  @param  Source                   A pointer to a Null-terminated Ascii string.
+  @param  Length                   The maximum number of Ascii characters to copy.
+
+  @retval RETURN_SUCCESS           String is appended.
+  @retval RETURN_BAD_BUFFER_SIZE   If DestMax is NOT greater than
+                                   StrLen(Destination).
+  @retval RETURN_BUFFER_TOO_SMALL  If (DestMax - StrLen(Destination)) is NOT
+                                   greater than MIN(StrLen(Source), Length).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrnCatS (
+  IN OUT CHAR8        *Destination,
+  IN     UINTN        DestMax,
+  IN     CONST CHAR8  *Source,
+  IN     UINTN        Length
+  );
+
+/**
+  Convert a Null-terminated Ascii decimal string to a value of type UINTN.
+
+  This function outputs a value of type UINTN by interpreting the contents of
+  the Ascii string specified by String as a decimal number. The format of the
+  input Ascii string String is:
+
+                  [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The function will
+  ignore the pad space, which includes spaces or tab characters, before
+  [decimal digits]. The running zero in the beginning of [decimal digits] will
+  be ignored. Then, the function stops at the first character that is a not a
+  valid decimal character or a Null-terminator, whichever one comes first.
+
+  If String has no valid decimal digits in the above format, then 0 is stored
+  at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINTN, then
+  MAX_UINTN is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  decimal digits right after the optional pad spaces, the value of String is
+  stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Ascii string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                   and String contains more than
+                                   PcdMaximumAsciiStringLength Ascii
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINTN.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrDecimalToUintnS (
+  IN  CONST CHAR8              *String,
+  OUT       CHAR8              **EndPointer,  OPTIONAL
+  OUT       UINTN              *Data
+  );
+
+/**
+  Convert a Null-terminated Ascii decimal string to a value of type UINT64.
+
+  This function outputs a value of type UINT64 by interpreting the contents of
+  the Ascii string specified by String as a decimal number. The format of the
+  input Ascii string String is:
+
+                  [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The function will
+  ignore the pad space, which includes spaces or tab characters, before
+  [decimal digits]. The running zero in the beginning of [decimal digits] will
+  be ignored. Then, the function stops at the first character that is a not a
+  valid decimal character or a Null-terminator, whichever one comes first.
+
+  If String has no valid decimal digits in the above format, then 0 is stored
+  at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINT64, then
+  MAX_UINT64 is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  decimal digits right after the optional pad spaces, the value of String is
+  stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Ascii string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                   and String contains more than
+                                   PcdMaximumAsciiStringLength Ascii
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINT64.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrDecimalToUint64S (
+  IN  CONST CHAR8              *String,
+  OUT       CHAR8              **EndPointer,  OPTIONAL
+  OUT       UINT64             *Data
+  );
+
+/**
+  Convert a Null-terminated Ascii hexadecimal string to a value of type UINTN.
+
+  This function outputs a value of type UINTN by interpreting the contents of
+  the Ascii string specified by String as a hexadecimal number. The format of
+  the input Ascii string String is:
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix. If
+  "x" appears in the input string, it must be prefixed with at least one 0. The
+  function will ignore the pad space, which includes spaces or tab characters,
+  before [zeros], [x] or [hexadecimal digits]. The running zero before [x] or
+  [hexadecimal digits] will be ignored. Then, the decoding starts after [x] or
+  the first valid hexadecimal digit. Then, the function stops at the first
+  character that is a not a valid hexadecimal character or Null-terminator,
+  whichever on comes first.
+
+  If String has no valid hexadecimal digits in the above format, then 0 is
+  stored at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINTN, then
+  MAX_UINTN is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  hexadecimal digits right after the optional pad spaces, the value of String
+  is stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Ascii string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                   and String contains more than
+                                   PcdMaximumAsciiStringLength Ascii
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINTN.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrHexToUintnS (
+  IN  CONST CHAR8              *String,
+  OUT       CHAR8              **EndPointer,  OPTIONAL
+  OUT       UINTN              *Data
+  );
+
+/**
+  Convert a Null-terminated Ascii hexadecimal string to a value of type UINT64.
+
+  This function outputs a value of type UINT64 by interpreting the contents of
+  the Ascii string specified by String as a hexadecimal number. The format of
+  the input Ascii string String is:
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix. If
+  "x" appears in the input string, it must be prefixed with at least one 0. The
+  function will ignore the pad space, which includes spaces or tab characters,
+  before [zeros], [x] or [hexadecimal digits]. The running zero before [x] or
+  [hexadecimal digits] will be ignored. Then, the decoding starts after [x] or
+  the first valid hexadecimal digit. Then, the function stops at the first
+  character that is a not a valid hexadecimal character or Null-terminator,
+  whichever on comes first.
+
+  If String has no valid hexadecimal digits in the above format, then 0 is
+  stored at the location pointed to by Data.
+  If the number represented by String exceeds the range defined by UINT64, then
+  MAX_UINT64 is stored at the location pointed to by Data.
+
+  If EndPointer is not NULL, a pointer to the character that stopped the scan
+  is stored at the location pointed to by EndPointer. If String has no valid
+  hexadecimal digits right after the optional pad spaces, the value of String
+  is stored at the location pointed to by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Ascii string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Data                     Pointer to the converted value.
+
+  @retval RETURN_SUCCESS           Value is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                   and String contains more than
+                                   PcdMaximumAsciiStringLength Ascii
+                                   characters, not including the
+                                   Null-terminator.
+  @retval RETURN_UNSUPPORTED       If the number represented by String exceeds
+                                   the range defined by UINT64.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrHexToUint64S (
+  IN  CONST CHAR8              *String,
+  OUT       CHAR8              **EndPointer,  OPTIONAL
+  OUT       UINT64             *Data
+  );
+
+
+/**
+  Returns the length of a Null-terminated Unicode string.
+
+  This function returns the number of Unicode characters in the Null-terminated
+  Unicode string specified by String.
+
+  If String is NULL, then ASSERT().
+  If String is not aligned on a 16-bit boundary, then ASSERT().
+  If PcdMaximumUnicodeStringLength is not zero, and String contains more than
+  PcdMaximumUnicodeStringLength Unicode characters not including the
+  Null-terminator, then ASSERT().
+
+  @param  String  Pointer to a Null-terminated Unicode string.
+
+  @return The length of String.
+
+**/
+UINTN
+EFIAPI
+StrLen (
+  IN      CONST CHAR16              *String
+  );
+
+
+/**
+  Returns the size of a Null-terminated Unicode string in bytes, including the
+  Null terminator.
+
+  This function returns the size, in bytes, of the Null-terminated Unicode string
+  specified by String.
+
+  If String is NULL, then ASSERT().
+  If String is not aligned on a 16-bit boundary, then ASSERT().
+  If PcdMaximumUnicodeStringLength is not zero, and String contains more than
+  PcdMaximumUnicodeStringLength Unicode characters not including the
+  Null-terminator, then ASSERT().
+
+  @param  String  The pointer to a Null-terminated Unicode string.
+
+  @return The size of String.
+
+**/
+UINTN
+EFIAPI
+StrSize (
+  IN      CONST CHAR16              *String
+  );
+
+
+/**
+  Compares two Null-terminated Unicode strings, and returns the difference
+  between the first mismatched Unicode characters.
+
+  This function compares the Null-terminated Unicode string FirstString to the
+  Null-terminated Unicode string SecondString. If FirstString is identical to
+  SecondString, then 0 is returned. Otherwise, the value returned is the first
+  mismatched Unicode character in SecondString subtracted from the first
+  mismatched Unicode character in FirstString.
+
+  If FirstString is NULL, then ASSERT().
+  If FirstString is not aligned on a 16-bit boundary, then ASSERT().
+  If SecondString is NULL, then ASSERT().
+  If SecondString is not aligned on a 16-bit boundary, then ASSERT().
+  If PcdMaximumUnicodeStringLength is not zero, and FirstString contains more
+  than PcdMaximumUnicodeStringLength Unicode characters not including the
+  Null-terminator, then ASSERT().
+  If PcdMaximumUnicodeStringLength is not zero, and SecondString contains more
+  than PcdMaximumUnicodeStringLength Unicode characters, not including the
+  Null-terminator, then ASSERT().
+
+  @param  FirstString   The pointer to a Null-terminated Unicode string.
+  @param  SecondString  The pointer to a Null-terminated Unicode string.
+
+  @retval 0      FirstString is identical to SecondString.
+  @return others FirstString is not identical to SecondString.
+
+**/
+INTN
+EFIAPI
+StrCmp (
+  IN      CONST CHAR16              *FirstString,
+  IN      CONST CHAR16              *SecondString
+  );
+
+
+/**
+  Compares up to a specified length the contents of two Null-terminated Unicode strings,
+  and returns the difference between the first mismatched Unicode characters.
+
+  This function compares the Null-terminated Unicode string FirstString to the
+  Null-terminated Unicode string SecondString. At most, Length Unicode
+  characters will be compared. If Length is 0, then 0 is returned. If
+  FirstString is identical to SecondString, then 0 is returned. Otherwise, the
+  value returned is the first mismatched Unicode character in SecondString
+  subtracted from the first mismatched Unicode character in FirstString.
+
+  If Length > 0 and FirstString is NULL, then ASSERT().
+  If Length > 0 and FirstString is not aligned on a 16-bit boundary, then ASSERT().
+  If Length > 0 and SecondString is NULL, then ASSERT().
+  If Length > 0 and SecondString is not aligned on a 16-bit boundary, then ASSERT().
+  If PcdMaximumUnicodeStringLength is not zero, and Length is greater than
+  PcdMaximumUnicodeStringLength, then ASSERT().
+  If PcdMaximumUnicodeStringLength is not zero, and FirstString contains more than
+  PcdMaximumUnicodeStringLength Unicode characters, not including the Null-terminator,
+  then ASSERT().
+  If PcdMaximumUnicodeStringLength is not zero, and SecondString contains more than
+  PcdMaximumUnicodeStringLength Unicode characters, not including the Null-terminator,
+  then ASSERT().
+
+  @param  FirstString   The pointer to a Null-terminated Unicode string.
+  @param  SecondString  The pointer to a Null-terminated Unicode string.
+  @param  Length        The maximum number of Unicode characters to compare.
+
+  @retval 0      FirstString is identical to SecondString.
+  @return others FirstString is not identical to SecondString.
+
+**/
+INTN
+EFIAPI
+StrnCmp (
+  IN      CONST CHAR16              *FirstString,
+  IN      CONST CHAR16              *SecondString,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the first occurrence of a Null-terminated Unicode sub-string
+  in a Null-terminated Unicode string.
+
+  This function scans the contents of the Null-terminated Unicode string
+  specified by String and returns the first occurrence of SearchString.
+  If SearchString is not found in String, then NULL is returned.  If
+  the length of SearchString is zero, then String is returned.
+
+  If String is NULL, then ASSERT().
+  If String is not aligned on a 16-bit boundary, then ASSERT().
+  If SearchString is NULL, then ASSERT().
+  If SearchString is not aligned on a 16-bit boundary, then ASSERT().
+
+  If PcdMaximumUnicodeStringLength is not zero, and SearchString
+  or String contains more than PcdMaximumUnicodeStringLength Unicode
+  characters, not including the Null-terminator, then ASSERT().
+
+  @param  String          The pointer to a Null-terminated Unicode string.
+  @param  SearchString    The pointer to a Null-terminated Unicode string to search for.
+
+  @retval NULL            If the SearchString does not appear in String.
+  @return others          If there is a match.
+
+**/
+CHAR16 *
+EFIAPI
+StrStr (
+  IN      CONST CHAR16              *String,
+  IN      CONST CHAR16              *SearchString
+  );
+
+/**
+  Convert a Null-terminated Unicode decimal string to a value of
+  type UINTN.
+
+  This function returns a value of type UINTN by interpreting the contents
+  of the Unicode string specified by String as a decimal number. The format
+  of the input Unicode string String is:
+
+                  [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The
+  function will ignore the pad space, which includes spaces or
+  tab characters, before [decimal digits]. The running zero in the
+  beginning of [decimal digits] will be ignored. Then, the function
+  stops at the first character that is a not a valid decimal character
+  or a Null-terminator, whichever one comes first.
+
+  If String is NULL, then ASSERT().
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+  If String has only pad spaces, then 0 is returned.
+  If String has no pad spaces or valid decimal digits,
+  then 0 is returned.
+  If the number represented by String overflows according
+  to the range defined by UINTN, then MAX_UINTN is returned.
+
+  If PcdMaximumUnicodeStringLength is not zero, and String contains
+  more than PcdMaximumUnicodeStringLength Unicode characters not including
+  the Null-terminator, then ASSERT().
+
+  @param  String      The pointer to a Null-terminated Unicode string.
+
+  @retval Value translated from String.
+
+**/
+UINTN
+EFIAPI
+StrDecimalToUintn (
+  IN      CONST CHAR16              *String
+  );
+
+/**
+  Convert a Null-terminated Unicode decimal string to a value of
+  type UINT64.
+
+  This function returns a value of type UINT64 by interpreting the contents
+  of the Unicode string specified by String as a decimal number. The format
+  of the input Unicode string String is:
+
+                  [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The
+  function will ignore the pad space, which includes spaces or
+  tab characters, before [decimal digits]. The running zero in the
+  beginning of [decimal digits] will be ignored. Then, the function
+  stops at the first character that is a not a valid decimal character
+  or a Null-terminator, whichever one comes first.
+
+  If String is NULL, then ASSERT().
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+  If String has only pad spaces, then 0 is returned.
+  If String has no pad spaces or valid decimal digits,
+  then 0 is returned.
+  If the number represented by String overflows according
+  to the range defined by UINT64, then MAX_UINT64 is returned.
+
+  If PcdMaximumUnicodeStringLength is not zero, and String contains
+  more than PcdMaximumUnicodeStringLength Unicode characters not including
+  the Null-terminator, then ASSERT().
+
+  @param  String          The pointer to a Null-terminated Unicode string.
+
+  @retval Value translated from String.
+
+**/
+UINT64
+EFIAPI
+StrDecimalToUint64 (
+  IN      CONST CHAR16              *String
+  );
+
+
+/**
+  Convert a Null-terminated Unicode hexadecimal string to a value of type UINTN.
+
+  This function returns a value of type UINTN by interpreting the contents
+  of the Unicode string specified by String as a hexadecimal number.
+  The format of the input Unicode string String is:
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix.
+  If "x" appears in the input string, it must be prefixed with at least one 0.
+  The function will ignore the pad space, which includes spaces or tab characters,
+  before [zeros], [x] or [hexadecimal digit]. The running zero before [x] or
+  [hexadecimal digit] will be ignored. Then, the decoding starts after [x] or the
+  first valid hexadecimal digit. Then, the function stops at the first character
+  that is a not a valid hexadecimal character or NULL, whichever one comes first.
+
+  If String is NULL, then ASSERT().
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+  If String has only pad spaces, then zero is returned.
+  If String has no leading pad spaces, leading zeros or valid hexadecimal digits,
+  then zero is returned.
+  If the number represented by String overflows according to the range defined by
+  UINTN, then MAX_UINTN is returned.
+
+  If PcdMaximumUnicodeStringLength is not zero, and String contains more than
+  PcdMaximumUnicodeStringLength Unicode characters not including the Null-terminator,
+  then ASSERT().
+
+  @param  String          The pointer to a Null-terminated Unicode string.
+
+  @retval Value translated from String.
+
+**/
+UINTN
+EFIAPI
+StrHexToUintn (
+  IN      CONST CHAR16              *String
+  );
+
+
+/**
+  Convert a Null-terminated Unicode hexadecimal string to a value of type UINT64.
+
+  This function returns a value of type UINT64 by interpreting the contents
+  of the Unicode string specified by String as a hexadecimal number.
+  The format of the input Unicode string String is
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix.
+  If "x" appears in the input string, it must be prefixed with at least one 0.
+  The function will ignore the pad space, which includes spaces or tab characters,
+  before [zeros], [x] or [hexadecimal digit]. The running zero before [x] or
+  [hexadecimal digit] will be ignored. Then, the decoding starts after [x] or the
+  first valid hexadecimal digit. Then, the function stops at the first character that is
+  a not a valid hexadecimal character or NULL, whichever one comes first.
+
+  If String is NULL, then ASSERT().
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+  If String has only pad spaces, then zero is returned.
+  If String has no leading pad spaces, leading zeros or valid hexadecimal digits,
+  then zero is returned.
+  If the number represented by String overflows according to the range defined by
+  UINT64, then MAX_UINT64 is returned.
+
+  If PcdMaximumUnicodeStringLength is not zero, and String contains more than
+  PcdMaximumUnicodeStringLength Unicode characters not including the Null-terminator,
+  then ASSERT().
+
+  @param  String          The pointer to a Null-terminated Unicode string.
+
+  @retval Value translated from String.
+
+**/
+UINT64
+EFIAPI
+StrHexToUint64 (
+  IN      CONST CHAR16             *String
+  );
+
+/**
+  Convert a Null-terminated Unicode string to IPv6 address and prefix length.
+
+  This function outputs a value of type IPv6_ADDRESS and may output a value
+  of type UINT8 by interpreting the contents of the Unicode string specified
+  by String. The format of the input Unicode string String is as follows:
+
+                  X:X:X:X:X:X:X:X[/P]
+
+  X contains one to four hexadecimal digit characters in the range [0-9], [a-f] and
+  [A-F]. X is converted to a value of type UINT16, whose low byte is stored in low
+  memory address and high byte is stored in high memory address. P contains decimal
+  digit characters in the range [0-9]. The running zero in the beginning of P will
+  be ignored. /P is optional.
+
+  When /P is not in the String, the function stops at the first character that is
+  not a valid hexadecimal digit character after eight X's are converted.
+
+  When /P is in the String, the function stops at the first character that is not
+  a valid decimal digit character after P is converted.
+
+  "::" can be used to compress one or more groups of X when X contains only 0.
+  The "::" can only appear once in the String.
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  If EndPointer is not NULL and Address is translated from String, a pointer
+  to the character that stopped the scan is stored at the location pointed to
+  by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Address                  Pointer to the converted IPv6 address.
+  @param  PrefixLength             Pointer to the converted IPv6 address prefix
+                                   length. MAX_UINT8 is returned when /P is
+                                   not in the String.
+
+  @retval RETURN_SUCCESS           Address is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+  @retval RETURN_UNSUPPORTED       If X contains more than four hexadecimal
+                                    digit characters.
+                                   If String contains "::" and number of X
+                                    is not less than 8.
+                                   If P starts with character that is not a
+                                    valid decimal digit character.
+                                   If the decimal number converted from P
+                                    exceeds 128.
+
+**/
+RETURN_STATUS
+EFIAPI
+StrToIpv6Address (
+  IN  CONST CHAR16       *String,
+  OUT CHAR16             **EndPointer, OPTIONAL
+  OUT IPv6_ADDRESS       *Address,
+  OUT UINT8              *PrefixLength OPTIONAL
+  );
+
+/**
+  Convert a Null-terminated Unicode string to IPv4 address and prefix length.
+
+  This function outputs a value of type IPv4_ADDRESS and may output a value
+  of type UINT8 by interpreting the contents of the Unicode string specified
+  by String. The format of the input Unicode string String is as follows:
+
+                  D.D.D.D[/P]
+
+  D and P are decimal digit characters in the range [0-9]. The running zero in
+  the beginning of D and P will be ignored. /P is optional.
+
+  When /P is not in the String, the function stops at the first character that is
+  not a valid decimal digit character after four D's are converted.
+
+  When /P is in the String, the function stops at the first character that is not
+  a valid decimal digit character after P is converted.
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  If EndPointer is not NULL and Address is translated from String, a pointer
+  to the character that stopped the scan is stored at the location pointed to
+  by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Address                  Pointer to the converted IPv4 address.
+  @param  PrefixLength             Pointer to the converted IPv4 address prefix
+                                   length. MAX_UINT8 is returned when /P is
+                                   not in the String.
+
+  @retval RETURN_SUCCESS           Address is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+  @retval RETURN_UNSUPPORTED       If String is not in the correct format.
+                                   If any decimal number converted from D
+                                    exceeds 255.
+                                   If the decimal number converted from P
+                                    exceeds 32.
+
+**/
+RETURN_STATUS
+EFIAPI
+StrToIpv4Address (
+  IN  CONST CHAR16       *String,
+  OUT CHAR16             **EndPointer, OPTIONAL
+  OUT IPv4_ADDRESS       *Address,
+  OUT UINT8              *PrefixLength OPTIONAL
+  );
+
+#define GUID_STRING_LENGTH  36
+
+/**
+  Convert a Null-terminated Unicode GUID string to a value of type
+  EFI_GUID.
+
+  This function outputs a GUID value by interpreting the contents of
+  the Unicode string specified by String. The format of the input
+  Unicode string String consists of 36 characters, as follows:
+
+                  aabbccdd-eeff-gghh-iijj-kkllmmnnoopp
+
+  The pairs aa - pp are two characters in the range [0-9], [a-f] and
+  [A-F], with each pair representing a single byte hexadecimal value.
+
+  The mapping between String and the EFI_GUID structure is as follows:
+                  aa          Data1[24:31]
+                  bb          Data1[16:23]
+                  cc          Data1[8:15]
+                  dd          Data1[0:7]
+                  ee          Data2[8:15]
+                  ff          Data2[0:7]
+                  gg          Data3[8:15]
+                  hh          Data3[0:7]
+                  ii          Data4[0:7]
+                  jj          Data4[8:15]
+                  kk          Data4[16:23]
+                  ll          Data4[24:31]
+                  mm          Data4[32:39]
+                  nn          Data4[40:47]
+                  oo          Data4[48:55]
+                  pp          Data4[56:63]
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  Guid                     Pointer to the converted GUID.
+
+  @retval RETURN_SUCCESS           Guid is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+  @retval RETURN_UNSUPPORTED       If String is not as the above format.
+
+**/
+RETURN_STATUS
+EFIAPI
+StrToGuid (
+  IN  CONST CHAR16       *String,
+  OUT GUID               *Guid
+  );
+
+/**
+  Convert a Null-terminated Unicode hexadecimal string to a byte array.
+
+  This function outputs a byte array by interpreting the contents of
+  the Unicode string specified by String in hexadecimal format. The format of
+  the input Unicode string String is:
+
+                  [XX]*
+
+  X is a hexadecimal digit character in the range [0-9], [a-f] and [A-F].
+  The function decodes every two hexadecimal digit characters as one byte. The
+  decoding stops after Length of characters and outputs Buffer containing
+  (Length / 2) bytes.
+
+  If String is not aligned in a 16-bit boundary, then ASSERT().
+
+  @param  String                   Pointer to a Null-terminated Unicode string.
+  @param  Length                   The number of Unicode characters to decode.
+  @param  Buffer                   Pointer to the converted bytes array.
+  @param  MaxBufferSize            The maximum size of Buffer.
+
+  @retval RETURN_SUCCESS           Buffer is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If Length is not multiple of 2.
+                                   If PcdMaximumUnicodeStringLength is not zero,
+                                    and Length is greater than
+                                    PcdMaximumUnicodeStringLength.
+  @retval RETURN_UNSUPPORTED       If Length of characters from String contain
+                                    a character that is not valid hexadecimal
+                                    digit characters, or a Null-terminator.
+  @retval RETURN_BUFFER_TOO_SMALL  If MaxBufferSize is less than (Length / 2).
+**/
+RETURN_STATUS
+EFIAPI
+StrHexToBytes (
+  IN  CONST CHAR16       *String,
+  IN  UINTN              Length,
+  OUT UINT8              *Buffer,
+  IN  UINTN              MaxBufferSize
+  );
+
+
+/**
+  Convert a Null-terminated Unicode string to a Null-terminated
+  ASCII string.
+
+  This function is similar to AsciiStrCpyS.
+
+  This function converts the content of the Unicode string Source
+  to the ASCII string Destination by copying the lower 8 bits of
+  each Unicode character. The function terminates the ASCII string
+  Destination by appending a Null-terminator character at the end.
+
+  The caller is responsible to make sure Destination points to a buffer with size
+  equal or greater than ((StrLen (Source) + 1) * sizeof (CHAR8)) in bytes.
+
+  If any Unicode characters in Source contain non-zero value in
+  the upper 8 bits, then ASSERT().
+
+  If Source is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Source        The pointer to a Null-terminated Unicode string.
+  @param  Destination   The pointer to a Null-terminated ASCII string.
+  @param  DestMax       The maximum number of Destination Ascii
+                        char, including terminating null char.
+
+  @retval RETURN_SUCCESS           String is converted.
+  @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                   If PcdMaximumUnicodeStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+
+**/
+RETURN_STATUS
+EFIAPI
+UnicodeStrToAsciiStrS (
+  IN      CONST CHAR16              *Source,
+  OUT     CHAR8                     *Destination,
+  IN      UINTN                     DestMax
+  );
+
+/**
+  Convert not more than Length successive characters from a Null-terminated
+  Unicode string to a Null-terminated Ascii string. If no null char is copied
+  from Source, then Destination[Length] is always set to null.
+
+  This function converts not more than Length successive characters from the
+  Unicode string Source to the Ascii string Destination by copying the lower 8
+  bits of each Unicode character. The function terminates the Ascii string
+  Destination by appending a Null-terminator character at the end.
+
+  The caller is responsible to make sure Destination points to a buffer with size
+  equal or greater than ((StrLen (Source) + 1) * sizeof (CHAR8)) in bytes.
+
+  If any Unicode characters in Source contain non-zero value in the upper 8
+  bits, then ASSERT().
+  If Source is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Source             The pointer to a Null-terminated Unicode string.
+  @param  Length             The maximum number of Unicode characters to
+                             convert.
+  @param  Destination        The pointer to a Null-terminated Ascii string.
+  @param  DestMax            The maximum number of Destination Ascii
+                             char, including terminating null char.
+  @param  DestinationLength  The number of Unicode characters converted.
+
+  @retval RETURN_SUCCESS            String is converted.
+  @retval RETURN_INVALID_PARAMETER  If Destination is NULL.
+                                    If Source is NULL.
+                                    If DestinationLength is NULL.
+                                    If PcdMaximumAsciiStringLength is not zero,
+                                    and Length or DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                    If PcdMaximumUnicodeStringLength is not
+                                    zero, and Length or DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                    If DestMax is 0.
+  @retval RETURN_BUFFER_TOO_SMALL   If DestMax is NOT greater than
+                                    MIN(StrLen(Source), Length).
+  @retval RETURN_ACCESS_DENIED      If Source and Destination overlap.
+
+**/
+RETURN_STATUS
+EFIAPI
+UnicodeStrnToAsciiStrS (
+  IN      CONST CHAR16              *Source,
+  IN      UINTN                     Length,
+  OUT     CHAR8                     *Destination,
+  IN      UINTN                     DestMax,
+  OUT     UINTN                     *DestinationLength
+  );
+
+
+/**
+  Returns the length of a Null-terminated ASCII string.
+
+  This function returns the number of ASCII characters in the Null-terminated
+  ASCII string specified by String.
+
+  If Length > 0 and Destination is NULL, then ASSERT().
+  If Length > 0 and Source is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero and String contains more than
+  PcdMaximumAsciiStringLength ASCII characters not including the Null-terminator,
+  then ASSERT().
+
+  @param  String  The pointer to a Null-terminated ASCII string.
+
+  @return The length of String.
+
+**/
+UINTN
+EFIAPI
+AsciiStrLen (
+  IN      CONST CHAR8               *String
+  );
+
+
+/**
+  Returns the size of a Null-terminated ASCII string in bytes, including the
+  Null terminator.
+
+  This function returns the size, in bytes, of the Null-terminated ASCII string
+  specified by String.
+
+  If String is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero and String contains more than
+  PcdMaximumAsciiStringLength ASCII characters not including the Null-terminator,
+  then ASSERT().
+
+  @param  String  The pointer to a Null-terminated ASCII string.
+
+  @return The size of String.
+
+**/
+UINTN
+EFIAPI
+AsciiStrSize (
+  IN      CONST CHAR8               *String
+  );
+
+
+/**
+  Compares two Null-terminated ASCII strings, and returns the difference
+  between the first mismatched ASCII characters.
+
+  This function compares the Null-terminated ASCII string FirstString to the
+  Null-terminated ASCII string SecondString. If FirstString is identical to
+  SecondString, then 0 is returned. Otherwise, the value returned is the first
+  mismatched ASCII character in SecondString subtracted from the first
+  mismatched ASCII character in FirstString.
+
+  If FirstString is NULL, then ASSERT().
+  If SecondString is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero and FirstString contains more than
+  PcdMaximumAsciiStringLength ASCII characters not including the Null-terminator,
+  then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero and SecondString contains more
+  than PcdMaximumAsciiStringLength ASCII characters not including the
+  Null-terminator, then ASSERT().
+
+  @param  FirstString   The pointer to a Null-terminated ASCII string.
+  @param  SecondString  The pointer to a Null-terminated ASCII string.
+
+  @retval ==0      FirstString is identical to SecondString.
+  @retval !=0      FirstString is not identical to SecondString.
+
+**/
+INTN
+EFIAPI
+AsciiStrCmp (
+  IN      CONST CHAR8               *FirstString,
+  IN      CONST CHAR8               *SecondString
+  );
+
+
+/**
+  Performs a case insensitive comparison of two Null-terminated ASCII strings,
+  and returns the difference between the first mismatched ASCII characters.
+
+  This function performs a case insensitive comparison of the Null-terminated
+  ASCII string FirstString to the Null-terminated ASCII string SecondString. If
+  FirstString is identical to SecondString, then 0 is returned. Otherwise, the
+  value returned is the first mismatched lower case ASCII character in
+  SecondString subtracted from the first mismatched lower case ASCII character
+  in FirstString.
+
+  If FirstString is NULL, then ASSERT().
+  If SecondString is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero and FirstString contains more than
+  PcdMaximumAsciiStringLength ASCII characters not including the Null-terminator,
+  then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero and SecondString contains more
+  than PcdMaximumAsciiStringLength ASCII characters not including the
+  Null-terminator, then ASSERT().
+
+  @param  FirstString   The pointer to a Null-terminated ASCII string.
+  @param  SecondString  The pointer to a Null-terminated ASCII string.
+
+  @retval ==0    FirstString is identical to SecondString using case insensitive
+                 comparisons.
+  @retval !=0    FirstString is not identical to SecondString using case
+                 insensitive comparisons.
+
+**/
+INTN
+EFIAPI
+AsciiStriCmp (
+  IN      CONST CHAR8               *FirstString,
+  IN      CONST CHAR8               *SecondString
+  );
+
+
+/**
+  Compares two Null-terminated ASCII strings with maximum lengths, and returns
+  the difference between the first mismatched ASCII characters.
+
+  This function compares the Null-terminated ASCII string FirstString to the
+  Null-terminated ASCII  string SecondString. At most, Length ASCII characters
+  will be compared. If Length is 0, then 0 is returned. If FirstString is
+  identical to SecondString, then 0 is returned. Otherwise, the value returned
+  is the first mismatched ASCII character in SecondString subtracted from the
+  first mismatched ASCII character in FirstString.
+
+  If Length > 0 and FirstString is NULL, then ASSERT().
+  If Length > 0 and SecondString is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero, and Length is greater than
+  PcdMaximumAsciiStringLength, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero, and FirstString contains more than
+  PcdMaximumAsciiStringLength ASCII characters, not including the Null-terminator,
+  then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero, and SecondString contains more than
+  PcdMaximumAsciiStringLength ASCII characters, not including the Null-terminator,
+  then ASSERT().
+
+  @param  FirstString   The pointer to a Null-terminated ASCII string.
+  @param  SecondString  The pointer to a Null-terminated ASCII string.
+  @param  Length        The maximum number of ASCII characters for compare.
+
+  @retval ==0       FirstString is identical to SecondString.
+  @retval !=0       FirstString is not identical to SecondString.
+
+**/
+INTN
+EFIAPI
+AsciiStrnCmp (
+  IN      CONST CHAR8               *FirstString,
+  IN      CONST CHAR8               *SecondString,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the first occurrence of a Null-terminated ASCII sub-string
+  in a Null-terminated ASCII string.
+
+  This function scans the contents of the ASCII string specified by String
+  and returns the first occurrence of SearchString. If SearchString is not
+  found in String, then NULL is returned. If the length of SearchString is zero,
+  then String is returned.
+
+  If String is NULL, then ASSERT().
+  If SearchString is NULL, then ASSERT().
+
+  If PcdMaximumAsciiStringLength is not zero, and SearchString or
+  String contains more than PcdMaximumAsciiStringLength Unicode characters
+  not including the Null-terminator, then ASSERT().
+
+  @param  String          The pointer to a Null-terminated ASCII string.
+  @param  SearchString    The pointer to a Null-terminated ASCII string to search for.
+
+  @retval NULL            If the SearchString does not appear in String.
+  @retval others          If there is a match return the first occurrence of SearchingString.
+                          If the length of SearchString is zero,return String.
+
+**/
+CHAR8 *
+EFIAPI
+AsciiStrStr (
+  IN      CONST CHAR8               *String,
+  IN      CONST CHAR8               *SearchString
+  );
+
+
+/**
+  Convert a Null-terminated ASCII decimal string to a value of type
+  UINTN.
+
+  This function returns a value of type UINTN by interpreting the contents
+  of the ASCII string String as a decimal number. The format of the input
+  ASCII string String is:
+
+                    [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The function will
+  ignore the pad space, which includes spaces or tab characters, before the digits.
+  The running zero in the beginning of [decimal digits] will be ignored. Then, the
+  function stops at the first character that is a not a valid decimal character or
+  Null-terminator, whichever on comes first.
+
+  If String has only pad spaces, then 0 is returned.
+  If String has no pad spaces or valid decimal digits, then 0 is returned.
+  If the number represented by String overflows according to the range defined by
+  UINTN, then MAX_UINTN is returned.
+  If String is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero, and String contains more than
+  PcdMaximumAsciiStringLength ASCII characters not including the Null-terminator,
+  then ASSERT().
+
+  @param  String          The pointer to a Null-terminated ASCII string.
+
+  @retval The value translated from String.
+
+**/
+UINTN
+EFIAPI
+AsciiStrDecimalToUintn (
+  IN      CONST CHAR8               *String
+  );
+
+
+/**
+  Convert a Null-terminated ASCII decimal string to a value of type
+  UINT64.
+
+  This function returns a value of type UINT64 by interpreting the contents
+  of the ASCII string String as a decimal number. The format of the input
+  ASCII string String is:
+
+                    [spaces] [decimal digits].
+
+  The valid decimal digit character is in the range [0-9]. The function will
+  ignore the pad space, which includes spaces or tab characters, before the digits.
+  The running zero in the beginning of [decimal digits] will be ignored. Then, the
+  function stops at the first character that is a not a valid decimal character or
+  Null-terminator, whichever on comes first.
+
+  If String has only pad spaces, then 0 is returned.
+  If String has no pad spaces or valid decimal digits, then 0 is returned.
+  If the number represented by String overflows according to the range defined by
+  UINT64, then MAX_UINT64 is returned.
+  If String is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero, and String contains more than
+  PcdMaximumAsciiStringLength ASCII characters not including the Null-terminator,
+  then ASSERT().
+
+  @param  String          The pointer to a Null-terminated ASCII string.
+
+  @retval Value translated from String.
+
+**/
+UINT64
+EFIAPI
+AsciiStrDecimalToUint64 (
+  IN      CONST CHAR8               *String
+  );
+
+
+/**
+  Convert a Null-terminated ASCII hexadecimal string to a value of type UINTN.
+
+  This function returns a value of type UINTN by interpreting the contents of
+  the ASCII string String as a hexadecimal number. The format of the input ASCII
+  string String is:
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix. If "x"
+  appears in the input string, it must be prefixed with at least one 0. The function
+  will ignore the pad space, which includes spaces or tab characters, before [zeros],
+  [x] or [hexadecimal digits]. The running zero before [x] or [hexadecimal digits]
+  will be ignored. Then, the decoding starts after [x] or the first valid hexadecimal
+  digit. Then, the function stops at the first character that is a not a valid
+  hexadecimal character or Null-terminator, whichever on comes first.
+
+  If String has only pad spaces, then 0 is returned.
+  If String has no leading pad spaces, leading zeros or valid hexadecimal digits, then
+  0 is returned.
+
+  If the number represented by String overflows according to the range defined by UINTN,
+  then MAX_UINTN is returned.
+  If String is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero,
+  and String contains more than PcdMaximumAsciiStringLength ASCII characters not including
+  the Null-terminator, then ASSERT().
+
+  @param  String          The pointer to a Null-terminated ASCII string.
+
+  @retval Value translated from String.
+
+**/
+UINTN
+EFIAPI
+AsciiStrHexToUintn (
+  IN      CONST CHAR8               *String
+  );
+
+
+/**
+  Convert a Null-terminated ASCII hexadecimal string to a value of type UINT64.
+
+  This function returns a value of type UINT64 by interpreting the contents of
+  the ASCII string String as a hexadecimal number. The format of the input ASCII
+  string String is:
+
+                  [spaces][zeros][x][hexadecimal digits].
+
+  The valid hexadecimal digit character is in the range [0-9], [a-f] and [A-F].
+  The prefix "0x" is optional. Both "x" and "X" is allowed in "0x" prefix. If "x"
+  appears in the input string, it must be prefixed with at least one 0. The function
+  will ignore the pad space, which includes spaces or tab characters, before [zeros],
+  [x] or [hexadecimal digits]. The running zero before [x] or [hexadecimal digits]
+  will be ignored. Then, the decoding starts after [x] or the first valid hexadecimal
+  digit. Then, the function stops at the first character that is a not a valid
+  hexadecimal character or Null-terminator, whichever on comes first.
+
+  If String has only pad spaces, then 0 is returned.
+  If String has no leading pad spaces, leading zeros or valid hexadecimal digits, then
+  0 is returned.
+
+  If the number represented by String overflows according to the range defined by UINT64,
+  then MAX_UINT64 is returned.
+  If String is NULL, then ASSERT().
+  If PcdMaximumAsciiStringLength is not zero,
+  and String contains more than PcdMaximumAsciiStringLength ASCII characters not including
+  the Null-terminator, then ASSERT().
+
+  @param  String          The pointer to a Null-terminated ASCII string.
+
+  @retval Value translated from String.
+
+**/
+UINT64
+EFIAPI
+AsciiStrHexToUint64 (
+  IN      CONST CHAR8                *String
+  );
+
+/**
+  Convert a Null-terminated ASCII string to IPv6 address and prefix length.
+
+  This function outputs a value of type IPv6_ADDRESS and may output a value
+  of type UINT8 by interpreting the contents of the ASCII string specified
+  by String. The format of the input ASCII string String is as follows:
+
+                  X:X:X:X:X:X:X:X[/P]
+
+  X contains one to four hexadecimal digit characters in the range [0-9], [a-f] and
+  [A-F]. X is converted to a value of type UINT16, whose low byte is stored in low
+  memory address and high byte is stored in high memory address. P contains decimal
+  digit characters in the range [0-9]. The running zero in the beginning of P will
+  be ignored. /P is optional.
+
+  When /P is not in the String, the function stops at the first character that is
+  not a valid hexadecimal digit character after eight X's are converted.
+
+  When /P is in the String, the function stops at the first character that is not
+  a valid decimal digit character after P is converted.
+
+  "::" can be used to compress one or more groups of X when X contains only 0.
+  The "::" can only appear once in the String.
+
+  If EndPointer is not NULL and Address is translated from String, a pointer
+  to the character that stopped the scan is stored at the location pointed to
+  by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated ASCII string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Address                  Pointer to the converted IPv6 address.
+  @param  PrefixLength             Pointer to the converted IPv6 address prefix
+                                   length. MAX_UINT8 is returned when /P is
+                                   not in the String.
+
+  @retval RETURN_SUCCESS           Address is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+  @retval RETURN_UNSUPPORTED       If X contains more than four hexadecimal
+                                    digit characters.
+                                   If String contains "::" and number of X
+                                    is not less than 8.
+                                   If P starts with character that is not a
+                                    valid decimal digit character.
+                                   If the decimal number converted from P
+                                    exceeds 128.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrToIpv6Address (
+  IN  CONST CHAR8        *String,
+  OUT CHAR8              **EndPointer, OPTIONAL
+  OUT IPv6_ADDRESS       *Address,
+  OUT UINT8              *PrefixLength OPTIONAL
+  );
+
+/**
+  Convert a Null-terminated ASCII string to IPv4 address and prefix length.
+
+  This function outputs a value of type IPv4_ADDRESS and may output a value
+  of type UINT8 by interpreting the contents of the ASCII string specified
+  by String. The format of the input ASCII string String is as follows:
+
+                  D.D.D.D[/P]
+
+  D and P are decimal digit characters in the range [0-9]. The running zero in
+  the beginning of D and P will be ignored. /P is optional.
+
+  When /P is not in the String, the function stops at the first character that is
+  not a valid decimal digit character after four D's are converted.
+
+  When /P is in the String, the function stops at the first character that is not
+  a valid decimal digit character after P is converted.
+
+  If EndPointer is not NULL and Address is translated from String, a pointer
+  to the character that stopped the scan is stored at the location pointed to
+  by EndPointer.
+
+  @param  String                   Pointer to a Null-terminated ASCII string.
+  @param  EndPointer               Pointer to character that stops scan.
+  @param  Address                  Pointer to the converted IPv4 address.
+  @param  PrefixLength             Pointer to the converted IPv4 address prefix
+                                   length. MAX_UINT8 is returned when /P is
+                                   not in the String.
+
+  @retval RETURN_SUCCESS           Address is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+  @retval RETURN_UNSUPPORTED       If String is not in the correct format.
+                                   If any decimal number converted from D
+                                    exceeds 255.
+                                   If the decimal number converted from P
+                                    exceeds 32.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrToIpv4Address (
+  IN  CONST CHAR8        *String,
+  OUT CHAR8              **EndPointer, OPTIONAL
+  OUT IPv4_ADDRESS       *Address,
+  OUT UINT8              *PrefixLength OPTIONAL
+  );
+
+/**
+  Convert a Null-terminated ASCII GUID string to a value of type
+  EFI_GUID.
+
+  This function outputs a GUID value by interpreting the contents of
+  the ASCII string specified by String. The format of the input
+  ASCII string String consists of 36 characters, as follows:
+
+                  aabbccdd-eeff-gghh-iijj-kkllmmnnoopp
+
+  The pairs aa - pp are two characters in the range [0-9], [a-f] and
+  [A-F], with each pair representing a single byte hexadecimal value.
+
+  The mapping between String and the EFI_GUID structure is as follows:
+                  aa          Data1[24:31]
+                  bb          Data1[16:23]
+                  cc          Data1[8:15]
+                  dd          Data1[0:7]
+                  ee          Data2[8:15]
+                  ff          Data2[0:7]
+                  gg          Data3[8:15]
+                  hh          Data3[0:7]
+                  ii          Data4[0:7]
+                  jj          Data4[8:15]
+                  kk          Data4[16:23]
+                  ll          Data4[24:31]
+                  mm          Data4[32:39]
+                  nn          Data4[40:47]
+                  oo          Data4[48:55]
+                  pp          Data4[56:63]
+
+  @param  String                   Pointer to a Null-terminated ASCII string.
+  @param  Guid                     Pointer to the converted GUID.
+
+  @retval RETURN_SUCCESS           Guid is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+  @retval RETURN_UNSUPPORTED       If String is not as the above format.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrToGuid (
+  IN  CONST CHAR8        *String,
+  OUT GUID               *Guid
+  );
+
+/**
+  Convert a Null-terminated ASCII hexadecimal string to a byte array.
+
+  This function outputs a byte array by interpreting the contents of
+  the ASCII string specified by String in hexadecimal format. The format of
+  the input ASCII string String is:
+
+                  [XX]*
+
+  X is a hexadecimal digit character in the range [0-9], [a-f] and [A-F].
+  The function decodes every two hexadecimal digit characters as one byte. The
+  decoding stops after Length of characters and outputs Buffer containing
+  (Length / 2) bytes.
+
+  @param  String                   Pointer to a Null-terminated ASCII string.
+  @param  Length                   The number of ASCII characters to decode.
+  @param  Buffer                   Pointer to the converted bytes array.
+  @param  MaxBufferSize            The maximum size of Buffer.
+
+  @retval RETURN_SUCCESS           Buffer is translated from String.
+  @retval RETURN_INVALID_PARAMETER If String is NULL.
+                                   If Data is NULL.
+                                   If Length is not multiple of 2.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                    and Length is greater than
+                                    PcdMaximumAsciiStringLength.
+  @retval RETURN_UNSUPPORTED       If Length of characters from String contain
+                                    a character that is not valid hexadecimal
+                                    digit characters, or a Null-terminator.
+  @retval RETURN_BUFFER_TOO_SMALL  If MaxBufferSize is less than (Length / 2).
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrHexToBytes (
+  IN  CONST CHAR8        *String,
+  IN  UINTN              Length,
+  OUT UINT8              *Buffer,
+  IN  UINTN              MaxBufferSize
+  );
+
+
+/**
+  Convert one Null-terminated ASCII string to a Null-terminated
+  Unicode string.
+
+  This function is similar to StrCpyS.
+
+  This function converts the contents of the ASCII string Source to the Unicode
+  string Destination. The function terminates the Unicode string Destination by
+  appending a Null-terminator character at the end.
+
+  The caller is responsible to make sure Destination points to a buffer with size
+  equal or greater than ((AsciiStrLen (Source) + 1) * sizeof (CHAR16)) in bytes.
+
+  If Destination is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then the Destination is unmodified.
+
+  @param  Source        The pointer to a Null-terminated ASCII string.
+  @param  Destination   The pointer to a Null-terminated Unicode string.
+  @param  DestMax       The maximum number of Destination Unicode
+                        char, including terminating null char.
+
+  @retval RETURN_SUCCESS           String is converted.
+  @retval RETURN_BUFFER_TOO_SMALL  If DestMax is NOT greater than StrLen(Source).
+  @retval RETURN_INVALID_PARAMETER If Destination is NULL.
+                                   If Source is NULL.
+                                   If PcdMaximumUnicodeStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                   If PcdMaximumAsciiStringLength is not zero,
+                                    and DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                   If DestMax is 0.
+  @retval RETURN_ACCESS_DENIED     If Source and Destination overlap.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrToUnicodeStrS (
+  IN      CONST CHAR8               *Source,
+  OUT     CHAR16                    *Destination,
+  IN      UINTN                     DestMax
+  );
+
+/**
+  Convert not more than Length successive characters from a Null-terminated
+  Ascii string to a Null-terminated Unicode string. If no null char is copied
+  from Source, then Destination[Length] is always set to null.
+
+  This function converts not more than Length successive characters from the
+  Ascii string Source to the Unicode string Destination. The function
+  terminates the Unicode string Destination by appending a Null-terminator
+  character at the end.
+
+  The caller is responsible to make sure Destination points to a buffer with
+  size not smaller than
+  ((MIN(AsciiStrLen(Source), Length) + 1) * sizeof (CHAR8)) in bytes.
+
+  If Destination is not aligned on a 16-bit boundary, then ASSERT().
+
+  If an error is returned, then Destination and DestinationLength are
+  unmodified.
+
+  @param  Source             The pointer to a Null-terminated Ascii string.
+  @param  Length             The maximum number of Ascii characters to convert.
+  @param  Destination        The pointer to a Null-terminated Unicode string.
+  @param  DestMax            The maximum number of Destination Unicode char,
+                             including terminating null char.
+  @param  DestinationLength  The number of Ascii characters converted.
+
+  @retval RETURN_SUCCESS            String is converted.
+  @retval RETURN_INVALID_PARAMETER  If Destination is NULL.
+                                    If Source is NULL.
+                                    If DestinationLength is NULL.
+                                    If PcdMaximumUnicodeStringLength is not
+                                    zero, and Length or DestMax is greater than
+                                    PcdMaximumUnicodeStringLength.
+                                    If PcdMaximumAsciiStringLength is not zero,
+                                    and Length or DestMax is greater than
+                                    PcdMaximumAsciiStringLength.
+                                    If DestMax is 0.
+  @retval RETURN_BUFFER_TOO_SMALL   If DestMax is NOT greater than
+                                    MIN(AsciiStrLen(Source), Length).
+  @retval RETURN_ACCESS_DENIED      If Source and Destination overlap.
+
+**/
+RETURN_STATUS
+EFIAPI
+AsciiStrnToUnicodeStrS (
+  IN      CONST CHAR8               *Source,
+  IN      UINTN                     Length,
+  OUT     CHAR16                    *Destination,
+  IN      UINTN                     DestMax,
+  OUT     UINTN                     *DestinationLength
+  );
+
+/**
+  Convert a Unicode character to upper case only if
+  it maps to a valid small-case ASCII character.
+
+  This internal function only deal with Unicode character
+  which maps to a valid small-case ASCII character, i.e.
+  L'a' to L'z'. For other Unicode character, the input character
+  is returned directly.
+
+  @param  Char  The character to convert.
+
+  @retval LowerCharacter   If the Char is with range L'a' to L'z'.
+  @retval Unchanged        Otherwise.
+
+**/
+CHAR16
+EFIAPI
+CharToUpper (
+  IN      CHAR16                    Char
+  );
+
+/**
+  Converts a lowercase Ascii character to upper one.
+
+  If Chr is lowercase Ascii character, then converts it to upper one.
+
+  If Value >= 0xA0, then ASSERT().
+  If (Value & 0x0F) >= 0x0A, then ASSERT().
+
+  @param  Chr   one Ascii character
+
+  @return The uppercase value of Ascii character
+
+**/
+CHAR8
+EFIAPI
+AsciiCharToUpper (
+  IN      CHAR8                     Chr
+  );
+
+/**
+  Convert binary data to a Base64 encoded ascii string based on RFC4648.
+
+  Produce a Null-terminated Ascii string in the output buffer specified by Destination and DestinationSize.
+  The Ascii string is produced by converting the data string specified by Source and SourceLength.
+
+  @param Source           Input UINT8 data
+  @param SourceLength     Number of UINT8 bytes of data
+  @param Destination      Pointer to output string buffer
+  @param DestinationSize  Size of ascii buffer. Set to 0 to get the size needed.
+                          Caller is responsible for passing in buffer of DestinationSize
+
+  @retval RETURN_SUCCESS             When ascii buffer is filled in.
+  @retval RETURN_INVALID_PARAMETER   If Source is NULL or DestinationSize is NULL.
+  @retval RETURN_INVALID_PARAMETER   If SourceLength or DestinationSize is bigger than (MAX_ADDRESS - (UINTN)Destination).
+  @retval RETURN_BUFFER_TOO_SMALL    If SourceLength is 0 and DestinationSize is <1.
+  @retval RETURN_BUFFER_TOO_SMALL    If Destination is NULL or DestinationSize is smaller than required buffersize.
+
+**/
+RETURN_STATUS
+EFIAPI
+Base64Encode (
+  IN  CONST UINT8  *Source,
+  IN        UINTN   SourceLength,
+  OUT       CHAR8  *Destination  OPTIONAL,
+  IN OUT    UINTN  *DestinationSize
+  );
+
+/**
+  Decode Base64 ASCII encoded data to 8-bit binary representation, based on
+  RFC4648.
+
+  Decoding occurs according to "Table 1: The Base 64 Alphabet" in RFC4648.
+
+  Whitespace is ignored at all positions:
+  - 0x09 ('\t') horizontal tab
+  - 0x0A ('\n') new line
+  - 0x0B ('\v') vertical tab
+  - 0x0C ('\f') form feed
+  - 0x0D ('\r') carriage return
+  - 0x20 (' ')  space
+
+  The minimum amount of required padding (with ASCII 0x3D, '=') is tolerated
+  and enforced at the end of the Base64 ASCII encoded data, and only there.
+
+  Other characters outside of the encoding alphabet cause the function to
+  reject the Base64 ASCII encoded data.
+
+  @param[in] Source               Array of CHAR8 elements containing the Base64
+                                  ASCII encoding. May be NULL if SourceSize is
+                                  zero.
+
+  @param[in] SourceSize           Number of CHAR8 elements in Source.
+
+  @param[out] Destination         Array of UINT8 elements receiving the decoded
+                                  8-bit binary representation. Allocated by the
+                                  caller. May be NULL if DestinationSize is
+                                  zero on input. If NULL, decoding is
+                                  performed, but the 8-bit binary
+                                  representation is not stored. If non-NULL and
+                                  the function returns an error, the contents
+                                  of Destination are indeterminate.
+
+  @param[in,out] DestinationSize  On input, the number of UINT8 elements that
+                                  the caller allocated for Destination. On
+                                  output, if the function returns
+                                  RETURN_SUCCESS or RETURN_BUFFER_TOO_SMALL,
+                                  the number of UINT8 elements that are
+                                  required for decoding the Base64 ASCII
+                                  representation. If the function returns a
+                                  value different from both RETURN_SUCCESS and
+                                  RETURN_BUFFER_TOO_SMALL, then DestinationSize
+                                  is indeterminate on output.
+
+  @retval RETURN_SUCCESS            SourceSize CHAR8 elements at Source have
+                                    been decoded to on-output DestinationSize
+                                    UINT8 elements at Destination. Note that
+                                    RETURN_SUCCESS covers the case when
+                                    DestinationSize is zero on input, and
+                                    Source decodes to zero bytes (due to
+                                    containing at most ignored whitespace).
+
+  @retval RETURN_BUFFER_TOO_SMALL   The input value of DestinationSize is not
+                                    large enough for decoding SourceSize CHAR8
+                                    elements at Source. The required number of
+                                    UINT8 elements has been stored to
+                                    DestinationSize.
+
+  @retval RETURN_INVALID_PARAMETER  DestinationSize is NULL.
+
+  @retval RETURN_INVALID_PARAMETER  Source is NULL, but SourceSize is not zero.
+
+  @retval RETURN_INVALID_PARAMETER  Destination is NULL, but DestinationSize is
+                                    not zero on input.
+
+  @retval RETURN_INVALID_PARAMETER  Source is non-NULL, and (Source +
+                                    SourceSize) would wrap around MAX_ADDRESS.
+
+  @retval RETURN_INVALID_PARAMETER  Destination is non-NULL, and (Destination +
+                                    DestinationSize) would wrap around
+                                    MAX_ADDRESS, as specified on input.
+
+  @retval RETURN_INVALID_PARAMETER  None of Source and Destination are NULL,
+                                    and CHAR8[SourceSize] at Source overlaps
+                                    UINT8[DestinationSize] at Destination, as
+                                    specified on input.
+
+  @retval RETURN_INVALID_PARAMETER  Invalid CHAR8 element encountered in
+                                    Source.
+**/
+RETURN_STATUS
+EFIAPI
+Base64Decode (
+  IN     CONST CHAR8 *Source          OPTIONAL,
+  IN     UINTN       SourceSize,
+  OUT    UINT8       *Destination     OPTIONAL,
+  IN OUT UINTN       *DestinationSize
+  );
+
+/**
+  Converts an 8-bit value to an 8-bit BCD value.
+
+  Converts the 8-bit value specified by Value to BCD. The BCD value is
+  returned.
+
+  If Value >= 100, then ASSERT().
+
+  @param  Value The 8-bit value to convert to BCD. Range 0..99.
+
+  @return The BCD value.
+
+**/
+UINT8
+EFIAPI
+DecimalToBcd8 (
+  IN      UINT8                     Value
+  );
+
+
+/**
+  Converts an 8-bit BCD value to an 8-bit value.
+
+  Converts the 8-bit BCD value specified by Value to an 8-bit value. The 8-bit
+  value is returned.
+
+  If Value >= 0xA0, then ASSERT().
+  If (Value & 0x0F) >= 0x0A, then ASSERT().
+
+  @param  Value The 8-bit BCD value to convert to an 8-bit value.
+
+  @return The 8-bit value is returned.
+
+**/
+UINT8
+EFIAPI
+BcdToDecimal8 (
+  IN      UINT8                     Value
+  );
+
+//
+//  File Path Manipulation Functions
+//
+
+/**
+  Removes the last directory or file entry in a path.
+
+  @param[in, out] Path    The pointer to the path to modify.
+
+  @retval FALSE     Nothing was found to remove.
+  @retval TRUE      A directory or file was removed.
+**/
+BOOLEAN
+EFIAPI
+PathRemoveLastItem(
+  IN OUT CHAR16 *Path
+  );
+
+/**
+  Function to clean up paths.
+    - Single periods in the path are removed.
+    - Double periods in the path are removed along with a single parent directory.
+    - Forward slashes L'/' are converted to backward slashes L'\'.
+
+  This will be done inline and the existing buffer may be larger than required
+  upon completion.
+
+  @param[in] Path       The pointer to the string containing the path.
+
+  @return       Returns Path, otherwise returns NULL to indicate that an error has occurred.
+**/
+CHAR16*
+EFIAPI
+PathCleanUpDirectories(
+  IN CHAR16 *Path
+  );
+
+//
+// Linked List Functions and Macros
+//
+
+/**
+  Initializes the head node of a doubly linked list that is declared as a
+  global variable in a module.
+
+  Initializes the forward and backward links of a new linked list. After
+  initializing a linked list with this macro, the other linked list functions
+  may be used to add and remove nodes from the linked list. This macro results
+  in smaller executables by initializing the linked list in the data section,
+  instead if calling the InitializeListHead() function to perform the
+  equivalent operation.
+
+  @param  ListHead  The head note of a list to initialize.
+
+**/
+#define INITIALIZE_LIST_HEAD_VARIABLE(ListHead)  {&(ListHead), &(ListHead)}
+
+/**
+  Iterates over each node in a doubly linked list using each node's forward link.
+
+  @param  Entry     A pointer to a list node used as a loop cursor during iteration
+  @param  ListHead  The head node of the doubly linked list
+
+**/
+#define BASE_LIST_FOR_EACH(Entry, ListHead)    \
+  for(Entry = (ListHead)->ForwardLink; Entry != (ListHead); Entry = Entry->ForwardLink)
+
+/**
+  Iterates over each node in a doubly linked list using each node's forward link
+  with safety against node removal.
+
+  This macro uses NextEntry to temporarily store the next list node so the node
+  pointed to by Entry may be deleted in the current loop iteration step and
+  iteration can continue from the node pointed to by NextEntry.
+
+  @param  Entry     A pointer to a list node used as a loop cursor during iteration
+  @param  NextEntry A pointer to a list node used to temporarily store the next node
+  @param  ListHead  The head node of the doubly linked list
+
+**/
+#define BASE_LIST_FOR_EACH_SAFE(Entry, NextEntry, ListHead)            \
+  for(Entry = (ListHead)->ForwardLink, NextEntry = Entry->ForwardLink;\
+      Entry != (ListHead); Entry = NextEntry, NextEntry = Entry->ForwardLink)
+
+/**
+  Checks whether FirstEntry and SecondEntry are part of the same doubly-linked
+  list.
+
+  If FirstEntry is NULL, then ASSERT().
+  If FirstEntry->ForwardLink is NULL, then ASSERT().
+  If FirstEntry->BackLink is NULL, then ASSERT().
+  If SecondEntry is NULL, then ASSERT();
+  If PcdMaximumLinkedListLength is not zero, and List contains more than
+  PcdMaximumLinkedListLength nodes, then ASSERT().
+
+  @param  FirstEntry   A pointer to a node in a linked list.
+  @param  SecondEntry  A pointer to the node to locate.
+
+  @retval TRUE   SecondEntry is in the same doubly-linked list as FirstEntry.
+  @retval FALSE  SecondEntry isn't in the same doubly-linked list as FirstEntry,
+                 or FirstEntry is invalid.
+
+**/
+BOOLEAN
+EFIAPI
+IsNodeInList (
+  IN      CONST LIST_ENTRY      *FirstEntry,
+  IN      CONST LIST_ENTRY      *SecondEntry
+  );
+
+
+/**
+  Initializes the head node of a doubly linked list, and returns the pointer to
+  the head node of the doubly linked list.
+
+  Initializes the forward and backward links of a new linked list. After
+  initializing a linked list with this function, the other linked list
+  functions may be used to add and remove nodes from the linked list. It is up
+  to the caller of this function to allocate the memory for ListHead.
+
+  If ListHead is NULL, then ASSERT().
+
+  @param  ListHead  A pointer to the head node of a new doubly linked list.
+
+  @return ListHead
+
+**/
+LIST_ENTRY *
+EFIAPI
+InitializeListHead (
+  IN OUT  LIST_ENTRY                *ListHead
+  );
+
+
+/**
+  Adds a node to the beginning of a doubly linked list, and returns the pointer
+  to the head node of the doubly linked list.
+
+  Adds the node Entry at the beginning of the doubly linked list denoted by
+  ListHead, and returns ListHead.
+
+  If ListHead is NULL, then ASSERT().
+  If Entry is NULL, then ASSERT().
+  If ListHead was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or
+  InitializeListHead(), then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and prior to insertion the number
+  of nodes in ListHead, including the ListHead node, is greater than or
+  equal to PcdMaximumLinkedListLength, then ASSERT().
+
+  @param  ListHead  A pointer to the head node of a doubly linked list.
+  @param  Entry     A pointer to a node that is to be inserted at the beginning
+                    of a doubly linked list.
+
+  @return ListHead
+
+**/
+LIST_ENTRY *
+EFIAPI
+InsertHeadList (
+  IN OUT  LIST_ENTRY                *ListHead,
+  IN OUT  LIST_ENTRY                *Entry
+  );
+
+
+/**
+  Adds a node to the end of a doubly linked list, and returns the pointer to
+  the head node of the doubly linked list.
+
+  Adds the node Entry to the end of the doubly linked list denoted by ListHead,
+  and returns ListHead.
+
+  If ListHead is NULL, then ASSERT().
+  If Entry is NULL, then ASSERT().
+  If ListHead was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or
+  InitializeListHead(), then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and prior to insertion the number
+  of nodes in ListHead, including the ListHead node, is greater than or
+  equal to PcdMaximumLinkedListLength, then ASSERT().
+
+  @param  ListHead  A pointer to the head node of a doubly linked list.
+  @param  Entry     A pointer to a node that is to be added at the end of the
+                    doubly linked list.
+
+  @return ListHead
+
+**/
+LIST_ENTRY *
+EFIAPI
+InsertTailList (
+  IN OUT  LIST_ENTRY                *ListHead,
+  IN OUT  LIST_ENTRY                *Entry
+  );
+
+
+/**
+  Retrieves the first node of a doubly linked list.
+
+  Returns the first node of a doubly linked list.  List must have been
+  initialized with INTIALIZE_LIST_HEAD_VARIABLE() or InitializeListHead().
+  If List is empty, then List is returned.
+
+  If List is NULL, then ASSERT().
+  If List was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or
+  InitializeListHead(), then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and the number of nodes
+  in List, including the List node, is greater than or equal to
+  PcdMaximumLinkedListLength, then ASSERT().
+
+  @param  List  A pointer to the head node of a doubly linked list.
+
+  @return The first node of a doubly linked list.
+  @retval List  The list is empty.
+
+**/
+LIST_ENTRY *
+EFIAPI
+GetFirstNode (
+  IN      CONST LIST_ENTRY          *List
+  );
+
+
+/**
+  Retrieves the next node of a doubly linked list.
+
+  Returns the node of a doubly linked list that follows Node.
+  List must have been initialized with INTIALIZE_LIST_HEAD_VARIABLE()
+  or InitializeListHead().  If List is empty, then List is returned.
+
+  If List is NULL, then ASSERT().
+  If Node is NULL, then ASSERT().
+  If List was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or
+  InitializeListHead(), then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and List contains more than
+  PcdMaximumLinkedListLength nodes, then ASSERT().
+  If PcdVerifyNodeInList is TRUE and Node is not a node in List, then ASSERT().
+
+  @param  List  A pointer to the head node of a doubly linked list.
+  @param  Node  A pointer to a node in the doubly linked list.
+
+  @return The pointer to the next node if one exists. Otherwise List is returned.
+
+**/
+LIST_ENTRY *
+EFIAPI
+GetNextNode (
+  IN      CONST LIST_ENTRY          *List,
+  IN      CONST LIST_ENTRY          *Node
+  );
+
+
+/**
+  Retrieves the previous node of a doubly linked list.
+
+  Returns the node of a doubly linked list that precedes Node.
+  List must have been initialized with INTIALIZE_LIST_HEAD_VARIABLE()
+  or InitializeListHead().  If List is empty, then List is returned.
+
+  If List is NULL, then ASSERT().
+  If Node is NULL, then ASSERT().
+  If List was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or
+  InitializeListHead(), then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and List contains more than
+  PcdMaximumLinkedListLength nodes, then ASSERT().
+  If PcdVerifyNodeInList is TRUE and Node is not a node in List, then ASSERT().
+
+  @param  List  A pointer to the head node of a doubly linked list.
+  @param  Node  A pointer to a node in the doubly linked list.
+
+  @return The pointer to the previous node if one exists. Otherwise List is returned.
+
+**/
+LIST_ENTRY *
+EFIAPI
+GetPreviousNode (
+  IN      CONST LIST_ENTRY          *List,
+  IN      CONST LIST_ENTRY          *Node
+  );
+
+
+/**
+  Checks to see if a doubly linked list is empty or not.
+
+  Checks to see if the doubly linked list is empty. If the linked list contains
+  zero nodes, this function returns TRUE. Otherwise, it returns FALSE.
+
+  If ListHead is NULL, then ASSERT().
+  If ListHead was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or
+  InitializeListHead(), then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and the number of nodes
+  in List, including the List node, is greater than or equal to
+  PcdMaximumLinkedListLength, then ASSERT().
+
+  @param  ListHead  A pointer to the head node of a doubly linked list.
+
+  @retval TRUE  The linked list is empty.
+  @retval FALSE The linked list is not empty.
+
+**/
+BOOLEAN
+EFIAPI
+IsListEmpty (
+  IN      CONST LIST_ENTRY          *ListHead
+  );
+
+
+/**
+  Determines if a node in a doubly linked list is the head node of a the same
+  doubly linked list.  This function is typically used to terminate a loop that
+  traverses all the nodes in a doubly linked list starting with the head node.
+
+  Returns TRUE if Node is equal to List.  Returns FALSE if Node is one of the
+  nodes in the doubly linked list specified by List.  List must have been
+  initialized with INTIALIZE_LIST_HEAD_VARIABLE() or InitializeListHead().
+
+  If List is NULL, then ASSERT().
+  If Node is NULL, then ASSERT().
+  If List was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or InitializeListHead(),
+  then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and the number of nodes
+  in List, including the List node, is greater than or equal to
+  PcdMaximumLinkedListLength, then ASSERT().
+  If PcdVerifyNodeInList is TRUE and Node is not a node in List the and Node is not equal
+  to List, then ASSERT().
+
+  @param  List  A pointer to the head node of a doubly linked list.
+  @param  Node  A pointer to a node in the doubly linked list.
+
+  @retval TRUE  Node is the head of the doubly-linked list pointed by List.
+  @retval FALSE Node is not the head of the doubly-linked list pointed by List.
+
+**/
+BOOLEAN
+EFIAPI
+IsNull (
+  IN      CONST LIST_ENTRY          *List,
+  IN      CONST LIST_ENTRY          *Node
+  );
+
+
+/**
+  Determines if a node the last node in a doubly linked list.
+
+  Returns TRUE if Node is the last node in the doubly linked list specified by
+  List. Otherwise, FALSE is returned. List must have been initialized with
+  INTIALIZE_LIST_HEAD_VARIABLE() or InitializeListHead().
+
+  If List is NULL, then ASSERT().
+  If Node is NULL, then ASSERT().
+  If List was not initialized with INTIALIZE_LIST_HEAD_VARIABLE() or
+  InitializeListHead(), then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and the number of nodes
+  in List, including the List node, is greater than or equal to
+  PcdMaximumLinkedListLength, then ASSERT().
+  If PcdVerifyNodeInList is TRUE and Node is not a node in List, then ASSERT().
+
+  @param  List  A pointer to the head node of a doubly linked list.
+  @param  Node  A pointer to a node in the doubly linked list.
+
+  @retval TRUE  Node is the last node in the linked list.
+  @retval FALSE Node is not the last node in the linked list.
+
+**/
+BOOLEAN
+EFIAPI
+IsNodeAtEnd (
+  IN      CONST LIST_ENTRY          *List,
+  IN      CONST LIST_ENTRY          *Node
+  );
+
+
+/**
+  Swaps the location of two nodes in a doubly linked list, and returns the
+  first node after the swap.
+
+  If FirstEntry is identical to SecondEntry, then SecondEntry is returned.
+  Otherwise, the location of the FirstEntry node is swapped with the location
+  of the SecondEntry node in a doubly linked list. SecondEntry must be in the
+  same double linked list as FirstEntry and that double linked list must have
+  been initialized with INTIALIZE_LIST_HEAD_VARIABLE() or InitializeListHead().
+  SecondEntry is returned after the nodes are swapped.
+
+  If FirstEntry is NULL, then ASSERT().
+  If SecondEntry is NULL, then ASSERT().
+  If PcdVerifyNodeInList is TRUE and SecondEntry and FirstEntry are not in the
+  same linked list, then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and the number of nodes in the
+  linked list containing the FirstEntry and SecondEntry nodes, including
+  the FirstEntry and SecondEntry nodes, is greater than or equal to
+  PcdMaximumLinkedListLength, then ASSERT().
+
+  @param  FirstEntry  A pointer to a node in a linked list.
+  @param  SecondEntry A pointer to another node in the same linked list.
+
+  @return SecondEntry.
+
+**/
+LIST_ENTRY *
+EFIAPI
+SwapListEntries (
+  IN OUT  LIST_ENTRY                *FirstEntry,
+  IN OUT  LIST_ENTRY                *SecondEntry
+  );
+
+
+/**
+  Removes a node from a doubly linked list, and returns the node that follows
+  the removed node.
+
+  Removes the node Entry from a doubly linked list. It is up to the caller of
+  this function to release the memory used by this node if that is required. On
+  exit, the node following Entry in the doubly linked list is returned. If
+  Entry is the only node in the linked list, then the head node of the linked
+  list is returned.
+
+  If Entry is NULL, then ASSERT().
+  If Entry is the head node of an empty list, then ASSERT().
+  If PcdMaximumLinkedListLength is not zero, and the number of nodes in the
+  linked list containing Entry, including the Entry node, is greater than
+  or equal to PcdMaximumLinkedListLength, then ASSERT().
+
+  @param  Entry A pointer to a node in a linked list.
+
+  @return Entry.
+
+**/
+LIST_ENTRY *
+EFIAPI
+RemoveEntryList (
+  IN      CONST LIST_ENTRY          *Entry
+  );
+
+//
+// Math Services
+//
+/**
+  Prototype for comparison function for any two element types.
+
+  @param[in] Buffer1                  The pointer to first buffer.
+  @param[in] Buffer2                  The pointer to second buffer.
+
+  @retval 0                           Buffer1 equal to Buffer2.
+  @return <0                          Buffer1 is less than Buffer2.
+  @return >0                          Buffer1 is greater than Buffer2.
+**/
+typedef
+INTN
+(EFIAPI *BASE_SORT_COMPARE)(
+  IN CONST VOID                 *Buffer1,
+  IN CONST VOID                 *Buffer2
+  );
+
+/**
+  This function is identical to perform QuickSort,
+  except that is uses the pre-allocated buffer so the in place sorting does not need to
+  allocate and free buffers constantly.
+
+  Each element must be equal sized.
+
+  if BufferToSort is NULL, then ASSERT.
+  if CompareFunction is NULL, then ASSERT.
+  if BufferOneElement is NULL, then ASSERT.
+  if ElementSize is < 1, then ASSERT.
+
+  if Count is < 2 then perform no action.
+
+  @param[in, out] BufferToSort   on call a Buffer of (possibly sorted) elements
+                                 on return a buffer of sorted elements
+  @param[in] Count               the number of elements in the buffer to sort
+  @param[in] ElementSize         Size of an element in bytes
+  @param[in] CompareFunction     The function to call to perform the comparison
+                                 of any 2 elements
+  @param[out] BufferOneElement   Caller provided buffer whose size equals to ElementSize.
+                                 It's used by QuickSort() for swapping in sorting.
+**/
+VOID
+EFIAPI
+QuickSort (
+  IN OUT VOID                           *BufferToSort,
+  IN CONST UINTN                        Count,
+  IN CONST UINTN                        ElementSize,
+  IN       BASE_SORT_COMPARE            CompareFunction,
+  OUT VOID                              *BufferOneElement
+  );
+
+/**
+  Shifts a 64-bit integer left between 0 and 63 bits. The low bits are filled
+  with zeros. The shifted value is returned.
+
+  This function shifts the 64-bit value Operand to the left by Count bits. The
+  low Count bits are set to zero. The shifted value is returned.
+
+  If Count is greater than 63, then ASSERT().
+
+  @param  Operand The 64-bit operand to shift left.
+  @param  Count   The number of bits to shift left.
+
+  @return Operand << Count.
+
+**/
+UINT64
+EFIAPI
+LShiftU64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     Count
+  );
+
+
+/**
+  Shifts a 64-bit integer right between 0 and 63 bits. This high bits are
+  filled with zeros. The shifted value is returned.
+
+  This function shifts the 64-bit value Operand to the right by Count bits. The
+  high Count bits are set to zero. The shifted value is returned.
+
+  If Count is greater than 63, then ASSERT().
+
+  @param  Operand The 64-bit operand to shift right.
+  @param  Count   The number of bits to shift right.
+
+  @return Operand >> Count
+
+**/
+UINT64
+EFIAPI
+RShiftU64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     Count
+  );
+
+
+/**
+  Shifts a 64-bit integer right between 0 and 63 bits. The high bits are filled
+  with original integer's bit 63. The shifted value is returned.
+
+  This function shifts the 64-bit value Operand to the right by Count bits. The
+  high Count bits are set to bit 63 of Operand.  The shifted value is returned.
+
+  If Count is greater than 63, then ASSERT().
+
+  @param  Operand The 64-bit operand to shift right.
+  @param  Count   The number of bits to shift right.
+
+  @return Operand >> Count
+
+**/
+UINT64
+EFIAPI
+ARShiftU64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     Count
+  );
+
+
+/**
+  Rotates a 32-bit integer left between 0 and 31 bits, filling the low bits
+  with the high bits that were rotated.
+
+  This function rotates the 32-bit value Operand to the left by Count bits. The
+  low Count bits are fill with the high Count bits of Operand. The rotated
+  value is returned.
+
+  If Count is greater than 31, then ASSERT().
+
+  @param  Operand The 32-bit operand to rotate left.
+  @param  Count   The number of bits to rotate left.
+
+  @return Operand << Count
+
+**/
+UINT32
+EFIAPI
+LRotU32 (
+  IN      UINT32                    Operand,
+  IN      UINTN                     Count
+  );
+
+
+/**
+  Rotates a 32-bit integer right between 0 and 31 bits, filling the high bits
+  with the low bits that were rotated.
+
+  This function rotates the 32-bit value Operand to the right by Count bits.
+  The high Count bits are fill with the low Count bits of Operand. The rotated
+  value is returned.
+
+  If Count is greater than 31, then ASSERT().
+
+  @param  Operand The 32-bit operand to rotate right.
+  @param  Count   The number of bits to rotate right.
+
+  @return Operand >> Count
+
+**/
+UINT32
+EFIAPI
+RRotU32 (
+  IN      UINT32                    Operand,
+  IN      UINTN                     Count
+  );
+
+
+/**
+  Rotates a 64-bit integer left between 0 and 63 bits, filling the low bits
+  with the high bits that were rotated.
+
+  This function rotates the 64-bit value Operand to the left by Count bits. The
+  low Count bits are fill with the high Count bits of Operand. The rotated
+  value is returned.
+
+  If Count is greater than 63, then ASSERT().
+
+  @param  Operand The 64-bit operand to rotate left.
+  @param  Count   The number of bits to rotate left.
+
+  @return Operand << Count
+
+**/
+UINT64
+EFIAPI
+LRotU64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     Count
+  );
+
+
+/**
+  Rotates a 64-bit integer right between 0 and 63 bits, filling the high bits
+  with the high low bits that were rotated.
+
+  This function rotates the 64-bit value Operand to the right by Count bits.
+  The high Count bits are fill with the low Count bits of Operand. The rotated
+  value is returned.
+
+  If Count is greater than 63, then ASSERT().
+
+  @param  Operand The 64-bit operand to rotate right.
+  @param  Count   The number of bits to rotate right.
+
+  @return Operand >> Count
+
+**/
+UINT64
+EFIAPI
+RRotU64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     Count
+  );
+
+
+/**
+  Returns the bit position of the lowest bit set in a 32-bit value.
+
+  This function computes the bit position of the lowest bit set in the 32-bit
+  value specified by Operand. If Operand is zero, then -1 is returned.
+  Otherwise, a value between 0 and 31 is returned.
+
+  @param  Operand The 32-bit operand to evaluate.
+
+  @retval 0..31  The lowest bit set in Operand was found.
+  @retval -1    Operand is zero.
+
+**/
+INTN
+EFIAPI
+LowBitSet32 (
+  IN      UINT32                    Operand
+  );
+
+
+/**
+  Returns the bit position of the lowest bit set in a 64-bit value.
+
+  This function computes the bit position of the lowest bit set in the 64-bit
+  value specified by Operand. If Operand is zero, then -1 is returned.
+  Otherwise, a value between 0 and 63 is returned.
+
+  @param  Operand The 64-bit operand to evaluate.
+
+  @retval 0..63  The lowest bit set in Operand was found.
+  @retval -1    Operand is zero.
+
+
+**/
+INTN
+EFIAPI
+LowBitSet64 (
+  IN      UINT64                    Operand
+  );
+
+
+/**
+  Returns the bit position of the highest bit set in a 32-bit value. Equivalent
+  to log2(x).
+
+  This function computes the bit position of the highest bit set in the 32-bit
+  value specified by Operand. If Operand is zero, then -1 is returned.
+  Otherwise, a value between 0 and 31 is returned.
+
+  @param  Operand The 32-bit operand to evaluate.
+
+  @retval 0..31  Position of the highest bit set in Operand if found.
+  @retval -1    Operand is zero.
+
+**/
+INTN
+EFIAPI
+HighBitSet32 (
+  IN      UINT32                    Operand
+  );
+
+
+/**
+  Returns the bit position of the highest bit set in a 64-bit value. Equivalent
+  to log2(x).
+
+  This function computes the bit position of the highest bit set in the 64-bit
+  value specified by Operand. If Operand is zero, then -1 is returned.
+  Otherwise, a value between 0 and 63 is returned.
+
+  @param  Operand The 64-bit operand to evaluate.
+
+  @retval 0..63   Position of the highest bit set in Operand if found.
+  @retval -1     Operand is zero.
+
+**/
+INTN
+EFIAPI
+HighBitSet64 (
+  IN      UINT64                    Operand
+  );
+
+
+/**
+  Returns the value of the highest bit set in a 32-bit value. Equivalent to
+  1 << log2(x).
+
+  This function computes the value of the highest bit set in the 32-bit value
+  specified by Operand. If Operand is zero, then zero is returned.
+
+  @param  Operand The 32-bit operand to evaluate.
+
+  @return 1 << HighBitSet32(Operand)
+  @retval 0 Operand is zero.
+
+**/
+UINT32
+EFIAPI
+GetPowerOfTwo32 (
+  IN      UINT32                    Operand
+  );
+
+
+/**
+  Returns the value of the highest bit set in a 64-bit value. Equivalent to
+  1 << log2(x).
+
+  This function computes the value of the highest bit set in the 64-bit value
+  specified by Operand. If Operand is zero, then zero is returned.
+
+  @param  Operand The 64-bit operand to evaluate.
+
+  @return 1 << HighBitSet64(Operand)
+  @retval 0 Operand is zero.
+
+**/
+UINT64
+EFIAPI
+GetPowerOfTwo64 (
+  IN      UINT64                    Operand
+  );
+
+
+/**
+  Switches the endianness of a 16-bit integer.
+
+  This function swaps the bytes in a 16-bit unsigned value to switch the value
+  from little endian to big endian or vice versa. The byte swapped value is
+  returned.
+
+  @param  Value A 16-bit unsigned value.
+
+  @return The byte swapped Value.
+
+**/
+UINT16
+EFIAPI
+SwapBytes16 (
+  IN      UINT16                    Value
+  );
+
+
+/**
+  Switches the endianness of a 32-bit integer.
+
+  This function swaps the bytes in a 32-bit unsigned value to switch the value
+  from little endian to big endian or vice versa. The byte swapped value is
+  returned.
+
+  @param  Value A 32-bit unsigned value.
+
+  @return The byte swapped Value.
+
+**/
+UINT32
+EFIAPI
+SwapBytes32 (
+  IN      UINT32                    Value
+  );
+
+
+/**
+  Switches the endianness of a 64-bit integer.
+
+  This function swaps the bytes in a 64-bit unsigned value to switch the value
+  from little endian to big endian or vice versa. The byte swapped value is
+  returned.
+
+  @param  Value A 64-bit unsigned value.
+
+  @return The byte swapped Value.
+
+**/
+UINT64
+EFIAPI
+SwapBytes64 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Multiples a 64-bit unsigned integer by a 32-bit unsigned integer and
+  generates a 64-bit unsigned result.
+
+  This function multiples the 64-bit unsigned value Multiplicand by the 32-bit
+  unsigned value Multiplier and generates a 64-bit unsigned result. This 64-
+  bit unsigned result is returned.
+
+  @param  Multiplicand  A 64-bit unsigned value.
+  @param  Multiplier    A 32-bit unsigned value.
+
+  @return Multiplicand * Multiplier
+
+**/
+UINT64
+EFIAPI
+MultU64x32 (
+  IN      UINT64                    Multiplicand,
+  IN      UINT32                    Multiplier
+  );
+
+
+/**
+  Multiples a 64-bit unsigned integer by a 64-bit unsigned integer and
+  generates a 64-bit unsigned result.
+
+  This function multiples the 64-bit unsigned value Multiplicand by the 64-bit
+  unsigned value Multiplier and generates a 64-bit unsigned result. This 64-
+  bit unsigned result is returned.
+
+  @param  Multiplicand  A 64-bit unsigned value.
+  @param  Multiplier    A 64-bit unsigned value.
+
+  @return Multiplicand * Multiplier.
+
+**/
+UINT64
+EFIAPI
+MultU64x64 (
+  IN      UINT64                    Multiplicand,
+  IN      UINT64                    Multiplier
+  );
+
+
+/**
+  Multiples a 64-bit signed integer by a 64-bit signed integer and generates a
+  64-bit signed result.
+
+  This function multiples the 64-bit signed value Multiplicand by the 64-bit
+  signed value Multiplier and generates a 64-bit signed result. This 64-bit
+  signed result is returned.
+
+  @param  Multiplicand  A 64-bit signed value.
+  @param  Multiplier    A 64-bit signed value.
+
+  @return Multiplicand * Multiplier
+
+**/
+INT64
+EFIAPI
+MultS64x64 (
+  IN      INT64                     Multiplicand,
+  IN      INT64                     Multiplier
+  );
+
+
+/**
+  Divides a 64-bit unsigned integer by a 32-bit unsigned integer and generates
+  a 64-bit unsigned result.
+
+  This function divides the 64-bit unsigned value Dividend by the 32-bit
+  unsigned value Divisor and generates a 64-bit unsigned quotient. This
+  function returns the 64-bit unsigned quotient.
+
+  If Divisor is 0, then ASSERT().
+
+  @param  Dividend  A 64-bit unsigned value.
+  @param  Divisor   A 32-bit unsigned value.
+
+  @return Dividend / Divisor.
+
+**/
+UINT64
+EFIAPI
+DivU64x32 (
+  IN      UINT64                    Dividend,
+  IN      UINT32                    Divisor
+  );
+
+
+/**
+  Divides a 64-bit unsigned integer by a 32-bit unsigned integer and generates
+  a 32-bit unsigned remainder.
+
+  This function divides the 64-bit unsigned value Dividend by the 32-bit
+  unsigned value Divisor and generates a 32-bit remainder. This function
+  returns the 32-bit unsigned remainder.
+
+  If Divisor is 0, then ASSERT().
+
+  @param  Dividend  A 64-bit unsigned value.
+  @param  Divisor   A 32-bit unsigned value.
+
+  @return Dividend % Divisor.
+
+**/
+UINT32
+EFIAPI
+ModU64x32 (
+  IN      UINT64                    Dividend,
+  IN      UINT32                    Divisor
+  );
+
+
+/**
+  Divides a 64-bit unsigned integer by a 32-bit unsigned integer and generates
+  a 64-bit unsigned result and an optional 32-bit unsigned remainder.
+
+  This function divides the 64-bit unsigned value Dividend by the 32-bit
+  unsigned value Divisor and generates a 64-bit unsigned quotient. If Remainder
+  is not NULL, then the 32-bit unsigned remainder is returned in Remainder.
+  This function returns the 64-bit unsigned quotient.
+
+  If Divisor is 0, then ASSERT().
+
+  @param  Dividend  A 64-bit unsigned value.
+  @param  Divisor   A 32-bit unsigned value.
+  @param  Remainder A pointer to a 32-bit unsigned value. This parameter is
+                    optional and may be NULL.
+
+  @return Dividend / Divisor.
+
+**/
+UINT64
+EFIAPI
+DivU64x32Remainder (
+  IN      UINT64                    Dividend,
+  IN      UINT32                    Divisor,
+  OUT     UINT32                    *Remainder  OPTIONAL
+  );
+
+
+/**
+  Divides a 64-bit unsigned integer by a 64-bit unsigned integer and generates
+  a 64-bit unsigned result and an optional 64-bit unsigned remainder.
+
+  This function divides the 64-bit unsigned value Dividend by the 64-bit
+  unsigned value Divisor and generates a 64-bit unsigned quotient. If Remainder
+  is not NULL, then the 64-bit unsigned remainder is returned in Remainder.
+  This function returns the 64-bit unsigned quotient.
+
+  If Divisor is 0, then ASSERT().
+
+  @param  Dividend  A 64-bit unsigned value.
+  @param  Divisor   A 64-bit unsigned value.
+  @param  Remainder A pointer to a 64-bit unsigned value. This parameter is
+                    optional and may be NULL.
+
+  @return Dividend / Divisor.
+
+**/
+UINT64
+EFIAPI
+DivU64x64Remainder (
+  IN      UINT64                    Dividend,
+  IN      UINT64                    Divisor,
+  OUT     UINT64                    *Remainder  OPTIONAL
+  );
+
+
+/**
+  Divides a 64-bit signed integer by a 64-bit signed integer and generates a
+  64-bit signed result and a optional 64-bit signed remainder.
+
+  This function divides the 64-bit signed value Dividend by the 64-bit signed
+  value Divisor and generates a 64-bit signed quotient. If Remainder is not
+  NULL, then the 64-bit signed remainder is returned in Remainder. This
+  function returns the 64-bit signed quotient.
+
+  It is the caller's responsibility to not call this function with a Divisor of 0.
+  If Divisor is 0, then the quotient and remainder should be assumed to be
+  the largest negative integer.
+
+  If Divisor is 0, then ASSERT().
+
+  @param  Dividend  A 64-bit signed value.
+  @param  Divisor   A 64-bit signed value.
+  @param  Remainder A pointer to a 64-bit signed value. This parameter is
+                    optional and may be NULL.
+
+  @return Dividend / Divisor.
+
+**/
+INT64
+EFIAPI
+DivS64x64Remainder (
+  IN      INT64                     Dividend,
+  IN      INT64                     Divisor,
+  OUT     INT64                     *Remainder  OPTIONAL
+  );
+
+
+/**
+  Reads a 16-bit value from memory that may be unaligned.
+
+  This function returns the 16-bit value pointed to by Buffer. The function
+  guarantees that the read operation does not produce an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 16-bit value that may be unaligned.
+
+  @return The 16-bit value read from Buffer.
+
+**/
+UINT16
+EFIAPI
+ReadUnaligned16 (
+  IN CONST UINT16              *Buffer
+  );
+
+
+/**
+  Writes a 16-bit value to memory that may be unaligned.
+
+  This function writes the 16-bit value specified by Value to Buffer. Value is
+  returned. The function guarantees that the write operation does not produce
+  an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 16-bit value that may be unaligned.
+  @param  Value   16-bit value to write to Buffer.
+
+  @return The 16-bit value to write to Buffer.
+
+**/
+UINT16
+EFIAPI
+WriteUnaligned16 (
+  OUT UINT16                    *Buffer,
+  IN  UINT16                    Value
+  );
+
+
+/**
+  Reads a 24-bit value from memory that may be unaligned.
+
+  This function returns the 24-bit value pointed to by Buffer. The function
+  guarantees that the read operation does not produce an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 24-bit value that may be unaligned.
+
+  @return The 24-bit value read from Buffer.
+
+**/
+UINT32
+EFIAPI
+ReadUnaligned24 (
+  IN CONST UINT32              *Buffer
+  );
+
+
+/**
+  Writes a 24-bit value to memory that may be unaligned.
+
+  This function writes the 24-bit value specified by Value to Buffer. Value is
+  returned. The function guarantees that the write operation does not produce
+  an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 24-bit value that may be unaligned.
+  @param  Value   24-bit value to write to Buffer.
+
+  @return The 24-bit value to write to Buffer.
+
+**/
+UINT32
+EFIAPI
+WriteUnaligned24 (
+  OUT UINT32                    *Buffer,
+  IN  UINT32                    Value
+  );
+
+
+/**
+  Reads a 32-bit value from memory that may be unaligned.
+
+  This function returns the 32-bit value pointed to by Buffer. The function
+  guarantees that the read operation does not produce an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 32-bit value that may be unaligned.
+
+  @return The 32-bit value read from Buffer.
+
+**/
+UINT32
+EFIAPI
+ReadUnaligned32 (
+  IN CONST UINT32              *Buffer
+  );
+
+
+/**
+  Writes a 32-bit value to memory that may be unaligned.
+
+  This function writes the 32-bit value specified by Value to Buffer. Value is
+  returned. The function guarantees that the write operation does not produce
+  an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 32-bit value that may be unaligned.
+  @param  Value   32-bit value to write to Buffer.
+
+  @return The 32-bit value to write to Buffer.
+
+**/
+UINT32
+EFIAPI
+WriteUnaligned32 (
+  OUT UINT32                    *Buffer,
+  IN  UINT32                    Value
+  );
+
+
+/**
+  Reads a 64-bit value from memory that may be unaligned.
+
+  This function returns the 64-bit value pointed to by Buffer. The function
+  guarantees that the read operation does not produce an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 64-bit value that may be unaligned.
+
+  @return The 64-bit value read from Buffer.
+
+**/
+UINT64
+EFIAPI
+ReadUnaligned64 (
+  IN CONST UINT64              *Buffer
+  );
+
+
+/**
+  Writes a 64-bit value to memory that may be unaligned.
+
+  This function writes the 64-bit value specified by Value to Buffer. Value is
+  returned. The function guarantees that the write operation does not produce
+  an alignment fault.
+
+  If the Buffer is NULL, then ASSERT().
+
+  @param  Buffer  The pointer to a 64-bit value that may be unaligned.
+  @param  Value   64-bit value to write to Buffer.
+
+  @return The 64-bit value to write to Buffer.
+
+**/
+UINT64
+EFIAPI
+WriteUnaligned64 (
+  OUT UINT64                    *Buffer,
+  IN  UINT64                    Value
+  );
+
+
+//
+// Bit Field Functions
+//
+
+/**
+  Returns a bit field from an 8-bit value.
+
+  Returns the bitfield specified by the StartBit and the EndBit from Operand.
+
+  If 8-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+
+  @return The bit field read.
+
+**/
+UINT8
+EFIAPI
+BitFieldRead8 (
+  IN      UINT8                     Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+
+/**
+  Writes a bit field to an 8-bit value, and returns the result.
+
+  Writes Value to the bit field specified by the StartBit and the EndBit in
+  Operand. All other bits in Operand are preserved. The new 8-bit value is
+  returned.
+
+  If 8-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  Value     New value of the bit field.
+
+  @return The new 8-bit value.
+
+**/
+UINT8
+EFIAPI
+BitFieldWrite8 (
+  IN      UINT8                     Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     Value
+  );
+
+
+/**
+  Reads a bit field from an 8-bit value, performs a bitwise OR, and returns the
+  result.
+
+  Performs a bitwise OR between the bit field specified by StartBit
+  and EndBit in Operand and the value specified by OrData. All other bits in
+  Operand are preserved. The new 8-bit value is returned.
+
+  If 8-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  OrData    The value to OR with the read value from the value
+
+  @return The new 8-bit value.
+
+**/
+UINT8
+EFIAPI
+BitFieldOr8 (
+  IN      UINT8                     Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     OrData
+  );
+
+
+/**
+  Reads a bit field from an 8-bit value, performs a bitwise AND, and returns
+  the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData. All other bits in Operand are
+  preserved. The new 8-bit value is returned.
+
+  If 8-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with the read value from the value.
+
+  @return The new 8-bit value.
+
+**/
+UINT8
+EFIAPI
+BitFieldAnd8 (
+  IN      UINT8                     Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData
+  );
+
+
+/**
+  Reads a bit field from an 8-bit value, performs a bitwise AND followed by a
+  bitwise OR, and returns the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData, followed by a bitwise
+  OR with value specified by OrData. All other bits in Operand are
+  preserved. The new 8-bit value is returned.
+
+  If 8-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with the read value from the value.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The new 8-bit value.
+
+**/
+UINT8
+EFIAPI
+BitFieldAndThenOr8 (
+  IN      UINT8                     Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData,
+  IN      UINT8                     OrData
+  );
+
+
+/**
+  Returns a bit field from a 16-bit value.
+
+  Returns the bitfield specified by the StartBit and the EndBit from Operand.
+
+  If 16-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+
+  @return The bit field read.
+
+**/
+UINT16
+EFIAPI
+BitFieldRead16 (
+  IN      UINT16                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+
+/**
+  Writes a bit field to a 16-bit value, and returns the result.
+
+  Writes Value to the bit field specified by the StartBit and the EndBit in
+  Operand. All other bits in Operand are preserved. The new 16-bit value is
+  returned.
+
+  If 16-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  Value     New value of the bit field.
+
+  @return The new 16-bit value.
+
+**/
+UINT16
+EFIAPI
+BitFieldWrite16 (
+  IN      UINT16                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    Value
+  );
+
+
+/**
+  Reads a bit field from a 16-bit value, performs a bitwise OR, and returns the
+  result.
+
+  Performs a bitwise OR between the bit field specified by StartBit
+  and EndBit in Operand and the value specified by OrData. All other bits in
+  Operand are preserved. The new 16-bit value is returned.
+
+  If 16-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  OrData    The value to OR with the read value from the value
+
+  @return The new 16-bit value.
+
+**/
+UINT16
+EFIAPI
+BitFieldOr16 (
+  IN      UINT16                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    OrData
+  );
+
+
+/**
+  Reads a bit field from a 16-bit value, performs a bitwise AND, and returns
+  the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData. All other bits in Operand are
+  preserved. The new 16-bit value is returned.
+
+  If 16-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with the read value from the value
+
+  @return The new 16-bit value.
+
+**/
+UINT16
+EFIAPI
+BitFieldAnd16 (
+  IN      UINT16                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData
+  );
+
+
+/**
+  Reads a bit field from a 16-bit value, performs a bitwise AND followed by a
+  bitwise OR, and returns the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData, followed by a bitwise
+  OR with value specified by OrData. All other bits in Operand are
+  preserved. The new 16-bit value is returned.
+
+  If 16-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with the read value from the value.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The new 16-bit value.
+
+**/
+UINT16
+EFIAPI
+BitFieldAndThenOr16 (
+  IN      UINT16                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData,
+  IN      UINT16                    OrData
+  );
+
+
+/**
+  Returns a bit field from a 32-bit value.
+
+  Returns the bitfield specified by the StartBit and the EndBit from Operand.
+
+  If 32-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+
+  @return The bit field read.
+
+**/
+UINT32
+EFIAPI
+BitFieldRead32 (
+  IN      UINT32                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+
+/**
+  Writes a bit field to a 32-bit value, and returns the result.
+
+  Writes Value to the bit field specified by the StartBit and the EndBit in
+  Operand. All other bits in Operand are preserved. The new 32-bit value is
+  returned.
+
+  If 32-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  Value     New value of the bit field.
+
+  @return The new 32-bit value.
+
+**/
+UINT32
+EFIAPI
+BitFieldWrite32 (
+  IN      UINT32                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    Value
+  );
+
+
+/**
+  Reads a bit field from a 32-bit value, performs a bitwise OR, and returns the
+  result.
+
+  Performs a bitwise OR between the bit field specified by StartBit
+  and EndBit in Operand and the value specified by OrData. All other bits in
+  Operand are preserved. The new 32-bit value is returned.
+
+  If 32-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  OrData    The value to OR with the read value from the value.
+
+  @return The new 32-bit value.
+
+**/
+UINT32
+EFIAPI
+BitFieldOr32 (
+  IN      UINT32                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    OrData
+  );
+
+
+/**
+  Reads a bit field from a 32-bit value, performs a bitwise AND, and returns
+  the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData. All other bits in Operand are
+  preserved. The new 32-bit value is returned.
+
+  If 32-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the read value from the value
+
+  @return The new 32-bit value.
+
+**/
+UINT32
+EFIAPI
+BitFieldAnd32 (
+  IN      UINT32                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData
+  );
+
+
+/**
+  Reads a bit field from a 32-bit value, performs a bitwise AND followed by a
+  bitwise OR, and returns the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData, followed by a bitwise
+  OR with value specified by OrData. All other bits in Operand are
+  preserved. The new 32-bit value is returned.
+
+  If 32-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the read value from the value.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The new 32-bit value.
+
+**/
+UINT32
+EFIAPI
+BitFieldAndThenOr32 (
+  IN      UINT32                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  );
+
+
+/**
+  Returns a bit field from a 64-bit value.
+
+  Returns the bitfield specified by the StartBit and the EndBit from Operand.
+
+  If 64-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+
+  @return The bit field read.
+
+**/
+UINT64
+EFIAPI
+BitFieldRead64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+
+/**
+  Writes a bit field to a 64-bit value, and returns the result.
+
+  Writes Value to the bit field specified by the StartBit and the EndBit in
+  Operand. All other bits in Operand are preserved. The new 64-bit value is
+  returned.
+
+  If 64-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  Value     New value of the bit field.
+
+  @return The new 64-bit value.
+
+**/
+UINT64
+EFIAPI
+BitFieldWrite64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Reads a bit field from a 64-bit value, performs a bitwise OR, and returns the
+  result.
+
+  Performs a bitwise OR between the bit field specified by StartBit
+  and EndBit in Operand and the value specified by OrData. All other bits in
+  Operand are preserved. The new 64-bit value is returned.
+
+  If 64-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  OrData    The value to OR with the read value from the value
+
+  @return The new 64-bit value.
+
+**/
+UINT64
+EFIAPI
+BitFieldOr64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    OrData
+  );
+
+
+/**
+  Reads a bit field from a 64-bit value, performs a bitwise AND, and returns
+  the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData. All other bits in Operand are
+  preserved. The new 64-bit value is returned.
+
+  If 64-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with the read value from the value
+
+  @return The new 64-bit value.
+
+**/
+UINT64
+EFIAPI
+BitFieldAnd64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData
+  );
+
+
+/**
+  Reads a bit field from a 64-bit value, performs a bitwise AND followed by a
+  bitwise OR, and returns the result.
+
+  Performs a bitwise AND between the bit field specified by StartBit and EndBit
+  in Operand and the value specified by AndData, followed by a bitwise
+  OR with value specified by OrData. All other bits in Operand are
+  preserved. The new 64-bit value is returned.
+
+  If 64-bit operations are not supported, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with the read value from the value.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The new 64-bit value.
+
+**/
+UINT64
+EFIAPI
+BitFieldAndThenOr64 (
+  IN      UINT64                    Operand,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads a bit field from a 32-bit value, counts and returns
+  the number of set bits.
+
+  Counts the number of set bits in the  bit field specified by
+  StartBit and EndBit in Operand. The count is returned.
+
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Operand   Operand on which to perform the bitfield operation.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+
+  @return The number of bits set between StartBit and EndBit.
+
+**/
+UINT8
+EFIAPI
+BitFieldCountOnes32 (
+  IN       UINT32                   Operand,
+  IN       UINTN                    StartBit,
+  IN       UINTN                    EndBit
+  );
+
+/**
+   Reads a bit field from a 64-bit value, counts and returns
+   the number of set bits.
+
+   Counts the number of set bits in the  bit field specified by
+   StartBit and EndBit in Operand. The count is returned.
+
+   If StartBit is greater than 63, then ASSERT().
+   If EndBit is greater than 63, then ASSERT().
+   If EndBit is less than StartBit, then ASSERT().
+
+   @param  Operand   Operand on which to perform the bitfield operation.
+   @param  StartBit  The ordinal of the least significant bit in the bit field.
+   Range 0..63.
+   @param  EndBit    The ordinal of the most significant bit in the bit field.
+   Range 0..63.
+
+   @return The number of bits set between StartBit and EndBit.
+
+**/
+UINT8
+EFIAPI
+BitFieldCountOnes64 (
+  IN       UINT64                   Operand,
+  IN       UINTN                    StartBit,
+  IN       UINTN                    EndBit
+  );
+
+//
+// Base Library Checksum Functions
+//
+
+/**
+  Returns the sum of all elements in a buffer in unit of UINT8.
+  During calculation, the carry bits are dropped.
+
+  This function calculates the sum of all elements in a buffer
+  in unit of UINT8. The carry bits in result of addition are dropped.
+  The result is returned as UINT8. If Length is Zero, then Zero is
+  returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the sum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Sum         The sum of Buffer with carry bits dropped during additions.
+
+**/
+UINT8
+EFIAPI
+CalculateSum8 (
+  IN      CONST UINT8              *Buffer,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the two's complement checksum of all elements in a buffer
+  of 8-bit values.
+
+  This function first calculates the sum of the 8-bit values in the
+  buffer specified by Buffer and Length.  The carry bits in the result
+  of addition are dropped. Then, the two's complement of the sum is
+  returned.  If Length is 0, then 0 is returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the checksum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Checksum    The two's complement checksum of Buffer.
+
+**/
+UINT8
+EFIAPI
+CalculateCheckSum8 (
+  IN      CONST UINT8              *Buffer,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the sum of all elements in a buffer of 16-bit values.  During
+  calculation, the carry bits are dropped.
+
+  This function calculates the sum of the 16-bit values in the buffer
+  specified by Buffer and Length. The carry bits in result of addition are dropped.
+  The 16-bit result is returned.  If Length is 0, then 0 is returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 16-bit boundary, then ASSERT().
+  If Length is not aligned on a 16-bit boundary, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the sum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Sum         The sum of Buffer with carry bits dropped during additions.
+
+**/
+UINT16
+EFIAPI
+CalculateSum16 (
+  IN      CONST UINT16             *Buffer,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the two's complement checksum of all elements in a buffer of
+  16-bit values.
+
+  This function first calculates the sum of the 16-bit values in the buffer
+  specified by Buffer and Length.  The carry bits in the result of addition
+  are dropped. Then, the two's complement of the sum is returned.  If Length
+  is 0, then 0 is returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 16-bit boundary, then ASSERT().
+  If Length is not aligned on a 16-bit boundary, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the checksum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Checksum    The two's complement checksum of Buffer.
+
+**/
+UINT16
+EFIAPI
+CalculateCheckSum16 (
+  IN      CONST UINT16             *Buffer,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the sum of all elements in a buffer of 32-bit values. During
+  calculation, the carry bits are dropped.
+
+  This function calculates the sum of the 32-bit values in the buffer
+  specified by Buffer and Length. The carry bits in result of addition are dropped.
+  The 32-bit result is returned. If Length is 0, then 0 is returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 32-bit boundary, then ASSERT().
+  If Length is not aligned on a 32-bit boundary, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the sum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Sum         The sum of Buffer with carry bits dropped during additions.
+
+**/
+UINT32
+EFIAPI
+CalculateSum32 (
+  IN      CONST UINT32             *Buffer,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the two's complement checksum of all elements in a buffer of
+  32-bit values.
+
+  This function first calculates the sum of the 32-bit values in the buffer
+  specified by Buffer and Length.  The carry bits in the result of addition
+  are dropped. Then, the two's complement of the sum is returned.  If Length
+  is 0, then 0 is returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 32-bit boundary, then ASSERT().
+  If Length is not aligned on a 32-bit boundary, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the checksum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Checksum    The two's complement checksum of Buffer.
+
+**/
+UINT32
+EFIAPI
+CalculateCheckSum32 (
+  IN      CONST UINT32             *Buffer,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the sum of all elements in a buffer of 64-bit values.  During
+  calculation, the carry bits are dropped.
+
+  This function calculates the sum of the 64-bit values in the buffer
+  specified by Buffer and Length. The carry bits in result of addition are dropped.
+  The 64-bit result is returned.  If Length is 0, then 0 is returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 64-bit boundary, then ASSERT().
+  If Length is not aligned on a 64-bit boundary, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the sum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Sum         The sum of Buffer with carry bits dropped during additions.
+
+**/
+UINT64
+EFIAPI
+CalculateSum64 (
+  IN      CONST UINT64             *Buffer,
+  IN      UINTN                     Length
+  );
+
+
+/**
+  Returns the two's complement checksum of all elements in a buffer of
+  64-bit values.
+
+  This function first calculates the sum of the 64-bit values in the buffer
+  specified by Buffer and Length.  The carry bits in the result of addition
+  are dropped. Then, the two's complement of the sum is returned.  If Length
+  is 0, then 0 is returned.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 64-bit boundary, then ASSERT().
+  If Length is not aligned on a 64-bit boundary, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param  Buffer      The pointer to the buffer to carry out the checksum operation.
+  @param  Length      The size, in bytes, of Buffer.
+
+  @return Checksum    The two's complement checksum of Buffer.
+
+**/
+UINT64
+EFIAPI
+CalculateCheckSum64 (
+  IN      CONST UINT64             *Buffer,
+  IN      UINTN                     Length
+  );
+
+/**
+  Computes and returns a 32-bit CRC for a data buffer.
+  CRC32 value bases on ITU-T V.42.
+
+  If Buffer is NULL, then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  @param[in]  Buffer       A pointer to the buffer on which the 32-bit CRC is to be computed.
+  @param[in]  Length       The number of bytes in the buffer Data.
+
+  @retval Crc32            The 32-bit CRC was computed for the data buffer.
+
+**/
+UINT32
+EFIAPI
+CalculateCrc32(
+  IN  VOID                         *Buffer,
+  IN  UINTN                        Length
+  );
+
+//
+// Base Library CPU Functions
+//
+
+/**
+  Function entry point used when a stack switch is requested with SwitchStack()
+
+  @param  Context1        Context1 parameter passed into SwitchStack().
+  @param  Context2        Context2 parameter passed into SwitchStack().
+
+**/
+typedef
+VOID
+(EFIAPI *SWITCH_STACK_ENTRY_POINT)(
+  IN      VOID                      *Context1,  OPTIONAL
+  IN      VOID                      *Context2   OPTIONAL
+  );
+
+
+/**
+  Used to serialize load and store operations.
+
+  All loads and stores that proceed calls to this function are guaranteed to be
+  globally visible when this function returns.
+
+**/
+VOID
+EFIAPI
+MemoryFence (
+  VOID
+  );
+
+
+/**
+  Saves the current CPU context that can be restored with a call to LongJump()
+  and returns 0.
+
+  Saves the current CPU context in the buffer specified by JumpBuffer and
+  returns 0. The initial call to SetJump() must always return 0. Subsequent
+  calls to LongJump() cause a non-zero value to be returned by SetJump().
+
+  If JumpBuffer is NULL, then ASSERT().
+  For Itanium processors, if JumpBuffer is not aligned on a 16-byte boundary, then ASSERT().
+
+  NOTE: The structure BASE_LIBRARY_JUMP_BUFFER is CPU architecture specific.
+  The same structure must never be used for more than one CPU architecture context.
+  For example, a BASE_LIBRARY_JUMP_BUFFER allocated by an IA-32 module must never be used from an x64 module.
+  SetJump()/LongJump() is not currently supported for the EBC processor type.
+
+  @param  JumpBuffer  A pointer to CPU context buffer.
+
+  @retval 0 Indicates a return from SetJump().
+
+**/
+RETURNS_TWICE
+UINTN
+EFIAPI
+SetJump (
+  OUT     BASE_LIBRARY_JUMP_BUFFER  *JumpBuffer
+  );
+
+
+/**
+  Restores the CPU context that was saved with SetJump().
+
+  Restores the CPU context from the buffer specified by JumpBuffer. This
+  function never returns to the caller. Instead is resumes execution based on
+  the state of JumpBuffer.
+
+  If JumpBuffer is NULL, then ASSERT().
+  For Itanium processors, if JumpBuffer is not aligned on a 16-byte boundary, then ASSERT().
+  If Value is 0, then ASSERT().
+
+  @param  JumpBuffer  A pointer to CPU context buffer.
+  @param  Value       The value to return when the SetJump() context is
+                      restored and must be non-zero.
+
+**/
+VOID
+EFIAPI
+LongJump (
+  IN      BASE_LIBRARY_JUMP_BUFFER  *JumpBuffer,
+  IN      UINTN                     Value
+  );
+
+
+/**
+  Enables CPU interrupts.
+
+**/
+VOID
+EFIAPI
+EnableInterrupts (
+  VOID
+  );
+
+
+/**
+  Disables CPU interrupts.
+
+**/
+VOID
+EFIAPI
+DisableInterrupts (
+  VOID
+  );
+
+
+/**
+  Disables CPU interrupts and returns the interrupt state prior to the disable
+  operation.
+
+  @retval TRUE  CPU interrupts were enabled on entry to this call.
+  @retval FALSE CPU interrupts were disabled on entry to this call.
+
+**/
+BOOLEAN
+EFIAPI
+SaveAndDisableInterrupts (
+  VOID
+  );
+
+
+/**
+  Enables CPU interrupts for the smallest window required to capture any
+  pending interrupts.
+
+**/
+VOID
+EFIAPI
+EnableDisableInterrupts (
+  VOID
+  );
+
+
+/**
+  Retrieves the current CPU interrupt state.
+
+  Returns TRUE if interrupts are currently enabled. Otherwise
+  returns FALSE.
+
+  @retval TRUE  CPU interrupts are enabled.
+  @retval FALSE CPU interrupts are disabled.
+
+**/
+BOOLEAN
+EFIAPI
+GetInterruptState (
+  VOID
+  );
+
+
+/**
+  Set the current CPU interrupt state.
+
+  Sets the current CPU interrupt state to the state specified by
+  InterruptState. If InterruptState is TRUE, then interrupts are enabled. If
+  InterruptState is FALSE, then interrupts are disabled. InterruptState is
+  returned.
+
+  @param  InterruptState  TRUE if interrupts should enabled. FALSE if
+                          interrupts should be disabled.
+
+  @return InterruptState
+
+**/
+BOOLEAN
+EFIAPI
+SetInterruptState (
+  IN      BOOLEAN                   InterruptState
+  );
+
+
+/**
+  Requests CPU to pause for a short period of time.
+
+  Requests CPU to pause for a short period of time. Typically used in MP
+  systems to prevent memory starvation while waiting for a spin lock.
+
+**/
+VOID
+EFIAPI
+CpuPause (
+  VOID
+  );
+
+
+/**
+  Transfers control to a function starting with a new stack.
+
+  Transfers control to the function specified by EntryPoint using the
+  new stack specified by NewStack and passing in the parameters specified
+  by Context1 and Context2.  Context1 and Context2 are optional and may
+  be NULL.  The function EntryPoint must never return.  This function
+  supports a variable number of arguments following the NewStack parameter.
+  These additional arguments are ignored on IA-32, x64, and EBC architectures.
+  Itanium processors expect one additional parameter of type VOID * that specifies
+  the new backing store pointer.
+
+  If EntryPoint is NULL, then ASSERT().
+  If NewStack is NULL, then ASSERT().
+
+  @param  EntryPoint  A pointer to function to call with the new stack.
+  @param  Context1    A pointer to the context to pass into the EntryPoint
+                      function.
+  @param  Context2    A pointer to the context to pass into the EntryPoint
+                      function.
+  @param  NewStack    A pointer to the new stack to use for the EntryPoint
+                      function.
+  @param  ...         This variable argument list is ignored for IA-32, x64, and
+                      EBC architectures.  For Itanium processors, this variable
+                      argument list is expected to contain a single parameter of
+                      type VOID * that specifies the new backing store pointer.
+
+
+**/
+VOID
+EFIAPI
+SwitchStack (
+  IN      SWITCH_STACK_ENTRY_POINT  EntryPoint,
+  IN      VOID                      *Context1,  OPTIONAL
+  IN      VOID                      *Context2,  OPTIONAL
+  IN      VOID                      *NewStack,
+  ...
+  );
+
+
+/**
+  Generates a breakpoint on the CPU.
+
+  Generates a breakpoint on the CPU. The breakpoint must be implemented such
+  that code can resume normal execution after the breakpoint.
+
+**/
+VOID
+EFIAPI
+CpuBreakpoint (
+  VOID
+  );
+
+
+/**
+  Executes an infinite loop.
+
+  Forces the CPU to execute an infinite loop. A debugger may be used to skip
+  past the loop and the code that follows the loop must execute properly. This
+  implies that the infinite loop must not cause the code that follow it to be
+  optimized away.
+
+**/
+VOID
+EFIAPI
+CpuDeadLoop (
+  VOID
+  );
+
+
+/**
+  Uses as a barrier to stop speculative execution.
+
+  Ensures that no later instruction will execute speculatively, until all prior
+  instructions have completed.
+
+**/
+VOID
+EFIAPI
+SpeculationBarrier (
+  VOID
+  );
+
+#if defined (MDE_CPU_X64)
+//
+// The page size for the PVALIDATE instruction
+//
+typedef enum {
+  PvalidatePageSize4K = 0,
+  PvalidatePageSize2MB,
+} PVALIDATE_PAGE_SIZE;
+
+//
+// PVALIDATE Return Code.
+//
+#define PVALIDATE_RET_SUCCESS         0
+#define PVALIDATE_RET_FAIL_INPUT      1
+#define PVALIDATE_RET_SIZE_MISMATCH   6
+
+//
+// The PVALIDATE instruction did not make any changes to the RMP entry.
+//
+#define PVALIDATE_RET_NO_RMPUPDATE    255
+
+/**
+ Execute a PVALIDATE instruction to validate or to rescinds validation of a guest
+ page's RMP entry.
+
+ The instruction is available only when CPUID Fn8000_001F_EAX[SNP]=1.
+
+ The function is available on X64.
+
+ @param[in]    PageSize         The page size to use.
+ @param[in]    Validate         If TRUE, validate the guest virtual address
+                                otherwise invalidate the guest virtual address.
+ @param[in]    Address          The guest virtual address.
+
+ @retval PVALIDATE_RET_SUCCESS        The PVALIDATE instruction succeeded, and
+                                      updated the RMP entry.
+ @retval PVALIDATE_RET_NO_RMPUPDATE   The PVALIDATE instruction succeeded, but
+                                      did not update the RMP entry.
+ @return                              Failure code from the PVALIDATE
+                                      instruction.
+**/
+UINT32
+EFIAPI
+AsmPvalidate (
+  IN   PVALIDATE_PAGE_SIZE     PageSize,
+  IN   BOOLEAN                 Validate,
+  IN   PHYSICAL_ADDRESS        Address
+  );
+
+//
+// RDX settings for RMPADJUST
+//
+#define RMPADJUST_VMPL_MAX               3
+#define RMPADJUST_VMPL_MASK              0xFF
+#define RMPADJUST_VMPL_SHIFT             0
+#define RMPADJUST_PERMISSION_MASK_MASK   0xFF
+#define RMPADJUST_PERMISSION_MASK_SHIFT  8
+#define RMPADJUST_VMSA_PAGE_BIT          BIT16
+
+/**
+  Adjusts the permissions of an SEV-SNP guest page.
+
+  Executes a RMPADJUST instruction with the register state specified by Rax,
+  Rcx, and Rdx. Returns Eax. This function is only available on X64.
+
+  The instruction is available only when CPUID Fn8000_001F_EAX[SNP]=1.
+
+  @param[in]  Rax   The value to load into RAX before executing the RMPADJUST
+                    instruction.
+  @param[in]  Rcx   The value to load into RCX before executing the RMPADJUST
+                    instruction.
+  @param[in]  Rdx   The value to load into RDX before executing the RMPADJUST
+                    instruction.
+
+  @return     Eax
+**/
+UINT32
+EFIAPI
+AsmRmpAdjust (
+  IN      UINT64                     Rax,
+  IN      UINT64                     Rcx,
+  IN      UINT64                     Rdx
+  );
+#endif
+
+
+#if defined (MDE_CPU_IA32) || defined (MDE_CPU_X64)
+///
+/// IA32 and x64 Specific Functions.
+/// Byte packed structure for 16-bit Real Mode EFLAGS.
+///
+typedef union {
+  struct {
+    UINT32  CF:1;           ///< Carry Flag.
+    UINT32  Reserved_0:1;   ///< Reserved.
+    UINT32  PF:1;           ///< Parity Flag.
+    UINT32  Reserved_1:1;   ///< Reserved.
+    UINT32  AF:1;           ///< Auxiliary Carry Flag.
+    UINT32  Reserved_2:1;   ///< Reserved.
+    UINT32  ZF:1;           ///< Zero Flag.
+    UINT32  SF:1;           ///< Sign Flag.
+    UINT32  TF:1;           ///< Trap Flag.
+    UINT32  IF:1;           ///< Interrupt Enable Flag.
+    UINT32  DF:1;           ///< Direction Flag.
+    UINT32  OF:1;           ///< Overflow Flag.
+    UINT32  IOPL:2;         ///< I/O Privilege Level.
+    UINT32  NT:1;           ///< Nested Task.
+    UINT32  Reserved_3:1;   ///< Reserved.
+  } Bits;
+  UINT16    Uint16;
+} IA32_FLAGS16;
+
+///
+/// Byte packed structure for EFLAGS/RFLAGS.
+/// 32-bits on IA-32.
+/// 64-bits on x64.  The upper 32-bits on x64 are reserved.
+///
+typedef union {
+  struct {
+    UINT32  CF:1;           ///< Carry Flag.
+    UINT32  Reserved_0:1;   ///< Reserved.
+    UINT32  PF:1;           ///< Parity Flag.
+    UINT32  Reserved_1:1;   ///< Reserved.
+    UINT32  AF:1;           ///< Auxiliary Carry Flag.
+    UINT32  Reserved_2:1;   ///< Reserved.
+    UINT32  ZF:1;           ///< Zero Flag.
+    UINT32  SF:1;           ///< Sign Flag.
+    UINT32  TF:1;           ///< Trap Flag.
+    UINT32  IF:1;           ///< Interrupt Enable Flag.
+    UINT32  DF:1;           ///< Direction Flag.
+    UINT32  OF:1;           ///< Overflow Flag.
+    UINT32  IOPL:2;         ///< I/O Privilege Level.
+    UINT32  NT:1;           ///< Nested Task.
+    UINT32  Reserved_3:1;   ///< Reserved.
+    UINT32  RF:1;           ///< Resume Flag.
+    UINT32  VM:1;           ///< Virtual 8086 Mode.
+    UINT32  AC:1;           ///< Alignment Check.
+    UINT32  VIF:1;          ///< Virtual Interrupt Flag.
+    UINT32  VIP:1;          ///< Virtual Interrupt Pending.
+    UINT32  ID:1;           ///< ID Flag.
+    UINT32  Reserved_4:10;  ///< Reserved.
+  } Bits;
+  UINTN     UintN;
+} IA32_EFLAGS32;
+
+///
+/// Byte packed structure for Control Register 0 (CR0).
+/// 32-bits on IA-32.
+/// 64-bits on x64.  The upper 32-bits on x64 are reserved.
+///
+typedef union {
+  struct {
+    UINT32  PE:1;           ///< Protection Enable.
+    UINT32  MP:1;           ///< Monitor Coprocessor.
+    UINT32  EM:1;           ///< Emulation.
+    UINT32  TS:1;           ///< Task Switched.
+    UINT32  ET:1;           ///< Extension Type.
+    UINT32  NE:1;           ///< Numeric Error.
+    UINT32  Reserved_0:10;  ///< Reserved.
+    UINT32  WP:1;           ///< Write Protect.
+    UINT32  Reserved_1:1;   ///< Reserved.
+    UINT32  AM:1;           ///< Alignment Mask.
+    UINT32  Reserved_2:10;  ///< Reserved.
+    UINT32  NW:1;           ///< Mot Write-through.
+    UINT32  CD:1;           ///< Cache Disable.
+    UINT32  PG:1;           ///< Paging.
+  } Bits;
+  UINTN     UintN;
+} IA32_CR0;
+
+///
+/// Byte packed structure for Control Register 4 (CR4).
+/// 32-bits on IA-32.
+/// 64-bits on x64.  The upper 32-bits on x64 are reserved.
+///
+typedef union {
+  struct {
+    UINT32  VME:1;          ///< Virtual-8086 Mode Extensions.
+    UINT32  PVI:1;          ///< Protected-Mode Virtual Interrupts.
+    UINT32  TSD:1;          ///< Time Stamp Disable.
+    UINT32  DE:1;           ///< Debugging Extensions.
+    UINT32  PSE:1;          ///< Page Size Extensions.
+    UINT32  PAE:1;          ///< Physical Address Extension.
+    UINT32  MCE:1;          ///< Machine Check Enable.
+    UINT32  PGE:1;          ///< Page Global Enable.
+    UINT32  PCE:1;          ///< Performance Monitoring Counter
+                            ///< Enable.
+    UINT32  OSFXSR:1;       ///< Operating System Support for
+                            ///< FXSAVE and FXRSTOR instructions
+    UINT32  OSXMMEXCPT:1;   ///< Operating System Support for
+                            ///< Unmasked SIMD Floating Point
+                            ///< Exceptions.
+    UINT32  UMIP:1;         ///< User-Mode Instruction Prevention.
+    UINT32  LA57:1;         ///< Linear Address 57bit.
+    UINT32  VMXE:1;         ///< VMX Enable.
+    UINT32  SMXE:1;         ///< SMX Enable.
+    UINT32  Reserved_3:1;   ///< Reserved.
+    UINT32  FSGSBASE:1;     ///< FSGSBASE Enable.
+    UINT32  PCIDE:1;        ///< PCID Enable.
+    UINT32  OSXSAVE:1;      ///< XSAVE and Processor Extended States Enable.
+    UINT32  Reserved_4:1;   ///< Reserved.
+    UINT32  SMEP:1;         ///< SMEP Enable.
+    UINT32  SMAP:1;         ///< SMAP Enable.
+    UINT32  PKE:1;          ///< Protection-Key Enable.
+    UINT32  Reserved_5:9;   ///< Reserved.
+  } Bits;
+  UINTN     UintN;
+} IA32_CR4;
+
+///
+/// Byte packed structure for a segment descriptor in a GDT/LDT.
+///
+typedef union {
+  struct {
+    UINT32  LimitLow:16;
+    UINT32  BaseLow:16;
+    UINT32  BaseMid:8;
+    UINT32  Type:4;
+    UINT32  S:1;
+    UINT32  DPL:2;
+    UINT32  P:1;
+    UINT32  LimitHigh:4;
+    UINT32  AVL:1;
+    UINT32  L:1;
+    UINT32  DB:1;
+    UINT32  G:1;
+    UINT32  BaseHigh:8;
+  } Bits;
+  UINT64  Uint64;
+} IA32_SEGMENT_DESCRIPTOR;
+
+///
+/// Byte packed structure for an IDTR, GDTR, LDTR descriptor.
+///
+#pragma pack (1)
+typedef struct {
+  UINT16  Limit;
+  UINTN   Base;
+} IA32_DESCRIPTOR;
+#pragma pack ()
+
+#define IA32_IDT_GATE_TYPE_TASK          0x85
+#define IA32_IDT_GATE_TYPE_INTERRUPT_16  0x86
+#define IA32_IDT_GATE_TYPE_TRAP_16       0x87
+#define IA32_IDT_GATE_TYPE_INTERRUPT_32  0x8E
+#define IA32_IDT_GATE_TYPE_TRAP_32       0x8F
+
+#define IA32_GDT_TYPE_TSS               0x9
+#define IA32_GDT_ALIGNMENT              8
+
+#if defined (MDE_CPU_IA32)
+///
+/// Byte packed structure for an IA-32 Interrupt Gate Descriptor.
+///
+typedef union {
+  struct {
+    UINT32  OffsetLow:16;   ///< Offset bits 15..0.
+    UINT32  Selector:16;    ///< Selector.
+    UINT32  Reserved_0:8;   ///< Reserved.
+    UINT32  GateType:8;     ///< Gate Type.  See #defines above.
+    UINT32  OffsetHigh:16;  ///< Offset bits 31..16.
+  } Bits;
+  UINT64  Uint64;
+} IA32_IDT_GATE_DESCRIPTOR;
+
+#pragma pack (1)
+//
+// IA32 Task-State Segment Definition
+//
+typedef struct {
+  UINT16    PreviousTaskLink;
+  UINT16    Reserved_2;
+  UINT32    ESP0;
+  UINT16    SS0;
+  UINT16    Reserved_10;
+  UINT32    ESP1;
+  UINT16    SS1;
+  UINT16    Reserved_18;
+  UINT32    ESP2;
+  UINT16    SS2;
+  UINT16    Reserved_26;
+  UINT32    CR3;
+  UINT32    EIP;
+  UINT32    EFLAGS;
+  UINT32    EAX;
+  UINT32    ECX;
+  UINT32    EDX;
+  UINT32    EBX;
+  UINT32    ESP;
+  UINT32    EBP;
+  UINT32    ESI;
+  UINT32    EDI;
+  UINT16    ES;
+  UINT16    Reserved_74;
+  UINT16    CS;
+  UINT16    Reserved_78;
+  UINT16    SS;
+  UINT16    Reserved_82;
+  UINT16    DS;
+  UINT16    Reserved_86;
+  UINT16    FS;
+  UINT16    Reserved_90;
+  UINT16    GS;
+  UINT16    Reserved_94;
+  UINT16    LDTSegmentSelector;
+  UINT16    Reserved_98;
+  UINT16    T;
+  UINT16    IOMapBaseAddress;
+} IA32_TASK_STATE_SEGMENT;
+
+typedef union {
+  struct {
+    UINT32  LimitLow:16;    ///< Segment Limit 15..00
+    UINT32  BaseLow:16;     ///< Base Address  15..00
+    UINT32  BaseMid:8;      ///< Base Address  23..16
+    UINT32  Type:4;         ///< Type (1 0 B 1)
+    UINT32  Reserved_43:1;  ///< 0
+    UINT32  DPL:2;          ///< Descriptor Privilege Level
+    UINT32  P:1;            ///< Segment Present
+    UINT32  LimitHigh:4;    ///< Segment Limit 19..16
+    UINT32  AVL:1;          ///< Available for use by system software
+    UINT32  Reserved_52:2;  ///< 0 0
+    UINT32  G:1;            ///< Granularity
+    UINT32  BaseHigh:8;     ///< Base Address 31..24
+  } Bits;
+  UINT64  Uint64;
+} IA32_TSS_DESCRIPTOR;
+#pragma pack ()
+
+#endif // defined (MDE_CPU_IA32)
+
+#if defined (MDE_CPU_X64)
+///
+/// Byte packed structure for an x64 Interrupt Gate Descriptor.
+///
+typedef union {
+  struct {
+    UINT32  OffsetLow:16;   ///< Offset bits 15..0.
+    UINT32  Selector:16;    ///< Selector.
+    UINT32  Reserved_0:8;   ///< Reserved.
+    UINT32  GateType:8;     ///< Gate Type.  See #defines above.
+    UINT32  OffsetHigh:16;  ///< Offset bits 31..16.
+    UINT32  OffsetUpper:32; ///< Offset bits 63..32.
+    UINT32  Reserved_1:32;  ///< Reserved.
+  } Bits;
+  struct {
+    UINT64  Uint64;
+    UINT64  Uint64_1;
+  } Uint128;
+} IA32_IDT_GATE_DESCRIPTOR;
+
+#pragma pack (1)
+//
+// IA32 Task-State Segment Definition
+//
+typedef struct {
+  UINT32    Reserved_0;
+  UINT64    RSP0;
+  UINT64    RSP1;
+  UINT64    RSP2;
+  UINT64    Reserved_28;
+  UINT64    IST[7];
+  UINT64    Reserved_92;
+  UINT16    Reserved_100;
+  UINT16    IOMapBaseAddress;
+} IA32_TASK_STATE_SEGMENT;
+
+typedef union {
+  struct {
+    UINT32  LimitLow:16;    ///< Segment Limit 15..00
+    UINT32  BaseLow:16;     ///< Base Address  15..00
+    UINT32  BaseMidl:8;     ///< Base Address  23..16
+    UINT32  Type:4;         ///< Type (1 0 B 1)
+    UINT32  Reserved_43:1;  ///< 0
+    UINT32  DPL:2;          ///< Descriptor Privilege Level
+    UINT32  P:1;            ///< Segment Present
+    UINT32  LimitHigh:4;    ///< Segment Limit 19..16
+    UINT32  AVL:1;          ///< Available for use by system software
+    UINT32  Reserved_52:2;  ///< 0 0
+    UINT32  G:1;            ///< Granularity
+    UINT32  BaseMidh:8;     ///< Base Address  31..24
+    UINT32  BaseHigh:32;    ///< Base Address  63..32
+    UINT32  Reserved_96:32; ///< Reserved
+  } Bits;
+  struct {
+    UINT64  Uint64;
+    UINT64  Uint64_1;
+  } Uint128;
+} IA32_TSS_DESCRIPTOR;
+#pragma pack ()
+
+#endif // defined (MDE_CPU_X64)
+
+///
+/// Byte packed structure for an FP/SSE/SSE2 context.
+///
+typedef struct {
+  UINT8  Buffer[512];
+} IA32_FX_BUFFER;
+
+///
+/// Structures for the 16-bit real mode thunks.
+///
+typedef struct {
+  UINT32                            Reserved1;
+  UINT32                            Reserved2;
+  UINT32                            Reserved3;
+  UINT32                            Reserved4;
+  UINT8                             BL;
+  UINT8                             BH;
+  UINT16                            Reserved5;
+  UINT8                             DL;
+  UINT8                             DH;
+  UINT16                            Reserved6;
+  UINT8                             CL;
+  UINT8                             CH;
+  UINT16                            Reserved7;
+  UINT8                             AL;
+  UINT8                             AH;
+  UINT16                            Reserved8;
+} IA32_BYTE_REGS;
+
+typedef struct {
+  UINT16                            DI;
+  UINT16                            Reserved1;
+  UINT16                            SI;
+  UINT16                            Reserved2;
+  UINT16                            BP;
+  UINT16                            Reserved3;
+  UINT16                            SP;
+  UINT16                            Reserved4;
+  UINT16                            BX;
+  UINT16                            Reserved5;
+  UINT16                            DX;
+  UINT16                            Reserved6;
+  UINT16                            CX;
+  UINT16                            Reserved7;
+  UINT16                            AX;
+  UINT16                            Reserved8;
+} IA32_WORD_REGS;
+
+typedef struct {
+  UINT32                            EDI;
+  UINT32                            ESI;
+  UINT32                            EBP;
+  UINT32                            ESP;
+  UINT32                            EBX;
+  UINT32                            EDX;
+  UINT32                            ECX;
+  UINT32                            EAX;
+  UINT16                            DS;
+  UINT16                            ES;
+  UINT16                            FS;
+  UINT16                            GS;
+  IA32_EFLAGS32                     EFLAGS;
+  UINT32                            Eip;
+  UINT16                            CS;
+  UINT16                            SS;
+} IA32_DWORD_REGS;
+
+typedef union {
+  IA32_DWORD_REGS                   E;
+  IA32_WORD_REGS                    X;
+  IA32_BYTE_REGS                    H;
+} IA32_REGISTER_SET;
+
+///
+/// Byte packed structure for an 16-bit real mode thunks.
+///
+typedef struct {
+  IA32_REGISTER_SET                 *RealModeState;
+  VOID                              *RealModeBuffer;
+  UINT32                            RealModeBufferSize;
+  UINT32                            ThunkAttributes;
+} THUNK_CONTEXT;
+
+#define THUNK_ATTRIBUTE_BIG_REAL_MODE             0x00000001
+#define THUNK_ATTRIBUTE_DISABLE_A20_MASK_INT_15   0x00000002
+#define THUNK_ATTRIBUTE_DISABLE_A20_MASK_KBD_CTRL 0x00000004
+
+///
+/// Type definition for representing labels in NASM source code that allow for
+/// the patching of immediate operands of IA32 and X64 instructions.
+///
+/// While the type is technically defined as a function type (note: not a
+/// pointer-to-function type), such labels in NASM source code never stand for
+/// actual functions, and identifiers declared with this function type should
+/// never be called. This is also why the EFIAPI calling convention specifier
+/// is missing from the typedef, and why the typedef does not follow the usual
+/// edk2 coding style for function (or pointer-to-function) typedefs. The VOID
+/// return type and the VOID argument list are merely artifacts.
+///
+typedef VOID (X86_ASSEMBLY_PATCH_LABEL) (VOID);
+
+/**
+  Retrieves CPUID information.
+
+  Executes the CPUID instruction with EAX set to the value specified by Index.
+  This function always returns Index.
+  If Eax is not NULL, then the value of EAX after CPUID is returned in Eax.
+  If Ebx is not NULL, then the value of EBX after CPUID is returned in Ebx.
+  If Ecx is not NULL, then the value of ECX after CPUID is returned in Ecx.
+  If Edx is not NULL, then the value of EDX after CPUID is returned in Edx.
+  This function is only available on IA-32 and x64.
+
+  @param  Index The 32-bit value to load into EAX prior to invoking the CPUID
+                instruction.
+  @param  Eax   The pointer to the 32-bit EAX value returned by the CPUID
+                instruction. This is an optional parameter that may be NULL.
+  @param  Ebx   The pointer to the 32-bit EBX value returned by the CPUID
+                instruction. This is an optional parameter that may be NULL.
+  @param  Ecx   The pointer to the 32-bit ECX value returned by the CPUID
+                instruction. This is an optional parameter that may be NULL.
+  @param  Edx   The pointer to the 32-bit EDX value returned by the CPUID
+                instruction. This is an optional parameter that may be NULL.
+
+  @return Index.
+
+**/
+UINT32
+EFIAPI
+AsmCpuid (
+  IN      UINT32                    Index,
+  OUT     UINT32                    *Eax,  OPTIONAL
+  OUT     UINT32                    *Ebx,  OPTIONAL
+  OUT     UINT32                    *Ecx,  OPTIONAL
+  OUT     UINT32                    *Edx   OPTIONAL
+  );
+
+
+/**
+  Retrieves CPUID information using an extended leaf identifier.
+
+  Executes the CPUID instruction with EAX set to the value specified by Index
+  and ECX set to the value specified by SubIndex. This function always returns
+  Index. This function is only available on IA-32 and x64.
+
+  If Eax is not NULL, then the value of EAX after CPUID is returned in Eax.
+  If Ebx is not NULL, then the value of EBX after CPUID is returned in Ebx.
+  If Ecx is not NULL, then the value of ECX after CPUID is returned in Ecx.
+  If Edx is not NULL, then the value of EDX after CPUID is returned in Edx.
+
+  @param  Index     The 32-bit value to load into EAX prior to invoking the
+                    CPUID instruction.
+  @param  SubIndex  The 32-bit value to load into ECX prior to invoking the
+                    CPUID instruction.
+  @param  Eax       The pointer to the 32-bit EAX value returned by the CPUID
+                    instruction. This is an optional parameter that may be
+                    NULL.
+  @param  Ebx       The pointer to the 32-bit EBX value returned by the CPUID
+                    instruction. This is an optional parameter that may be
+                    NULL.
+  @param  Ecx       The pointer to the 32-bit ECX value returned by the CPUID
+                    instruction. This is an optional parameter that may be
+                    NULL.
+  @param  Edx       The pointer to the 32-bit EDX value returned by the CPUID
+                    instruction. This is an optional parameter that may be
+                    NULL.
+
+  @return Index.
+
+**/
+UINT32
+EFIAPI
+AsmCpuidEx (
+  IN      UINT32                    Index,
+  IN      UINT32                    SubIndex,
+  OUT     UINT32                    *Eax,  OPTIONAL
+  OUT     UINT32                    *Ebx,  OPTIONAL
+  OUT     UINT32                    *Ecx,  OPTIONAL
+  OUT     UINT32                    *Edx   OPTIONAL
+  );
+
+
+/**
+  Set CD bit and clear NW bit of CR0 followed by a WBINVD.
+
+  Disables the caches by setting the CD bit of CR0 to 1, clearing the NW bit of CR0 to 0,
+  and executing a WBINVD instruction.  This function is only available on IA-32 and x64.
+
+**/
+VOID
+EFIAPI
+AsmDisableCache (
+  VOID
+  );
+
+
+/**
+  Perform a WBINVD and clear both the CD and NW bits of CR0.
+
+  Enables the caches by executing a WBINVD instruction and then clear both the CD and NW
+  bits of CR0 to 0.  This function is only available on IA-32 and x64.
+
+**/
+VOID
+EFIAPI
+AsmEnableCache (
+  VOID
+  );
+
+
+/**
+  Returns the lower 32-bits of a Machine Specific Register(MSR).
+
+  Reads and returns the lower 32-bits of the MSR specified by Index.
+  No parameter checking is performed on Index, and some Index values may cause
+  CPU exceptions. The caller must either guarantee that Index is valid, or the
+  caller must set up exception handlers to catch the exceptions. This function
+  is only available on IA-32 and x64.
+
+  @param  Index The 32-bit MSR index to read.
+
+  @return The lower 32 bits of the MSR identified by Index.
+
+**/
+UINT32
+EFIAPI
+AsmReadMsr32 (
+  IN      UINT32                    Index
+  );
+
+
+/**
+  Writes a 32-bit value to a Machine Specific Register(MSR), and returns the value.
+  The upper 32-bits of the MSR are set to zero.
+
+  Writes the 32-bit value specified by Value to the MSR specified by Index. The
+  upper 32-bits of the MSR write are set to zero. The 32-bit value written to
+  the MSR is returned. No parameter checking is performed on Index or Value,
+  and some of these may cause CPU exceptions. The caller must either guarantee
+  that Index and Value are valid, or the caller must establish proper exception
+  handlers. This function is only available on IA-32 and x64.
+
+  @param  Index The 32-bit MSR index to write.
+  @param  Value The 32-bit value to write to the MSR.
+
+  @return Value
+
+**/
+UINT32
+EFIAPI
+AsmWriteMsr32 (
+  IN      UINT32                    Index,
+  IN      UINT32                    Value
+  );
+
+
+/**
+  Reads a 64-bit MSR, performs a bitwise OR on the lower 32-bits, and
+  writes the result back to the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise OR
+  between the lower 32-bits of the read result and the value specified by
+  OrData, and writes the result to the 64-bit MSR specified by Index. The lower
+  32-bits of the value written to the MSR is returned. No parameter checking is
+  performed on Index or OrData, and some of these may cause CPU exceptions. The
+  caller must either guarantee that Index and OrData are valid, or the caller
+  must establish proper exception handlers. This function is only available on
+  IA-32 and x64.
+
+  @param  Index   The 32-bit MSR index to write.
+  @param  OrData  The value to OR with the read value from the MSR.
+
+  @return The lower 32-bit value written to the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrOr32 (
+  IN      UINT32                    Index,
+  IN      UINT32                    OrData
+  );
+
+
+/**
+  Reads a 64-bit MSR, performs a bitwise AND on the lower 32-bits, and writes
+  the result back to the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND between the
+  lower 32-bits of the read result and the value specified by AndData, and
+  writes the result to the 64-bit MSR specified by Index. The lower 32-bits of
+  the value written to the MSR is returned. No parameter checking is performed
+  on Index or AndData, and some of these may cause CPU exceptions. The caller
+  must either guarantee that Index and AndData are valid, or the caller must
+  establish proper exception handlers. This function is only available on IA-32
+  and x64.
+
+  @param  Index   The 32-bit MSR index to write.
+  @param  AndData The value to AND with the read value from the MSR.
+
+  @return The lower 32-bit value written to the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrAnd32 (
+  IN      UINT32                    Index,
+  IN      UINT32                    AndData
+  );
+
+
+/**
+  Reads a 64-bit MSR, performs a bitwise AND followed by a bitwise OR
+  on the lower 32-bits, and writes the result back to the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND between the
+  lower 32-bits of the read result and the value specified by AndData
+  preserving the upper 32-bits, performs a bitwise OR between the
+  result of the AND operation and the value specified by OrData, and writes the
+  result to the 64-bit MSR specified by Address. The lower 32-bits of the value
+  written to the MSR is returned. No parameter checking is performed on Index,
+  AndData, or OrData, and some of these may cause CPU exceptions. The caller
+  must either guarantee that Index, AndData, and OrData are valid, or the
+  caller must establish proper exception handlers. This function is only
+  available on IA-32 and x64.
+
+  @param  Index   The 32-bit MSR index to write.
+  @param  AndData The value to AND with the read value from the MSR.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The lower 32-bit value written to the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrAndThenOr32 (
+  IN      UINT32                    Index,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  );
+
+
+/**
+  Reads a bit field of an MSR.
+
+  Reads the bit field in the lower 32-bits of a 64-bit MSR. The bit field is
+  specified by the StartBit and the EndBit. The value of the bit field is
+  returned. The caller must either guarantee that Index is valid, or the caller
+  must set up exception handlers to catch the exceptions. This function is only
+  available on IA-32 and x64.
+
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+
+  @return The bit field read from the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrBitFieldRead32 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+
+/**
+  Writes a bit field to an MSR.
+
+  Writes Value to a bit field in the lower 32-bits of a 64-bit MSR. The bit
+  field is specified by the StartBit and the EndBit. All other bits in the
+  destination MSR are preserved. The lower 32-bits of the MSR written is
+  returned. The caller must either guarantee that Index and the data written
+  is valid, or the caller must set up exception handlers to catch the exceptions.
+  This function is only available on IA-32 and x64.
+
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  Value     New value of the bit field.
+
+  @return The lower 32-bit of the value written to the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrBitFieldWrite32 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    Value
+  );
+
+
+/**
+  Reads a bit field in a 64-bit MSR, performs a bitwise OR, and writes the
+  result back to the bit field in the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 64-bit MSR specified by Index. The lower 32-bits of the value
+  written to the MSR are returned. Extra left bits in OrData are stripped. The
+  caller must either guarantee that Index and the data written is valid, or
+  the caller must set up exception handlers to catch the exceptions. This
+  function is only available on IA-32 and x64.
+
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  OrData    The value to OR with the read value from the MSR.
+
+  @return The lower 32-bit of the value written to the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrBitFieldOr32 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    OrData
+  );
+
+
+/**
+  Reads a bit field in a 64-bit MSR, performs a bitwise AND, and writes the
+  result back to the bit field in the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND between the
+  read result and the value specified by AndData, and writes the result to the
+  64-bit MSR specified by Index. The lower 32-bits of the value written to the
+  MSR are returned. Extra left bits in AndData are stripped. The caller must
+  either guarantee that Index and the data written is valid, or the caller must
+  set up exception handlers to catch the exceptions. This function is only
+  available on IA-32 and x64.
+
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the read value from the MSR.
+
+  @return The lower 32-bit of the value written to the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrBitFieldAnd32 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData
+  );
+
+
+/**
+  Reads a bit field in a 64-bit MSR, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND followed by a
+  bitwise OR between the read result and the value specified by
+  AndData, and writes the result to the 64-bit MSR specified by Index. The
+  lower 32-bits of the value written to the MSR are returned. Extra left bits
+  in both AndData and OrData are stripped. The caller must either guarantee
+  that Index and the data written is valid, or the caller must set up exception
+  handlers to catch the exceptions. This function is only available on IA-32
+  and x64.
+
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the read value from the MSR.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The lower 32-bit of the value written to the MSR.
+
+**/
+UINT32
+EFIAPI
+AsmMsrBitFieldAndThenOr32 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  );
+
+
+/**
+  Returns a 64-bit Machine Specific Register(MSR).
+
+  Reads and returns the 64-bit MSR specified by Index. No parameter checking is
+  performed on Index, and some Index values may cause CPU exceptions. The
+  caller must either guarantee that Index is valid, or the caller must set up
+  exception handlers to catch the exceptions. This function is only available
+  on IA-32 and x64.
+
+  @param  Index The 32-bit MSR index to read.
+
+  @return The value of the MSR identified by Index.
+
+**/
+UINT64
+EFIAPI
+AsmReadMsr64 (
+  IN      UINT32                    Index
+  );
+
+
+/**
+  Writes a 64-bit value to a Machine Specific Register(MSR), and returns the
+  value.
+
+  Writes the 64-bit value specified by Value to the MSR specified by Index. The
+  64-bit value written to the MSR is returned. No parameter checking is
+  performed on Index or Value, and some of these may cause CPU exceptions. The
+  caller must either guarantee that Index and Value are valid, or the caller
+  must establish proper exception handlers. This function is only available on
+  IA-32 and x64.
+
+  @param  Index The 32-bit MSR index to write.
+  @param  Value The 64-bit value to write to the MSR.
+
+  @return Value
+
+**/
+UINT64
+EFIAPI
+AsmWriteMsr64 (
+  IN      UINT32                    Index,
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Reads a 64-bit MSR, performs a bitwise OR, and writes the result
+  back to the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 64-bit MSR specified by Index. The value written to the MSR is
+  returned. No parameter checking is performed on Index or OrData, and some of
+  these may cause CPU exceptions. The caller must either guarantee that Index
+  and OrData are valid, or the caller must establish proper exception handlers.
+  This function is only available on IA-32 and x64.
+
+  @param  Index   The 32-bit MSR index to write.
+  @param  OrData  The value to OR with the read value from the MSR.
+
+  @return The value written back to the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrOr64 (
+  IN      UINT32                    Index,
+  IN      UINT64                    OrData
+  );
+
+
+/**
+  Reads a 64-bit MSR, performs a bitwise AND, and writes the result back to the
+  64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND between the
+  read result and the value specified by OrData, and writes the result to the
+  64-bit MSR specified by Index. The value written to the MSR is returned. No
+  parameter checking is performed on Index or OrData, and some of these may
+  cause CPU exceptions. The caller must either guarantee that Index and OrData
+  are valid, or the caller must establish proper exception handlers. This
+  function is only available on IA-32 and x64.
+
+  @param  Index   The 32-bit MSR index to write.
+  @param  AndData The value to AND with the read value from the MSR.
+
+  @return The value written back to the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrAnd64 (
+  IN      UINT32                    Index,
+  IN      UINT64                    AndData
+  );
+
+
+/**
+  Reads a 64-bit MSR, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND between read
+  result and the value specified by AndData, performs a bitwise OR
+  between the result of the AND operation and the value specified by OrData,
+  and writes the result to the 64-bit MSR specified by Index. The value written
+  to the MSR is returned. No parameter checking is performed on Index, AndData,
+  or OrData, and some of these may cause CPU exceptions. The caller must either
+  guarantee that Index, AndData, and OrData are valid, or the caller must
+  establish proper exception handlers. This function is only available on IA-32
+  and x64.
+
+  @param  Index   The 32-bit MSR index to write.
+  @param  AndData The value to AND with the read value from the MSR.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrAndThenOr64 (
+  IN      UINT32                    Index,
+  IN      UINT64                    AndData,
+  IN      UINT64                    OrData
+  );
+
+
+/**
+  Reads a bit field of an MSR.
+
+  Reads the bit field in the 64-bit MSR. The bit field is specified by the
+  StartBit and the EndBit. The value of the bit field is returned. The caller
+  must either guarantee that Index is valid, or the caller must set up
+  exception handlers to catch the exceptions. This function is only available
+  on IA-32 and x64.
+
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+
+  @return The value read from the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrBitFieldRead64 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+
+/**
+  Writes a bit field to an MSR.
+
+  Writes Value to a bit field in a 64-bit MSR. The bit field is specified by
+  the StartBit and the EndBit. All other bits in the destination MSR are
+  preserved. The MSR written is returned. The caller must either guarantee
+  that Index and the data written is valid, or the caller must set up exception
+  handlers to catch the exceptions. This function is only available on IA-32 and x64.
+
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrBitFieldWrite64 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Reads a bit field in a 64-bit MSR, performs a bitwise OR, and
+  writes the result back to the bit field in the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 64-bit MSR specified by Index. The value written to the MSR is
+  returned. Extra left bits in OrData are stripped. The caller must either
+  guarantee that Index and the data written is valid, or the caller must set up
+  exception handlers to catch the exceptions. This function is only available
+  on IA-32 and x64.
+
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  OrData    The value to OR with the read value from the bit field.
+
+  @return The value written back to the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrBitFieldOr64 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    OrData
+  );
+
+
+/**
+  Reads a bit field in a 64-bit MSR, performs a bitwise AND, and writes the
+  result back to the bit field in the 64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND between the
+  read result and the value specified by AndData, and writes the result to the
+  64-bit MSR specified by Index. The value written to the MSR is returned.
+  Extra left bits in AndData are stripped. The caller must either guarantee
+  that Index and the data written is valid, or the caller must set up exception
+  handlers to catch the exceptions. This function is only available on IA-32
+  and x64.
+
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with the read value from the bit field.
+
+  @return The value written back to the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrBitFieldAnd64 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData
+  );
+
+
+/**
+  Reads a bit field in a 64-bit MSR, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  64-bit MSR.
+
+  Reads the 64-bit MSR specified by Index, performs a bitwise AND followed by
+  a bitwise OR between the read result and the value specified by
+  AndData, and writes the result to the 64-bit MSR specified by Index. The
+  value written to the MSR is returned. Extra left bits in both AndData and
+  OrData are stripped. The caller must either guarantee that Index and the data
+  written is valid, or the caller must set up exception handlers to catch the
+  exceptions. This function is only available on IA-32 and x64.
+
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Index     The 32-bit MSR index to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with the read value from the bit field.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the MSR.
+
+**/
+UINT64
+EFIAPI
+AsmMsrBitFieldAndThenOr64 (
+  IN      UINT32                    Index,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData,
+  IN      UINT64                    OrData
+  );
+
+
+/**
+  Reads the current value of the EFLAGS register.
+
+  Reads and returns the current value of the EFLAGS register. This function is
+  only available on IA-32 and x64. This returns a 32-bit value on IA-32 and a
+  64-bit value on x64.
+
+  @return EFLAGS on IA-32 or RFLAGS on x64.
+
+**/
+UINTN
+EFIAPI
+AsmReadEflags (
+  VOID
+  );
+
+
+/**
+  Reads the current value of the Control Register 0 (CR0).
+
+  Reads and returns the current value of CR0. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of the Control Register 0 (CR0).
+
+**/
+UINTN
+EFIAPI
+AsmReadCr0 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of the Control Register 2 (CR2).
+
+  Reads and returns the current value of CR2. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of the Control Register 2 (CR2).
+
+**/
+UINTN
+EFIAPI
+AsmReadCr2 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of the Control Register 3 (CR3).
+
+  Reads and returns the current value of CR3. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of the Control Register 3 (CR3).
+
+**/
+UINTN
+EFIAPI
+AsmReadCr3 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of the Control Register 4 (CR4).
+
+  Reads and returns the current value of CR4. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of the Control Register 4 (CR4).
+
+**/
+UINTN
+EFIAPI
+AsmReadCr4 (
+  VOID
+  );
+
+
+/**
+  Writes a value to Control Register 0 (CR0).
+
+  Writes and returns a new value to CR0. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Cr0 The value to write to CR0.
+
+  @return The value written to CR0.
+
+**/
+UINTN
+EFIAPI
+AsmWriteCr0 (
+  UINTN  Cr0
+  );
+
+
+/**
+  Writes a value to Control Register 2 (CR2).
+
+  Writes and returns a new value to CR2. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Cr2 The value to write to CR2.
+
+  @return The value written to CR2.
+
+**/
+UINTN
+EFIAPI
+AsmWriteCr2 (
+  UINTN  Cr2
+  );
+
+
+/**
+  Writes a value to Control Register 3 (CR3).
+
+  Writes and returns a new value to CR3. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Cr3 The value to write to CR3.
+
+  @return The value written to CR3.
+
+**/
+UINTN
+EFIAPI
+AsmWriteCr3 (
+  UINTN  Cr3
+  );
+
+
+/**
+  Writes a value to Control Register 4 (CR4).
+
+  Writes and returns a new value to CR4. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Cr4 The value to write to CR4.
+
+  @return The value written to CR4.
+
+**/
+UINTN
+EFIAPI
+AsmWriteCr4 (
+  UINTN  Cr4
+  );
+
+
+/**
+  Reads the current value of Debug Register 0 (DR0).
+
+  Reads and returns the current value of DR0. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 0 (DR0).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr0 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Debug Register 1 (DR1).
+
+  Reads and returns the current value of DR1. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 1 (DR1).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr1 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Debug Register 2 (DR2).
+
+  Reads and returns the current value of DR2. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 2 (DR2).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr2 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Debug Register 3 (DR3).
+
+  Reads and returns the current value of DR3. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 3 (DR3).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr3 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Debug Register 4 (DR4).
+
+  Reads and returns the current value of DR4. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 4 (DR4).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr4 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Debug Register 5 (DR5).
+
+  Reads and returns the current value of DR5. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 5 (DR5).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr5 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Debug Register 6 (DR6).
+
+  Reads and returns the current value of DR6. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 6 (DR6).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr6 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Debug Register 7 (DR7).
+
+  Reads and returns the current value of DR7. This function is only available
+  on IA-32 and x64. This returns a 32-bit value on IA-32 and a 64-bit value on
+  x64.
+
+  @return The value of Debug Register 7 (DR7).
+
+**/
+UINTN
+EFIAPI
+AsmReadDr7 (
+  VOID
+  );
+
+
+/**
+  Writes a value to Debug Register 0 (DR0).
+
+  Writes and returns a new value to DR0. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr0 The value to write to Dr0.
+
+  @return The value written to Debug Register 0 (DR0).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr0 (
+  UINTN  Dr0
+  );
+
+
+/**
+  Writes a value to Debug Register 1 (DR1).
+
+  Writes and returns a new value to DR1. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr1 The value to write to Dr1.
+
+  @return The value written to Debug Register 1 (DR1).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr1 (
+  UINTN  Dr1
+  );
+
+
+/**
+  Writes a value to Debug Register 2 (DR2).
+
+  Writes and returns a new value to DR2. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr2 The value to write to Dr2.
+
+  @return The value written to Debug Register 2 (DR2).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr2 (
+  UINTN  Dr2
+  );
+
+
+/**
+  Writes a value to Debug Register 3 (DR3).
+
+  Writes and returns a new value to DR3. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr3 The value to write to Dr3.
+
+  @return The value written to Debug Register 3 (DR3).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr3 (
+  UINTN  Dr3
+  );
+
+
+/**
+  Writes a value to Debug Register 4 (DR4).
+
+  Writes and returns a new value to DR4. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr4 The value to write to Dr4.
+
+  @return The value written to Debug Register 4 (DR4).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr4 (
+  UINTN  Dr4
+  );
+
+
+/**
+  Writes a value to Debug Register 5 (DR5).
+
+  Writes and returns a new value to DR5. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr5 The value to write to Dr5.
+
+  @return The value written to Debug Register 5 (DR5).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr5 (
+  UINTN  Dr5
+  );
+
+
+/**
+  Writes a value to Debug Register 6 (DR6).
+
+  Writes and returns a new value to DR6. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr6 The value to write to Dr6.
+
+  @return The value written to Debug Register 6 (DR6).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr6 (
+  UINTN  Dr6
+  );
+
+
+/**
+  Writes a value to Debug Register 7 (DR7).
+
+  Writes and returns a new value to DR7. This function is only available on
+  IA-32 and x64. This writes a 32-bit value on IA-32 and a 64-bit value on x64.
+
+  @param  Dr7 The value to write to Dr7.
+
+  @return The value written to Debug Register 7 (DR7).
+
+**/
+UINTN
+EFIAPI
+AsmWriteDr7 (
+  UINTN  Dr7
+  );
+
+
+/**
+  Reads the current value of Code Segment Register (CS).
+
+  Reads and returns the current value of CS. This function is only available on
+  IA-32 and x64.
+
+  @return The current value of CS.
+
+**/
+UINT16
+EFIAPI
+AsmReadCs (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Data Segment Register (DS).
+
+  Reads and returns the current value of DS. This function is only available on
+  IA-32 and x64.
+
+  @return The current value of DS.
+
+**/
+UINT16
+EFIAPI
+AsmReadDs (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Extra Segment Register (ES).
+
+  Reads and returns the current value of ES. This function is only available on
+  IA-32 and x64.
+
+  @return The current value of ES.
+
+**/
+UINT16
+EFIAPI
+AsmReadEs (
+  VOID
+  );
+
+
+/**
+  Reads the current value of FS Data Segment Register (FS).
+
+  Reads and returns the current value of FS. This function is only available on
+  IA-32 and x64.
+
+  @return The current value of FS.
+
+**/
+UINT16
+EFIAPI
+AsmReadFs (
+  VOID
+  );
+
+
+/**
+  Reads the current value of GS Data Segment Register (GS).
+
+  Reads and returns the current value of GS. This function is only available on
+  IA-32 and x64.
+
+  @return The current value of GS.
+
+**/
+UINT16
+EFIAPI
+AsmReadGs (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Stack Segment Register (SS).
+
+  Reads and returns the current value of SS. This function is only available on
+  IA-32 and x64.
+
+  @return The current value of SS.
+
+**/
+UINT16
+EFIAPI
+AsmReadSs (
+  VOID
+  );
+
+
+/**
+  Reads the current value of Task Register (TR).
+
+  Reads and returns the current value of TR. This function is only available on
+  IA-32 and x64.
+
+  @return The current value of TR.
+
+**/
+UINT16
+EFIAPI
+AsmReadTr (
+  VOID
+  );
+
+
+/**
+  Reads the current Global Descriptor Table Register(GDTR) descriptor.
+
+  Reads and returns the current GDTR descriptor and returns it in Gdtr. This
+  function is only available on IA-32 and x64.
+
+  If Gdtr is NULL, then ASSERT().
+
+  @param  Gdtr  The pointer to a GDTR descriptor.
+
+**/
+VOID
+EFIAPI
+AsmReadGdtr (
+  OUT     IA32_DESCRIPTOR           *Gdtr
+  );
+
+
+/**
+  Writes the current Global Descriptor Table Register (GDTR) descriptor.
+
+  Writes and the current GDTR descriptor specified by Gdtr. This function is
+  only available on IA-32 and x64.
+
+  If Gdtr is NULL, then ASSERT().
+
+  @param  Gdtr  The pointer to a GDTR descriptor.
+
+**/
+VOID
+EFIAPI
+AsmWriteGdtr (
+  IN      CONST IA32_DESCRIPTOR     *Gdtr
+  );
+
+
+/**
+  Reads the current Interrupt Descriptor Table Register(IDTR) descriptor.
+
+  Reads and returns the current IDTR descriptor and returns it in Idtr. This
+  function is only available on IA-32 and x64.
+
+  If Idtr is NULL, then ASSERT().
+
+  @param  Idtr  The pointer to a IDTR descriptor.
+
+**/
+VOID
+EFIAPI
+AsmReadIdtr (
+  OUT     IA32_DESCRIPTOR           *Idtr
+  );
+
+
+/**
+  Writes the current Interrupt Descriptor Table Register(IDTR) descriptor.
+
+  Writes the current IDTR descriptor and returns it in Idtr. This function is
+  only available on IA-32 and x64.
+
+  If Idtr is NULL, then ASSERT().
+
+  @param  Idtr  The pointer to a IDTR descriptor.
+
+**/
+VOID
+EFIAPI
+AsmWriteIdtr (
+  IN      CONST IA32_DESCRIPTOR     *Idtr
+  );
+
+
+/**
+  Reads the current Local Descriptor Table Register(LDTR) selector.
+
+  Reads and returns the current 16-bit LDTR descriptor value. This function is
+  only available on IA-32 and x64.
+
+  @return The current selector of LDT.
+
+**/
+UINT16
+EFIAPI
+AsmReadLdtr (
+  VOID
+  );
+
+
+/**
+  Writes the current Local Descriptor Table Register (LDTR) selector.
+
+  Writes and the current LDTR descriptor specified by Ldtr. This function is
+  only available on IA-32 and x64.
+
+  @param  Ldtr  16-bit LDTR selector value.
+
+**/
+VOID
+EFIAPI
+AsmWriteLdtr (
+  IN      UINT16                    Ldtr
+  );
+
+
+/**
+  Save the current floating point/SSE/SSE2 context to a buffer.
+
+  Saves the current floating point/SSE/SSE2 state to the buffer specified by
+  Buffer. Buffer must be aligned on a 16-byte boundary. This function is only
+  available on IA-32 and x64.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 16-byte boundary, then ASSERT().
+
+  @param  Buffer  The pointer to a buffer to save the floating point/SSE/SSE2 context.
+
+**/
+VOID
+EFIAPI
+AsmFxSave (
+  OUT     IA32_FX_BUFFER            *Buffer
+  );
+
+
+/**
+  Restores the current floating point/SSE/SSE2 context from a buffer.
+
+  Restores the current floating point/SSE/SSE2 state from the buffer specified
+  by Buffer. Buffer must be aligned on a 16-byte boundary. This function is
+  only available on IA-32 and x64.
+
+  If Buffer is NULL, then ASSERT().
+  If Buffer is not aligned on a 16-byte boundary, then ASSERT().
+  If Buffer was not saved with AsmFxSave(), then ASSERT().
+
+  @param  Buffer  The pointer to a buffer to save the floating point/SSE/SSE2 context.
+
+**/
+VOID
+EFIAPI
+AsmFxRestore (
+  IN      CONST IA32_FX_BUFFER      *Buffer
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #0 (MM0).
+
+  Reads and returns the current value of MM0. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM0.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm0 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #1 (MM1).
+
+  Reads and returns the current value of MM1. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM1.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm1 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #2 (MM2).
+
+  Reads and returns the current value of MM2. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM2.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm2 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #3 (MM3).
+
+  Reads and returns the current value of MM3. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM3.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm3 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #4 (MM4).
+
+  Reads and returns the current value of MM4. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM4.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm4 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #5 (MM5).
+
+  Reads and returns the current value of MM5. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM5.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm5 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #6 (MM6).
+
+  Reads and returns the current value of MM6. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM6.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm6 (
+  VOID
+  );
+
+
+/**
+  Reads the current value of 64-bit MMX Register #7 (MM7).
+
+  Reads and returns the current value of MM7. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of MM7.
+
+**/
+UINT64
+EFIAPI
+AsmReadMm7 (
+  VOID
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #0 (MM0).
+
+  Writes the current value of MM0. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM0.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm0 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #1 (MM1).
+
+  Writes the current value of MM1. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM1.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm1 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #2 (MM2).
+
+  Writes the current value of MM2. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM2.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm2 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #3 (MM3).
+
+  Writes the current value of MM3. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM3.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm3 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #4 (MM4).
+
+  Writes the current value of MM4. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM4.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm4 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #5 (MM5).
+
+  Writes the current value of MM5. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM5.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm5 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #6 (MM6).
+
+  Writes the current value of MM6. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM6.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm6 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Writes the current value of 64-bit MMX Register #7 (MM7).
+
+  Writes the current value of MM7. This function is only available on IA32 and
+  x64.
+
+  @param  Value The 64-bit value to write to MM7.
+
+**/
+VOID
+EFIAPI
+AsmWriteMm7 (
+  IN      UINT64                    Value
+  );
+
+
+/**
+  Reads the current value of Time Stamp Counter (TSC).
+
+  Reads and returns the current value of TSC. This function is only available
+  on IA-32 and x64.
+
+  @return The current value of TSC
+
+**/
+UINT64
+EFIAPI
+AsmReadTsc (
+  VOID
+  );
+
+
+/**
+  Reads the current value of a Performance Counter (PMC).
+
+  Reads and returns the current value of performance counter specified by
+  Index. This function is only available on IA-32 and x64.
+
+  @param  Index The 32-bit Performance Counter index to read.
+
+  @return The value of the PMC specified by Index.
+
+**/
+UINT64
+EFIAPI
+AsmReadPmc (
+  IN      UINT32                    Index
+  );
+
+
+/**
+  Sets up a monitor buffer that is used by AsmMwait().
+
+  Executes a MONITOR instruction with the register state specified by Eax, Ecx
+  and Edx. Returns Eax. This function is only available on IA-32 and x64.
+
+  @param  Eax The value to load into EAX or RAX before executing the MONITOR
+              instruction.
+  @param  Ecx The value to load into ECX or RCX before executing the MONITOR
+              instruction.
+  @param  Edx The value to load into EDX or RDX before executing the MONITOR
+              instruction.
+
+  @return Eax
+
+**/
+UINTN
+EFIAPI
+AsmMonitor (
+  IN      UINTN                     Eax,
+  IN      UINTN                     Ecx,
+  IN      UINTN                     Edx
+  );
+
+
+/**
+  Executes an MWAIT instruction.
+
+  Executes an MWAIT instruction with the register state specified by Eax and
+  Ecx. Returns Eax. This function is only available on IA-32 and x64.
+
+  @param  Eax The value to load into EAX or RAX before executing the MONITOR
+              instruction.
+  @param  Ecx The value to load into ECX or RCX before executing the MONITOR
+              instruction.
+
+  @return Eax
+
+**/
+UINTN
+EFIAPI
+AsmMwait (
+  IN      UINTN                     Eax,
+  IN      UINTN                     Ecx
+  );
+
+
+/**
+  Executes a WBINVD instruction.
+
+  Executes a WBINVD instruction. This function is only available on IA-32 and
+  x64.
+
+**/
+VOID
+EFIAPI
+AsmWbinvd (
+  VOID
+  );
+
+
+/**
+  Executes a INVD instruction.
+
+  Executes a INVD instruction. This function is only available on IA-32 and
+  x64.
+
+**/
+VOID
+EFIAPI
+AsmInvd (
+  VOID
+  );
+
+
+/**
+  Flushes a cache line from all the instruction and data caches within the
+  coherency domain of the CPU.
+
+  Flushed the cache line specified by LinearAddress, and returns LinearAddress.
+  This function is only available on IA-32 and x64.
+
+  @param  LinearAddress The address of the cache line to flush. If the CPU is
+                        in a physical addressing mode, then LinearAddress is a
+                        physical address. If the CPU is in a virtual
+                        addressing mode, then LinearAddress is a virtual
+                        address.
+
+  @return LinearAddress.
+**/
+VOID *
+EFIAPI
+AsmFlushCacheLine (
+  IN      VOID                      *LinearAddress
+  );
+
+
+/**
+  Enables the 32-bit paging mode on the CPU.
+
+  Enables the 32-bit paging mode on the CPU. CR0, CR3, CR4, and the page tables
+  must be properly initialized prior to calling this service. This function
+  assumes the current execution mode is 32-bit protected mode. This function is
+  only available on IA-32. After the 32-bit paging mode is enabled, control is
+  transferred to the function specified by EntryPoint using the new stack
+  specified by NewStack and passing in the parameters specified by Context1 and
+  Context2. Context1 and Context2 are optional and may be NULL. The function
+  EntryPoint must never return.
+
+  If the current execution mode is not 32-bit protected mode, then ASSERT().
+  If EntryPoint is NULL, then ASSERT().
+  If NewStack is NULL, then ASSERT().
+
+  There are a number of constraints that must be followed before calling this
+  function:
+  1)  Interrupts must be disabled.
+  2)  The caller must be in 32-bit protected mode with flat descriptors. This
+      means all descriptors must have a base of 0 and a limit of 4GB.
+  3)  CR0 and CR4 must be compatible with 32-bit protected mode with flat
+      descriptors.
+  4)  CR3 must point to valid page tables that will be used once the transition
+      is complete, and those page tables must guarantee that the pages for this
+      function and the stack are identity mapped.
+
+  @param  EntryPoint  A pointer to function to call with the new stack after
+                      paging is enabled.
+  @param  Context1    A pointer to the context to pass into the EntryPoint
+                      function as the first parameter after paging is enabled.
+  @param  Context2    A pointer to the context to pass into the EntryPoint
+                      function as the second parameter after paging is enabled.
+  @param  NewStack    A pointer to the new stack to use for the EntryPoint
+                      function after paging is enabled.
+
+**/
+VOID
+EFIAPI
+AsmEnablePaging32 (
+  IN      SWITCH_STACK_ENTRY_POINT  EntryPoint,
+  IN      VOID                      *Context1,  OPTIONAL
+  IN      VOID                      *Context2,  OPTIONAL
+  IN      VOID                      *NewStack
+  );
+
+
+/**
+  Disables the 32-bit paging mode on the CPU.
+
+  Disables the 32-bit paging mode on the CPU and returns to 32-bit protected
+  mode. This function assumes the current execution mode is 32-paged protected
+  mode. This function is only available on IA-32. After the 32-bit paging mode
+  is disabled, control is transferred to the function specified by EntryPoint
+  using the new stack specified by NewStack and passing in the parameters
+  specified by Context1 and Context2. Context1 and Context2 are optional and
+  may be NULL. The function EntryPoint must never return.
+
+  If the current execution mode is not 32-bit paged mode, then ASSERT().
+  If EntryPoint is NULL, then ASSERT().
+  If NewStack is NULL, then ASSERT().
+
+  There are a number of constraints that must be followed before calling this
+  function:
+  1)  Interrupts must be disabled.
+  2)  The caller must be in 32-bit paged mode.
+  3)  CR0, CR3, and CR4 must be compatible with 32-bit paged mode.
+  4)  CR3 must point to valid page tables that guarantee that the pages for
+      this function and the stack are identity mapped.
+
+  @param  EntryPoint  A pointer to function to call with the new stack after
+                      paging is disabled.
+  @param  Context1    A pointer to the context to pass into the EntryPoint
+                      function as the first parameter after paging is disabled.
+  @param  Context2    A pointer to the context to pass into the EntryPoint
+                      function as the second parameter after paging is
+                      disabled.
+  @param  NewStack    A pointer to the new stack to use for the EntryPoint
+                      function after paging is disabled.
+
+**/
+VOID
+EFIAPI
+AsmDisablePaging32 (
+  IN      SWITCH_STACK_ENTRY_POINT  EntryPoint,
+  IN      VOID                      *Context1,  OPTIONAL
+  IN      VOID                      *Context2,  OPTIONAL
+  IN      VOID                      *NewStack
+  );
+
+
+/**
+  Enables the 64-bit paging mode on the CPU.
+
+  Enables the 64-bit paging mode on the CPU. CR0, CR3, CR4, and the page tables
+  must be properly initialized prior to calling this service. This function
+  assumes the current execution mode is 32-bit protected mode with flat
+  descriptors. This function is only available on IA-32. After the 64-bit
+  paging mode is enabled, control is transferred to the function specified by
+  EntryPoint using the new stack specified by NewStack and passing in the
+  parameters specified by Context1 and Context2. Context1 and Context2 are
+  optional and may be 0. The function EntryPoint must never return.
+
+  If the current execution mode is not 32-bit protected mode with flat
+  descriptors, then ASSERT().
+  If EntryPoint is 0, then ASSERT().
+  If NewStack is 0, then ASSERT().
+
+  @param  Cs          The 16-bit selector to load in the CS before EntryPoint
+                      is called. The descriptor in the GDT that this selector
+                      references must be setup for long mode.
+  @param  EntryPoint  The 64-bit virtual address of the function to call with
+                      the new stack after paging is enabled.
+  @param  Context1    The 64-bit virtual address of the context to pass into
+                      the EntryPoint function as the first parameter after
+                      paging is enabled.
+  @param  Context2    The 64-bit virtual address of the context to pass into
+                      the EntryPoint function as the second parameter after
+                      paging is enabled.
+  @param  NewStack    The 64-bit virtual address of the new stack to use for
+                      the EntryPoint function after paging is enabled.
+
+**/
+VOID
+EFIAPI
+AsmEnablePaging64 (
+  IN      UINT16                    Cs,
+  IN      UINT64                    EntryPoint,
+  IN      UINT64                    Context1,  OPTIONAL
+  IN      UINT64                    Context2,  OPTIONAL
+  IN      UINT64                    NewStack
+  );
+
+
+/**
+  Disables the 64-bit paging mode on the CPU.
+
+  Disables the 64-bit paging mode on the CPU and returns to 32-bit protected
+  mode. This function assumes the current execution mode is 64-paging mode.
+  This function is only available on x64. After the 64-bit paging mode is
+  disabled, control is transferred to the function specified by EntryPoint
+  using the new stack specified by NewStack and passing in the parameters
+  specified by Context1 and Context2. Context1 and Context2 are optional and
+  may be 0. The function EntryPoint must never return.
+
+  If the current execution mode is not 64-bit paged mode, then ASSERT().
+  If EntryPoint is 0, then ASSERT().
+  If NewStack is 0, then ASSERT().
+
+  @param  Cs          The 16-bit selector to load in the CS before EntryPoint
+                      is called. The descriptor in the GDT that this selector
+                      references must be setup for 32-bit protected mode.
+  @param  EntryPoint  The 64-bit virtual address of the function to call with
+                      the new stack after paging is disabled.
+  @param  Context1    The 64-bit virtual address of the context to pass into
+                      the EntryPoint function as the first parameter after
+                      paging is disabled.
+  @param  Context2    The 64-bit virtual address of the context to pass into
+                      the EntryPoint function as the second parameter after
+                      paging is disabled.
+  @param  NewStack    The 64-bit virtual address of the new stack to use for
+                      the EntryPoint function after paging is disabled.
+
+**/
+VOID
+EFIAPI
+AsmDisablePaging64 (
+  IN      UINT16                    Cs,
+  IN      UINT32                    EntryPoint,
+  IN      UINT32                    Context1,  OPTIONAL
+  IN      UINT32                    Context2,  OPTIONAL
+  IN      UINT32                    NewStack
+  );
+
+
+//
+// 16-bit thunking services
+//
+
+/**
+  Retrieves the properties for 16-bit thunk functions.
+
+  Computes the size of the buffer and stack below 1MB required to use the
+  AsmPrepareThunk16(), AsmThunk16() and AsmPrepareAndThunk16() functions. This
+  buffer size is returned in RealModeBufferSize, and the stack size is returned
+  in ExtraStackSize. If parameters are passed to the 16-bit real mode code,
+  then the actual minimum stack size is ExtraStackSize plus the maximum number
+  of bytes that need to be passed to the 16-bit real mode code.
+
+  If RealModeBufferSize is NULL, then ASSERT().
+  If ExtraStackSize is NULL, then ASSERT().
+
+  @param  RealModeBufferSize  A pointer to the size of the buffer below 1MB
+                              required to use the 16-bit thunk functions.
+  @param  ExtraStackSize      A pointer to the extra size of stack below 1MB
+                              that the 16-bit thunk functions require for
+                              temporary storage in the transition to and from
+                              16-bit real mode.
+
+**/
+VOID
+EFIAPI
+AsmGetThunk16Properties (
+  OUT     UINT32                    *RealModeBufferSize,
+  OUT     UINT32                    *ExtraStackSize
+  );
+
+
+/**
+  Prepares all structures a code required to use AsmThunk16().
+
+  Prepares all structures and code required to use AsmThunk16().
+
+  This interface is limited to be used in either physical mode or virtual modes with paging enabled where the
+  virtual to physical mappings for ThunkContext.RealModeBuffer is mapped 1:1.
+
+  If ThunkContext is NULL, then ASSERT().
+
+  @param  ThunkContext  A pointer to the context structure that describes the
+                        16-bit real mode code to call.
+
+**/
+VOID
+EFIAPI
+AsmPrepareThunk16 (
+  IN OUT  THUNK_CONTEXT             *ThunkContext
+  );
+
+
+/**
+  Transfers control to a 16-bit real mode entry point and returns the results.
+
+  Transfers control to a 16-bit real mode entry point and returns the results.
+  AsmPrepareThunk16() must be called with ThunkContext before this function is used.
+  This function must be called with interrupts disabled.
+
+  The register state from the RealModeState field of ThunkContext is restored just prior
+  to calling the 16-bit real mode entry point.  This includes the EFLAGS field of RealModeState,
+  which is used to set the interrupt state when a 16-bit real mode entry point is called.
+  Control is transferred to the 16-bit real mode entry point specified by the CS and Eip fields of RealModeState.
+  The stack is initialized to the SS and ESP fields of RealModeState.  Any parameters passed to
+  the 16-bit real mode code must be populated by the caller at SS:ESP prior to calling this function.
+  The 16-bit real mode entry point is invoked with a 16-bit CALL FAR instruction,
+  so when accessing stack contents, the 16-bit real mode code must account for the 16-bit segment
+  and 16-bit offset of the return address that were pushed onto the stack. The 16-bit real mode entry
+  point must exit with a RETF instruction. The register state is captured into RealModeState immediately
+  after the RETF instruction is executed.
+
+  If EFLAGS specifies interrupts enabled, or any of the 16-bit real mode code enables interrupts,
+  or any of the 16-bit real mode code makes a SW interrupt, then the caller is responsible for making sure
+  the IDT at address 0 is initialized to handle any HW or SW interrupts that may occur while in 16-bit real mode.
+
+  If EFLAGS specifies interrupts enabled, or any of the 16-bit real mode code enables interrupts,
+  then the caller is responsible for making sure the 8259 PIC is in a state compatible with 16-bit real mode.
+  This includes the base vectors, the interrupt masks, and the edge/level trigger mode.
+
+  If THUNK_ATTRIBUTE_BIG_REAL_MODE is set in the ThunkAttributes field of ThunkContext, then the user code
+  is invoked in big real mode.  Otherwise, the user code is invoked in 16-bit real mode with 64KB segment limits.
+
+  If neither THUNK_ATTRIBUTE_DISABLE_A20_MASK_INT_15 nor THUNK_ATTRIBUTE_DISABLE_A20_MASK_KBD_CTRL are set in
+  ThunkAttributes, then it is assumed that the user code did not enable the A20 mask, and no attempt is made to
+  disable the A20 mask.
+
+  If THUNK_ATTRIBUTE_DISABLE_A20_MASK_INT_15 is set and THUNK_ATTRIBUTE_DISABLE_A20_MASK_KBD_CTRL is clear in
+  ThunkAttributes, then attempt to use the INT 15 service to disable the A20 mask.  If this INT 15 call fails,
+  then attempt to disable the A20 mask by directly accessing the 8042 keyboard controller I/O ports.
+
+  If THUNK_ATTRIBUTE_DISABLE_A20_MASK_INT_15 is clear and THUNK_ATTRIBUTE_DISABLE_A20_MASK_KBD_CTRL is set in
+  ThunkAttributes, then attempt to disable the A20 mask by directly accessing the 8042 keyboard controller I/O ports.
+
+  If ThunkContext is NULL, then ASSERT().
+  If AsmPrepareThunk16() was not previously called with ThunkContext, then ASSERT().
+  If both THUNK_ATTRIBUTE_DISABLE_A20_MASK_INT_15 and THUNK_ATTRIBUTE_DISABLE_A20_MASK_KBD_CTRL are set in
+  ThunkAttributes, then ASSERT().
+
+  This interface is limited to be used in either physical mode or virtual modes with paging enabled where the
+  virtual to physical mappings for ThunkContext.RealModeBuffer are mapped 1:1.
+
+  @param  ThunkContext  A pointer to the context structure that describes the
+                        16-bit real mode code to call.
+
+**/
+VOID
+EFIAPI
+AsmThunk16 (
+  IN OUT  THUNK_CONTEXT             *ThunkContext
+  );
+
+
+/**
+  Prepares all structures and code for a 16-bit real mode thunk, transfers
+  control to a 16-bit real mode entry point, and returns the results.
+
+  Prepares all structures and code for a 16-bit real mode thunk, transfers
+  control to a 16-bit real mode entry point, and returns the results. If the
+  caller only need to perform a single 16-bit real mode thunk, then this
+  service should be used. If the caller intends to make more than one 16-bit
+  real mode thunk, then it is more efficient if AsmPrepareThunk16() is called
+  once and AsmThunk16() can be called for each 16-bit real mode thunk.
+
+  This interface is limited to be used in either physical mode or virtual modes with paging enabled where the
+  virtual to physical mappings for ThunkContext.RealModeBuffer is mapped 1:1.
+
+  See AsmPrepareThunk16() and AsmThunk16() for the detailed description and ASSERT() conditions.
+
+  @param  ThunkContext  A pointer to the context structure that describes the
+                        16-bit real mode code to call.
+
+**/
+VOID
+EFIAPI
+AsmPrepareAndThunk16 (
+  IN OUT  THUNK_CONTEXT             *ThunkContext
+  );
+
+/**
+  Generates a 16-bit random number through RDRAND instruction.
+
+  if Rand is NULL, then ASSERT().
+
+  @param[out]  Rand     Buffer pointer to store the random result.
+
+  @retval TRUE          RDRAND call was successful.
+  @retval FALSE         Failed attempts to call RDRAND.
+
+ **/
+BOOLEAN
+EFIAPI
+AsmRdRand16 (
+  OUT     UINT16                    *Rand
+  );
+
+/**
+  Generates a 32-bit random number through RDRAND instruction.
+
+  if Rand is NULL, then ASSERT().
+
+  @param[out]  Rand     Buffer pointer to store the random result.
+
+  @retval TRUE          RDRAND call was successful.
+  @retval FALSE         Failed attempts to call RDRAND.
+
+**/
+BOOLEAN
+EFIAPI
+AsmRdRand32 (
+  OUT     UINT32                    *Rand
+  );
+
+/**
+  Generates a 64-bit random number through RDRAND instruction.
+
+  if Rand is NULL, then ASSERT().
+
+  @param[out]  Rand     Buffer pointer to store the random result.
+
+  @retval TRUE          RDRAND call was successful.
+  @retval FALSE         Failed attempts to call RDRAND.
+
+**/
+BOOLEAN
+EFIAPI
+AsmRdRand64  (
+  OUT     UINT64                    *Rand
+  );
+
+/**
+  Load given selector into TR register.
+
+  @param[in] Selector     Task segment selector
+**/
+VOID
+EFIAPI
+AsmWriteTr (
+  IN UINT16 Selector
+  );
+
+/**
+  Performs a serializing operation on all load-from-memory instructions that
+  were issued prior the AsmLfence function.
+
+  Executes a LFENCE instruction. This function is only available on IA-32 and x64.
+
+**/
+VOID
+EFIAPI
+AsmLfence (
+  VOID
+  );
+
+/**
+  Executes a XGETBV instruction
+
+  Executes a XGETBV instruction. This function is only available on IA-32 and
+  x64.
+
+  @param[in] Index        Extended control register index
+
+  @return                 The current value of the extended control register
+**/
+UINT64
+EFIAPI
+AsmXGetBv (
+  IN UINT32  Index
+  );
+
+/**
+  Executes a XSETBV instruction to write a 64-bit value to a Extended Control
+  Register(XCR), and returns the value.
+
+  Writes the 64-bit value specified by Value to the XCR specified by Index. The
+  64-bit value written to the XCR is returned. No parameter checking is
+  performed on Index or Value, and some of these may cause CPU exceptions. The
+  caller must either guarantee that Index and Value are valid, or the caller
+  must establish proper exception handlers. This function is only available on
+  IA-32 and x64.
+
+  @param  Index The 32-bit XCR index to write.
+  @param  Value The 64-bit value to write to the XCR.
+
+  @return Value
+
+**/
+UINT64
+EFIAPI
+AsmXSetBv (
+  IN UINT32  Index,
+  IN UINT64  Value
+  );
+
+/**
+  Executes a VMGEXIT instruction (VMMCALL with a REP prefix)
+
+  Executes a VMGEXIT instruction. This function is only available on IA-32 and
+  x64.
+
+**/
+VOID
+EFIAPI
+AsmVmgExit (
+  VOID
+  );
+
+
+/**
+  Patch the immediate operand of an IA32 or X64 instruction such that the byte,
+  word, dword or qword operand is encoded at the end of the instruction's
+  binary representation.
+
+  This function should be used to update object code that was compiled with
+  NASM from assembly source code. Example:
+
+  NASM source code:
+
+        mov     eax, strict dword 0 ; the imm32 zero operand will be patched
+    ASM_PFX(gPatchCr3):
+        mov     cr3, eax
+
+  C source code:
+
+    X86_ASSEMBLY_PATCH_LABEL gPatchCr3;
+    PatchInstructionX86 (gPatchCr3, AsmReadCr3 (), 4);
+
+  @param[out] InstructionEnd  Pointer right past the instruction to patch. The
+                              immediate operand to patch is expected to
+                              comprise the trailing bytes of the instruction.
+                              If InstructionEnd is closer to address 0 than
+                              ValueSize permits, then ASSERT().
+
+  @param[in] PatchValue       The constant to write to the immediate operand.
+                              The caller is responsible for ensuring that
+                              PatchValue can be represented in the byte, word,
+                              dword or qword operand (as indicated through
+                              ValueSize); otherwise ASSERT().
+
+  @param[in] ValueSize        The size of the operand in bytes; must be 1, 2,
+                              4, or 8. ASSERT() otherwise.
+**/
+VOID
+EFIAPI
+PatchInstructionX86 (
+  OUT X86_ASSEMBLY_PATCH_LABEL *InstructionEnd,
+  IN  UINT64                   PatchValue,
+  IN  UINTN                    ValueSize
+  );
+
+#endif // defined (MDE_CPU_IA32) || defined (MDE_CPU_X64)
+#endif // !defined (__BASE_LIB__)
diff --git a/libedk2_tpm/include/BaseTypes.h b/libedk2_tpm/include/BaseTypes.h
new file mode 100644
index 0000000..0c05c8d
--- /dev/null
+++ b/libedk2_tpm/include/BaseTypes.h
@@ -0,0 +1,308 @@
+/** @file
+  Processor or Compiler specific defines for all supported processors.
+
+  This file is stand alone self consistent set of definitions.
+
+  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __BASE_TYPES_H__
+#define __BASE_TYPES_H__
+
+//
+// Include processor specific binding
+//
+#include <ProcessorBind.h>
+#include <stdarg.h>
+
+//
+// Modifiers to abstract standard types to aid in debug of problems
+//
+#define CONST     const
+#define STATIC    static
+#define VOID      void
+
+//
+// Modifiers for Data Types used to self document code.
+// This concept is borrowed for UEFI specification.
+//
+#ifndef IN
+//
+// Some other environments use this construct, so #ifndef to prevent
+// multiple definition.
+//
+#define IN
+#define OUT
+#define OPTIONAL
+#endif
+
+//
+// Constants. They may exist in other build structures, so #ifndef them.
+//
+#ifndef TRUE
+//
+// BugBug: UEFI specification claims 1 and 0. We are concerned about the
+//  compiler portability so we did it this way.
+//
+#define TRUE  ((BOOLEAN)(1==1))
+#endif
+
+#ifndef FALSE
+#define FALSE ((BOOLEAN)(0==1))
+#endif
+
+#ifndef NULL
+#define NULL  ((VOID *) 0)
+#endif
+
+//
+//  Support for variable length argument lists using the ANSI standard.
+//
+//  Since we are using the ANSI standard we used the standard naming and
+//  did not follow the coding convention
+//
+//  VA_LIST  - typedef for argument list.
+//  VA_START (VA_LIST Marker, argument before the ...) - Init Marker for use.
+//  VA_END (VA_LIST Marker) - Clear Marker
+//  VA_ARG (VA_LIST Marker, var arg size) - Use Marker to get an argument from
+//    the ... list. You must know the size and pass it in this macro.
+//
+//  example:
+//
+//  UINTN
+//  ExampleVarArg (
+//    IN UINTN  NumberOfArgs,
+//    ...
+//    )
+//  {
+//    VA_LIST Marker;
+//    UINTN   Index;
+//    UINTN   Result;
+//
+//    //
+//    // Initialize the Marker
+//    //
+//    VA_START (Marker, NumberOfArgs);
+//    for (Index = 0, Result = 0; Index < NumberOfArgs; Index++) {
+//      //
+//      // The ... list is a series of UINTN values, so average them up.
+//      //
+//      Result += VA_ARG (Marker, UINTN);
+//    }
+//
+//    VA_END (Marker);
+//    return Result
+//  }
+//
+
+#define _INT_SIZE_OF(n) ((sizeof (n) + sizeof (UINTN) - 1) &~(sizeof (UINTN) - 1))
+
+//
+// Also support coding convention rules for var arg macros
+//
+#ifndef VA_START
+
+// typedef CHAR8 *VA_LIST;
+// #define VA_START(ap, v) (ap = (VA_LIST) & (v) + _INT_SIZE_OF (v))
+// #define VA_ARG(ap, t)   (*(t *) ((ap += _INT_SIZE_OF (t)) - _INT_SIZE_OF (t)))
+// #define VA_END(ap)      (ap = (VA_LIST) 0)
+// Use the native arguments for tools.
+#define VA_START va_start
+#define VA_ARG   va_arg
+#define VA_END   va_end
+#define VA_LIST  va_list
+
+#endif
+
+#ifndef GUID_DEFINED
+#define GUID_DEFINED
+///
+/// 128 bit buffer containing a unique identifier value.
+/// Unless otherwise specified, aligned on a 64 bit boundary.
+///
+typedef struct {
+  UINT32  Data1;
+  UINT16  Data2;
+  UINT16  Data3;
+  UINT8   Data4[8];
+} GUID;
+#endif
+
+///
+/// 4-byte buffer. An IPv4 internet protocol address.
+///
+typedef struct {
+  UINT8 Addr[4];
+} IPv4_ADDRESS;
+
+///
+/// 16-byte buffer. An IPv6 internet protocol address.
+///
+typedef struct {
+  UINT8 Addr[16];
+} IPv6_ADDRESS;
+
+//
+// Macro that returns the byte offset of a field in a data structure.
+//
+#define OFFSET_OF(TYPE, Field) ((UINTN) &(((TYPE *)0)->Field))
+
+///
+///  _CR - returns a pointer to the structure
+///      from one of its elements.
+///
+#define _CR(Record, TYPE, Field)  ((TYPE *) ((CHAR8 *) (Record) - (CHAR8 *) &(((TYPE *) 0)->Field)))
+
+///
+///  ALIGN_POINTER - aligns a pointer to the lowest boundary
+///
+#define ALIGN_POINTER(p, s) ((VOID *) ((UINTN)(p) + (((s) - ((UINTN) (p))) & ((s) - 1))))
+
+///
+///  ALIGN_VARIABLE - aligns a variable up to the next natural boundary for int size of a processor
+///
+#define ALIGN_VARIABLE(Value, Adjustment) \
+  Adjustment = 0U; \
+  if ((UINTN) (Value) % sizeof (UINTN)) { \
+    (Adjustment) = (UINTN)(sizeof (UINTN) - ((UINTN) (Value) % sizeof (UINTN))); \
+  } \
+  (Value) = (UINTN)((UINTN) (Value) + (UINTN) (Adjustment))
+
+//
+// Return the maximum of two operands.
+// This macro returns the maximum of two operand specified by a and b.
+// Both a and b must be the same numerical types, signed or unsigned.
+//
+#define MAX(a, b)                       \
+  (((a) > (b)) ? (a) : (b))
+
+
+//
+// Return the minimum of two operands.
+// This macro returns the minimal of two operand specified by a and b.
+// Both a and b must be the same numerical types, signed or unsigned.
+//
+#define MIN(a, b)                       \
+  (((a) < (b)) ? (a) : (b))
+
+
+//
+// EFI Error Codes common to all execution phases
+//
+
+typedef UINTN RETURN_STATUS;
+
+///
+/// Set the upper bit to indicate EFI Error.
+///
+#define ENCODE_ERROR(a)              ((RETURN_STATUS)(MAX_BIT | (a)))
+
+#define ENCODE_WARNING(a)            ((RETURN_STATUS)(a))
+#define RETURN_ERROR(a)              (((INTN)(RETURN_STATUS)(a)) < 0)
+
+#define RETURN_SUCCESS               0
+#define RETURN_LOAD_ERROR            ENCODE_ERROR (1)
+#define RETURN_INVALID_PARAMETER     ENCODE_ERROR (2)
+#define RETURN_UNSUPPORTED           ENCODE_ERROR (3)
+#define RETURN_BAD_BUFFER_SIZE       ENCODE_ERROR (4)
+#define RETURN_BUFFER_TOO_SMALL      ENCODE_ERROR (5)
+#define RETURN_NOT_READY             ENCODE_ERROR (6)
+#define RETURN_DEVICE_ERROR          ENCODE_ERROR (7)
+#define RETURN_WRITE_PROTECTED       ENCODE_ERROR (8)
+#define RETURN_OUT_OF_RESOURCES      ENCODE_ERROR (9)
+#define RETURN_VOLUME_CORRUPTED      ENCODE_ERROR (10)
+#define RETURN_VOLUME_FULL           ENCODE_ERROR (11)
+#define RETURN_NO_MEDIA              ENCODE_ERROR (12)
+#define RETURN_MEDIA_CHANGED         ENCODE_ERROR (13)
+#define RETURN_NOT_FOUND             ENCODE_ERROR (14)
+#define RETURN_ACCESS_DENIED         ENCODE_ERROR (15)
+#define RETURN_NO_RESPONSE           ENCODE_ERROR (16)
+#define RETURN_NO_MAPPING            ENCODE_ERROR (17)
+#define RETURN_TIMEOUT               ENCODE_ERROR (18)
+#define RETURN_NOT_STARTED           ENCODE_ERROR (19)
+#define RETURN_ALREADY_STARTED       ENCODE_ERROR (20)
+#define RETURN_ABORTED               ENCODE_ERROR (21)
+#define RETURN_ICMP_ERROR            ENCODE_ERROR (22)
+#define RETURN_TFTP_ERROR            ENCODE_ERROR (23)
+#define RETURN_PROTOCOL_ERROR        ENCODE_ERROR (24)
+#define RETURN_INCOMPATIBLE_VERSION  ENCODE_ERROR (25)
+#define RETURN_SECURITY_VIOLATION    ENCODE_ERROR (26)
+#define RETURN_CRC_ERROR             ENCODE_ERROR (27)
+#define RETURN_END_OF_MEDIA          ENCODE_ERROR (28)
+#define RETURN_END_OF_FILE           ENCODE_ERROR (31)
+
+#define RETURN_WARN_UNKNOWN_GLYPH    ENCODE_WARNING (1)
+#define RETURN_WARN_DELETE_FAILURE   ENCODE_WARNING (2)
+#define RETURN_WARN_WRITE_FAILURE    ENCODE_WARNING (3)
+#define RETURN_WARN_BUFFER_TOO_SMALL ENCODE_WARNING (4)
+
+typedef UINT64 PHYSICAL_ADDRESS;
+
+#define  BIT0     0x00000001
+#define  BIT1     0x00000002
+#define  BIT2     0x00000004
+#define  BIT3     0x00000008
+#define  BIT4     0x00000010
+#define  BIT5     0x00000020
+#define  BIT6     0x00000040
+#define  BIT7     0x00000080
+#define  BIT8     0x00000100
+#define  BIT9     0x00000200
+#define  BIT10    0x00000400
+#define  BIT11    0x00000800
+#define  BIT12    0x00001000
+#define  BIT13    0x00002000
+#define  BIT14    0x00004000
+#define  BIT15    0x00008000
+#define  BIT16    0x00010000
+#define  BIT17    0x00020000
+#define  BIT18    0x00040000
+#define  BIT19    0x00080000
+#define  BIT20    0x00100000
+#define  BIT21    0x00200000
+#define  BIT22    0x00400000
+#define  BIT23    0x00800000
+#define  BIT24    0x01000000
+#define  BIT25    0x02000000
+#define  BIT26    0x04000000
+#define  BIT27    0x08000000
+#define  BIT28    0x10000000
+#define  BIT29    0x20000000
+#define  BIT30    0x40000000
+#define  BIT31    0x80000000
+#define  BIT32    0x0000000100000000ULL
+#define  BIT33    0x0000000200000000ULL
+#define  BIT34    0x0000000400000000ULL
+#define  BIT35    0x0000000800000000ULL
+#define  BIT36    0x0000001000000000ULL
+#define  BIT37    0x0000002000000000ULL
+#define  BIT38    0x0000004000000000ULL
+#define  BIT39    0x0000008000000000ULL
+#define  BIT40    0x0000010000000000ULL
+#define  BIT41    0x0000020000000000ULL
+#define  BIT42    0x0000040000000000ULL
+#define  BIT43    0x0000080000000000ULL
+#define  BIT44    0x0000100000000000ULL
+#define  BIT45    0x0000200000000000ULL
+#define  BIT46    0x0000400000000000ULL
+#define  BIT47    0x0000800000000000ULL
+#define  BIT48    0x0001000000000000ULL
+#define  BIT49    0x0002000000000000ULL
+#define  BIT50    0x0004000000000000ULL
+#define  BIT51    0x0008000000000000ULL
+#define  BIT52    0x0010000000000000ULL
+#define  BIT53    0x0020000000000000ULL
+#define  BIT54    0x0040000000000000ULL
+#define  BIT55    0x0080000000000000ULL
+#define  BIT56    0x0100000000000000ULL
+#define  BIT57    0x0200000000000000ULL
+#define  BIT58    0x0400000000000000ULL
+#define  BIT59    0x0800000000000000ULL
+#define  BIT60    0x1000000000000000ULL
+#define  BIT61    0x2000000000000000ULL
+#define  BIT62    0x4000000000000000ULL
+#define  BIT63    0x8000000000000000ULL
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi.h b/libedk2_tpm/include/IndustryStandard/Acpi.h
new file mode 100644
index 0000000..929d259
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi.h
@@ -0,0 +1,16 @@
+/** @file
+  This file contains the latest ACPI definitions that are
+  consumed by drivers that do not care about ACPI versions.
+
+  Copyright (c) 2006 - 2017, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2019 - 2021, ARM Ltd. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _ACPI_H_
+#define _ACPI_H_
+
+#include <IndustryStandard/Acpi64.h>
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi10.h b/libedk2_tpm/include/IndustryStandard/Acpi10.h
new file mode 100644
index 0000000..ce9ab53
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi10.h
@@ -0,0 +1,666 @@
+/** @file
+  ACPI 1.0b definitions from the ACPI Specification, revision 1.0b
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+Copyright (c) 2020, Arm Limited. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_1_0_H_
+#define _ACPI_1_0_H_
+#include <Base.h>
+#include <IndustryStandard/AcpiAml.h>
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure.
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_COMMON_HEADER;
+
+#pragma pack(1)
+///
+/// The common ACPI description table header.  This structure prefaces most ACPI tables.
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT8   Revision;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT64  OemTableId;
+  UINT32  OemRevision;
+  UINT32  CreatorId;
+  UINT32  CreatorRevision;
+} EFI_ACPI_DESCRIPTION_HEADER;
+#pragma pack()
+
+//
+// Define for Descriptor
+//
+#define ACPI_SMALL_ITEM_FLAG                   0x00
+#define ACPI_LARGE_ITEM_FLAG                   0x01
+
+//
+// Small Item Descriptor Name
+//
+#define ACPI_SMALL_IRQ_DESCRIPTOR_NAME                       0x04
+#define ACPI_SMALL_DMA_DESCRIPTOR_NAME                       0x05
+#define ACPI_SMALL_START_DEPENDENT_DESCRIPTOR_NAME           0x06
+#define ACPI_SMALL_END_DEPENDENT_DESCRIPTOR_NAME             0x07
+#define ACPI_SMALL_IO_PORT_DESCRIPTOR_NAME                   0x08
+#define ACPI_SMALL_FIXED_IO_PORT_DESCRIPTOR_NAME             0x09
+#define ACPI_SMALL_VENDOR_DEFINED_DESCRIPTOR_NAME            0x0E
+#define ACPI_SMALL_END_TAG_DESCRIPTOR_NAME                   0x0F
+
+//
+// Large Item Descriptor Name
+//
+#define ACPI_LARGE_24_BIT_MEMORY_RANGE_DESCRIPTOR_NAME       0x01
+#define ACPI_LARGE_VENDOR_DEFINED_DESCRIPTOR_NAME            0x04
+#define ACPI_LARGE_32_BIT_MEMORY_RANGE_DESCRIPTOR_NAME       0x05
+#define ACPI_LARGE_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR_NAME 0x06
+#define ACPI_LARGE_DWORD_ADDRESS_SPACE_DESCRIPTOR_NAME       0x07
+#define ACPI_LARGE_WORD_ADDRESS_SPACE_DESCRIPTOR_NAME        0x08
+#define ACPI_LARGE_EXTENDED_IRQ_DESCRIPTOR_NAME              0x09
+#define ACPI_LARGE_QWORD_ADDRESS_SPACE_DESCRIPTOR_NAME       0x0A
+
+//
+// Small Item Descriptor Value
+//
+#define ACPI_IRQ_NOFLAG_DESCRIPTOR                0x22
+#define ACPI_IRQ_DESCRIPTOR                       0x23
+#define ACPI_DMA_DESCRIPTOR                       0x2A
+#define ACPI_START_DEPENDENT_DESCRIPTOR           0x30
+#define ACPI_START_DEPENDENT_EX_DESCRIPTOR        0x31
+#define ACPI_END_DEPENDENT_DESCRIPTOR             0x38
+#define ACPI_IO_PORT_DESCRIPTOR                   0x47
+#define ACPI_FIXED_LOCATION_IO_PORT_DESCRIPTOR    0x4B
+#define ACPI_END_TAG_DESCRIPTOR                   0x79
+
+//
+// Large Item Descriptor Value
+//
+#define ACPI_24_BIT_MEMORY_RANGE_DESCRIPTOR       0x81
+#define ACPI_32_BIT_MEMORY_RANGE_DESCRIPTOR       0x85
+#define ACPI_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR 0x86
+#define ACPI_DWORD_ADDRESS_SPACE_DESCRIPTOR       0x87
+#define ACPI_WORD_ADDRESS_SPACE_DESCRIPTOR        0x88
+#define ACPI_EXTENDED_INTERRUPT_DESCRIPTOR        0x89
+#define ACPI_QWORD_ADDRESS_SPACE_DESCRIPTOR       0x8A
+#define ACPI_ADDRESS_SPACE_DESCRIPTOR             0x8A
+
+//
+// Resource Type
+//
+#define ACPI_ADDRESS_SPACE_TYPE_MEM   0x00
+#define ACPI_ADDRESS_SPACE_TYPE_IO    0x01
+#define ACPI_ADDRESS_SPACE_TYPE_BUS   0x02
+
+///
+/// Power Management Timer frequency is fixed at 3.579545MHz.
+///
+#define ACPI_TIMER_FREQUENCY       3579545
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// The common definition of QWORD, DWORD, and WORD
+/// Address Space Descriptors.
+///
+typedef PACKED struct {
+  UINT8   Desc;
+  UINT16  Len;
+  UINT8   ResType;
+  UINT8   GenFlag;
+  UINT8   SpecificFlag;
+  UINT64  AddrSpaceGranularity;
+  UINT64  AddrRangeMin;
+  UINT64  AddrRangeMax;
+  UINT64  AddrTranslationOffset;
+  UINT64  AddrLen;
+} EFI_ACPI_ADDRESS_SPACE_DESCRIPTOR;
+
+typedef PACKED union {
+  UINT8     Byte;
+  PACKED struct {
+    UINT8 Length : 3;
+    UINT8 Name : 4;
+    UINT8 Type : 1;
+  } Bits;
+} ACPI_SMALL_RESOURCE_HEADER;
+
+typedef PACKED struct {
+  PACKED union {
+    UINT8 Byte;
+    PACKED struct {
+      UINT8 Name : 7;
+      UINT8 Type : 1;
+    }Bits;
+  } Header;
+  UINT16 Length;
+} ACPI_LARGE_RESOURCE_HEADER;
+
+///
+/// IRQ Descriptor.
+///
+typedef PACKED struct {
+  ACPI_SMALL_RESOURCE_HEADER   Header;
+  UINT16                       Mask;
+} EFI_ACPI_IRQ_NOFLAG_DESCRIPTOR;
+
+///
+/// IRQ Descriptor.
+///
+typedef PACKED struct {
+  ACPI_SMALL_RESOURCE_HEADER   Header;
+  UINT16                       Mask;
+  UINT8                        Information;
+} EFI_ACPI_IRQ_DESCRIPTOR;
+
+///
+/// DMA Descriptor.
+///
+typedef PACKED struct {
+  ACPI_SMALL_RESOURCE_HEADER   Header;
+  UINT8                        ChannelMask;
+  UINT8                        Information;
+} EFI_ACPI_DMA_DESCRIPTOR;
+
+///
+/// I/O Port Descriptor
+///
+typedef PACKED struct {
+  ACPI_SMALL_RESOURCE_HEADER   Header;
+  UINT8                        Information;
+  UINT16                       BaseAddressMin;
+  UINT16                       BaseAddressMax;
+  UINT8                        Alignment;
+  UINT8                        Length;
+} EFI_ACPI_IO_PORT_DESCRIPTOR;
+
+///
+/// Fixed Location I/O Port Descriptor.
+///
+typedef PACKED struct {
+  ACPI_SMALL_RESOURCE_HEADER   Header;
+  UINT16                       BaseAddress;
+  UINT8                        Length;
+} EFI_ACPI_FIXED_LOCATION_IO_PORT_DESCRIPTOR;
+
+///
+/// 24-Bit Memory Range Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         Information;
+  UINT16                        BaseAddressMin;
+  UINT16                        BaseAddressMax;
+  UINT16                        Alignment;
+  UINT16                        Length;
+} EFI_ACPI_24_BIT_MEMORY_RANGE_DESCRIPTOR;
+
+///
+/// 32-Bit Memory Range Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         Information;
+  UINT32                        BaseAddressMin;
+  UINT32                        BaseAddressMax;
+  UINT32                        Alignment;
+  UINT32                        Length;
+} EFI_ACPI_32_BIT_MEMORY_RANGE_DESCRIPTOR;
+
+///
+/// Fixed 32-Bit Fixed Memory Range Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         Information;
+  UINT32                        BaseAddress;
+  UINT32                        Length;
+} EFI_ACPI_32_BIT_FIXED_MEMORY_RANGE_DESCRIPTOR;
+
+///
+/// QWORD Address Space Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         ResType;
+  UINT8                         GenFlag;
+  UINT8                         SpecificFlag;
+  UINT64                        AddrSpaceGranularity;
+  UINT64                        AddrRangeMin;
+  UINT64                        AddrRangeMax;
+  UINT64                        AddrTranslationOffset;
+  UINT64                        AddrLen;
+} EFI_ACPI_QWORD_ADDRESS_SPACE_DESCRIPTOR;
+
+///
+/// DWORD Address Space Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         ResType;
+  UINT8                         GenFlag;
+  UINT8                         SpecificFlag;
+  UINT32                        AddrSpaceGranularity;
+  UINT32                        AddrRangeMin;
+  UINT32                        AddrRangeMax;
+  UINT32                        AddrTranslationOffset;
+  UINT32                        AddrLen;
+} EFI_ACPI_DWORD_ADDRESS_SPACE_DESCRIPTOR;
+
+///
+/// WORD Address Space Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         ResType;
+  UINT8                         GenFlag;
+  UINT8                         SpecificFlag;
+  UINT16                        AddrSpaceGranularity;
+  UINT16                        AddrRangeMin;
+  UINT16                        AddrRangeMax;
+  UINT16                        AddrTranslationOffset;
+  UINT16                        AddrLen;
+} EFI_ACPI_WORD_ADDRESS_SPACE_DESCRIPTOR;
+
+///
+/// Extended Interrupt Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         InterruptVectorFlags;
+  UINT8                         InterruptTableLength;
+  UINT32                        InterruptNumber[1];
+} EFI_ACPI_EXTENDED_INTERRUPT_DESCRIPTOR;
+
+#pragma pack()
+
+///
+/// The End tag identifies an end of resource data.
+///
+typedef struct {
+  UINT8 Desc;
+  UINT8 Checksum;
+} EFI_ACPI_END_TAG_DESCRIPTOR;
+
+//
+// General use definitions
+//
+#define EFI_ACPI_RESERVED_BYTE  0x00
+#define EFI_ACPI_RESERVED_WORD  0x0000
+#define EFI_ACPI_RESERVED_DWORD 0x00000000
+#define EFI_ACPI_RESERVED_QWORD 0x0000000000000000
+
+//
+// Resource Type Specific Flags
+// Ref ACPI specification 6.4.3.5.5
+//
+// Bit [0]    : Write Status, _RW
+//
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_READ_WRITE                (1 << 0)
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_READ_ONLY                 (0 << 0)
+//
+// Bit [2:1]  : Memory Attributes, _MEM
+//
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_NON_CACHEABLE             (0 << 1)
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE                 (1 << 1)
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE_WRITE_COMBINING (2 << 1)
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_CACHEABLE_PREFETCHABLE    (3 << 1)
+//
+// Bit [4:3]  : Memory Attributes, _MTP
+//
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_MEMORY      (0 << 3)
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_RESERVED    (1 << 3)
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_ACPI        (2 << 3)
+#define EFI_APCI_MEMORY_RESOURCE_SPECIFIC_FLAG_ADDRESS_RANGE_NVS         (3 << 3)
+//
+// Bit [5]    : Memory to I/O Translation, _TTP
+//
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_TYPE_TRANSLATION          (1 << 5)
+#define EFI_ACPI_MEMORY_RESOURCE_SPECIFIC_FLAG_TYPE_STATIC               (0 << 5)
+
+//
+// IRQ Information
+// Ref ACPI specification 6.4.2.1
+//
+#define EFI_ACPI_IRQ_SHARABLE_MASK                      0x10
+#define   EFI_ACPI_IRQ_SHARABLE                         0x10
+
+#define EFI_ACPI_IRQ_POLARITY_MASK                      0x08
+#define   EFI_ACPI_IRQ_HIGH_TRUE                        0x00
+#define   EFI_ACPI_IRQ_LOW_FALSE                        0x08
+
+#define EFI_ACPI_IRQ_MODE                               0x01
+#define   EFI_ACPI_IRQ_LEVEL_TRIGGERED                  0x00
+#define   EFI_ACPI_IRQ_EDGE_TRIGGERED                   0x01
+
+//
+// DMA Information
+// Ref ACPI specification 6.4.2.2
+//
+#define EFI_ACPI_DMA_SPEED_TYPE_MASK                    0x60
+#define   EFI_ACPI_DMA_SPEED_TYPE_COMPATIBILITY         0x00
+#define   EFI_ACPI_DMA_SPEED_TYPE_A                     0x20
+#define   EFI_ACPI_DMA_SPEED_TYPE_B                     0x40
+#define   EFI_ACPI_DMA_SPEED_TYPE_F                     0x60
+
+#define EFI_ACPI_DMA_BUS_MASTER_MASK                    0x04
+#define   EFI_ACPI_DMA_BUS_MASTER                       0x04
+
+#define EFI_ACPI_DMA_TRANSFER_TYPE_MASK                 0x03
+#define   EFI_ACPI_DMA_TRANSFER_TYPE_8_BIT              0x00
+#define   EFI_ACPI_DMA_TRANSFER_TYPE_8_BIT_AND_16_BIT   0x01
+#define   EFI_ACPI_DMA_TRANSFER_TYPE_16_BIT             0x02
+
+//
+// IO Information
+// Ref ACPI specification 6.4.2.5
+//
+#define EFI_ACPI_IO_DECODE_MASK                         0x01
+#define   EFI_ACPI_IO_DECODE_16_BIT                     0x01
+#define   EFI_ACPI_IO_DECODE_10_BIT                     0x00
+
+//
+// Memory Information
+// Ref ACPI specification 6.4.3.4
+//
+#define EFI_ACPI_MEMORY_WRITE_STATUS_MASK               0x01
+#define   EFI_ACPI_MEMORY_WRITABLE                      0x01
+#define   EFI_ACPI_MEMORY_NON_WRITABLE                  0x00
+
+//
+// Interrupt Vector Flags definitions for Extended Interrupt Descriptor
+// Ref ACPI specification 6.4.3.6
+//
+#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_PRODUCER_CONSUMER_MASK   BIT0
+#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_MODE_MASK                BIT1
+#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_POLARITY_MASK            BIT2
+#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_SHARABLE_MASK            BIT3
+#define EFI_ACPI_EXTENDED_INTERRUPT_FLAG_WAKE_CAPABLITY_MASK      BIT4
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+//
+// ACPI 1.0b table structures
+//
+
+///
+/// Root System Description Pointer Structure.
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Reserved;
+  UINT32  RsdtAddress;
+} EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 1.0b specification).
+///
+#define EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT).
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      FirmwareCtrl;
+  UINT32                      Dsdt;
+  UINT8                       IntModel;
+  UINT8                       Reserved1;
+  UINT16                      SciInt;
+  UINT32                      SmiCmd;
+  UINT8                       AcpiEnable;
+  UINT8                       AcpiDisable;
+  UINT8                       S4BiosReq;
+  UINT8                       Reserved2;
+  UINT32                      Pm1aEvtBlk;
+  UINT32                      Pm1bEvtBlk;
+  UINT32                      Pm1aCntBlk;
+  UINT32                      Pm1bCntBlk;
+  UINT32                      Pm2CntBlk;
+  UINT32                      PmTmrBlk;
+  UINT32                      Gpe0Blk;
+  UINT32                      Gpe1Blk;
+  UINT8                       Pm1EvtLen;
+  UINT8                       Pm1CntLen;
+  UINT8                       Pm2CntLen;
+  UINT8                       PmTmLen;
+  UINT8                       Gpe0BlkLen;
+  UINT8                       Gpe1BlkLen;
+  UINT8                       Gpe1Base;
+  UINT8                       Reserved3;
+  UINT16                      PLvl2Lat;
+  UINT16                      PLvl3Lat;
+  UINT16                      FlushSize;
+  UINT16                      FlushStride;
+  UINT8                       DutyOffset;
+  UINT8                       DutyWidth;
+  UINT8                       DayAlrm;
+  UINT8                       MonAlrm;
+  UINT8                       Century;
+  UINT8                       Reserved4;
+  UINT8                       Reserved5;
+  UINT8                       Reserved6;
+  UINT32                      Flags;
+} EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 1.0b specification).
+///
+#define EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x01
+
+#define EFI_ACPI_1_0_INT_MODE_DUAL_PIC         0
+#define EFI_ACPI_1_0_INT_MODE_MULTIPLE_APIC    1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_1_0_WBINVD               BIT0
+#define EFI_ACPI_1_0_WBINVD_FLUSH         BIT1
+#define EFI_ACPI_1_0_PROC_C1              BIT2
+#define EFI_ACPI_1_0_P_LVL2_UP            BIT3
+#define EFI_ACPI_1_0_PWR_BUTTON           BIT4
+#define EFI_ACPI_1_0_SLP_BUTTON           BIT5
+#define EFI_ACPI_1_0_FIX_RTC              BIT6
+#define EFI_ACPI_1_0_RTC_S4               BIT7
+#define EFI_ACPI_1_0_TMR_VAL_EXT          BIT8
+#define EFI_ACPI_1_0_DCK_CAP              BIT9
+
+///
+/// Firmware ACPI Control Structure.
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT8   Reserved[40];
+} EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// Firmware Control Structure Feature Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_1_0_S4BIOS_F             BIT0
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform-specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 1.0b specification).
+///
+#define EFI_ACPI_1_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_1_0_PCAT_COMPAT           BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x05 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_1_0_IO_APIC                        0x01
+#define EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_1_0_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_1_0_LOCAL_APIC_NMI                 0x04
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition.
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_1_0_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_1_0_LOCAL_APIC_ENABLED      BIT0
+
+///
+/// IO APIC Structure.
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  SystemVectorBase;
+} EFI_ACPI_1_0_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure.
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterruptVector;
+  UINT16  Flags;
+} EFI_ACPI_1_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Non-Maskable Interrupt Source Structure.
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterruptVector;
+} EFI_ACPI_1_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure.
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT16  Flags;
+  UINT8   LocalApicInti;
+} EFI_ACPI_1_0_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_1_0_SMART_BATTERY_DESCRIPTION_TABLE;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer.
+///
+#define EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table.
+///
+#define EFI_ACPI_1_0_APIC_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "DSDT" Differentiated System Description Table.
+///
+#define EFI_ACPI_1_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "FACS" Firmware ACPI Control Structure.
+///
+#define EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FACP" Fixed ACPI Description Table.
+///
+#define EFI_ACPI_1_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "PSDT" Persistent System Description Table.
+///
+#define EFI_ACPI_1_0_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RSDT" Root System Description Table.
+///
+#define EFI_ACPI_1_0_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table.
+///
+#define EFI_ACPI_1_0_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SSDT" Secondary System Description Table.
+///
+#define EFI_ACPI_1_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi20.h b/libedk2_tpm/include/IndustryStandard/Acpi20.h
new file mode 100644
index 0000000..1bd926a
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi20.h
@@ -0,0 +1,539 @@
+/** @file
+  ACPI 2.0 definitions from the ACPI Specification, revision 2.0
+
+  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_2_0_H_
+#define _ACPI_2_0_H_
+#include <Base.h>
+#include <IndustryStandard/Acpi10.h>
+
+//
+// Define for Descriptor
+//
+#define ACPI_LARGE_GENERIC_REGISTER_DESCRIPTOR_NAME          0x02
+
+#define ACPI_GENERIC_REGISTER_DESCRIPTOR          0x82
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// Generic Register Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         AddressSpaceId;
+  UINT8                         RegisterBitWidth;
+  UINT8                         RegisterBitOffset;
+  UINT8                         AddressSize;
+  UINT64                        RegisterAddress;
+} EFI_ACPI_GENERIC_REGISTER_DESCRIPTOR;
+
+#pragma pack()
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 2.0 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   Reserved;
+  UINT64  Address;
+} EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_2_0_SYSTEM_MEMORY              0
+#define EFI_ACPI_2_0_SYSTEM_IO                  1
+#define EFI_ACPI_2_0_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_2_0_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_2_0_SMBUS                      4
+#define EFI_ACPI_2_0_FUNCTIONAL_FIXED_HARDWARE  0x7F
+
+//
+// ACPI 2.0 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_2_0_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT8                                   Reserved2[3];
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+} EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x03
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_2_0_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_2_0_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_2_0_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_2_0_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_2_0_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_2_0_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_2_0_PM_PROFILE_APPLIANCE_PC        6
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_2_0_LEGACY_DEVICES          BIT0
+#define EFI_ACPI_2_0_8042                    BIT1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_2_0_WBINVD                  BIT0
+#define EFI_ACPI_2_0_WBINVD_FLUSH            BIT1
+#define EFI_ACPI_2_0_PROC_C1                 BIT2
+#define EFI_ACPI_2_0_P_LVL2_UP               BIT3
+#define EFI_ACPI_2_0_PWR_BUTTON              BIT4
+#define EFI_ACPI_2_0_SLP_BUTTON              BIT5
+#define EFI_ACPI_2_0_FIX_RTC                 BIT6
+#define EFI_ACPI_2_0_RTC_S4                  BIT7
+#define EFI_ACPI_2_0_TMR_VAL_EXT             BIT8
+#define EFI_ACPI_2_0_DCK_CAP                 BIT9
+#define EFI_ACPI_2_0_RESET_REG_SUP           BIT10
+#define EFI_ACPI_2_0_SEALED_CASE             BIT11
+#define EFI_ACPI_2_0_HEADLESS                BIT12
+#define EFI_ACPI_2_0_CPU_SW_SLP              BIT13
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved[31];
+} EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x01
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_2_0_S4BIOS_F        BIT0
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_2_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_2_0_PCAT_COMPAT          BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x09 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_2_0_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_2_0_IO_APIC                        0x01
+#define EFI_ACPI_2_0_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_2_0_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_2_0_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_2_0_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_2_0_IO_SAPIC                       0x06
+#define EFI_ACPI_2_0_PROCESSOR_LOCAL_SAPIC          0x07
+#define EFI_ACPI_2_0_PLATFORM_INTERRUPT_SOURCES     0x08
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_2_0_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_2_0_LOCAL_APIC_ENABLED         BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_2_0_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_2_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_2_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_2_0_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_2_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_2_0_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+} EFI_ACPI_2_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  Reserved;
+} EFI_ACPI_2_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_2_0_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_2_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 2.0 spec.)
+///
+#define EFI_ACPI_2_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "SPIC" Multiple SAPIC Description Table
+///
+/// BUGBUG: Don't know where this came from except SR870BN4 uses it.
+/// #define EFI_ACPI_2_0_MULTIPLE_SAPIC_DESCRIPTION_TABLE_SIGNATURE 0x43495053
+///
+#define EFI_ACPI_2_0_MULTIPLE_SAPIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_2_0_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "DBGP" MS Bebug Port Spec
+///
+#define EFI_ACPI_2_0_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_2_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_2_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_2_0_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_2_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_2_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_2_0_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_2_0_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_2_0_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_2_0_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_2_0_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_2_0_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SRAT" Static Resource Affinity Table
+///
+#define EFI_ACPI_2_0_STATIC_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_2_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_2_0_SERVER_PLATFORM_MANAGEMENT_INTERFACE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_2_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_2_0_MEMORY_MAPPED_CONFIGURATION_BASE_ADDRESS_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi30.h b/libedk2_tpm/include/IndustryStandard/Acpi30.h
new file mode 100644
index 0000000..075bf5b
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi30.h
@@ -0,0 +1,723 @@
+/** @file
+  ACPI 3.0 definitions from the ACPI Specification Revision 3.0b October 10, 2006
+
+  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_3_0_H_
+#define _ACPI_3_0_H_
+#include <Base.h>
+#include <IndustryStandard/Acpi20.h>
+
+//
+// Define for Descriptor
+//
+#define ACPI_LARGE_EXTENDED_ADDRESS_SPACE_DESCRIPTOR_NAME    0x0B
+
+#define ACPI_EXTENDED_ADDRESS_SPACE_DESCRIPTOR    0x8B
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// Extended Address Space Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         ResType;
+  UINT8                         GenFlag;
+  UINT8                         SpecificFlag;
+  UINT8                         RevisionId;
+  UINT8                         Reserved;
+  UINT64                        AddrSpaceGranularity;
+  UINT64                        AddrRangeMin;
+  UINT64                        AddrRangeMax;
+  UINT64                        AddrTranslationOffset;
+  UINT64                        AddrLen;
+  UINT64                        TypeSpecificAttribute;
+} EFI_ACPI_EXTENDED_ADDRESS_SPACE_DESCRIPTOR;
+
+#pragma pack()
+
+//
+// Memory Type Specific Flags
+//
+#define EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_UC  0x0000000000000001
+#define EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_WC  0x0000000000000002
+#define EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_WT  0x0000000000000004
+#define EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_WB  0x0000000000000008
+#define EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_UCE 0x0000000000000010
+#define EFI_ACPI_MEMORY_TYPE_SPECIFIC_ATTRIBUTES_NV  0x0000000000008000
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 3.0 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_3_0_SYSTEM_MEMORY              0
+#define EFI_ACPI_3_0_SYSTEM_IO                  1
+#define EFI_ACPI_3_0_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_3_0_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_3_0_SMBUS                      4
+#define EFI_ACPI_3_0_FUNCTIONAL_FIXED_HARDWARE  0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_3_0_UNDEFINED  0
+#define EFI_ACPI_3_0_BYTE       1
+#define EFI_ACPI_3_0_WORD       2
+#define EFI_ACPI_3_0_DWORD      3
+#define EFI_ACPI_3_0_QWORD      4
+
+//
+// ACPI 3.0 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 3.0b spec.)
+///
+#define EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 3.0b) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_3_0_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT8                                   Reserved2[3];
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+} EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x04
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_3_0_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_3_0_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_3_0_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_3_0_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_3_0_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_3_0_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_3_0_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_3_0_PM_PROFILE_PERFORMANCE_SERVER  7
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_3_0_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_3_0_8042                        BIT1
+#define EFI_ACPI_3_0_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_3_0_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_3_0_PCIE_ASPM_CONTROLS          BIT4
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_3_0_WBINVD                                 BIT0
+#define EFI_ACPI_3_0_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_3_0_PROC_C1                                BIT2
+#define EFI_ACPI_3_0_P_LVL2_UP                              BIT3
+#define EFI_ACPI_3_0_PWR_BUTTON                             BIT4
+#define EFI_ACPI_3_0_SLP_BUTTON                             BIT5
+#define EFI_ACPI_3_0_FIX_RTC                                BIT6
+#define EFI_ACPI_3_0_RTC_S4                                 BIT7
+#define EFI_ACPI_3_0_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_3_0_DCK_CAP                                BIT9
+#define EFI_ACPI_3_0_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_3_0_SEALED_CASE                            BIT11
+#define EFI_ACPI_3_0_HEADLESS                               BIT12
+#define EFI_ACPI_3_0_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_3_0_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_3_0_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_3_0_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_3_0_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_3_0_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_3_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved[31];
+} EFI_ACPI_3_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x01
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_3_0_S4BIOS_F       BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_3_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_3_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_3_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x02
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_3_0_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x09 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_3_0_IO_APIC                        0x01
+#define EFI_ACPI_3_0_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_3_0_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_3_0_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_3_0_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_3_0_IO_SAPIC                       0x06
+#define EFI_ACPI_3_0_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_3_0_PLATFORM_INTERRUPT_SOURCES     0x08
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_3_0_LOCAL_APIC_ENABLED        BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_3_0_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_3_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_3_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_3_0_POLARITY      (3 << 0)
+#define EFI_ACPI_3_0_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_3_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_3_0_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_3_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_3_0_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_3_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_3_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_3_0_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_3_0_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_3_0_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_3_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_3_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x02
+
+//
+// SRAT structure types.
+// All other values between 0x02 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_3_0_MEMORY_AFFINITY                      0x01
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT8   Reserved[4];
+} EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_3_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_3_0_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_3_0_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_3_0_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_3_0_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_3_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 3.0 spec.)
+///
+#define EFI_ACPI_3_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_3_0_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_3_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_3_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_3_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_3_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_3_0_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_3_0_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_3_0_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_3_0_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_3_0_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_3_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_3_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_3_0_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_3_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_3_0_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_3_0_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_3_0_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_3_0_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_3_0_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_3_0_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_3_0_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_3_0_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_3_0_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WSPT" Windows Specific Properties Table
+///
+#define EFI_ACPI_3_0_WINDOWS_SPECIFIC_PROPERTIES_TABLE_SIGNATURE  SIGNATURE_32('W', 'S', 'P', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_3_0_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi40.h b/libedk2_tpm/include/IndustryStandard/Acpi40.h
new file mode 100644
index 0000000..cfd491d
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi40.h
@@ -0,0 +1,1303 @@
+/** @file
+  ACPI 4.0 definitions from the ACPI Specification Revision 4.0a April 5, 2010
+
+  Copyright (c) 2010 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_4_0_H_
+#define _ACPI_4_0_H_
+
+#include <IndustryStandard/Acpi30.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 4.0 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_4_0_SYSTEM_MEMORY              0
+#define EFI_ACPI_4_0_SYSTEM_IO                  1
+#define EFI_ACPI_4_0_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_4_0_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_4_0_SMBUS                      4
+#define EFI_ACPI_4_0_FUNCTIONAL_FIXED_HARDWARE  0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_4_0_UNDEFINED  0
+#define EFI_ACPI_4_0_BYTE       1
+#define EFI_ACPI_4_0_WORD       2
+#define EFI_ACPI_4_0_DWORD      3
+#define EFI_ACPI_4_0_QWORD      4
+
+//
+// ACPI 4.0 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 4.0b spec.)
+///
+#define EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 4.0a) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_4_0_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT8                                   Reserved2[3];
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+} EFI_ACPI_4_0_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x04
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_4_0_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_4_0_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_4_0_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_4_0_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_4_0_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_4_0_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_4_0_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_4_0_PM_PROFILE_PERFORMANCE_SERVER  7
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_4_0_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_4_0_8042                        BIT1
+#define EFI_ACPI_4_0_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_4_0_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_4_0_PCIE_ASPM_CONTROLS          BIT4
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_4_0_WBINVD                                 BIT0
+#define EFI_ACPI_4_0_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_4_0_PROC_C1                                BIT2
+#define EFI_ACPI_4_0_P_LVL2_UP                              BIT3
+#define EFI_ACPI_4_0_PWR_BUTTON                             BIT4
+#define EFI_ACPI_4_0_SLP_BUTTON                             BIT5
+#define EFI_ACPI_4_0_FIX_RTC                                BIT6
+#define EFI_ACPI_4_0_RTC_S4                                 BIT7
+#define EFI_ACPI_4_0_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_4_0_DCK_CAP                                BIT9
+#define EFI_ACPI_4_0_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_4_0_SEALED_CASE                            BIT11
+#define EFI_ACPI_4_0_HEADLESS                               BIT12
+#define EFI_ACPI_4_0_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_4_0_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_4_0_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_4_0_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_4_0_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_4_0_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_4_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_4_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_4_0_S4BIOS_F                     BIT0
+#define EFI_ACPI_4_0_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_4_0_OSPM_64BIT_WAKE__F           BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_4_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_4_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_4_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x03
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_4_0_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x0B an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_4_0_IO_APIC                        0x01
+#define EFI_ACPI_4_0_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_4_0_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_4_0_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_4_0_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_4_0_IO_SAPIC                       0x06
+#define EFI_ACPI_4_0_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_4_0_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_4_0_LOCAL_X2APIC_NMI               0x0A
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_4_0_LOCAL_APIC_ENABLED        BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_4_0_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_4_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_4_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_4_0_POLARITY      (3 << 0)
+#define EFI_ACPI_4_0_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_4_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_4_0_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_4_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_4_0_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_4_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_4_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_4_0_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_4_0_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_4_0_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_4_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_4_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x03 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_4_0_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_4_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_4_0_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_4_0_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_4_0_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_4_0_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_4_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_4_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_4_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_4_0_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_4_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_4_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_4_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_4_0_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_4_0_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_4_0_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_4_0_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_4_0_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_4_0_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_4_0_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_4_0_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+} EFI_ACPI_4_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0201
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_4_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_4_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_4_0_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_4_0_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_4_0_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_4_0_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_4_0_GENERIC_HARDWARE_ERROR                     0x09
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_4_0_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_4_0_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_4_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_POLLED                0x00
+#define EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT    0x01
+#define EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT       0x02
+#define EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_SCI                   0x03
+#define EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_NMI                   0x04
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_4_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_4_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_4_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_4_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_4_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_4_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_4_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_4_0_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_4_0_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_4_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_4_0_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_4_0_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_4_0_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_4_0_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_4_0_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_4_0_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_4_0_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_4_0_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_4_0_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_4_0_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_4_0_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_4_0_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_4_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_4_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_4_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_4_0_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_4_0_EINJ_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_4_0_EINJ_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_4_0_EINJ_STATUS_FAILED                            0x03
+#define EFI_ACPI_4_0_EINJ_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_4_0_EINJ_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_4_0_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_4_0_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_4_0_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_4_0_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_4_0_ERST_NOOP                                     0x04
+#define EFI_ACPI_4_0_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_4_0_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_4_0_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_4_0_ERST_ADD                                      0x08
+#define EFI_ACPI_4_0_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_4_0_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_4_0_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_4_0_ERST_STALL                                    0x0C
+#define EFI_ACPI_4_0_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_4_0_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_4_0_ERST_GOTO                                     0x0F
+#define EFI_ACPI_4_0_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_4_0_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_4_0_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_4_0_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_4_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_4_0_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 4.0 spec.)
+///
+#define EFI_ACPI_4_0_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_4_0_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_4_0_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_4_0_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_4_0_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_4_0_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_4_0_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_4_0_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_4_0_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_4_0_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_4_0_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_4_0_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_4_0_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_4_0_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_4_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_4_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_4_0_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_4_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_4_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_4_0_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_4_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_4_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_4_0_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_4_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_4_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_4_0_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_4_0_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_4_0_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_4_0_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_4_0_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_4_0_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_4_0_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_4_0_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_4_0_EINJ_TRIGGER_ACTION_TABLE;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_4_0_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_4_0_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_4_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_4_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_4_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_4_0_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_4_0_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_4_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_4_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_4_0_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_4_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_4_0_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_4_0_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_4_0_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_4_0_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_4_0_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_4_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_4_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_4_0_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_4_0_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_4_0_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_4_0_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_4_0_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_4_0_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_4_0_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_4_0_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_4_0_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_4_0_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_4_0_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_4_0_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_4_0_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Enlightenment Table
+///
+#define EFI_ACPI_4_0_WINDOWS_ACPI_ENLIGHTENMENT_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_4_0_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_4_0_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi50.h b/libedk2_tpm/include/IndustryStandard/Acpi50.h
new file mode 100644
index 0000000..0adb020
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi50.h
@@ -0,0 +1,2119 @@
+/** @file
+  ACPI 5.0 definitions from the ACPI Specification Revision 5.0a November 13, 2013.
+
+  Copyright (c) 2014 Hewlett-Packard Development Company, L.P.<BR>
+  Copyright (c) 2011 - 2018, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_5_0_H_
+#define _ACPI_5_0_H_
+#include <Base.h>
+#include <IndustryStandard/Acpi40.h>
+
+//
+// Define for Descriptor
+//
+#define ACPI_SMALL_FIXED_DMA_DESCRIPTOR_NAME                         0x0A
+#define ACPI_LARGE_GPIO_CONNECTION_DESCRIPTOR_NAME                   0x0C
+#define ACPI_LARGE_GENERIC_SERIAL_BUS_CONNECTION_DESCRIPTOR_NAME     0x0E
+
+#define ACPI_FIXED_DMA_DESCRIPTOR                         0x55
+#define ACPI_GPIO_CONNECTION_DESCRIPTOR                   0x8C
+#define ACPI_GENERIC_SERIAL_BUS_CONNECTION_DESCRIPTOR     0x8E
+
+#pragma pack(1)
+
+///
+/// Generic DMA Descriptor.
+///
+typedef PACKED struct {
+  ACPI_SMALL_RESOURCE_HEADER   Header;
+  UINT16                       DmaRequestLine;
+  UINT16                       DmaChannel;
+  UINT8                        DmaTransferWidth;
+} EFI_ACPI_FIXED_DMA_DESCRIPTOR;
+
+///
+/// GPIO Connection Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT8                         ConnectionType;
+  UINT16                        GeneralFlags;
+  UINT16                        InterruptFlags;
+  UINT8                         PinConfiguration;
+  UINT16                        OutputDriveStrength;
+  UINT16                        DebounceTimeout;
+  UINT16                        PinTableOffset;
+  UINT8                         ResourceSourceIndex;
+  UINT16                        ResourceSourceNameOffset;
+  UINT16                        VendorDataOffset;
+  UINT16                        VendorDataLength;
+} EFI_ACPI_GPIO_CONNECTION_DESCRIPTOR;
+
+#define EFI_ACPI_GPIO_CONNECTION_TYPE_INTERRUPT   0x0
+#define EFI_ACPI_GPIO_CONNECTION_TYPE_IO          0x1
+
+///
+/// Serial Bus Resource Descriptor (Generic)
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT8                         ResourceSourceIndex;
+  UINT8                         SerialBusType;
+  UINT8                         GeneralFlags;
+  UINT16                        TypeSpecificFlags;
+  UINT8                         TypeSpecificRevisionId;
+  UINT16                        TypeDataLength;
+// Type specific data
+} EFI_ACPI_SERIAL_BUS_RESOURCE_DESCRIPTOR;
+
+#define EFI_ACPI_SERIAL_BUS_RESOURCE_TYPE_I2C   0x1
+#define EFI_ACPI_SERIAL_BUS_RESOURCE_TYPE_SPI   0x2
+#define EFI_ACPI_SERIAL_BUS_RESOURCE_TYPE_UART  0x3
+
+///
+/// Serial Bus Resource Descriptor (I2C)
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT8                         ResourceSourceIndex;
+  UINT8                         SerialBusType;
+  UINT8                         GeneralFlags;
+  UINT16                        TypeSpecificFlags;
+  UINT8                         TypeSpecificRevisionId;
+  UINT16                        TypeDataLength;
+  UINT32                        ConnectionSpeed;
+  UINT16                        SlaveAddress;
+} EFI_ACPI_SERIAL_BUS_RESOURCE_I2C_DESCRIPTOR;
+
+///
+/// Serial Bus Resource Descriptor (SPI)
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT8                         ResourceSourceIndex;
+  UINT8                         SerialBusType;
+  UINT8                         GeneralFlags;
+  UINT16                        TypeSpecificFlags;
+  UINT8                         TypeSpecificRevisionId;
+  UINT16                        TypeDataLength;
+  UINT32                        ConnectionSpeed;
+  UINT8                         DataBitLength;
+  UINT8                         Phase;
+  UINT8                         Polarity;
+  UINT16                        DeviceSelection;
+} EFI_ACPI_SERIAL_BUS_RESOURCE_SPI_DESCRIPTOR;
+
+///
+/// Serial Bus Resource Descriptor (UART)
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT8                         ResourceSourceIndex;
+  UINT8                         SerialBusType;
+  UINT8                         GeneralFlags;
+  UINT16                        TypeSpecificFlags;
+  UINT8                         TypeSpecificRevisionId;
+  UINT16                        TypeDataLength;
+  UINT32                        DefaultBaudRate;
+  UINT16                        RxFIFO;
+  UINT16                        TxFIFO;
+  UINT8                         Parity;
+  UINT8                         SerialLinesEnabled;
+} EFI_ACPI_SERIAL_BUS_RESOURCE_UART_DESCRIPTOR;
+
+#pragma pack()
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 5.0 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_5_0_SYSTEM_MEMORY              0
+#define EFI_ACPI_5_0_SYSTEM_IO                  1
+#define EFI_ACPI_5_0_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_5_0_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_5_0_SMBUS                      4
+#define EFI_ACPI_5_0_PLATFORM_COMMUNICATION_CHANNEL  0x0A
+#define EFI_ACPI_5_0_FUNCTIONAL_FIXED_HARDWARE       0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_5_0_UNDEFINED  0
+#define EFI_ACPI_5_0_BYTE       1
+#define EFI_ACPI_5_0_WORD       2
+#define EFI_ACPI_5_0_DWORD      3
+#define EFI_ACPI_5_0_QWORD      4
+
+//
+// ACPI 5.0 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 5.0) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_5_0_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT8                                   Reserved2[3];
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  SleepControlReg;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  SleepStatusReg;
+} EFI_ACPI_5_0_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x05
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_5_0_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_5_0_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_5_0_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_5_0_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_5_0_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_5_0_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_5_0_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_5_0_PM_PROFILE_PERFORMANCE_SERVER  7
+#define EFI_ACPI_5_0_PM_PROFILE_TABLET              8
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_5_0_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_5_0_8042                        BIT1
+#define EFI_ACPI_5_0_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_5_0_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_5_0_PCIE_ASPM_CONTROLS          BIT4
+#define EFI_ACPI_5_0_CMOS_RTC_NOT_PRESENT        BIT5
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_5_0_WBINVD                                 BIT0
+#define EFI_ACPI_5_0_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_5_0_PROC_C1                                BIT2
+#define EFI_ACPI_5_0_P_LVL2_UP                              BIT3
+#define EFI_ACPI_5_0_PWR_BUTTON                             BIT4
+#define EFI_ACPI_5_0_SLP_BUTTON                             BIT5
+#define EFI_ACPI_5_0_FIX_RTC                                BIT6
+#define EFI_ACPI_5_0_RTC_S4                                 BIT7
+#define EFI_ACPI_5_0_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_5_0_DCK_CAP                                BIT9
+#define EFI_ACPI_5_0_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_5_0_SEALED_CASE                            BIT11
+#define EFI_ACPI_5_0_HEADLESS                               BIT12
+#define EFI_ACPI_5_0_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_5_0_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_5_0_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_5_0_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_5_0_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_5_0_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_5_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+#define EFI_ACPI_5_0_HW_REDUCED_ACPI                        BIT20
+#define EFI_ACPI_5_0_LOW_POWER_S0_IDLE_CAPABLE              BIT21
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_5_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_0_S4BIOS_F                     BIT0
+#define EFI_ACPI_5_0_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_0_OSPM_64BIT_WAKE_F            BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_5_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_5_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_5_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x03
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_0_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x0D and 0x7F are reserved and
+// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
+//
+#define EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_5_0_IO_APIC                        0x01
+#define EFI_ACPI_5_0_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_5_0_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_5_0_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_5_0_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_5_0_IO_SAPIC                       0x06
+#define EFI_ACPI_5_0_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_5_0_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_5_0_LOCAL_X2APIC_NMI               0x0A
+#define EFI_ACPI_5_0_GIC                            0x0B
+#define EFI_ACPI_5_0_GICD                           0x0C
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_0_LOCAL_APIC_ENABLED        BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_5_0_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_5_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_5_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_5_0_POLARITY      (3 << 0)
+#define EFI_ACPI_5_0_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_5_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_5_0_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_5_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_5_0_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_5_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_5_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_0_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_5_0_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// GIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  GicId;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ParkingProtocolVersion;
+  UINT32  PerformanceInterruptGsiv;
+  UINT64  ParkedAddress;
+  UINT64  PhysicalBaseAddress;
+} EFI_ACPI_5_0_GIC_STRUCTURE;
+
+///
+/// GIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_0_GIC_ENABLED                     BIT0
+#define EFI_ACPI_5_0_PERFORMANCE_INTERRUPT_MODEL     BIT1
+
+///
+/// GIC Distributor Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  SystemVectorBase;
+  UINT32  Reserved2;
+} EFI_ACPI_5_0_GIC_DISTRIBUTOR_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_5_0_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_5_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT).  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_5_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x03 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_5_0_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_5_0_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_5_0_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_5_0_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_5_0_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_5_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_5_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_5_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_5_0_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_5_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_5_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_5_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// ACPI RAS Feature Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier[12];
+} EFI_ACPI_5_0_RAS_FEATURE_TABLE;
+
+///
+/// RASF Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_RAS_FEATURE_TABLE_REVISION 0x01
+
+///
+/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT16                      Version;
+  UINT8                       RASCapabilities[16];
+  UINT8                       SetRASCapabilities[16];
+  UINT16                      NumberOfRASFParameterBlocks;
+  UINT32                      SetRASCapabilitiesStatus;
+} EFI_ACPI_5_0_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI RASF PCC command code
+///
+#define EFI_ACPI_5_0_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01
+
+///
+/// ACPI RASF Platform RAS Capabilities
+///
+#define EFI_ACPI_5_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED                          0x01
+#define EFI_ACPI_5_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED_AND_EXPOSED_TO_SOFTWARE  0x02
+
+///
+/// ACPI RASF Parameter Block structure for PATROL_SCRUB
+///
+typedef struct {
+  UINT16                      Type;
+  UINT16                      Version;
+  UINT16                      Length;
+  UINT16                      PatrolScrubCommand;
+  UINT64                      RequestedAddressRange[2];
+  UINT64                      ActualAddressRange[2];
+  UINT16                      Flags;
+  UINT8                       RequestedSpeed;
+} EFI_ACPI_5_0_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;
+
+///
+/// ACPI RASF Patrol Scrub command
+///
+#define EFI_ACPI_5_0_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS   0x01
+#define EFI_ACPI_5_0_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER   0x02
+#define EFI_ACPI_5_0_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER    0x03
+
+///
+/// Memory Power State Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier;
+  UINT8                       Reserved[3];
+// Memory Power Node Structure
+// Memory Power State Characteristics
+} EFI_ACPI_5_0_MEMORY_POWER_STATUS_TABLE;
+
+///
+/// MPST Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_MEMORY_POWER_STATE_TABLE_REVISION 0x01
+
+///
+/// MPST Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT32                      MemoryPowerCommandRegister;
+  UINT32                      MemoryPowerStatusRegister;
+  UINT32                      PowerStateId;
+  UINT32                      MemoryPowerNodeId;
+  UINT64                      MemoryEnergyConsumed;
+  UINT64                      ExpectedAveragePowerComsuned;
+} EFI_ACPI_5_0_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI MPST PCC command code
+///
+#define EFI_ACPI_5_0_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03
+
+///
+/// ACPI MPST Memory Power command
+///
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE       0x01
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE       0x02
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED   0x03
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED   0x04
+
+///
+/// MPST Memory Power Node Table
+///
+typedef struct {
+  UINT8                                             PowerStateValue;
+  UINT8                                             PowerStateInformationIndex;
+} EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE;
+
+typedef struct {
+  UINT8                                             Flag;
+  UINT8                                             Reserved;
+  UINT16                                            MemoryPowerNodeId;
+  UINT32                                            Length;
+  UINT64                                            AddressBase;
+  UINT64                                            AddressLength;
+  UINT32                                            NumberOfPowerStates;
+  UINT32                                            NumberOfPhysicalComponents;
+//EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
+//UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
+} EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE;
+
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE          0x01
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED   0x02
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE   0x04
+
+typedef struct {
+  UINT16                      MemoryPowerNodeCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_5_0_MPST_MEMORY_POWER_NODE_TABLE;
+
+///
+/// MPST Memory Power State Characteristics Table
+///
+typedef struct {
+  UINT8                                             PowerStateStructureID;
+  UINT8                                             Flag;
+  UINT16                                            Reserved;
+  UINT32                                            AveragePowerConsumedInMPS0;
+  UINT32                                            RelativePowerSavingToMPS0;
+  UINT64                                            ExitLatencyToMPS0;
+} EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;
+
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED              0x01
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY   0x02
+#define EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT    0x04
+
+typedef struct {
+  UINT16                      MemoryPowerStateCharacteristicsCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_5_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;
+
+///
+/// Memory Topology Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved;
+} EFI_ACPI_5_0_MEMORY_TOPOLOGY_TABLE;
+
+///
+/// PMTT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_MEMORY_TOPOLOGY_TABLE_REVISION 0x01
+
+///
+/// Common Memory Aggregator Device Structure.
+///
+typedef struct {
+  UINT8                       Type;
+  UINT8                       Reserved;
+  UINT16                      Length;
+  UINT16                      Flags;
+  UINT16                      Reserved1;
+} EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Memory Aggregator Device Type
+///
+#define EFI_ACPI_5_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET            0x0
+#define EFI_ACPI_5_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER 0x1
+#define EFI_ACPI_5_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM              0x2
+
+///
+/// Socket Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       SocketIdentifier;
+  UINT16                                                       Reserved;
+//EFI_ACPI_5_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
+} EFI_ACPI_5_0_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// MemoryController Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT32                                                       ReadLatency;
+  UINT32                                                       WriteLatency;
+  UINT32                                                       ReadBandwidth;
+  UINT32                                                       WriteBandwidth;
+  UINT16                                                       OptimalAccessUnit;
+  UINT16                                                       OptimalAccessAlignment;
+  UINT16                                                       Reserved;
+  UINT16                                                       NumberOfProximityDomains;
+//UINT32                                                       ProximityDomain[NumberOfProximityDomains];
+//EFI_ACPI_5_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
+} EFI_ACPI_5_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// DIMM Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_5_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       PhysicalComponentIdentifier;
+  UINT16                                                       Reserved;
+  UINT32                                                       SizeOfDimm;
+  UINT32                                                       SmbiosHandle;
+} EFI_ACPI_5_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Boot Graphics Resource Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  ///
+  /// 2-bytes (16 bit) version ID. This value must be 1.
+  ///
+  UINT16                      Version;
+  ///
+  /// 1-byte status field indicating current status about the table.
+  ///     Bits[7:1] = Reserved (must be zero)
+  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
+  ///
+  UINT8                       Status;
+  ///
+  /// 1-byte enumerated type field indicating format of the image.
+  ///     0 = Bitmap
+  ///     1 - 255  Reserved (for future use)
+  ///
+  UINT8                       ImageType;
+  ///
+  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
+  /// of the image bitmap.
+  ///
+  UINT64                      ImageAddress;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetX;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetY;
+} EFI_ACPI_5_0_BOOT_GRAPHICS_RESOURCE_TABLE;
+
+///
+/// BGRT Revision
+///
+#define EFI_ACPI_5_0_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION 1
+
+///
+/// BGRT Version
+///
+#define EFI_ACPI_5_0_BGRT_VERSION         0x01
+
+///
+/// BGRT Status
+///
+#define EFI_ACPI_5_0_BGRT_STATUS_NOT_DISPLAYED 0x00
+#define EFI_ACPI_5_0_BGRT_STATUS_DISPLAYED     0x01
+#define EFI_ACPI_5_0_BGRT_STATUS_INVALID       EFI_ACPI_5_0_BGRT_STATUS_NOT_DISPLAYED
+#define EFI_ACPI_5_0_BGRT_STATUS_VALID         EFI_ACPI_5_0_BGRT_STATUS_DISPLAYED
+
+///
+/// BGRT Image Type
+///
+#define EFI_ACPI_5_0_BGRT_IMAGE_TYPE_BMP  0x00
+
+///
+/// FPDT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION 0x01
+
+///
+/// FPDT Performance Record Types
+///
+#define EFI_ACPI_5_0_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER      0x0000
+#define EFI_ACPI_5_0_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER     0x0001
+
+///
+/// FPDT Performance Record Revision
+///
+#define EFI_ACPI_5_0_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER  0x01
+#define EFI_ACPI_5_0_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER 0x01
+
+///
+/// FPDT Runtime Performance Record Types
+///
+#define EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME                0x0000
+#define EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND               0x0001
+#define EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT      0x0002
+
+///
+/// FPDT Runtime Performance Record Revision
+///
+#define EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
+#define EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
+#define EFI_ACPI_5_0_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02
+
+///
+/// FPDT Performance Record header
+///
+typedef struct {
+  UINT16           Type;
+  UINT8            Length;
+  UINT8            Revision;
+} EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER;
+
+///
+/// FPDT Performance Table header
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER;
+
+///
+/// FPDT Firmware Basic Boot Performance Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
+  ///
+  UINT64                                          BootPerformanceTablePointer;
+} EFI_ACPI_5_0_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT S3 Performance Table Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the S3 Performance Table.
+  ///
+  UINT64                                          S3PerformanceTablePointer;
+} EFI_ACPI_5_0_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Record Structure
+///
+typedef struct {
+  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// Timer value logged at the beginning of firmware image execution.
+  /// This may not always be zero or near zero.
+  ///
+  UINT64                                          ResetEnd;
+  ///
+  /// Timer value logged just prior to loading the OS boot loader into memory.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          OsLoaderLoadImageStart;
+  ///
+  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
+  /// For non-UEFI compatible boots, the timer value logged will be just prior
+  /// to the INT 19h handler invocation.
+  ///
+  UINT64                                          OsLoaderStartImageStart;
+  ///
+  /// Timer value logged at the point when the OS loader calls the
+  /// ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesEntry;
+  ///
+  /// Timer value logged at the point just prior to when the OS loader gaining
+  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesExit;
+} EFI_ACPI_5_0_FPDT_FIRMWARE_BASIC_BOOT_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Table signature
+///
+#define EFI_ACPI_5_0_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')
+
+//
+// FPDT Firmware Basic Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_5_0_FPDT_FIRMWARE_BASIC_BOOT_TABLE;
+
+///
+/// FPDT "S3PT" S3 Performance Table
+///
+#define EFI_ACPI_5_0_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')
+
+//
+// FPDT Firmware S3 Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_5_0_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_5_0_FPDT_FIRMWARE_S3_BOOT_TABLE;
+
+///
+/// FPDT Basic S3 Resume Performance Record
+///
+typedef struct {
+  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// A count of the number of S3 resume cycles since the last full boot sequence.
+  ///
+  UINT32                                          ResumeCount;
+  ///
+  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
+  /// OS waking vector. Only the most recent resume cycle's time is retained.
+  ///
+  UINT64                                          FullResume;
+  ///
+  /// Average timer value of all resume cycles logged since the last full boot
+  /// sequence, including the most recent resume.  Note that the entire log of
+  /// timer values does not need to be retained in order to calculate this average.
+  ///
+  UINT64                                          AverageResume;
+} EFI_ACPI_5_0_FPDT_S3_RESUME_RECORD;
+
+///
+/// FPDT Basic S3 Suspend Performance Record
+///
+typedef struct {
+  EFI_ACPI_5_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendStart;
+  ///
+  /// Timer value recorded at the final firmware write to SLP_TYP (or other
+  /// mechanism) used to trigger hardware entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendEnd;
+} EFI_ACPI_5_0_FPDT_S3_SUSPEND_RECORD;
+
+///
+/// Firmware Performance Record Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+} EFI_ACPI_5_0_FIRMWARE_PERFORMANCE_RECORD_TABLE;
+
+///
+/// Generic Timer Description Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      PhysicalAddress;
+  UINT32                      GlobalFlags;
+  UINT32                      SecurePL1TimerGSIV;
+  UINT32                      SecurePL1TimerFlags;
+  UINT32                      NonSecurePL1TimerGSIV;
+  UINT32                      NonSecurePL1TimerFlags;
+  UINT32                      VirtualTimerGSIV;
+  UINT32                      VirtualTimerFlags;
+  UINT32                      NonSecurePL2TimerGSIV;
+  UINT32                      NonSecurePL2TimerFlags;
+} EFI_ACPI_5_0_GENERIC_TIMER_DESCRIPTION_TABLE;
+
+///
+/// GTDT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Global Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_0_GTDT_GLOBAL_FLAG_MEMORY_MAPPED_BLOCK_PRESENT   BIT0
+#define EFI_ACPI_5_0_GTDT_GLOBAL_FLAG_INTERRUPT_MODE                BIT1
+
+///
+/// Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_5_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_5_0_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_5_0_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_5_0_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_5_0_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_5_0_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_5_0_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_5_0_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_5_0_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+} EFI_ACPI_5_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0201
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_5_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_5_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_5_0_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_5_0_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_5_0_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_5_0_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_5_0_GENERIC_HARDWARE_ERROR                     0x09
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_5_0_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_5_0_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_5_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_POLLED                0x00
+#define EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT    0x01
+#define EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT       0x02
+#define EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_SCI                   0x03
+#define EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_NMI                   0x04
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_5_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_5_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_5_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_5_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_5_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_5_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_5_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_5_0_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_5_0_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_5_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_5_0_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_5_0_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_5_0_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_5_0_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_5_0_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_5_0_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_5_0_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_5_0_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_5_0_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_5_0_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_5_0_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_5_0_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_5_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_5_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_5_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_5_0_ERST_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_5_0_ERST_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_5_0_ERST_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_5_0_ERST_STATUS_FAILED                            0x03
+#define EFI_ACPI_5_0_ERST_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_5_0_ERST_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_5_0_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_5_0_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_5_0_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_5_0_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_5_0_ERST_NOOP                                     0x04
+#define EFI_ACPI_5_0_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_5_0_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_5_0_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_5_0_ERST_ADD                                      0x08
+#define EFI_ACPI_5_0_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_5_0_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_5_0_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_5_0_ERST_STALL                                    0x0C
+#define EFI_ACPI_5_0_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_5_0_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_5_0_ERST_GOTO                                     0x0F
+#define EFI_ACPI_5_0_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_5_0_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_5_0_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_5_0_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_5_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_5_0_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_5_0_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_5_0_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_5_0_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_5_0_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_5_0_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_5_0_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_5_0_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_5_0_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_5_0_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_5_0_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_5_0_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_5_0_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_5_0_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_5_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_5_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_5_0_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_5_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_5_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_5_0_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_5_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_5_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_5_0_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_5_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_5_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_5_0_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_5_0_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_5_0_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_5_0_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_5_0_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_5_0_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_5_0_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_5_0_EINJ_TRIGGER_ACTION_TABLE;
+
+///
+/// Platform Communications Channel Table (PCCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Flags;
+  UINT64                      Reserved;
+} EFI_ACPI_5_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;
+
+///
+/// PCCT Version (as defined in ACPI 5.0 spec.)
+///
+#define EFI_ACPI_5_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION 0x01
+
+///
+/// PCCT Global Flags
+///
+#define EFI_ACPI_5_0_PCCT_FLAGS_SCI_DOORBELL                      BIT0
+
+//
+// PCCT Subspace type
+//
+#define EFI_ACPI_5_0_PCCT_SUBSPACE_TYPE_GENERIC  0x00
+
+///
+/// PCC Subspace Structure Header
+///
+typedef struct {
+  UINT8        Type;
+  UINT8        Length;
+} EFI_ACPI_5_0_PCCT_SUBSPACE_HEADER;
+
+///
+/// Generic Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT8                                    Reserved[6];
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_5_0_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_5_0_PCCT_SUBSPACE_GENERIC;
+
+///
+/// Generic Communications Channel Shared Memory Region
+///
+
+typedef struct {
+  UINT8                                    Command;
+  UINT8                                    Reserved:7;
+  UINT8                                    GenerateSci:1;
+} EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
+
+typedef struct {
+  UINT8                                    CommandComplete:1;
+  UINT8                                    SciDoorbell:1;
+  UINT8                                    Error:1;
+  UINT8                                    PlatformNotification:1;
+  UINT8                                    Reserved:4;
+  UINT8                                    Reserved1;
+} EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
+
+typedef struct {
+  UINT32                                                    Signature;
+  EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
+  EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
+} EFI_ACPI_5_0_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_5_0_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_5_0_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "BGRT" Boot Graphics Resource Table
+///
+#define EFI_ACPI_5_0_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_5_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_5_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_5_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_5_0_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_5_0_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_5_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_5_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FPDT" Firmware Performance Data Table
+///
+#define EFI_ACPI_5_0_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')
+
+///
+/// "GTDT" Generic Timer Description Table
+///
+#define EFI_ACPI_5_0_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_5_0_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "MPST" Memory Power State Table
+///
+#define EFI_ACPI_5_0_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_5_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "PMTT" Platform Memory Topology Table
+///
+#define EFI_ACPI_5_0_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_5_0_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RASF" ACPI RAS Feature Table
+///
+#define EFI_ACPI_5_0_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_5_0_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_5_0_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_5_0_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_5_0_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_5_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_5_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_5_0_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CSRT" MS Core System Resource Table
+///
+#define EFI_ACPI_5_0_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')
+
+///
+/// "DBG2" MS Debug Port 2 Spec
+///
+#define EFI_ACPI_5_0_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_5_0_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_5_0_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "DRTM" Dynamic Root of Trust for Measurement Table
+///
+#define EFI_ACPI_5_0_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_5_0_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_5_0_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_5_0_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_5_0_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_5_0_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_5_0_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "MSDM" MS Data Management Table
+///
+#define EFI_ACPI_5_0_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')
+
+///
+/// "PCCT" Platform Communications Channel Table
+///
+#define EFI_ACPI_5_0_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')
+
+///
+/// "SLIC" MS Software Licensing Table Specification
+///
+#define EFI_ACPI_5_0_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_5_0_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_5_0_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_5_0_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "TPM2" Trusted Computing Platform 1 Table
+///
+#define EFI_ACPI_5_0_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_5_0_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Emulated Devices Table
+///
+#define EFI_ACPI_5_0_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+#define EFI_ACPI_5_0_WINDOWS_ACPI_ENLIGHTENMENT_TABLE_SIGNATURE  EFI_ACPI_5_0_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_5_0_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_5_0_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WPBT" MS Platform Binary Table
+///
+#define EFI_ACPI_5_0_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi51.h b/libedk2_tpm/include/IndustryStandard/Acpi51.h
new file mode 100644
index 0000000..e2877df
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi51.h
@@ -0,0 +1,2139 @@
+/** @file
+  ACPI 5.1 definitions from the ACPI Specification Revision 5.1 Errata B January, 2016.
+
+  Copyright (c) 2014 Hewlett-Packard Development Company, L.P.<BR>
+  Copyright (c) 2014 - 2018, Intel Corporation. All rights reserved.<BR>
+  (C) Copyright 2015 Hewlett Packard Enterprise Development LP<BR>
+  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_5_1_H_
+#define _ACPI_5_1_H_
+
+#include <IndustryStandard/Acpi50.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 5.1 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_5_1_SYSTEM_MEMORY              0
+#define EFI_ACPI_5_1_SYSTEM_IO                  1
+#define EFI_ACPI_5_1_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_5_1_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_5_1_SMBUS                      4
+#define EFI_ACPI_5_1_PLATFORM_COMMUNICATION_CHANNEL  0x0A
+#define EFI_ACPI_5_1_FUNCTIONAL_FIXED_HARDWARE       0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_5_1_UNDEFINED  0
+#define EFI_ACPI_5_1_BYTE       1
+#define EFI_ACPI_5_1_WORD       2
+#define EFI_ACPI_5_1_DWORD      3
+#define EFI_ACPI_5_1_QWORD      4
+
+//
+// ACPI 5.1 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 5.1) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_5_1_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT16                                  ArmBootArch;
+  UINT8                                   MinorVersion;
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  SleepControlReg;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  SleepStatusReg;
+} EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x05
+#define EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION  0x01
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_5_1_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_5_1_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_5_1_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_5_1_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_5_1_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_5_1_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_5_1_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_5_1_PM_PROFILE_PERFORMANCE_SERVER  7
+#define EFI_ACPI_5_1_PM_PROFILE_TABLET              8
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_5_1_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_5_1_8042                        BIT1
+#define EFI_ACPI_5_1_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_5_1_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_5_1_PCIE_ASPM_CONTROLS          BIT4
+#define EFI_ACPI_5_1_CMOS_RTC_NOT_PRESENT        BIT5
+
+//
+// Fixed ACPI Description Table Arm Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_5_1_ARM_PSCI_COMPLIANT              BIT0
+#define EFI_ACPI_5_1_ARM_PSCI_USE_HVC                BIT1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_5_1_WBINVD                                 BIT0
+#define EFI_ACPI_5_1_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_5_1_PROC_C1                                BIT2
+#define EFI_ACPI_5_1_P_LVL2_UP                              BIT3
+#define EFI_ACPI_5_1_PWR_BUTTON                             BIT4
+#define EFI_ACPI_5_1_SLP_BUTTON                             BIT5
+#define EFI_ACPI_5_1_FIX_RTC                                BIT6
+#define EFI_ACPI_5_1_RTC_S4                                 BIT7
+#define EFI_ACPI_5_1_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_5_1_DCK_CAP                                BIT9
+#define EFI_ACPI_5_1_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_5_1_SEALED_CASE                            BIT11
+#define EFI_ACPI_5_1_HEADLESS                               BIT12
+#define EFI_ACPI_5_1_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_5_1_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_5_1_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_5_1_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_5_1_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_5_1_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_5_1_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+#define EFI_ACPI_5_1_HW_REDUCED_ACPI                        BIT20
+#define EFI_ACPI_5_1_LOW_POWER_S0_IDLE_CAPABLE              BIT21
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_5_1_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_1_S4BIOS_F                     BIT0
+#define EFI_ACPI_5_1_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_1_OSPM_64BIT_WAKE_F            BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_5_1_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_5_1_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_5_1_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x03
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_1_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x0D and 0x7F are reserved and
+// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
+//
+#define EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_5_1_IO_APIC                        0x01
+#define EFI_ACPI_5_1_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_5_1_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_5_1_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_5_1_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_5_1_IO_SAPIC                       0x06
+#define EFI_ACPI_5_1_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_5_1_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_5_1_LOCAL_X2APIC_NMI               0x0A
+#define EFI_ACPI_5_1_GIC                            0x0B
+#define EFI_ACPI_5_1_GICD                           0x0C
+#define EFI_ACPI_5_1_GIC_MSI_FRAME                  0x0D
+#define EFI_ACPI_5_1_GICR                           0x0E
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_LOCAL_APIC_ENABLED        BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_5_1_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_5_1_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_5_1_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_5_1_POLARITY      (3 << 0)
+#define EFI_ACPI_5_1_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_5_1_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_5_1_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_5_1_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_5_1_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_5_1_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_5_1_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_5_1_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_5_1_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// GIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  CPUInterfaceNumber;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ParkingProtocolVersion;
+  UINT32  PerformanceInterruptGsiv;
+  UINT64  ParkedAddress;
+  UINT64  PhysicalBaseAddress;
+  UINT64  GICV;
+  UINT64  GICH;
+  UINT32  VGICMaintenanceInterrupt;
+  UINT64  GICRBaseAddress;
+  UINT64  MPIDR;
+} EFI_ACPI_5_1_GIC_STRUCTURE;
+
+///
+/// GIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_GIC_ENABLED                              BIT0
+#define EFI_ACPI_5_1_PERFORMANCE_INTERRUPT_MODEL              BIT1
+#define EFI_ACPI_5_1_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS    BIT2
+
+///
+/// GIC Distributor Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  SystemVectorBase;
+  UINT8   GicVersion;
+  UINT8   Reserved2[3];
+} EFI_ACPI_5_1_GIC_DISTRIBUTOR_STRUCTURE;
+
+///
+/// GIC Version
+///
+#define EFI_ACPI_5_1_GIC_V1                                   0x01
+#define EFI_ACPI_5_1_GIC_V2                                   0x02
+#define EFI_ACPI_5_1_GIC_V3                                   0x03
+#define EFI_ACPI_5_1_GIC_V4                                   0x04
+
+///
+/// GIC MSI Frame Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicMsiFrameId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Flags;
+  UINT16  SPICount;
+  UINT16  SPIBase;
+} EFI_ACPI_5_1_GIC_MSI_FRAME_STRUCTURE;
+
+///
+/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_SPI_COUNT_BASE_SELECT                    BIT0
+
+///
+/// GICR Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  DiscoveryRangeBaseAddress;
+  UINT32  DiscoveryRangeLength;
+} EFI_ACPI_5_1_GICR_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_5_1_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_5_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT).  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_5_1_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x04 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_5_1_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+#define EFI_ACPI_5_1_GICC_AFFINITY                        0x03
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_5_1_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_5_1_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_5_1_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_5_1_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_5_1_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+} EFI_ACPI_5_1_GICC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_GICC_ENABLED (1 << 0)
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_5_1_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_5_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_5_1_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_5_1_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_5_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_5_1_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// ACPI RAS Feature Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier[12];
+} EFI_ACPI_5_1_RAS_FEATURE_TABLE;
+
+///
+/// RASF Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_RAS_FEATURE_TABLE_REVISION 0x01
+
+///
+/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT16                      Version;
+  UINT8                       RASCapabilities[16];
+  UINT8                       SetRASCapabilities[16];
+  UINT16                      NumberOfRASFParameterBlocks;
+  UINT32                      SetRASCapabilitiesStatus;
+} EFI_ACPI_5_1_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI RASF PCC command code
+///
+#define EFI_ACPI_5_1_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01
+
+///
+/// ACPI RASF Platform RAS Capabilities
+///
+#define EFI_ACPI_5_1_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED                          0x01
+#define EFI_ACPI_5_1_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED_AND_EXPOSED_TO_SOFTWARE  0x02
+
+///
+/// ACPI RASF Parameter Block structure for PATROL_SCRUB
+///
+typedef struct {
+  UINT16                      Type;
+  UINT16                      Version;
+  UINT16                      Length;
+  UINT16                      PatrolScrubCommand;
+  UINT64                      RequestedAddressRange[2];
+  UINT64                      ActualAddressRange[2];
+  UINT16                      Flags;
+  UINT8                       RequestedSpeed;
+} EFI_ACPI_5_1_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;
+
+///
+/// ACPI RASF Patrol Scrub command
+///
+#define EFI_ACPI_5_1_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS   0x01
+#define EFI_ACPI_5_1_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER   0x02
+#define EFI_ACPI_5_1_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER    0x03
+
+///
+/// Memory Power State Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier;
+  UINT8                       Reserved[3];
+// Memory Power Node Structure
+// Memory Power State Characteristics
+} EFI_ACPI_5_1_MEMORY_POWER_STATUS_TABLE;
+
+///
+/// MPST Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_MEMORY_POWER_STATE_TABLE_REVISION 0x01
+
+///
+/// MPST Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT32                      MemoryPowerCommandRegister;
+  UINT32                      MemoryPowerStatusRegister;
+  UINT32                      PowerStateId;
+  UINT32                      MemoryPowerNodeId;
+  UINT64                      MemoryEnergyConsumed;
+  UINT64                      ExpectedAveragePowerComsuned;
+} EFI_ACPI_5_1_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI MPST PCC command code
+///
+#define EFI_ACPI_5_1_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03
+
+///
+/// ACPI MPST Memory Power command
+///
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE       0x01
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE       0x02
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED   0x03
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED   0x04
+
+///
+/// MPST Memory Power Node Table
+///
+typedef struct {
+  UINT8                                             PowerStateValue;
+  UINT8                                             PowerStateInformationIndex;
+} EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE;
+
+typedef struct {
+  UINT8                                             Flag;
+  UINT8                                             Reserved;
+  UINT16                                            MemoryPowerNodeId;
+  UINT32                                            Length;
+  UINT64                                            AddressBase;
+  UINT64                                            AddressLength;
+  UINT32                                            NumberOfPowerStates;
+  UINT32                                            NumberOfPhysicalComponents;
+//EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
+//UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
+} EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE;
+
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE          0x01
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED   0x02
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE   0x04
+
+typedef struct {
+  UINT16                      MemoryPowerNodeCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_5_1_MPST_MEMORY_POWER_NODE_TABLE;
+
+///
+/// MPST Memory Power State Characteristics Table
+///
+typedef struct {
+  UINT8                                             PowerStateStructureID;
+  UINT8                                             Flag;
+  UINT16                                            Reserved;
+  UINT32                                            AveragePowerConsumedInMPS0;
+  UINT32                                            RelativePowerSavingToMPS0;
+  UINT64                                            ExitLatencyToMPS0;
+} EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;
+
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED              0x01
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY   0x02
+#define EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT    0x04
+
+typedef struct {
+  UINT16                      MemoryPowerStateCharacteristicsCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_5_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;
+
+///
+/// Memory Topology Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved;
+} EFI_ACPI_5_1_MEMORY_TOPOLOGY_TABLE;
+
+///
+/// PMTT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_MEMORY_TOPOLOGY_TABLE_REVISION 0x01
+
+///
+/// Common Memory Aggregator Device Structure.
+///
+typedef struct {
+  UINT8                       Type;
+  UINT8                       Reserved;
+  UINT16                      Length;
+  UINT16                      Flags;
+  UINT16                      Reserved1;
+} EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Memory Aggregator Device Type
+///
+#define EFI_ACPI_5_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET            0x0
+#define EFI_ACPI_5_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER 0x1
+#define EFI_ACPI_5_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM              0x2
+
+///
+/// Socket Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       SocketIdentifier;
+  UINT16                                                       Reserved;
+//EFI_ACPI_5_1_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
+} EFI_ACPI_5_1_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// MemoryController Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT32                                                       ReadLatency;
+  UINT32                                                       WriteLatency;
+  UINT32                                                       ReadBandwidth;
+  UINT32                                                       WriteBandwidth;
+  UINT16                                                       OptimalAccessUnit;
+  UINT16                                                       OptimalAccessAlignment;
+  UINT16                                                       Reserved;
+  UINT16                                                       NumberOfProximityDomains;
+//UINT32                                                       ProximityDomain[NumberOfProximityDomains];
+//EFI_ACPI_5_1_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
+} EFI_ACPI_5_1_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// DIMM Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_5_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       PhysicalComponentIdentifier;
+  UINT16                                                       Reserved;
+  UINT32                                                       SizeOfDimm;
+  UINT32                                                       SmbiosHandle;
+} EFI_ACPI_5_1_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Boot Graphics Resource Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  ///
+  /// 2-bytes (16 bit) version ID. This value must be 1.
+  ///
+  UINT16                      Version;
+  ///
+  /// 1-byte status field indicating current status about the table.
+  ///     Bits[7:1] = Reserved (must be zero)
+  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
+  ///
+  UINT8                       Status;
+  ///
+  /// 1-byte enumerated type field indicating format of the image.
+  ///     0 = Bitmap
+  ///     1 - 255  Reserved (for future use)
+  ///
+  UINT8                       ImageType;
+  ///
+  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
+  /// of the image bitmap.
+  ///
+  UINT64                      ImageAddress;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetX;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetY;
+} EFI_ACPI_5_1_BOOT_GRAPHICS_RESOURCE_TABLE;
+
+///
+/// BGRT Revision
+///
+#define EFI_ACPI_5_1_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION 1
+
+///
+/// BGRT Version
+///
+#define EFI_ACPI_5_1_BGRT_VERSION         0x01
+
+///
+/// BGRT Status
+///
+#define EFI_ACPI_5_1_BGRT_STATUS_NOT_DISPLAYED 0x00
+#define EFI_ACPI_5_1_BGRT_STATUS_DISPLAYED     0x01
+
+///
+/// BGRT Image Type
+///
+#define EFI_ACPI_5_1_BGRT_IMAGE_TYPE_BMP  0x00
+
+///
+/// FPDT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION 0x01
+
+///
+/// FPDT Performance Record Types
+///
+#define EFI_ACPI_5_1_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER      0x0000
+#define EFI_ACPI_5_1_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER     0x0001
+
+///
+/// FPDT Performance Record Revision
+///
+#define EFI_ACPI_5_1_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER  0x01
+#define EFI_ACPI_5_1_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER 0x01
+
+///
+/// FPDT Runtime Performance Record Types
+///
+#define EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME                0x0000
+#define EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND               0x0001
+#define EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT      0x0002
+
+///
+/// FPDT Runtime Performance Record Revision
+///
+#define EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
+#define EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
+#define EFI_ACPI_5_1_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02
+
+///
+/// FPDT Performance Record header
+///
+typedef struct {
+  UINT16           Type;
+  UINT8            Length;
+  UINT8            Revision;
+} EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER;
+
+///
+/// FPDT Performance Table header
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER;
+
+///
+/// FPDT Firmware Basic Boot Performance Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
+  ///
+  UINT64                                          BootPerformanceTablePointer;
+} EFI_ACPI_5_1_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT S3 Performance Table Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the S3 Performance Table.
+  ///
+  UINT64                                          S3PerformanceTablePointer;
+} EFI_ACPI_5_1_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Record Structure
+///
+typedef struct {
+  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// Timer value logged at the beginning of firmware image execution.
+  /// This may not always be zero or near zero.
+  ///
+  UINT64                                          ResetEnd;
+  ///
+  /// Timer value logged just prior to loading the OS boot loader into memory.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          OsLoaderLoadImageStart;
+  ///
+  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
+  /// For non-UEFI compatible boots, the timer value logged will be just prior
+  /// to the INT 19h handler invocation.
+  ///
+  UINT64                                          OsLoaderStartImageStart;
+  ///
+  /// Timer value logged at the point when the OS loader calls the
+  /// ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesEntry;
+  ///
+  /// Timer value logged at the point just prior to when the OS loader gaining
+  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesExit;
+} EFI_ACPI_5_1_FPDT_FIRMWARE_BASIC_BOOT_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Table signature
+///
+#define EFI_ACPI_5_1_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')
+
+//
+// FPDT Firmware Basic Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_5_1_FPDT_FIRMWARE_BASIC_BOOT_TABLE;
+
+///
+/// FPDT "S3PT" S3 Performance Table
+///
+#define EFI_ACPI_5_1_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')
+
+//
+// FPDT Firmware S3 Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_5_1_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_5_1_FPDT_FIRMWARE_S3_BOOT_TABLE;
+
+///
+/// FPDT Basic S3 Resume Performance Record
+///
+typedef struct {
+  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// A count of the number of S3 resume cycles since the last full boot sequence.
+  ///
+  UINT32                                          ResumeCount;
+  ///
+  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
+  /// OS waking vector. Only the most recent resume cycle's time is retained.
+  ///
+  UINT64                                          FullResume;
+  ///
+  /// Average timer value of all resume cycles logged since the last full boot
+  /// sequence, including the most recent resume.  Note that the entire log of
+  /// timer values does not need to be retained in order to calculate this average.
+  ///
+  UINT64                                          AverageResume;
+} EFI_ACPI_5_1_FPDT_S3_RESUME_RECORD;
+
+///
+/// FPDT Basic S3 Suspend Performance Record
+///
+typedef struct {
+  EFI_ACPI_5_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendStart;
+  ///
+  /// Timer value recorded at the final firmware write to SLP_TYP (or other
+  /// mechanism) used to trigger hardware entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendEnd;
+} EFI_ACPI_5_1_FPDT_S3_SUSPEND_RECORD;
+
+///
+/// Firmware Performance Record Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+} EFI_ACPI_5_1_FIRMWARE_PERFORMANCE_RECORD_TABLE;
+
+///
+/// Generic Timer Description Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      CntControlBasePhysicalAddress;
+  UINT32                      Reserved;
+  UINT32                      SecurePL1TimerGSIV;
+  UINT32                      SecurePL1TimerFlags;
+  UINT32                      NonSecurePL1TimerGSIV;
+  UINT32                      NonSecurePL1TimerFlags;
+  UINT32                      VirtualTimerGSIV;
+  UINT32                      VirtualTimerFlags;
+  UINT32                      NonSecurePL2TimerGSIV;
+  UINT32                      NonSecurePL2TimerFlags;
+  UINT64                      CntReadBasePhysicalAddress;
+  UINT32                      PlatformTimerCount;
+  UINT32                      PlatformTimerOffset;
+} EFI_ACPI_5_1_GENERIC_TIMER_DESCRIPTION_TABLE;
+
+///
+/// GTDT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION 0x02
+
+///
+/// Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_5_1_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_5_1_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY          BIT2
+
+///
+/// Platform Timer Type
+///
+#define EFI_ACPI_5_1_GTDT_GT_BLOCK                       0
+#define EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG          1
+
+///
+/// GT Block Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  CntCtlBase;
+  UINT32  GTBlockTimerCount;
+  UINT32  GTBlockTimerOffset;
+} EFI_ACPI_5_1_GTDT_GT_BLOCK_STRUCTURE;
+
+///
+/// GT Block Timer Structure
+///
+typedef struct {
+  UINT8   GTFrameNumber;
+  UINT8   Reserved[3];
+  UINT64  CntBaseX;
+  UINT64  CntEL0BaseX;
+  UINT32  GTxPhysicalTimerGSIV;
+  UINT32  GTxPhysicalTimerFlags;
+  UINT32  GTxVirtualTimerGSIV;
+  UINT32  GTxVirtualTimerFlags;
+  UINT32  GTxCommonFlags;
+} EFI_ACPI_5_1_GTDT_GT_BLOCK_TIMER_STRUCTURE;
+
+///
+/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_5_1_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+
+///
+/// Common Flags Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER              BIT0
+#define EFI_ACPI_5_1_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY      BIT1
+
+///
+/// SBSA Generic Watchdog Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  RefreshFramePhysicalAddress;
+  UINT64  WatchdogControlFramePhysicalAddress;
+  UINT32  WatchdogTimerGSIV;
+  UINT32  WatchdogTimerFlags;
+} EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE;
+
+///
+/// SBSA Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_5_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_SECURE_TIMER                  BIT2
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_5_1_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_5_1_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_5_1_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_5_1_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_5_1_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_5_1_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_5_1_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_5_1_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+} EFI_ACPI_5_1_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0201
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_5_1_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_5_1_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_5_1_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_5_1_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_5_1_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_5_1_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_5_1_GENERIC_HARDWARE_ERROR                     0x09
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_5_1_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_5_1_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_5_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_POLLED                0x00
+#define EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT    0x01
+#define EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT       0x02
+#define EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_SCI                   0x03
+#define EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_NMI                   0x04
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_5_1_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_5_1_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_5_1_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_5_1_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_5_1_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_5_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_5_1_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_5_1_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_5_1_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_5_1_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_5_1_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_5_1_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_5_1_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_5_1_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_5_1_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_5_1_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_5_1_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_5_1_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_5_1_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_5_1_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_5_1_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_5_1_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_5_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_5_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_5_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_5_1_ERST_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_5_1_ERST_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_5_1_ERST_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_5_1_ERST_STATUS_FAILED                            0x03
+#define EFI_ACPI_5_1_ERST_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_5_1_ERST_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_5_1_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_5_1_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_5_1_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_5_1_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_5_1_ERST_NOOP                                     0x04
+#define EFI_ACPI_5_1_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_5_1_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_5_1_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_5_1_ERST_ADD                                      0x08
+#define EFI_ACPI_5_1_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_5_1_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_5_1_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_5_1_ERST_STALL                                    0x0C
+#define EFI_ACPI_5_1_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_5_1_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_5_1_ERST_GOTO                                     0x0F
+#define EFI_ACPI_5_1_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_5_1_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_5_1_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_5_1_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_5_1_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_5_1_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_5_1_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_5_1_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_5_1_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_5_1_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_5_1_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_5_1_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_5_1_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_5_1_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_5_1_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_5_1_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_5_1_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_5_1_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_5_1_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_5_1_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_5_1_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_5_1_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_5_1_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_5_1_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_5_1_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_5_1_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_5_1_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_5_1_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_5_1_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_5_1_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_5_1_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_5_1_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_5_1_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_5_1_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_5_1_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_5_1_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_5_1_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_5_1_EINJ_TRIGGER_ACTION_TABLE;
+
+///
+/// Platform Communications Channel Table (PCCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Flags;
+  UINT64                      Reserved;
+} EFI_ACPI_5_1_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;
+
+///
+/// PCCT Version (as defined in ACPI 5.1 spec.)
+///
+#define EFI_ACPI_5_1_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION 0x01
+
+///
+/// PCCT Global Flags
+///
+#define EFI_ACPI_5_1_PCCT_FLAGS_SCI_DOORBELL                      BIT0
+
+//
+// PCCT Subspace type
+//
+#define EFI_ACPI_5_1_PCCT_SUBSPACE_TYPE_GENERIC  0x00
+
+///
+/// PCC Subspace Structure Header
+///
+typedef struct {
+  UINT8        Type;
+  UINT8        Length;
+} EFI_ACPI_5_1_PCCT_SUBSPACE_HEADER;
+
+///
+/// Generic Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT8                                    Reserved[6];
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_5_1_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_5_1_PCCT_SUBSPACE_GENERIC;
+
+///
+/// Generic Communications Channel Shared Memory Region
+///
+
+typedef struct {
+  UINT8                                    Command;
+  UINT8                                    Reserved:7;
+  UINT8                                    GenerateSci:1;
+} EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
+
+typedef struct {
+  UINT8                                    CommandComplete:1;
+  UINT8                                    SciDoorbell:1;
+  UINT8                                    Error:1;
+  UINT8                                    PlatformNotification:1;
+  UINT8                                    Reserved:4;
+  UINT8                                    Reserved1;
+} EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
+
+typedef struct {
+  UINT32                                                    Signature;
+  EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
+  EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
+} EFI_ACPI_5_1_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_5_1_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_5_1_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "BGRT" Boot Graphics Resource Table
+///
+#define EFI_ACPI_5_1_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_5_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_5_1_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_5_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_5_1_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_5_1_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_5_1_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_5_1_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FPDT" Firmware Performance Data Table
+///
+#define EFI_ACPI_5_1_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')
+
+///
+/// "GTDT" Generic Timer Description Table
+///
+#define EFI_ACPI_5_1_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_5_1_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "MPST" Memory Power State Table
+///
+#define EFI_ACPI_5_1_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_5_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "PMTT" Platform Memory Topology Table
+///
+#define EFI_ACPI_5_1_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_5_1_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RASF" ACPI RAS Feature Table
+///
+#define EFI_ACPI_5_1_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_5_1_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_5_1_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_5_1_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_5_1_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_5_1_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_5_1_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_5_1_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CSRT" MS Core System Resource Table
+///
+#define EFI_ACPI_5_1_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')
+
+///
+/// "DBG2" MS Debug Port 2 Spec
+///
+#define EFI_ACPI_5_1_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_5_1_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_5_1_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "DRTM" Dynamic Root of Trust for Measurement Table
+///
+#define EFI_ACPI_5_1_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_5_1_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_5_1_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_5_1_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_5_1_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "LPIT" Low Power Idle Table
+///
+#define EFI_ACPI_5_1_IO_LOW_POWER_IDLE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('L', 'P', 'I', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_5_1_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_5_1_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "MSDM" MS Data Management Table
+///
+#define EFI_ACPI_5_1_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')
+
+///
+/// "PCCT" Platform Communications Channel Table
+///
+#define EFI_ACPI_5_1_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')
+
+///
+/// "SLIC" MS Software Licensing Table Specification
+///
+#define EFI_ACPI_5_1_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_5_1_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_5_1_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_5_1_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "TPM2" Trusted Computing Platform 1 Table
+///
+#define EFI_ACPI_5_1_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_5_1_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Emulated Devices Table
+///
+#define EFI_ACPI_5_1_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_5_1_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_5_1_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WPBT" MS Platform Binary Table
+///
+#define EFI_ACPI_5_1_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi60.h b/libedk2_tpm/include/IndustryStandard/Acpi60.h
new file mode 100644
index 0000000..3b05df2
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi60.h
@@ -0,0 +1,2392 @@
+/** @file
+  ACPI 6.0 definitions from the ACPI Specification Revision 6.0 Errata A January, 2016.
+
+  Copyright (c) 2015 - 2018, Intel Corporation. All rights reserved.<BR>
+  (C) Copyright 2015-2016 Hewlett Packard Enterprise Development LP<BR>
+  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_6_0_H_
+#define _ACPI_6_0_H_
+
+#include <IndustryStandard/Acpi51.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 6.0 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_6_0_SYSTEM_MEMORY              0
+#define EFI_ACPI_6_0_SYSTEM_IO                  1
+#define EFI_ACPI_6_0_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_6_0_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_6_0_SMBUS                      4
+#define EFI_ACPI_6_0_PLATFORM_COMMUNICATION_CHANNEL  0x0A
+#define EFI_ACPI_6_0_FUNCTIONAL_FIXED_HARDWARE       0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_6_0_UNDEFINED  0
+#define EFI_ACPI_6_0_BYTE       1
+#define EFI_ACPI_6_0_WORD       2
+#define EFI_ACPI_6_0_DWORD      3
+#define EFI_ACPI_6_0_QWORD      4
+
+//
+// ACPI 6.0 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 6.0) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_0_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT16                                  ArmBootArch;
+  UINT8                                   MinorVersion;
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  SleepControlReg;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  SleepStatusReg;
+  UINT64                                  HypervisorVendorIdentity;
+} EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x06
+#define EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION  0x00
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_6_0_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_6_0_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_6_0_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_6_0_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_6_0_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_6_0_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_6_0_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_6_0_PM_PROFILE_PERFORMANCE_SERVER  7
+#define EFI_ACPI_6_0_PM_PROFILE_TABLET              8
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_0_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_6_0_8042                        BIT1
+#define EFI_ACPI_6_0_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_6_0_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_6_0_PCIE_ASPM_CONTROLS          BIT4
+#define EFI_ACPI_6_0_CMOS_RTC_NOT_PRESENT        BIT5
+
+//
+// Fixed ACPI Description Table Arm Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_0_ARM_PSCI_COMPLIANT              BIT0
+#define EFI_ACPI_6_0_ARM_PSCI_USE_HVC                BIT1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_0_WBINVD                                 BIT0
+#define EFI_ACPI_6_0_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_6_0_PROC_C1                                BIT2
+#define EFI_ACPI_6_0_P_LVL2_UP                              BIT3
+#define EFI_ACPI_6_0_PWR_BUTTON                             BIT4
+#define EFI_ACPI_6_0_SLP_BUTTON                             BIT5
+#define EFI_ACPI_6_0_FIX_RTC                                BIT6
+#define EFI_ACPI_6_0_RTC_S4                                 BIT7
+#define EFI_ACPI_6_0_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_6_0_DCK_CAP                                BIT9
+#define EFI_ACPI_6_0_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_6_0_SEALED_CASE                            BIT11
+#define EFI_ACPI_6_0_HEADLESS                               BIT12
+#define EFI_ACPI_6_0_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_6_0_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_6_0_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_6_0_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_6_0_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_6_0_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_6_0_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+#define EFI_ACPI_6_0_HW_REDUCED_ACPI                        BIT20
+#define EFI_ACPI_6_0_LOW_POWER_S0_IDLE_CAPABLE              BIT21
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_6_0_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_0_S4BIOS_F                     BIT0
+#define EFI_ACPI_6_0_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_0_OSPM_64BIT_WAKE_F            BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_6_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_6_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_6_0_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 6.0 Errata A spec.)
+///
+#define EFI_ACPI_6_0_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x04
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_0_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x0D and 0x7F are reserved and
+// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
+//
+#define EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_6_0_IO_APIC                        0x01
+#define EFI_ACPI_6_0_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_6_0_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_6_0_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_6_0_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_6_0_IO_SAPIC                       0x06
+#define EFI_ACPI_6_0_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_6_0_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_6_0_LOCAL_X2APIC_NMI               0x0A
+#define EFI_ACPI_6_0_GIC                            0x0B
+#define EFI_ACPI_6_0_GICD                           0x0C
+#define EFI_ACPI_6_0_GIC_MSI_FRAME                  0x0D
+#define EFI_ACPI_6_0_GICR                           0x0E
+#define EFI_ACPI_6_0_GIC_ITS                        0x0F
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_LOCAL_APIC_ENABLED        BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_6_0_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_6_0_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_6_0_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_0_POLARITY      (3 << 0)
+#define EFI_ACPI_6_0_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_6_0_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_6_0_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_6_0_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_6_0_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_6_0_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_6_0_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_0_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_0_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// GIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  CPUInterfaceNumber;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ParkingProtocolVersion;
+  UINT32  PerformanceInterruptGsiv;
+  UINT64  ParkedAddress;
+  UINT64  PhysicalBaseAddress;
+  UINT64  GICV;
+  UINT64  GICH;
+  UINT32  VGICMaintenanceInterrupt;
+  UINT64  GICRBaseAddress;
+  UINT64  MPIDR;
+  UINT8   ProcessorPowerEfficiencyClass;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_0_GIC_STRUCTURE;
+
+///
+/// GIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_GIC_ENABLED                              BIT0
+#define EFI_ACPI_6_0_PERFORMANCE_INTERRUPT_MODEL              BIT1
+#define EFI_ACPI_6_0_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS    BIT2
+
+///
+/// GIC Distributor Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  SystemVectorBase;
+  UINT8   GicVersion;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_0_GIC_DISTRIBUTOR_STRUCTURE;
+
+///
+/// GIC Version
+///
+#define EFI_ACPI_6_0_GIC_V1                                   0x01
+#define EFI_ACPI_6_0_GIC_V2                                   0x02
+#define EFI_ACPI_6_0_GIC_V3                                   0x03
+#define EFI_ACPI_6_0_GIC_V4                                   0x04
+
+///
+/// GIC MSI Frame Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicMsiFrameId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Flags;
+  UINT16  SPICount;
+  UINT16  SPIBase;
+} EFI_ACPI_6_0_GIC_MSI_FRAME_STRUCTURE;
+
+///
+/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_SPI_COUNT_BASE_SELECT                    BIT0
+
+///
+/// GICR Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  DiscoveryRangeBaseAddress;
+  UINT32  DiscoveryRangeLength;
+} EFI_ACPI_6_0_GICR_STRUCTURE;
+
+///
+/// GIC Interrupt Translation Service Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  GicItsId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Reserved2;
+} EFI_ACPI_6_0_GIC_ITS_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_6_0_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_6_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT).  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_6_0_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x04 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_6_0_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+#define EFI_ACPI_6_0_GICC_AFFINITY                        0x03
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_6_0_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_6_0_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_6_0_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_6_0_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_6_0_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+} EFI_ACPI_6_0_GICC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_GICC_ENABLED (1 << 0)
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_6_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_6_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_6_0_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_6_0_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_6_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_6_0_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// ACPI RAS Feature Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier[12];
+} EFI_ACPI_6_0_RAS_FEATURE_TABLE;
+
+///
+/// RASF Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_RAS_FEATURE_TABLE_REVISION 0x01
+
+///
+/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT16                      Version;
+  UINT8                       RASCapabilities[16];
+  UINT8                       SetRASCapabilities[16];
+  UINT16                      NumberOfRASFParameterBlocks;
+  UINT32                      SetRASCapabilitiesStatus;
+} EFI_ACPI_6_0_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI RASF PCC command code
+///
+#define EFI_ACPI_6_0_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01
+
+///
+/// ACPI RASF Platform RAS Capabilities
+///
+#define EFI_ACPI_6_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED                          0x01
+#define EFI_ACPI_6_0_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED_AND_EXPOSED_TO_SOFTWARE  0x02
+
+///
+/// ACPI RASF Parameter Block structure for PATROL_SCRUB
+///
+typedef struct {
+  UINT16                      Type;
+  UINT16                      Version;
+  UINT16                      Length;
+  UINT16                      PatrolScrubCommand;
+  UINT64                      RequestedAddressRange[2];
+  UINT64                      ActualAddressRange[2];
+  UINT16                      Flags;
+  UINT8                       RequestedSpeed;
+} EFI_ACPI_6_0_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;
+
+///
+/// ACPI RASF Patrol Scrub command
+///
+#define EFI_ACPI_6_0_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS   0x01
+#define EFI_ACPI_6_0_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER   0x02
+#define EFI_ACPI_6_0_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER    0x03
+
+///
+/// Memory Power State Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier;
+  UINT8                       Reserved[3];
+// Memory Power Node Structure
+// Memory Power State Characteristics
+} EFI_ACPI_6_0_MEMORY_POWER_STATUS_TABLE;
+
+///
+/// MPST Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_MEMORY_POWER_STATE_TABLE_REVISION 0x01
+
+///
+/// MPST Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT32                      MemoryPowerCommandRegister;
+  UINT32                      MemoryPowerStatusRegister;
+  UINT32                      PowerStateId;
+  UINT32                      MemoryPowerNodeId;
+  UINT64                      MemoryEnergyConsumed;
+  UINT64                      ExpectedAveragePowerComsuned;
+} EFI_ACPI_6_0_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI MPST PCC command code
+///
+#define EFI_ACPI_6_0_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03
+
+///
+/// ACPI MPST Memory Power command
+///
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE       0x01
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE       0x02
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED   0x03
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED   0x04
+
+///
+/// MPST Memory Power Node Table
+///
+typedef struct {
+  UINT8                                             PowerStateValue;
+  UINT8                                             PowerStateInformationIndex;
+} EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE;
+
+typedef struct {
+  UINT8                                             Flag;
+  UINT8                                             Reserved;
+  UINT16                                            MemoryPowerNodeId;
+  UINT32                                            Length;
+  UINT64                                            AddressBase;
+  UINT64                                            AddressLength;
+  UINT32                                            NumberOfPowerStates;
+  UINT32                                            NumberOfPhysicalComponents;
+//EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
+//UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
+} EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE;
+
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE          0x01
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED   0x02
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE   0x04
+
+typedef struct {
+  UINT16                      MemoryPowerNodeCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_0_MPST_MEMORY_POWER_NODE_TABLE;
+
+///
+/// MPST Memory Power State Characteristics Table
+///
+typedef struct {
+  UINT8                                             PowerStateStructureID;
+  UINT8                                             Flag;
+  UINT16                                            Reserved;
+  UINT32                                            AveragePowerConsumedInMPS0;
+  UINT32                                            RelativePowerSavingToMPS0;
+  UINT64                                            ExitLatencyToMPS0;
+} EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;
+
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED              0x01
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY   0x02
+#define EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT    0x04
+
+typedef struct {
+  UINT16                      MemoryPowerStateCharacteristicsCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_0_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;
+
+///
+/// Memory Topology Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved;
+} EFI_ACPI_6_0_MEMORY_TOPOLOGY_TABLE;
+
+///
+/// PMTT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_MEMORY_TOPOLOGY_TABLE_REVISION 0x01
+
+///
+/// Common Memory Aggregator Device Structure.
+///
+typedef struct {
+  UINT8                       Type;
+  UINT8                       Reserved;
+  UINT16                      Length;
+  UINT16                      Flags;
+  UINT16                      Reserved1;
+} EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Memory Aggregator Device Type
+///
+#define EFI_ACPI_6_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET            0x0
+#define EFI_ACPI_6_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER 0x1
+#define EFI_ACPI_6_0_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM              0x2
+
+///
+/// Socket Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       SocketIdentifier;
+  UINT16                                                       Reserved;
+//EFI_ACPI_6_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
+} EFI_ACPI_6_0_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// MemoryController Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT32                                                       ReadLatency;
+  UINT32                                                       WriteLatency;
+  UINT32                                                       ReadBandwidth;
+  UINT32                                                       WriteBandwidth;
+  UINT16                                                       OptimalAccessUnit;
+  UINT16                                                       OptimalAccessAlignment;
+  UINT16                                                       Reserved;
+  UINT16                                                       NumberOfProximityDomains;
+//UINT32                                                       ProximityDomain[NumberOfProximityDomains];
+//EFI_ACPI_6_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
+} EFI_ACPI_6_0_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// DIMM Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_0_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       PhysicalComponentIdentifier;
+  UINT16                                                       Reserved;
+  UINT32                                                       SizeOfDimm;
+  UINT32                                                       SmbiosHandle;
+} EFI_ACPI_6_0_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Boot Graphics Resource Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  ///
+  /// 2-bytes (16 bit) version ID. This value must be 1.
+  ///
+  UINT16                      Version;
+  ///
+  /// 1-byte status field indicating current status about the table.
+  ///     Bits[7:1] = Reserved (must be zero)
+  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
+  ///
+  UINT8                       Status;
+  ///
+  /// 1-byte enumerated type field indicating format of the image.
+  ///     0 = Bitmap
+  ///     1 - 255  Reserved (for future use)
+  ///
+  UINT8                       ImageType;
+  ///
+  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
+  /// of the image bitmap.
+  ///
+  UINT64                      ImageAddress;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetX;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetY;
+} EFI_ACPI_6_0_BOOT_GRAPHICS_RESOURCE_TABLE;
+
+///
+/// BGRT Revision
+///
+#define EFI_ACPI_6_0_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION 1
+
+///
+/// BGRT Version
+///
+#define EFI_ACPI_6_0_BGRT_VERSION         0x01
+
+///
+/// BGRT Status
+///
+#define EFI_ACPI_6_0_BGRT_STATUS_NOT_DISPLAYED 0x00
+#define EFI_ACPI_6_0_BGRT_STATUS_DISPLAYED     0x01
+
+///
+/// BGRT Image Type
+///
+#define EFI_ACPI_6_0_BGRT_IMAGE_TYPE_BMP  0x00
+
+///
+/// FPDT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION 0x01
+
+///
+/// FPDT Performance Record Types
+///
+#define EFI_ACPI_6_0_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER      0x0000
+#define EFI_ACPI_6_0_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER     0x0001
+
+///
+/// FPDT Performance Record Revision
+///
+#define EFI_ACPI_6_0_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER  0x01
+#define EFI_ACPI_6_0_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER 0x01
+
+///
+/// FPDT Runtime Performance Record Types
+///
+#define EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME                0x0000
+#define EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND               0x0001
+#define EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT      0x0002
+
+///
+/// FPDT Runtime Performance Record Revision
+///
+#define EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
+#define EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
+#define EFI_ACPI_6_0_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02
+
+///
+/// FPDT Performance Record header
+///
+typedef struct {
+  UINT16           Type;
+  UINT8            Length;
+  UINT8            Revision;
+} EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER;
+
+///
+/// FPDT Performance Table header
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER;
+
+///
+/// FPDT Firmware Basic Boot Performance Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
+  ///
+  UINT64                                          BootPerformanceTablePointer;
+} EFI_ACPI_6_0_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT S3 Performance Table Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the S3 Performance Table.
+  ///
+  UINT64                                          S3PerformanceTablePointer;
+} EFI_ACPI_6_0_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// Timer value logged at the beginning of firmware image execution.
+  /// This may not always be zero or near zero.
+  ///
+  UINT64                                          ResetEnd;
+  ///
+  /// Timer value logged just prior to loading the OS boot loader into memory.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          OsLoaderLoadImageStart;
+  ///
+  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
+  /// For non-UEFI compatible boots, the timer value logged will be just prior
+  /// to the INT 19h handler invocation.
+  ///
+  UINT64                                          OsLoaderStartImageStart;
+  ///
+  /// Timer value logged at the point when the OS loader calls the
+  /// ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesEntry;
+  ///
+  /// Timer value logged at the point just prior to when the OS loader gaining
+  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesExit;
+} EFI_ACPI_6_0_FPDT_FIRMWARE_BASIC_BOOT_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Table signature
+///
+#define EFI_ACPI_6_0_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')
+
+//
+// FPDT Firmware Basic Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_0_FPDT_FIRMWARE_BASIC_BOOT_TABLE;
+
+///
+/// FPDT "S3PT" S3 Performance Table
+///
+#define EFI_ACPI_6_0_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')
+
+//
+// FPDT Firmware S3 Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_0_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_0_FPDT_FIRMWARE_S3_BOOT_TABLE;
+
+///
+/// FPDT Basic S3 Resume Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// A count of the number of S3 resume cycles since the last full boot sequence.
+  ///
+  UINT32                                          ResumeCount;
+  ///
+  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
+  /// OS waking vector. Only the most recent resume cycle's time is retained.
+  ///
+  UINT64                                          FullResume;
+  ///
+  /// Average timer value of all resume cycles logged since the last full boot
+  /// sequence, including the most recent resume.  Note that the entire log of
+  /// timer values does not need to be retained in order to calculate this average.
+  ///
+  UINT64                                          AverageResume;
+} EFI_ACPI_6_0_FPDT_S3_RESUME_RECORD;
+
+///
+/// FPDT Basic S3 Suspend Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_0_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendStart;
+  ///
+  /// Timer value recorded at the final firmware write to SLP_TYP (or other
+  /// mechanism) used to trigger hardware entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendEnd;
+} EFI_ACPI_6_0_FPDT_S3_SUSPEND_RECORD;
+
+///
+/// Firmware Performance Record Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+} EFI_ACPI_6_0_FIRMWARE_PERFORMANCE_RECORD_TABLE;
+
+///
+/// Generic Timer Description Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      CntControlBasePhysicalAddress;
+  UINT32                      Reserved;
+  UINT32                      SecurePL1TimerGSIV;
+  UINT32                      SecurePL1TimerFlags;
+  UINT32                      NonSecurePL1TimerGSIV;
+  UINT32                      NonSecurePL1TimerFlags;
+  UINT32                      VirtualTimerGSIV;
+  UINT32                      VirtualTimerFlags;
+  UINT32                      NonSecurePL2TimerGSIV;
+  UINT32                      NonSecurePL2TimerFlags;
+  UINT64                      CntReadBasePhysicalAddress;
+  UINT32                      PlatformTimerCount;
+  UINT32                      PlatformTimerOffset;
+} EFI_ACPI_6_0_GENERIC_TIMER_DESCRIPTION_TABLE;
+
+///
+/// GTDT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION 0x02
+
+///
+/// Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_0_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_0_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY          BIT2
+
+///
+/// Platform Timer Type
+///
+#define EFI_ACPI_6_0_GTDT_GT_BLOCK                       0
+#define EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG          1
+
+///
+/// GT Block Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  CntCtlBase;
+  UINT32  GTBlockTimerCount;
+  UINT32  GTBlockTimerOffset;
+} EFI_ACPI_6_0_GTDT_GT_BLOCK_STRUCTURE;
+
+///
+/// GT Block Timer Structure
+///
+typedef struct {
+  UINT8   GTFrameNumber;
+  UINT8   Reserved[3];
+  UINT64  CntBaseX;
+  UINT64  CntEL0BaseX;
+  UINT32  GTxPhysicalTimerGSIV;
+  UINT32  GTxPhysicalTimerFlags;
+  UINT32  GTxVirtualTimerGSIV;
+  UINT32  GTxVirtualTimerFlags;
+  UINT32  GTxCommonFlags;
+} EFI_ACPI_6_0_GTDT_GT_BLOCK_TIMER_STRUCTURE;
+
+///
+/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_0_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+
+///
+/// Common Flags Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER              BIT0
+#define EFI_ACPI_6_0_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY      BIT1
+
+///
+/// SBSA Generic Watchdog Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  RefreshFramePhysicalAddress;
+  UINT64  WatchdogControlFramePhysicalAddress;
+  UINT32  WatchdogTimerGSIV;
+  UINT32  WatchdogTimerFlags;
+} EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE;
+
+///
+/// SBSA Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_0_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_SECURE_TIMER                  BIT2
+
+//
+// NVDIMM Firmware Interface Table definition.
+//
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER    Header;
+  UINT32                         Reserved;
+} EFI_ACPI_6_0_NVDIMM_FIRMWARE_INTERFACE_TABLE;
+
+//
+// NFIT Version (as defined in ACPI 6.0 spec.)
+//
+#define EFI_ACPI_6_0_NVDIMM_FIRMWARE_INTERFACE_TABLE_REVISION 0x1
+
+//
+// Definition for NFIT Table Structure Types
+//
+#define EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE_TYPE              0
+#define EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_TO_SYSTEM_ADDRESS_RANGE_MAP_STRUCTURE_TYPE  1
+#define EFI_ACPI_6_0_NFIT_INTERLEAVE_STRUCTURE_TYPE                                 2
+#define EFI_ACPI_6_0_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE_TYPE              3
+#define EFI_ACPI_6_0_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE_TYPE                      4
+#define EFI_ACPI_6_0_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE_TYPE            5
+#define EFI_ACPI_6_0_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE_TYPE                         6
+
+//
+// Definition for NFIT Structure Header
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+} EFI_ACPI_6_0_NFIT_STRUCTURE_HEADER;
+
+//
+// Definition for System Physical Address Range Structure
+//
+#define EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_CONTROL_REGION_FOR_MANAGEMENT      BIT0
+#define EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_PROXIMITY_DOMAIN_VALID             BIT1
+#define EFI_ACPI_6_0_NFIT_GUID_VOLATILE_MEMORY_REGION                             { 0x7305944F, 0xFDDA, 0x44E3, { 0xB1, 0x6C, 0x3F, 0x22, 0xD2, 0x52, 0xE5, 0xD0 }}
+#define EFI_ACPI_6_0_NFIT_GUID_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_REGION          { 0x66F0D379, 0xB4F3, 0x4074, { 0xAC, 0x43, 0x0D, 0x33, 0x18, 0xB7, 0x8C, 0xDB }}
+#define EFI_ACPI_6_0_NFIT_GUID_NVDIMM_CONTROL_REGION                              { 0x92F701F6, 0x13B4, 0x405D, { 0x91, 0x0B, 0x29, 0x93, 0x67, 0xE8, 0x23, 0x4C }}
+#define EFI_ACPI_6_0_NFIT_GUID_NVDIMM_BLOCK_DATA_WINDOW_REGION                    { 0x91AF0530, 0x5D86, 0x470E, { 0xA6, 0xB0, 0x0A, 0x2D, 0xB9, 0x40, 0x82, 0x49 }}
+#define EFI_ACPI_6_0_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_VOLATILE   { 0x77AB535A, 0x45FC, 0x624B, { 0x55, 0x60, 0xF7, 0xB2, 0x81, 0xD1, 0xF9, 0x6E }}
+#define EFI_ACPI_6_0_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_VOLATILE     { 0x3D5ABD30, 0x4175, 0x87CE, { 0x6D, 0x64, 0xD2, 0xAD, 0xE5, 0x23, 0xC4, 0xBB }}
+#define EFI_ACPI_6_0_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_PERSISTENT { 0x5CEA02C9, 0x4D07, 0x69D3, { 0x26, 0x9F ,0x44, 0x96, 0xFB, 0xE0, 0x96, 0xF9 }}
+#define EFI_ACPI_6_0_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_PERSISTENT   { 0x08018188, 0x42CD, 0xBB48, { 0x10, 0x0F, 0x53, 0x87, 0xD5, 0x3D, 0xED, 0x3D }}
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      SPARangeStructureIndex;
+  UINT16                                      Flags;
+  UINT32                                      Reserved_8;
+  UINT32                                      ProximityDomain;
+  GUID                                        AddressRangeTypeGUID;
+  UINT64                                      SystemPhysicalAddressRangeBase;
+  UINT64                                      SystemPhysicalAddressRangeLength;
+  UINT64                                      AddressRangeMemoryMappingAttribute;
+} EFI_ACPI_6_0_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE;
+
+//
+// Definition for Memory Device to System Physical Address Range Mapping Structure
+//
+typedef struct {
+  UINT32                                      DIMMNumber:4;
+  UINT32                                      MemoryChannelNumber:4;
+  UINT32                                      MemoryControllerID:4;
+  UINT32                                      SocketID:4;
+  UINT32                                      NodeControllerID:12;
+  UINT32                                      Reserved_28:4;
+} EFI_ACPI_6_0_NFIT_DEVICE_HANDLE;
+
+#define EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_PREVIOUS_SAVE_FAIL                                      BIT0
+#define EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_LAST_RESTORE_FAIL                                       BIT1
+#define EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_PLATFORM_FLUSH_FAIL                                     BIT2
+#define EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_NOT_ARMED_PRIOR_TO_OSPM_HAND_OFF                        BIT3
+#define EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_SMART_HEALTH_EVENTS_PRIOR_OSPM_HAND_OFF                 BIT4
+#define EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_ENABLED_TO_NOTIFY_OSPM_ON_SMART_HEALTH_EVENTS  BIT5
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_0_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      MemoryDevicePhysicalID;
+  UINT16                                      MemoryDeviceRegionID;
+  UINT16                                      SPARangeStructureIndex ;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT64                                      MemoryDeviceRegionSize;
+  UINT64                                      RegionOffset;
+  UINT64                                      MemoryDevicePhysicalAddressRegionBase;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      InterleaveWays;
+  UINT16                                      MemoryDeviceStateFlags;
+  UINT16                                      Reserved_46;
+} EFI_ACPI_6_0_NFIT_MEMORY_DEVICE_TO_SYSTEM_ADDRESS_RANGE_MAP_STRUCTURE;
+
+//
+// Definition for Interleave Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      Reserved_6;
+  UINT32                                      NumberOfLines;
+  UINT32                                      LineSize;
+//UINT32                                      LineOffset[NumberOfLines];
+} EFI_ACPI_6_0_NFIT_INTERLEAVE_STRUCTURE;
+
+//
+// Definition for SMBIOS Management Information Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT32                                      Reserved_4;
+//UINT8                                       Data[];
+} EFI_ACPI_6_0_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE;
+
+//
+// Definition for NVDIMM Control Region Structure
+//
+#define EFI_ACPI_6_0_NFIT_NVDIMM_CONTROL_REGION_FLAGS_BLOCK_DATA_WINDOWS_BUFFERED    BIT0
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      VendorID;
+  UINT16                                      DeviceID;
+  UINT16                                      RevisionID;
+  UINT16                                      SubsystemVendorID;
+  UINT16                                      SubsystemDeviceID;
+  UINT16                                      SubsystemRevisionID;
+  UINT8                                       Reserved_18[6];
+  UINT32                                      SerialNumber;
+  UINT16                                      RegionFormatInterfaceCode;
+  UINT16                                      NumberOfBlockControlWindows;
+  UINT64                                      SizeOfBlockControlWindow;
+  UINT64                                      CommandRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfCommandRegisterInBlockControlWindows;
+  UINT64                                      StatusRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfStatusRegisterInBlockControlWindows;
+  UINT16                                      NVDIMMControlRegionFlag;
+  UINT8                                       Reserved_74[6];
+} EFI_ACPI_6_0_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE;
+
+//
+// Definition for NVDIMM Block Data Window Region Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      NumberOfBlockDataWindows;
+  UINT64                                      BlockDataWindowStartOffset;
+  UINT64                                      SizeOfBlockDataWindow;
+  UINT64                                      BlockAccessibleMemoryCapacity;
+  UINT64                                      BeginningAddressOfFirstBlockInBlockAccessibleMemory;
+} EFI_ACPI_6_0_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE;
+
+//
+// Definition for Flush Hint Address Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_0_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NumberOfFlushHintAddresses;
+  UINT8                                       Reserved_10[6];
+//UINT64                                      FlushHintAddress[NumberOfFlushHintAddresses];
+} EFI_ACPI_6_0_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE;
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_6_0_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_6_0_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_0_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_6_0_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_6_0_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_6_0_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_6_0_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+} EFI_ACPI_6_0_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0201
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_6_0_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_6_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_6_0_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_6_0_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_6_0_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_6_0_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_6_0_GENERIC_HARDWARE_ERROR                     0x09
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_6_0_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_6_0_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_6_0_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_POLLED                0x00
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT    0x01
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT       0x02
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_SCI                   0x03
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_NMI                   0x04
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CMCI                  0x05
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_MCE                   0x06
+#define EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_GPIO_SIGNAL           0x07
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_6_0_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_6_0_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_6_0_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_0_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_0_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_0_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_6_0_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_6_0_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_0_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_6_0_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_6_0_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_6_0_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_6_0_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_6_0_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_6_0_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_6_0_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_0_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_0_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_0_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_6_0_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_6_0_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_6_0_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_6_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_6_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_6_0_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_6_0_ERST_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_0_ERST_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_6_0_ERST_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_6_0_ERST_STATUS_FAILED                            0x03
+#define EFI_ACPI_6_0_ERST_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_6_0_ERST_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_6_0_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_6_0_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_0_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_0_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_0_ERST_NOOP                                     0x04
+#define EFI_ACPI_6_0_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_6_0_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_6_0_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_6_0_ERST_ADD                                      0x08
+#define EFI_ACPI_6_0_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_6_0_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_6_0_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_6_0_ERST_STALL                                    0x0C
+#define EFI_ACPI_6_0_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_6_0_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_6_0_ERST_GOTO                                     0x0F
+#define EFI_ACPI_6_0_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_6_0_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_6_0_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_6_0_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_0_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_6_0_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_6_0_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_6_0_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_6_0_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_6_0_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_6_0_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_6_0_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_0_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_0_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_0_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_6_0_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_0_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_6_0_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_6_0_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_6_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_6_0_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_6_0_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_6_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_6_0_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_6_0_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_6_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_6_0_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_6_0_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_6_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_6_0_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_6_0_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_6_0_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_0_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_0_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_0_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_6_0_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_0_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_6_0_EINJ_TRIGGER_ACTION_TABLE;
+
+///
+/// Platform Communications Channel Table (PCCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Flags;
+  UINT64                      Reserved;
+} EFI_ACPI_6_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;
+
+///
+/// PCCT Version (as defined in ACPI 6.0 spec.)
+///
+#define EFI_ACPI_6_0_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION 0x01
+
+///
+/// PCCT Global Flags
+///
+#define EFI_ACPI_6_0_PCCT_FLAGS_SCI_DOORBELL                      BIT0
+
+//
+// PCCT Subspace type
+//
+#define EFI_ACPI_6_0_PCCT_SUBSPACE_TYPE_GENERIC                         0x00
+#define EFI_ACPI_6_0_PCCT_SUBSPACE_TYPE_1_HW_REDUCED_COMMUNICATIONS     0x01
+#define EFI_ACPI_6_0_PCCT_SUBSPACE_TYPE_2_HW_REDUCED_COMMUNICATIONS     0x02
+
+///
+/// PCC Subspace Structure Header
+///
+typedef struct {
+  UINT8        Type;
+  UINT8        Length;
+} EFI_ACPI_6_0_PCCT_SUBSPACE_HEADER;
+
+///
+/// Generic Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT8                                    Reserved[6];
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_0_PCCT_SUBSPACE_GENERIC;
+
+///
+/// Generic Communications Channel Shared Memory Region
+///
+
+typedef struct {
+  UINT8                                    Command;
+  UINT8                                    Reserved:7;
+  UINT8                                    GenerateSci:1;
+} EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
+
+typedef struct {
+  UINT8                                    CommandComplete:1;
+  UINT8                                    SciDoorbell:1;
+  UINT8                                    Error:1;
+  UINT8                                    PlatformNotification:1;
+  UINT8                                    Reserved:4;
+  UINT8                                    Reserved1;
+} EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
+
+typedef struct {
+  UINT32                                                    Signature;
+  EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
+  EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
+} EFI_ACPI_6_0_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;
+
+#define EFI_ACPI_6_0_PCCT_SUBSPACE_DOORBELL_INTERRUPT_FLAGS_POLARITY    BIT0
+#define EFI_ACPI_6_0_PCCT_SUBSPACE_DOORBELL_INTERRUPT_FLAGS_MODE        BIT1
+
+///
+/// Type 1 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   DoorbellInterrupt;
+  UINT8                                    DoorbellInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_0_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 2 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   DoorbellInterrupt;
+  UINT8                                    DoorbellInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_0_GENERIC_ADDRESS_STRUCTURE   DoorbellAckRegister;
+  UINT64                                   DoorbellAckPreserve;
+  UINT64                                   DoorbellAckWrite;
+} EFI_ACPI_6_0_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_6_0_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_6_0_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "BGRT" Boot Graphics Resource Table
+///
+#define EFI_ACPI_6_0_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_6_0_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_6_0_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_6_0_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_6_0_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_6_0_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_6_0_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_6_0_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FPDT" Firmware Performance Data Table
+///
+#define EFI_ACPI_6_0_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')
+
+///
+/// "GTDT" Generic Timer Description Table
+///
+#define EFI_ACPI_6_0_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_6_0_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "MPST" Memory Power State Table
+///
+#define EFI_ACPI_6_0_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_6_0_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "NFIT" NVDIMM Firmware Interface Table
+///
+#define EFI_ACPI_6_0_NVDIMM_FIRMWARE_INTERFACE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('N', 'F', 'I', 'T')
+
+///
+/// "PMTT" Platform Memory Topology Table
+///
+#define EFI_ACPI_6_0_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_6_0_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RASF" ACPI RAS Feature Table
+///
+#define EFI_ACPI_6_0_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_6_0_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_6_0_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_6_0_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_6_0_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_6_0_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_6_0_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_6_0_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CSRT" MS Core System Resource Table
+///
+#define EFI_ACPI_6_0_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')
+
+///
+/// "DBG2" MS Debug Port 2 Spec
+///
+#define EFI_ACPI_6_0_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_6_0_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_6_0_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "DRTM" Dynamic Root of Trust for Measurement Table
+///
+#define EFI_ACPI_6_0_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_6_0_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_6_0_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_6_0_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IORT" I/O Remapping Table
+///
+#define EFI_ACPI_6_0_IO_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('I', 'O', 'R', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_6_0_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "LPIT" Low Power Idle Table
+///
+#define EFI_ACPI_6_0_LOW_POWER_IDLE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('L', 'P', 'I', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_6_0_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_6_0_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "MSDM" MS Data Management Table
+///
+#define EFI_ACPI_6_0_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')
+
+///
+/// "PCCT" Platform Communications Channel Table
+///
+#define EFI_ACPI_6_0_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')
+
+///
+/// "SLIC" MS Software Licensing Table Specification
+///
+#define EFI_ACPI_6_0_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_6_0_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_6_0_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "STAO" _STA Override Table
+///
+#define EFI_ACPI_6_0_STA_OVERRIDE_TABLE_SIGNATURE  SIGNATURE_32('S', 'T', 'A', 'O')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_6_0_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "TPM2" Trusted Computing Platform 1 Table
+///
+#define EFI_ACPI_6_0_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_6_0_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Emulated Devices Table
+///
+#define EFI_ACPI_6_0_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_6_0_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_6_0_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WPBT" MS Platform Binary Table
+///
+#define EFI_ACPI_6_0_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')
+
+///
+/// "XENV" Xen Project Table
+///
+#define EFI_ACPI_6_0_XEN_PROJECT_TABLE_SIGNATURE  SIGNATURE_32('X', 'E', 'N', 'V')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi61.h b/libedk2_tpm/include/IndustryStandard/Acpi61.h
new file mode 100644
index 0000000..31ba4e7
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi61.h
@@ -0,0 +1,2424 @@
+/** @file
+  ACPI 6.1 definitions from the ACPI Specification Revision 6.1 January, 2016.
+
+  Copyright (c) 2016 - 2018, Intel Corporation. All rights reserved.<BR>
+ (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
+  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_6_1_H_
+#define _ACPI_6_1_H_
+
+#include <IndustryStandard/Acpi60.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 6.1 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_6_1_SYSTEM_MEMORY              0
+#define EFI_ACPI_6_1_SYSTEM_IO                  1
+#define EFI_ACPI_6_1_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_6_1_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_6_1_SMBUS                      4
+#define EFI_ACPI_6_1_PLATFORM_COMMUNICATION_CHANNEL  0x0A
+#define EFI_ACPI_6_1_FUNCTIONAL_FIXED_HARDWARE       0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_6_1_UNDEFINED  0
+#define EFI_ACPI_6_1_BYTE       1
+#define EFI_ACPI_6_1_WORD       2
+#define EFI_ACPI_6_1_DWORD      3
+#define EFI_ACPI_6_1_QWORD      4
+
+//
+// ACPI 6.1 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_1_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 6.1) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_1_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT16                                  ArmBootArch;
+  UINT8                                   MinorVersion;
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  SleepControlReg;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  SleepStatusReg;
+  UINT64                                  HypervisorVendorIdentity;
+} EFI_ACPI_6_1_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x06
+#define EFI_ACPI_6_1_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION  0x01
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_6_1_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_6_1_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_6_1_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_6_1_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_6_1_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_6_1_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_6_1_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_6_1_PM_PROFILE_PERFORMANCE_SERVER  7
+#define EFI_ACPI_6_1_PM_PROFILE_TABLET              8
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_1_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_6_1_8042                        BIT1
+#define EFI_ACPI_6_1_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_6_1_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_6_1_PCIE_ASPM_CONTROLS          BIT4
+#define EFI_ACPI_6_1_CMOS_RTC_NOT_PRESENT        BIT5
+
+//
+// Fixed ACPI Description Table Arm Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_1_ARM_PSCI_COMPLIANT              BIT0
+#define EFI_ACPI_6_1_ARM_PSCI_USE_HVC                BIT1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_1_WBINVD                                 BIT0
+#define EFI_ACPI_6_1_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_6_1_PROC_C1                                BIT2
+#define EFI_ACPI_6_1_P_LVL2_UP                              BIT3
+#define EFI_ACPI_6_1_PWR_BUTTON                             BIT4
+#define EFI_ACPI_6_1_SLP_BUTTON                             BIT5
+#define EFI_ACPI_6_1_FIX_RTC                                BIT6
+#define EFI_ACPI_6_1_RTC_S4                                 BIT7
+#define EFI_ACPI_6_1_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_6_1_DCK_CAP                                BIT9
+#define EFI_ACPI_6_1_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_6_1_SEALED_CASE                            BIT11
+#define EFI_ACPI_6_1_HEADLESS                               BIT12
+#define EFI_ACPI_6_1_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_6_1_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_6_1_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_6_1_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_6_1_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_6_1_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_6_1_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+#define EFI_ACPI_6_1_HW_REDUCED_ACPI                        BIT20
+#define EFI_ACPI_6_1_LOW_POWER_S0_IDLE_CAPABLE              BIT21
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_6_1_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_1_S4BIOS_F                     BIT0
+#define EFI_ACPI_6_1_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_1_OSPM_64BIT_WAKE_F            BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_6_1_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_6_1_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_6_1_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x04
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_1_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x0D and 0x7F are reserved and
+// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
+//
+#define EFI_ACPI_6_1_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_6_1_IO_APIC                        0x01
+#define EFI_ACPI_6_1_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_6_1_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_6_1_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_6_1_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_6_1_IO_SAPIC                       0x06
+#define EFI_ACPI_6_1_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_6_1_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_6_1_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_6_1_LOCAL_X2APIC_NMI               0x0A
+#define EFI_ACPI_6_1_GIC                            0x0B
+#define EFI_ACPI_6_1_GICD                           0x0C
+#define EFI_ACPI_6_1_GIC_MSI_FRAME                  0x0D
+#define EFI_ACPI_6_1_GICR                           0x0E
+#define EFI_ACPI_6_1_GIC_ITS                        0x0F
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_6_1_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_LOCAL_APIC_ENABLED        BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_6_1_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_6_1_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_6_1_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_1_POLARITY      (3 << 0)
+#define EFI_ACPI_6_1_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_6_1_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_6_1_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_6_1_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_6_1_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_6_1_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_6_1_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_1_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_6_1_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_1_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// GIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  CPUInterfaceNumber;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ParkingProtocolVersion;
+  UINT32  PerformanceInterruptGsiv;
+  UINT64  ParkedAddress;
+  UINT64  PhysicalBaseAddress;
+  UINT64  GICV;
+  UINT64  GICH;
+  UINT32  VGICMaintenanceInterrupt;
+  UINT64  GICRBaseAddress;
+  UINT64  MPIDR;
+  UINT8   ProcessorPowerEfficiencyClass;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_1_GIC_STRUCTURE;
+
+///
+/// GIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_GIC_ENABLED                              BIT0
+#define EFI_ACPI_6_1_PERFORMANCE_INTERRUPT_MODEL              BIT1
+#define EFI_ACPI_6_1_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS    BIT2
+
+///
+/// GIC Distributor Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  SystemVectorBase;
+  UINT8   GicVersion;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_1_GIC_DISTRIBUTOR_STRUCTURE;
+
+///
+/// GIC Version
+///
+#define EFI_ACPI_6_1_GIC_V1                                   0x01
+#define EFI_ACPI_6_1_GIC_V2                                   0x02
+#define EFI_ACPI_6_1_GIC_V3                                   0x03
+#define EFI_ACPI_6_1_GIC_V4                                   0x04
+
+///
+/// GIC MSI Frame Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicMsiFrameId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Flags;
+  UINT16  SPICount;
+  UINT16  SPIBase;
+} EFI_ACPI_6_1_GIC_MSI_FRAME_STRUCTURE;
+
+///
+/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_SPI_COUNT_BASE_SELECT                    BIT0
+
+///
+/// GICR Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  DiscoveryRangeBaseAddress;
+  UINT32  DiscoveryRangeLength;
+} EFI_ACPI_6_1_GICR_STRUCTURE;
+
+///
+/// GIC Interrupt Translation Service Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  GicItsId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Reserved2;
+} EFI_ACPI_6_1_GIC_ITS_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_6_1_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_6_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT).  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_6_1_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x04 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_6_1_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_6_1_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_6_1_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+#define EFI_ACPI_6_1_GICC_AFFINITY                        0x03
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_6_1_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_6_1_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_6_1_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_6_1_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_6_1_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_6_1_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+} EFI_ACPI_6_1_GICC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_GICC_ENABLED (1 << 0)
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_6_1_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_6_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_6_1_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_6_1_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_6_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_6_1_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// ACPI RAS Feature Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier[12];
+} EFI_ACPI_6_1_RAS_FEATURE_TABLE;
+
+///
+/// RASF Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_RAS_FEATURE_TABLE_REVISION 0x01
+
+///
+/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT16                      Version;
+  UINT8                       RASCapabilities[16];
+  UINT8                       SetRASCapabilities[16];
+  UINT16                      NumberOfRASFParameterBlocks;
+  UINT32                      SetRASCapabilitiesStatus;
+} EFI_ACPI_6_1_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI RASF PCC command code
+///
+#define EFI_ACPI_6_1_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01
+
+///
+/// ACPI RASF Platform RAS Capabilities
+///
+#define EFI_ACPI_6_1_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED                          0x01
+#define EFI_ACPI_6_1_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPOTED_AND_EXPOSED_TO_SOFTWARE  0x02
+
+///
+/// ACPI RASF Parameter Block structure for PATROL_SCRUB
+///
+typedef struct {
+  UINT16                      Type;
+  UINT16                      Version;
+  UINT16                      Length;
+  UINT16                      PatrolScrubCommand;
+  UINT64                      RequestedAddressRange[2];
+  UINT64                      ActualAddressRange[2];
+  UINT16                      Flags;
+  UINT8                       RequestedSpeed;
+} EFI_ACPI_6_1_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;
+
+///
+/// ACPI RASF Patrol Scrub command
+///
+#define EFI_ACPI_6_1_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS   0x01
+#define EFI_ACPI_6_1_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER   0x02
+#define EFI_ACPI_6_1_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER    0x03
+
+///
+/// Memory Power State Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier;
+  UINT8                       Reserved[3];
+// Memory Power Node Structure
+// Memory Power State Characteristics
+} EFI_ACPI_6_1_MEMORY_POWER_STATUS_TABLE;
+
+///
+/// MPST Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_MEMORY_POWER_STATE_TABLE_REVISION 0x01
+
+///
+/// MPST Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT32                      MemoryPowerCommandRegister;
+  UINT32                      MemoryPowerStatusRegister;
+  UINT32                      PowerStateId;
+  UINT32                      MemoryPowerNodeId;
+  UINT64                      MemoryEnergyConsumed;
+  UINT64                      ExpectedAveragePowerComsuned;
+} EFI_ACPI_6_1_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI MPST PCC command code
+///
+#define EFI_ACPI_6_1_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03
+
+///
+/// ACPI MPST Memory Power command
+///
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE       0x01
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE       0x02
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED   0x03
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED   0x04
+
+///
+/// MPST Memory Power Node Table
+///
+typedef struct {
+  UINT8                                             PowerStateValue;
+  UINT8                                             PowerStateInformationIndex;
+} EFI_ACPI_6_1_MPST_MEMORY_POWER_STATE;
+
+typedef struct {
+  UINT8                                             Flag;
+  UINT8                                             Reserved;
+  UINT16                                            MemoryPowerNodeId;
+  UINT32                                            Length;
+  UINT64                                            AddressBase;
+  UINT64                                            AddressLength;
+  UINT32                                            NumberOfPowerStates;
+  UINT32                                            NumberOfPhysicalComponents;
+//EFI_ACPI_6_1_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
+//UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
+} EFI_ACPI_6_1_MPST_MEMORY_POWER_STRUCTURE;
+
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE          0x01
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED   0x02
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE   0x04
+
+typedef struct {
+  UINT16                      MemoryPowerNodeCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_1_MPST_MEMORY_POWER_NODE_TABLE;
+
+///
+/// MPST Memory Power State Characteristics Table
+///
+typedef struct {
+  UINT8                                             PowerStateStructureID;
+  UINT8                                             Flag;
+  UINT16                                            Reserved;
+  UINT32                                            AveragePowerConsumedInMPS0;
+  UINT32                                            RelativePowerSavingToMPS0;
+  UINT64                                            ExitLatencyToMPS0;
+} EFI_ACPI_6_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;
+
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED              0x01
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY   0x02
+#define EFI_ACPI_6_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT    0x04
+
+typedef struct {
+  UINT16                      MemoryPowerStateCharacteristicsCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_1_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;
+
+///
+/// Memory Topology Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved;
+} EFI_ACPI_6_1_MEMORY_TOPOLOGY_TABLE;
+
+///
+/// PMTT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_MEMORY_TOPOLOGY_TABLE_REVISION 0x01
+
+///
+/// Common Memory Aggregator Device Structure.
+///
+typedef struct {
+  UINT8                       Type;
+  UINT8                       Reserved;
+  UINT16                      Length;
+  UINT16                      Flags;
+  UINT16                      Reserved1;
+} EFI_ACPI_6_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Memory Aggregator Device Type
+///
+#define EFI_ACPI_6_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET            0x0
+#define EFI_ACPI_6_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER 0x1
+#define EFI_ACPI_6_1_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM              0x2
+
+///
+/// Socket Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       SocketIdentifier;
+  UINT16                                                       Reserved;
+//EFI_ACPI_6_1_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
+} EFI_ACPI_6_1_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// MemoryController Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT32                                                       ReadLatency;
+  UINT32                                                       WriteLatency;
+  UINT32                                                       ReadBandwidth;
+  UINT32                                                       WriteBandwidth;
+  UINT16                                                       OptimalAccessUnit;
+  UINT16                                                       OptimalAccessAlignment;
+  UINT16                                                       Reserved;
+  UINT16                                                       NumberOfProximityDomains;
+//UINT32                                                       ProximityDomain[NumberOfProximityDomains];
+//EFI_ACPI_6_1_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
+} EFI_ACPI_6_1_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// DIMM Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_1_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       PhysicalComponentIdentifier;
+  UINT16                                                       Reserved;
+  UINT32                                                       SizeOfDimm;
+  UINT32                                                       SmbiosHandle;
+} EFI_ACPI_6_1_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Boot Graphics Resource Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  ///
+  /// 2-bytes (16 bit) version ID. This value must be 1.
+  ///
+  UINT16                      Version;
+  ///
+  /// 1-byte status field indicating current status about the table.
+  ///     Bits[7:1] = Reserved (must be zero)
+  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
+  ///
+  UINT8                       Status;
+  ///
+  /// 1-byte enumerated type field indicating format of the image.
+  ///     0 = Bitmap
+  ///     1 - 255  Reserved (for future use)
+  ///
+  UINT8                       ImageType;
+  ///
+  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
+  /// of the image bitmap.
+  ///
+  UINT64                      ImageAddress;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetX;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetY;
+} EFI_ACPI_6_1_BOOT_GRAPHICS_RESOURCE_TABLE;
+
+///
+/// BGRT Revision
+///
+#define EFI_ACPI_6_1_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION 1
+
+///
+/// BGRT Version
+///
+#define EFI_ACPI_6_1_BGRT_VERSION         0x01
+
+///
+/// BGRT Status
+///
+#define EFI_ACPI_6_1_BGRT_STATUS_NOT_DISPLAYED 0x00
+#define EFI_ACPI_6_1_BGRT_STATUS_DISPLAYED     0x01
+
+///
+/// BGRT Image Type
+///
+#define EFI_ACPI_6_1_BGRT_IMAGE_TYPE_BMP  0x00
+
+///
+/// FPDT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION 0x01
+
+///
+/// FPDT Performance Record Types
+///
+#define EFI_ACPI_6_1_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER      0x0000
+#define EFI_ACPI_6_1_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER     0x0001
+
+///
+/// FPDT Performance Record Revision
+///
+#define EFI_ACPI_6_1_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER  0x01
+#define EFI_ACPI_6_1_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER 0x01
+
+///
+/// FPDT Runtime Performance Record Types
+///
+#define EFI_ACPI_6_1_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME                0x0000
+#define EFI_ACPI_6_1_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND               0x0001
+#define EFI_ACPI_6_1_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT      0x0002
+
+///
+/// FPDT Runtime Performance Record Revision
+///
+#define EFI_ACPI_6_1_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
+#define EFI_ACPI_6_1_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
+#define EFI_ACPI_6_1_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02
+
+///
+/// FPDT Performance Record header
+///
+typedef struct {
+  UINT16           Type;
+  UINT8            Length;
+  UINT8            Revision;
+} EFI_ACPI_6_1_FPDT_PERFORMANCE_RECORD_HEADER;
+
+///
+/// FPDT Performance Table header
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_1_FPDT_PERFORMANCE_TABLE_HEADER;
+
+///
+/// FPDT Firmware Basic Boot Performance Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
+  ///
+  UINT64                                          BootPerformanceTablePointer;
+} EFI_ACPI_6_1_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT S3 Performance Table Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the S3 Performance Table.
+  ///
+  UINT64                                          S3PerformanceTablePointer;
+} EFI_ACPI_6_1_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// Timer value logged at the beginning of firmware image execution.
+  /// This may not always be zero or near zero.
+  ///
+  UINT64                                          ResetEnd;
+  ///
+  /// Timer value logged just prior to loading the OS boot loader into memory.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          OsLoaderLoadImageStart;
+  ///
+  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
+  /// For non-UEFI compatible boots, the timer value logged will be just prior
+  /// to the INT 19h handler invocation.
+  ///
+  UINT64                                          OsLoaderStartImageStart;
+  ///
+  /// Timer value logged at the point when the OS loader calls the
+  /// ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesEntry;
+  ///
+  /// Timer value logged at the point just prior to when the OS loader gaining
+  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesExit;
+} EFI_ACPI_6_1_FPDT_FIRMWARE_BASIC_BOOT_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Table signature
+///
+#define EFI_ACPI_6_1_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')
+
+//
+// FPDT Firmware Basic Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_1_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_1_FPDT_FIRMWARE_BASIC_BOOT_TABLE;
+
+///
+/// FPDT "S3PT" S3 Performance Table
+///
+#define EFI_ACPI_6_1_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')
+
+//
+// FPDT Firmware S3 Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_1_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_1_FPDT_FIRMWARE_S3_BOOT_TABLE;
+
+///
+/// FPDT Basic S3 Resume Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// A count of the number of S3 resume cycles since the last full boot sequence.
+  ///
+  UINT32                                          ResumeCount;
+  ///
+  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
+  /// OS waking vector. Only the most recent resume cycle's time is retained.
+  ///
+  UINT64                                          FullResume;
+  ///
+  /// Average timer value of all resume cycles logged since the last full boot
+  /// sequence, including the most recent resume.  Note that the entire log of
+  /// timer values does not need to be retained in order to calculate this average.
+  ///
+  UINT64                                          AverageResume;
+} EFI_ACPI_6_1_FPDT_S3_RESUME_RECORD;
+
+///
+/// FPDT Basic S3 Suspend Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_1_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendStart;
+  ///
+  /// Timer value recorded at the final firmware write to SLP_TYP (or other
+  /// mechanism) used to trigger hardware entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendEnd;
+} EFI_ACPI_6_1_FPDT_S3_SUSPEND_RECORD;
+
+///
+/// Firmware Performance Record Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+} EFI_ACPI_6_1_FIRMWARE_PERFORMANCE_RECORD_TABLE;
+
+///
+/// Generic Timer Description Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      CntControlBasePhysicalAddress;
+  UINT32                      Reserved;
+  UINT32                      SecurePL1TimerGSIV;
+  UINT32                      SecurePL1TimerFlags;
+  UINT32                      NonSecurePL1TimerGSIV;
+  UINT32                      NonSecurePL1TimerFlags;
+  UINT32                      VirtualTimerGSIV;
+  UINT32                      VirtualTimerFlags;
+  UINT32                      NonSecurePL2TimerGSIV;
+  UINT32                      NonSecurePL2TimerFlags;
+  UINT64                      CntReadBasePhysicalAddress;
+  UINT32                      PlatformTimerCount;
+  UINT32                      PlatformTimerOffset;
+} EFI_ACPI_6_1_GENERIC_TIMER_DESCRIPTION_TABLE;
+
+///
+/// GTDT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION 0x02
+
+///
+/// Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_1_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_1_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY          BIT2
+
+///
+/// Platform Timer Type
+///
+#define EFI_ACPI_6_1_GTDT_GT_BLOCK                       0
+#define EFI_ACPI_6_1_GTDT_SBSA_GENERIC_WATCHDOG          1
+
+///
+/// GT Block Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  CntCtlBase;
+  UINT32  GTBlockTimerCount;
+  UINT32  GTBlockTimerOffset;
+} EFI_ACPI_6_1_GTDT_GT_BLOCK_STRUCTURE;
+
+///
+/// GT Block Timer Structure
+///
+typedef struct {
+  UINT8   GTFrameNumber;
+  UINT8   Reserved[3];
+  UINT64  CntBaseX;
+  UINT64  CntEL0BaseX;
+  UINT32  GTxPhysicalTimerGSIV;
+  UINT32  GTxPhysicalTimerFlags;
+  UINT32  GTxVirtualTimerGSIV;
+  UINT32  GTxVirtualTimerFlags;
+  UINT32  GTxCommonFlags;
+} EFI_ACPI_6_1_GTDT_GT_BLOCK_TIMER_STRUCTURE;
+
+///
+/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_1_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+
+///
+/// Common Flags Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER              BIT0
+#define EFI_ACPI_6_1_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY      BIT1
+
+///
+/// SBSA Generic Watchdog Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  RefreshFramePhysicalAddress;
+  UINT64  WatchdogControlFramePhysicalAddress;
+  UINT32  WatchdogTimerGSIV;
+  UINT32  WatchdogTimerFlags;
+} EFI_ACPI_6_1_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE;
+
+///
+/// SBSA Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_1_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_SECURE_TIMER                  BIT2
+
+//
+// NVDIMM Firmware Interface Table definition.
+//
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER    Header;
+  UINT32                         Reserved;
+} EFI_ACPI_6_1_NVDIMM_FIRMWARE_INTERFACE_TABLE;
+
+//
+// NFIT Version (as defined in ACPI 6.1 spec.)
+//
+#define EFI_ACPI_6_1_NVDIMM_FIRMWARE_INTERFACE_TABLE_REVISION 0x1
+
+//
+// Definition for NFIT Table Structure Types
+//
+#define EFI_ACPI_6_1_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE_TYPE              0
+#define EFI_ACPI_6_1_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE_TYPE                      1
+#define EFI_ACPI_6_1_NFIT_INTERLEAVE_STRUCTURE_TYPE                                 2
+#define EFI_ACPI_6_1_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE_TYPE              3
+#define EFI_ACPI_6_1_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE_TYPE                      4
+#define EFI_ACPI_6_1_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE_TYPE            5
+#define EFI_ACPI_6_1_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE_TYPE                         6
+
+//
+// Definition for NFIT Structure Header
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+} EFI_ACPI_6_1_NFIT_STRUCTURE_HEADER;
+
+//
+// Definition for System Physical Address Range Structure
+//
+#define EFI_ACPI_6_1_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_CONTROL_REGION_FOR_MANAGEMENT      BIT0
+#define EFI_ACPI_6_1_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_PROXIMITY_DOMAIN_VALID             BIT1
+#define EFI_ACPI_6_1_NFIT_GUID_VOLATILE_MEMORY_REGION                             { 0x7305944F, 0xFDDA, 0x44E3, { 0xB1, 0x6C, 0x3F, 0x22, 0xD2, 0x52, 0xE5, 0xD0 }}
+#define EFI_ACPI_6_1_NFIT_GUID_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_REGION          { 0x66F0D379, 0xB4F3, 0x4074, { 0xAC, 0x43, 0x0D, 0x33, 0x18, 0xB7, 0x8C, 0xDB }}
+#define EFI_ACPI_6_1_NFIT_GUID_NVDIMM_CONTROL_REGION                              { 0x92F701F6, 0x13B4, 0x405D, { 0x91, 0x0B, 0x29, 0x93, 0x67, 0xE8, 0x23, 0x4C }}
+#define EFI_ACPI_6_1_NFIT_GUID_NVDIMM_BLOCK_DATA_WINDOW_REGION                    { 0x91AF0530, 0x5D86, 0x470E, { 0xA6, 0xB0, 0x0A, 0x2D, 0xB9, 0x40, 0x82, 0x49 }}
+#define EFI_ACPI_6_1_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_VOLATILE   { 0x77AB535A, 0x45FC, 0x624B, { 0x55, 0x60, 0xF7, 0xB2, 0x81, 0xD1, 0xF9, 0x6E }}
+#define EFI_ACPI_6_1_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_VOLATILE     { 0x3D5ABD30, 0x4175, 0x87CE, { 0x6D, 0x64, 0xD2, 0xAD, 0xE5, 0x23, 0xC4, 0xBB }}
+#define EFI_ACPI_6_1_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_PERSISTENT { 0x5CEA02C9, 0x4D07, 0x69D3, { 0x26, 0x9F ,0x44, 0x96, 0xFB, 0xE0, 0x96, 0xF9 }}
+#define EFI_ACPI_6_1_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_PERSISTENT   { 0x08018188, 0x42CD, 0xBB48, { 0x10, 0x0F, 0x53, 0x87, 0xD5, 0x3D, 0xED, 0x3D }}
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      SPARangeStructureIndex;
+  UINT16                                      Flags;
+  UINT32                                      Reserved_8;
+  UINT32                                      ProximityDomain;
+  GUID                                        AddressRangeTypeGUID;
+  UINT64                                      SystemPhysicalAddressRangeBase;
+  UINT64                                      SystemPhysicalAddressRangeLength;
+  UINT64                                      AddressRangeMemoryMappingAttribute;
+} EFI_ACPI_6_1_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE;
+
+//
+// Definition for Memory Device to System Physical Address Range Mapping Structure
+//
+typedef struct {
+  UINT32                                      DIMMNumber:4;
+  UINT32                                      MemoryChannelNumber:4;
+  UINT32                                      MemoryControllerID:4;
+  UINT32                                      SocketID:4;
+  UINT32                                      NodeControllerID:12;
+  UINT32                                      Reserved_28:4;
+} EFI_ACPI_6_1_NFIT_DEVICE_HANDLE;
+
+#define EFI_ACPI_6_1_NFIT_MEMORY_DEVICE_STATE_FLAGS_PREVIOUS_SAVE_FAIL                                      BIT0
+#define EFI_ACPI_6_1_NFIT_MEMORY_DEVICE_STATE_FLAGS_LAST_RESTORE_FAIL                                       BIT1
+#define EFI_ACPI_6_1_NFIT_MEMORY_DEVICE_STATE_FLAGS_PLATFORM_FLUSH_FAIL                                     BIT2
+#define EFI_ACPI_6_1_NFIT_MEMORY_DEVICE_STATE_FLAGS_NOT_ARMED_PRIOR_TO_OSPM_HAND_OFF                        BIT3
+#define EFI_ACPI_6_1_NFIT_MEMORY_DEVICE_STATE_FLAGS_SMART_HEALTH_EVENTS_PRIOR_OSPM_HAND_OFF                 BIT4
+#define EFI_ACPI_6_1_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_ENABLED_TO_NOTIFY_OSPM_ON_SMART_HEALTH_EVENTS  BIT5
+#define EFI_ACPI_6_1_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_NOT_MAP_NVDIMM_TO_SPA                          BIT6
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_1_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NVDIMMPhysicalID;
+  UINT16                                      NVDIMMRegionID;
+  UINT16                                      SPARangeStructureIndex ;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT64                                      NVDIMMRegionSize;
+  UINT64                                      RegionOffset;
+  UINT64                                      NVDIMMPhysicalAddressRegionBase;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      InterleaveWays;
+  UINT16                                      NVDIMMStateFlags;
+  UINT16                                      Reserved_46;
+} EFI_ACPI_6_1_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE;
+
+//
+// Definition for Interleave Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      Reserved_6;
+  UINT32                                      NumberOfLines;
+  UINT32                                      LineSize;
+//UINT32                                      LineOffset[NumberOfLines];
+} EFI_ACPI_6_1_NFIT_INTERLEAVE_STRUCTURE;
+
+//
+// Definition for SMBIOS Management Information Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT32                                      Reserved_4;
+//UINT8                                       Data[];
+} EFI_ACPI_6_1_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE;
+
+//
+// Definition for NVDIMM Control Region Structure
+//
+#define EFI_ACPI_6_1_NFIT_NVDIMM_CONTROL_REGION_VALID_FIELDS_MANUFACTURING           BIT0
+
+#define EFI_ACPI_6_1_NFIT_NVDIMM_CONTROL_REGION_FLAGS_BLOCK_DATA_WINDOWS_BUFFERED    BIT0
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      VendorID;
+  UINT16                                      DeviceID;
+  UINT16                                      RevisionID;
+  UINT16                                      SubsystemVendorID;
+  UINT16                                      SubsystemDeviceID;
+  UINT16                                      SubsystemRevisionID;
+  UINT8                                       ValidFields;
+  UINT8                                       ManufacturingLocation;
+  UINT16                                      ManufacturingDate;
+  UINT8                                       Reserved_22[2];
+  UINT32                                      SerialNumber;
+  UINT16                                      RegionFormatInterfaceCode;
+  UINT16                                      NumberOfBlockControlWindows;
+  UINT64                                      SizeOfBlockControlWindow;
+  UINT64                                      CommandRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfCommandRegisterInBlockControlWindows;
+  UINT64                                      StatusRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfStatusRegisterInBlockControlWindows;
+  UINT16                                      NVDIMMControlRegionFlag;
+  UINT8                                       Reserved_74[6];
+} EFI_ACPI_6_1_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE;
+
+//
+// Definition for NVDIMM Block Data Window Region Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      NumberOfBlockDataWindows;
+  UINT64                                      BlockDataWindowStartOffset;
+  UINT64                                      SizeOfBlockDataWindow;
+  UINT64                                      BlockAccessibleMemoryCapacity;
+  UINT64                                      BeginningAddressOfFirstBlockInBlockAccessibleMemory;
+} EFI_ACPI_6_1_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE;
+
+//
+// Definition for Flush Hint Address Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_1_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NumberOfFlushHintAddresses;
+  UINT8                                       Reserved_10[6];
+//UINT64                                      FlushHintAddress[NumberOfFlushHintAddresses];
+} EFI_ACPI_6_1_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE;
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_6_1_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_6_1_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_6_1_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_1_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_6_1_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_6_1_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_6_1_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_6_1_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+  UINT8    Timestamp[8];
+} EFI_ACPI_6_1_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0300
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_6_1_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_6_1_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_6_1_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_6_1_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_6_1_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_6_1_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_6_1_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_6_1_GENERIC_HARDWARE_ERROR                     0x09
+#define EFI_ACPI_6_1_GENERIC_HARDWARE_ERROR_VERSION_2           0x0A
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_6_1_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_6_1_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_6_1_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_6_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_6_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_6_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_6_1_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_POLLED                0x00
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT    0x01
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT       0x02
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_SCI                   0x03
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_NMI                   0x04
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_CMCI                  0x05
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_MCE                   0x06
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_GPIO_SIGNAL           0x07
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEA             0x08
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEI             0x09
+#define EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_GSIV                  0x0A
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_6_1_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_6_1_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_6_1_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_1_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_1_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_6_1_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Version 2 Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_1_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE                 ReadAckRegister;
+  UINT64                                                 ReadAckPreserve;
+  UINT64                                                 ReadAckWrite;
+} EFI_ACPI_6_1_GENERIC_HARDWARE_ERROR_SOURCE_VERSION_2_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_6_1_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_1_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_6_1_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_6_1_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_6_1_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_6_1_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_6_1_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_6_1_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_6_1_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_1_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_1_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_1_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_6_1_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_6_1_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_6_1_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_6_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_6_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_6_1_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+#define EFI_ACPI_6_1_ERST_GET_EXECUTE_OPERATION_TIMINGS            0x10
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_6_1_ERST_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_1_ERST_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_6_1_ERST_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_6_1_ERST_STATUS_FAILED                            0x03
+#define EFI_ACPI_6_1_ERST_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_6_1_ERST_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_6_1_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_6_1_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_1_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_1_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_1_ERST_NOOP                                     0x04
+#define EFI_ACPI_6_1_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_6_1_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_6_1_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_6_1_ERST_ADD                                      0x08
+#define EFI_ACPI_6_1_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_6_1_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_6_1_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_6_1_ERST_STALL                                    0x0C
+#define EFI_ACPI_6_1_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_6_1_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_6_1_ERST_GOTO                                     0x0F
+#define EFI_ACPI_6_1_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_6_1_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_6_1_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_6_1_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_1_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_6_1_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_6_1_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_6_1_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_6_1_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_6_1_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_6_1_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_6_1_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_1_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_1_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_1_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_6_1_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_1_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_6_1_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_6_1_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_6_1_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_6_1_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_6_1_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_6_1_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_6_1_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_6_1_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_6_1_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_6_1_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_6_1_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_6_1_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_6_1_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_6_1_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_6_1_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_1_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_1_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_1_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_6_1_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_1_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_6_1_EINJ_TRIGGER_ACTION_TABLE;
+
+///
+/// Platform Communications Channel Table (PCCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Flags;
+  UINT64                      Reserved;
+} EFI_ACPI_6_1_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;
+
+///
+/// PCCT Version (as defined in ACPI 6.1 spec.)
+///
+#define EFI_ACPI_6_1_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION 0x01
+
+///
+/// PCCT Global Flags
+///
+#define EFI_ACPI_6_1_PCCT_FLAGS_SCI_DOORBELL                      BIT0
+
+//
+// PCCT Subspace type
+//
+#define EFI_ACPI_6_1_PCCT_SUBSPACE_TYPE_GENERIC                         0x00
+#define EFI_ACPI_6_1_PCCT_SUBSPACE_TYPE_1_HW_REDUCED_COMMUNICATIONS     0x01
+#define EFI_ACPI_6_1_PCCT_SUBSPACE_TYPE_2_HW_REDUCED_COMMUNICATIONS     0x02
+
+///
+/// PCC Subspace Structure Header
+///
+typedef struct {
+  UINT8        Type;
+  UINT8        Length;
+} EFI_ACPI_6_1_PCCT_SUBSPACE_HEADER;
+
+///
+/// Generic Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT8                                    Reserved[6];
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_1_PCCT_SUBSPACE_GENERIC;
+
+///
+/// Generic Communications Channel Shared Memory Region
+///
+
+typedef struct {
+  UINT8                                    Command;
+  UINT8                                    Reserved:7;
+  UINT8                                    GenerateSci:1;
+} EFI_ACPI_6_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
+
+typedef struct {
+  UINT8                                    CommandComplete:1;
+  UINT8                                    SciDoorbell:1;
+  UINT8                                    Error:1;
+  UINT8                                    PlatformNotification:1;
+  UINT8                                    Reserved:4;
+  UINT8                                    Reserved1;
+} EFI_ACPI_6_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
+
+typedef struct {
+  UINT32                                                    Signature;
+  EFI_ACPI_6_1_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
+  EFI_ACPI_6_1_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
+} EFI_ACPI_6_1_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;
+
+#define EFI_ACPI_6_1_PCCT_SUBSPACE_DOORBELL_INTERRUPT_FLAGS_POLARITY    BIT0
+#define EFI_ACPI_6_1_PCCT_SUBSPACE_DOORBELL_INTERRUPT_FLAGS_MODE        BIT1
+
+///
+/// Type 1 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   DoorbellInterrupt;
+  UINT8                                    DoorbellInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_1_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 2 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   DoorbellInterrupt;
+  UINT8                                    DoorbellInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE   DoorbellAckRegister;
+  UINT64                                   DoorbellAckPreserve;
+  UINT64                                   DoorbellAckWrite;
+} EFI_ACPI_6_1_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_6_1_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_6_1_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_6_1_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "BGRT" Boot Graphics Resource Table
+///
+#define EFI_ACPI_6_1_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_6_1_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_6_1_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_6_1_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_6_1_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_6_1_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_6_1_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_6_1_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FPDT" Firmware Performance Data Table
+///
+#define EFI_ACPI_6_1_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')
+
+///
+/// "GTDT" Generic Timer Description Table
+///
+#define EFI_ACPI_6_1_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_6_1_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "MPST" Memory Power State Table
+///
+#define EFI_ACPI_6_1_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_6_1_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "NFIT" NVDIMM Firmware Interface Table
+///
+#define EFI_ACPI_6_1_NVDIMM_FIRMWARE_INTERFACE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('N', 'F', 'I', 'T')
+
+///
+/// "PMTT" Platform Memory Topology Table
+///
+#define EFI_ACPI_6_1_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_6_1_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RASF" ACPI RAS Feature Table
+///
+#define EFI_ACPI_6_1_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_6_1_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_6_1_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_6_1_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_6_1_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_6_1_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_6_1_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_6_1_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CSRT" MS Core System Resource Table
+///
+#define EFI_ACPI_6_1_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')
+
+///
+/// "DBG2" MS Debug Port 2 Spec
+///
+#define EFI_ACPI_6_1_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_6_1_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_6_1_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "DRTM" Dynamic Root of Trust for Measurement Table
+///
+#define EFI_ACPI_6_1_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_6_1_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_6_1_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_6_1_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IORT" I/O Remapping Table
+///
+#define EFI_ACPI_6_1_IO_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('I', 'O', 'R', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_6_1_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "LPIT" Low Power Idle Table
+///
+#define EFI_ACPI_6_1_LOW_POWER_IDLE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('L', 'P', 'I', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_6_1_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_6_1_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "MSDM" MS Data Management Table
+///
+#define EFI_ACPI_6_1_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')
+
+///
+/// "PCCT" Platform Communications Channel Table
+///
+#define EFI_ACPI_6_1_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')
+
+///
+/// "SLIC" MS Software Licensing Table Specification
+///
+#define EFI_ACPI_6_1_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_6_1_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_6_1_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "STAO" _STA Override Table
+///
+#define EFI_ACPI_6_1_STA_OVERRIDE_TABLE_SIGNATURE  SIGNATURE_32('S', 'T', 'A', 'O')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_6_1_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "TPM2" Trusted Computing Platform 1 Table
+///
+#define EFI_ACPI_6_1_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_6_1_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Emulated Devices Table
+///
+#define EFI_ACPI_6_1_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_6_1_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_6_1_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WPBT" MS Platform Binary Table
+///
+#define EFI_ACPI_6_1_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')
+
+///
+/// "XENV" Xen Project Table
+///
+#define EFI_ACPI_6_1_XEN_PROJECT_TABLE_SIGNATURE  SIGNATURE_32('X', 'E', 'N', 'V')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi62.h b/libedk2_tpm/include/IndustryStandard/Acpi62.h
new file mode 100644
index 0000000..bf6d2e2
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi62.h
@@ -0,0 +1,2960 @@
+/** @file
+  ACPI 6.2 definitions from the ACPI Specification Revision 6.2 May, 2017.
+
+  Copyright (c) 2017, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2020, ARM Ltd. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_6_2_H_
+#define _ACPI_6_2_H_
+#include <Base.h>
+#include <IndustryStandard/Acpi61.h>
+
+//
+// Large Item Descriptor Name
+//
+#define ACPI_LARGE_PIN_FUNCTION_DESCRIPTOR_NAME              0x0D
+#define ACPI_LARGE_PIN_CONFIGURATION_DESCRIPTOR_NAME         0x0F
+#define ACPI_LARGE_PIN_GROUP_DESCRIPTOR_NAME                 0x10
+#define ACPI_LARGE_PIN_GROUP_FUNCTION_DESCRIPTOR_NAME        0x11
+#define ACPI_LARGE_PIN_GROUP_CONFIGURATION_DESCRIPTOR_NAME   0x12
+
+//
+// Large Item Descriptor Value
+//
+#define ACPI_PIN_FUNCTION_DESCRIPTOR                         0x8D
+#define ACPI_PIN_CONFIGURATION_DESCRIPTOR                    0x8F
+#define ACPI_PIN_GROUP_DESCRIPTOR                            0x90
+#define ACPI_PIN_GROUP_FUNCTION_DESCRIPTOR                   0x91
+#define ACPI_PIN_GROUP_CONFIGURATION_DESCRIPTOR              0x92
+
+#pragma pack(1)
+
+///
+/// Pin Function Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT16                        Flags;
+  UINT8                         PinPullConfiguration;
+  UINT16                        FunctionNumber;
+  UINT16                        PinTableOffset;
+  UINT8                         ResourceSourceIndex;
+  UINT16                        ResourceSourceNameOffset;
+  UINT16                        VendorDataOffset;
+  UINT16                        VendorDataLength;
+} EFI_ACPI_PIN_FUNCTION_DESCRIPTOR;
+
+///
+/// Pin Configuration Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT16                        Flags;
+  UINT8                         PinConfigurationType;
+  UINT32                        PinConfigurationValue;
+  UINT16                        PinTableOffset;
+  UINT8                         ResourceSourceIndex;
+  UINT16                        ResourceSourceNameOffset;
+  UINT16                        VendorDataOffset;
+  UINT16                        VendorDataLength;
+} EFI_ACPI_PIN_CONFIGURATION_DESCRIPTOR;
+
+///
+/// Pin Group Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT16                        Flags;
+  UINT16                        PinTableOffset;
+  UINT16                        ResourceLabelOffset;
+  UINT16                        VendorDataOffset;
+  UINT16                        VendorDataLength;
+} EFI_ACPI_PIN_GROUP_DESCRIPTOR;
+
+///
+/// Pin Group Function Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT16                        Flags;
+  UINT16                        FunctionNumber;
+  UINT8                         ResourceSourceIndex;
+  UINT16                        ResourceSourceNameOffset;
+  UINT16                        ResourceSourceLabelOffset;
+  UINT16                        VendorDataOffset;
+  UINT16                        VendorDataLength;
+} EFI_ACPI_PIN_GROUP_FUNCTION_DESCRIPTOR;
+
+///
+/// Pin Group Configuration Descriptor
+///
+typedef PACKED struct {
+  ACPI_LARGE_RESOURCE_HEADER    Header;
+  UINT8                         RevisionId;
+  UINT16                        Flags;
+  UINT8                         PinConfigurationType;
+  UINT32                        PinConfigurationValue;
+  UINT8                         ResourceSourceIndex;
+  UINT16                        ResourceSourceNameOffset;
+  UINT16                        ResourceSourceLabelOffset;
+  UINT16                        VendorDataOffset;
+  UINT16                        VendorDataLength;
+} EFI_ACPI_PIN_GROUP_CONFIGURATION_DESCRIPTOR;
+
+#pragma pack()
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 6.2 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_6_2_SYSTEM_MEMORY              0
+#define EFI_ACPI_6_2_SYSTEM_IO                  1
+#define EFI_ACPI_6_2_PCI_CONFIGURATION_SPACE    2
+#define EFI_ACPI_6_2_EMBEDDED_CONTROLLER        3
+#define EFI_ACPI_6_2_SMBUS                      4
+#define EFI_ACPI_6_2_PLATFORM_COMMUNICATION_CHANNEL  0x0A
+#define EFI_ACPI_6_2_FUNCTIONAL_FIXED_HARDWARE       0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_6_2_UNDEFINED  0
+#define EFI_ACPI_6_2_BYTE       1
+#define EFI_ACPI_6_2_WORD       2
+#define EFI_ACPI_6_2_DWORD      3
+#define EFI_ACPI_6_2_QWORD      4
+
+//
+// ACPI 6.2 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_2_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 6.2) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_2_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT16                                  ArmBootArch;
+  UINT8                                   MinorVersion;
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  SleepControlReg;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  SleepStatusReg;
+  UINT64                                  HypervisorVendorIdentity;
+} EFI_ACPI_6_2_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x06
+#define EFI_ACPI_6_2_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION  0x02
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_6_2_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_6_2_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_6_2_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_6_2_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_6_2_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_6_2_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_6_2_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_6_2_PM_PROFILE_PERFORMANCE_SERVER  7
+#define EFI_ACPI_6_2_PM_PROFILE_TABLET              8
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_2_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_6_2_8042                        BIT1
+#define EFI_ACPI_6_2_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_6_2_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_6_2_PCIE_ASPM_CONTROLS          BIT4
+#define EFI_ACPI_6_2_CMOS_RTC_NOT_PRESENT        BIT5
+
+//
+// Fixed ACPI Description Table Arm Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_2_ARM_PSCI_COMPLIANT              BIT0
+#define EFI_ACPI_6_2_ARM_PSCI_USE_HVC                BIT1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_2_WBINVD                                 BIT0
+#define EFI_ACPI_6_2_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_6_2_PROC_C1                                BIT2
+#define EFI_ACPI_6_2_P_LVL2_UP                              BIT3
+#define EFI_ACPI_6_2_PWR_BUTTON                             BIT4
+#define EFI_ACPI_6_2_SLP_BUTTON                             BIT5
+#define EFI_ACPI_6_2_FIX_RTC                                BIT6
+#define EFI_ACPI_6_2_RTC_S4                                 BIT7
+#define EFI_ACPI_6_2_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_6_2_DCK_CAP                                BIT9
+#define EFI_ACPI_6_2_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_6_2_SEALED_CASE                            BIT11
+#define EFI_ACPI_6_2_HEADLESS                               BIT12
+#define EFI_ACPI_6_2_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_6_2_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_6_2_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_6_2_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_6_2_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_6_2_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_6_2_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+#define EFI_ACPI_6_2_HW_REDUCED_ACPI                        BIT20
+#define EFI_ACPI_6_2_LOW_POWER_S0_IDLE_CAPABLE              BIT21
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_6_2_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_2_S4BIOS_F                     BIT0
+#define EFI_ACPI_6_2_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_2_OSPM_64BIT_WAKE_F            BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_6_2_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_6_2_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_6_2_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x04
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_2_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x0D and 0x7F are reserved and
+// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
+//
+#define EFI_ACPI_6_2_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_6_2_IO_APIC                        0x01
+#define EFI_ACPI_6_2_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_6_2_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_6_2_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_6_2_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_6_2_IO_SAPIC                       0x06
+#define EFI_ACPI_6_2_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_6_2_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_6_2_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_6_2_LOCAL_X2APIC_NMI               0x0A
+#define EFI_ACPI_6_2_GIC                            0x0B
+#define EFI_ACPI_6_2_GICD                           0x0C
+#define EFI_ACPI_6_2_GIC_MSI_FRAME                  0x0D
+#define EFI_ACPI_6_2_GICR                           0x0E
+#define EFI_ACPI_6_2_GIC_ITS                        0x0F
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_6_2_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_LOCAL_APIC_ENABLED        BIT0
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_6_2_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_6_2_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_6_2_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_2_POLARITY      (3 << 0)
+#define EFI_ACPI_6_2_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_6_2_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_6_2_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_6_2_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_6_2_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_6_2_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_6_2_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_2_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_6_2_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_2_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// GIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  CPUInterfaceNumber;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ParkingProtocolVersion;
+  UINT32  PerformanceInterruptGsiv;
+  UINT64  ParkedAddress;
+  UINT64  PhysicalBaseAddress;
+  UINT64  GICV;
+  UINT64  GICH;
+  UINT32  VGICMaintenanceInterrupt;
+  UINT64  GICRBaseAddress;
+  UINT64  MPIDR;
+  UINT8   ProcessorPowerEfficiencyClass;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_2_GIC_STRUCTURE;
+
+///
+/// GIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_GIC_ENABLED                              BIT0
+#define EFI_ACPI_6_2_PERFORMANCE_INTERRUPT_MODEL              BIT1
+#define EFI_ACPI_6_2_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS    BIT2
+
+///
+/// GIC Distributor Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  SystemVectorBase;
+  UINT8   GicVersion;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_2_GIC_DISTRIBUTOR_STRUCTURE;
+
+///
+/// GIC Version
+///
+#define EFI_ACPI_6_2_GIC_V1                                   0x01
+#define EFI_ACPI_6_2_GIC_V2                                   0x02
+#define EFI_ACPI_6_2_GIC_V3                                   0x03
+#define EFI_ACPI_6_2_GIC_V4                                   0x04
+
+///
+/// GIC MSI Frame Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicMsiFrameId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Flags;
+  UINT16  SPICount;
+  UINT16  SPIBase;
+} EFI_ACPI_6_2_GIC_MSI_FRAME_STRUCTURE;
+
+///
+/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_SPI_COUNT_BASE_SELECT                    BIT0
+
+///
+/// GICR Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  DiscoveryRangeBaseAddress;
+  UINT32  DiscoveryRangeLength;
+} EFI_ACPI_6_2_GICR_STRUCTURE;
+
+///
+/// GIC Interrupt Translation Service Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  GicItsId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Reserved2;
+} EFI_ACPI_6_2_GIC_ITS_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_6_2_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_6_2_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT).  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_6_2_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x05 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_6_2_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_6_2_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_6_2_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+#define EFI_ACPI_6_2_GICC_AFFINITY                        0x03
+#define EFI_ACPI_6_2_GIC_ITS_AFFINITY                     0x04
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_6_2_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_6_2_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_6_2_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_6_2_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_6_2_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_6_2_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+} EFI_ACPI_6_2_GICC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_GICC_ENABLED (1 << 0)
+
+///
+/// GIC Interrupt Translation Service (ITS) Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT8   Reserved[2];
+  UINT32  ItsId;
+} EFI_ACPI_6_2_GIC_ITS_AFFINITY_STRUCTURE;
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_6_2_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_6_2_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_6_2_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_6_2_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_6_2_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_6_2_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// ACPI RAS Feature Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier[12];
+} EFI_ACPI_6_2_RAS_FEATURE_TABLE;
+
+///
+/// RASF Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_RAS_FEATURE_TABLE_REVISION 0x01
+
+///
+/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT16                      Version;
+  UINT8                       RASCapabilities[16];
+  UINT8                       SetRASCapabilities[16];
+  UINT16                      NumberOfRASFParameterBlocks;
+  UINT32                      SetRASCapabilitiesStatus;
+} EFI_ACPI_6_2_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI RASF PCC command code
+///
+#define EFI_ACPI_6_2_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01
+
+///
+/// ACPI RASF Platform RAS Capabilities
+///
+#define EFI_ACPI_6_2_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED                         BIT0
+#define EFI_ACPI_6_2_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED_AND_EXPOSED_TO_SOFTWARE BIT1
+#define EFI_ACPI_6_2_RASF_PLATFORM_RAS_CAPABILITY_CPU_CACHE_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS            BIT2
+#define EFI_ACPI_6_2_RASF_PLATFORM_RAS_CAPABILITY_MEMORY_CONTROLLER_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS    BIT3
+#define EFI_ACPI_6_2_RASF_PLATFORM_RAS_CAPABILITY_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_HARDWARE_MIRRORING         BIT4
+
+///
+/// ACPI RASF Parameter Block structure for PATROL_SCRUB
+///
+typedef struct {
+  UINT16                      Type;
+  UINT16                      Version;
+  UINT16                      Length;
+  UINT16                      PatrolScrubCommand;
+  UINT64                      RequestedAddressRange[2];
+  UINT64                      ActualAddressRange[2];
+  UINT16                      Flags;
+  UINT8                       RequestedSpeed;
+} EFI_ACPI_6_2_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;
+
+///
+/// ACPI RASF Patrol Scrub command
+///
+#define EFI_ACPI_6_2_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS   0x01
+#define EFI_ACPI_6_2_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER   0x02
+#define EFI_ACPI_6_2_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER    0x03
+
+///
+/// Memory Power State Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier;
+  UINT8                       Reserved[3];
+// Memory Power Node Structure
+// Memory Power State Characteristics
+} EFI_ACPI_6_2_MEMORY_POWER_STATUS_TABLE;
+
+///
+/// MPST Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_MEMORY_POWER_STATE_TABLE_REVISION 0x01
+
+///
+/// MPST Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT32                      MemoryPowerCommandRegister;
+  UINT32                      MemoryPowerStatusRegister;
+  UINT32                      PowerStateId;
+  UINT32                      MemoryPowerNodeId;
+  UINT64                      MemoryEnergyConsumed;
+  UINT64                      ExpectedAveragePowerComsuned;
+} EFI_ACPI_6_2_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI MPST PCC command code
+///
+#define EFI_ACPI_6_2_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03
+
+///
+/// ACPI MPST Memory Power command
+///
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE       0x01
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE       0x02
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED   0x03
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED   0x04
+
+///
+/// MPST Memory Power Node Table
+///
+typedef struct {
+  UINT8                                             PowerStateValue;
+  UINT8                                             PowerStateInformationIndex;
+} EFI_ACPI_6_2_MPST_MEMORY_POWER_STATE;
+
+typedef struct {
+  UINT8                                             Flag;
+  UINT8                                             Reserved;
+  UINT16                                            MemoryPowerNodeId;
+  UINT32                                            Length;
+  UINT64                                            AddressBase;
+  UINT64                                            AddressLength;
+  UINT32                                            NumberOfPowerStates;
+  UINT32                                            NumberOfPhysicalComponents;
+//EFI_ACPI_6_2_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
+//UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
+} EFI_ACPI_6_2_MPST_MEMORY_POWER_STRUCTURE;
+
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE          0x01
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED   0x02
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE   0x04
+
+typedef struct {
+  UINT16                      MemoryPowerNodeCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_2_MPST_MEMORY_POWER_NODE_TABLE;
+
+///
+/// MPST Memory Power State Characteristics Table
+///
+typedef struct {
+  UINT8                                             PowerStateStructureID;
+  UINT8                                             Flag;
+  UINT16                                            Reserved;
+  UINT32                                            AveragePowerConsumedInMPS0;
+  UINT32                                            RelativePowerSavingToMPS0;
+  UINT64                                            ExitLatencyToMPS0;
+} EFI_ACPI_6_2_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;
+
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED              0x01
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY   0x02
+#define EFI_ACPI_6_2_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT    0x04
+
+typedef struct {
+  UINT16                      MemoryPowerStateCharacteristicsCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_2_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;
+
+///
+/// Memory Topology Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved;
+} EFI_ACPI_6_2_MEMORY_TOPOLOGY_TABLE;
+
+///
+/// PMTT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_MEMORY_TOPOLOGY_TABLE_REVISION 0x01
+
+///
+/// Common Memory Aggregator Device Structure.
+///
+typedef struct {
+  UINT8                       Type;
+  UINT8                       Reserved;
+  UINT16                      Length;
+  UINT16                      Flags;
+  UINT16                      Reserved1;
+} EFI_ACPI_6_2_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Memory Aggregator Device Type
+///
+#define EFI_ACPI_6_2_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET            0x0
+#define EFI_ACPI_6_2_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER 0x1
+#define EFI_ACPI_6_2_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM              0x2
+
+///
+/// Socket Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_2_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       SocketIdentifier;
+  UINT16                                                       Reserved;
+//EFI_ACPI_6_2_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
+} EFI_ACPI_6_2_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// MemoryController Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_2_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT32                                                       ReadLatency;
+  UINT32                                                       WriteLatency;
+  UINT32                                                       ReadBandwidth;
+  UINT32                                                       WriteBandwidth;
+  UINT16                                                       OptimalAccessUnit;
+  UINT16                                                       OptimalAccessAlignment;
+  UINT16                                                       Reserved;
+  UINT16                                                       NumberOfProximityDomains;
+//UINT32                                                       ProximityDomain[NumberOfProximityDomains];
+//EFI_ACPI_6_2_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
+} EFI_ACPI_6_2_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// DIMM Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_2_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       PhysicalComponentIdentifier;
+  UINT16                                                       Reserved;
+  UINT32                                                       SizeOfDimm;
+  UINT32                                                       SmbiosHandle;
+} EFI_ACPI_6_2_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Boot Graphics Resource Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  ///
+  /// 2-bytes (16 bit) version ID. This value must be 1.
+  ///
+  UINT16                      Version;
+  ///
+  /// 1-byte status field indicating current status about the table.
+  ///     Bits[7:1] = Reserved (must be zero)
+  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
+  ///
+  UINT8                       Status;
+  ///
+  /// 1-byte enumerated type field indicating format of the image.
+  ///     0 = Bitmap
+  ///     1 - 255  Reserved (for future use)
+  ///
+  UINT8                       ImageType;
+  ///
+  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
+  /// of the image bitmap.
+  ///
+  UINT64                      ImageAddress;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetX;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetY;
+} EFI_ACPI_6_2_BOOT_GRAPHICS_RESOURCE_TABLE;
+
+///
+/// BGRT Revision
+///
+#define EFI_ACPI_6_2_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION 1
+
+///
+/// BGRT Version
+///
+#define EFI_ACPI_6_2_BGRT_VERSION         0x01
+
+///
+/// BGRT Status
+///
+#define EFI_ACPI_6_2_BGRT_STATUS_NOT_DISPLAYED 0x00
+#define EFI_ACPI_6_2_BGRT_STATUS_DISPLAYED     0x01
+
+///
+/// BGRT Image Type
+///
+#define EFI_ACPI_6_2_BGRT_IMAGE_TYPE_BMP  0x00
+
+///
+/// FPDT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION 0x01
+
+///
+/// FPDT Performance Record Types
+///
+#define EFI_ACPI_6_2_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER      0x0000
+#define EFI_ACPI_6_2_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER     0x0001
+
+///
+/// FPDT Performance Record Revision
+///
+#define EFI_ACPI_6_2_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER  0x01
+#define EFI_ACPI_6_2_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER 0x01
+
+///
+/// FPDT Runtime Performance Record Types
+///
+#define EFI_ACPI_6_2_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME                0x0000
+#define EFI_ACPI_6_2_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND               0x0001
+#define EFI_ACPI_6_2_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT      0x0002
+
+///
+/// FPDT Runtime Performance Record Revision
+///
+#define EFI_ACPI_6_2_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
+#define EFI_ACPI_6_2_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
+#define EFI_ACPI_6_2_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02
+
+///
+/// FPDT Performance Record header
+///
+typedef struct {
+  UINT16           Type;
+  UINT8            Length;
+  UINT8            Revision;
+} EFI_ACPI_6_2_FPDT_PERFORMANCE_RECORD_HEADER;
+
+///
+/// FPDT Performance Table header
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_2_FPDT_PERFORMANCE_TABLE_HEADER;
+
+///
+/// FPDT Firmware Basic Boot Performance Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_2_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
+  ///
+  UINT64                                          BootPerformanceTablePointer;
+} EFI_ACPI_6_2_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT S3 Performance Table Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_2_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the S3 Performance Table.
+  ///
+  UINT64                                          S3PerformanceTablePointer;
+} EFI_ACPI_6_2_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_2_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// Timer value logged at the beginning of firmware image execution.
+  /// This may not always be zero or near zero.
+  ///
+  UINT64                                          ResetEnd;
+  ///
+  /// Timer value logged just prior to loading the OS boot loader into memory.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          OsLoaderLoadImageStart;
+  ///
+  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
+  /// For non-UEFI compatible boots, the timer value logged will be just prior
+  /// to the INT 19h handler invocation.
+  ///
+  UINT64                                          OsLoaderStartImageStart;
+  ///
+  /// Timer value logged at the point when the OS loader calls the
+  /// ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesEntry;
+  ///
+  /// Timer value logged at the point just prior to when the OS loader gaining
+  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesExit;
+} EFI_ACPI_6_2_FPDT_FIRMWARE_BASIC_BOOT_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Table signature
+///
+#define EFI_ACPI_6_2_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')
+
+//
+// FPDT Firmware Basic Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_2_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_2_FPDT_FIRMWARE_BASIC_BOOT_TABLE;
+
+///
+/// FPDT "S3PT" S3 Performance Table
+///
+#define EFI_ACPI_6_2_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')
+
+//
+// FPDT Firmware S3 Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_2_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_2_FPDT_FIRMWARE_S3_BOOT_TABLE;
+
+///
+/// FPDT Basic S3 Resume Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_2_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// A count of the number of S3 resume cycles since the last full boot sequence.
+  ///
+  UINT32                                          ResumeCount;
+  ///
+  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
+  /// OS waking vector. Only the most recent resume cycle's time is retained.
+  ///
+  UINT64                                          FullResume;
+  ///
+  /// Average timer value of all resume cycles logged since the last full boot
+  /// sequence, including the most recent resume.  Note that the entire log of
+  /// timer values does not need to be retained in order to calculate this average.
+  ///
+  UINT64                                          AverageResume;
+} EFI_ACPI_6_2_FPDT_S3_RESUME_RECORD;
+
+///
+/// FPDT Basic S3 Suspend Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_2_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendStart;
+  ///
+  /// Timer value recorded at the final firmware write to SLP_TYP (or other
+  /// mechanism) used to trigger hardware entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendEnd;
+} EFI_ACPI_6_2_FPDT_S3_SUSPEND_RECORD;
+
+///
+/// Firmware Performance Record Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+} EFI_ACPI_6_2_FIRMWARE_PERFORMANCE_RECORD_TABLE;
+
+///
+/// Generic Timer Description Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      CntControlBasePhysicalAddress;
+  UINT32                      Reserved;
+  UINT32                      SecurePL1TimerGSIV;
+  UINT32                      SecurePL1TimerFlags;
+  UINT32                      NonSecurePL1TimerGSIV;
+  UINT32                      NonSecurePL1TimerFlags;
+  UINT32                      VirtualTimerGSIV;
+  UINT32                      VirtualTimerFlags;
+  UINT32                      NonSecurePL2TimerGSIV;
+  UINT32                      NonSecurePL2TimerFlags;
+  UINT64                      CntReadBasePhysicalAddress;
+  UINT32                      PlatformTimerCount;
+  UINT32                      PlatformTimerOffset;
+} EFI_ACPI_6_2_GENERIC_TIMER_DESCRIPTION_TABLE;
+
+///
+/// GTDT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION 0x02
+
+///
+/// Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_2_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_2_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY          BIT2
+
+///
+/// Platform Timer Type
+///
+#define EFI_ACPI_6_2_GTDT_GT_BLOCK                       0
+#define EFI_ACPI_6_2_GTDT_SBSA_GENERIC_WATCHDOG          1
+
+///
+/// GT Block Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  CntCtlBase;
+  UINT32  GTBlockTimerCount;
+  UINT32  GTBlockTimerOffset;
+} EFI_ACPI_6_2_GTDT_GT_BLOCK_STRUCTURE;
+
+///
+/// GT Block Timer Structure
+///
+typedef struct {
+  UINT8   GTFrameNumber;
+  UINT8   Reserved[3];
+  UINT64  CntBaseX;
+  UINT64  CntEL0BaseX;
+  UINT32  GTxPhysicalTimerGSIV;
+  UINT32  GTxPhysicalTimerFlags;
+  UINT32  GTxVirtualTimerGSIV;
+  UINT32  GTxVirtualTimerFlags;
+  UINT32  GTxCommonFlags;
+} EFI_ACPI_6_2_GTDT_GT_BLOCK_TIMER_STRUCTURE;
+
+///
+/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_2_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+
+///
+/// Common Flags Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER              BIT0
+#define EFI_ACPI_6_2_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY      BIT1
+
+///
+/// SBSA Generic Watchdog Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  RefreshFramePhysicalAddress;
+  UINT64  WatchdogControlFramePhysicalAddress;
+  UINT32  WatchdogTimerGSIV;
+  UINT32  WatchdogTimerFlags;
+} EFI_ACPI_6_2_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE;
+
+///
+/// SBSA Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_2_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_2_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_2_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_SECURE_TIMER                  BIT2
+
+//
+// NVDIMM Firmware Interface Table definition.
+//
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER    Header;
+  UINT32                         Reserved;
+} EFI_ACPI_6_2_NVDIMM_FIRMWARE_INTERFACE_TABLE;
+
+//
+// NFIT Version (as defined in ACPI 6.2 spec.)
+//
+#define EFI_ACPI_6_2_NVDIMM_FIRMWARE_INTERFACE_TABLE_REVISION 0x1
+
+//
+// Definition for NFIT Table Structure Types
+//
+#define EFI_ACPI_6_2_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE_TYPE              0
+#define EFI_ACPI_6_2_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE_TYPE                      1
+#define EFI_ACPI_6_2_NFIT_INTERLEAVE_STRUCTURE_TYPE                                 2
+#define EFI_ACPI_6_2_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE_TYPE              3
+#define EFI_ACPI_6_2_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE_TYPE                      4
+#define EFI_ACPI_6_2_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE_TYPE            5
+#define EFI_ACPI_6_2_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE_TYPE                         6
+
+//
+// Definition for NFIT Structure Header
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+} EFI_ACPI_6_2_NFIT_STRUCTURE_HEADER;
+
+//
+// Definition for System Physical Address Range Structure
+//
+#define EFI_ACPI_6_2_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_CONTROL_REGION_FOR_MANAGEMENT      BIT0
+#define EFI_ACPI_6_2_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_PROXIMITY_DOMAIN_VALID             BIT1
+#define EFI_ACPI_6_2_NFIT_GUID_VOLATILE_MEMORY_REGION                             { 0x7305944F, 0xFDDA, 0x44E3, { 0xB1, 0x6C, 0x3F, 0x22, 0xD2, 0x52, 0xE5, 0xD0 }}
+#define EFI_ACPI_6_2_NFIT_GUID_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_REGION          { 0x66F0D379, 0xB4F3, 0x4074, { 0xAC, 0x43, 0x0D, 0x33, 0x18, 0xB7, 0x8C, 0xDB }}
+#define EFI_ACPI_6_2_NFIT_GUID_NVDIMM_CONTROL_REGION                              { 0x92F701F6, 0x13B4, 0x405D, { 0x91, 0x0B, 0x29, 0x93, 0x67, 0xE8, 0x23, 0x4C }}
+#define EFI_ACPI_6_2_NFIT_GUID_NVDIMM_BLOCK_DATA_WINDOW_REGION                    { 0x91AF0530, 0x5D86, 0x470E, { 0xA6, 0xB0, 0x0A, 0x2D, 0xB9, 0x40, 0x82, 0x49 }}
+#define EFI_ACPI_6_2_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_VOLATILE   { 0x77AB535A, 0x45FC, 0x624B, { 0x55, 0x60, 0xF7, 0xB2, 0x81, 0xD1, 0xF9, 0x6E }}
+#define EFI_ACPI_6_2_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_VOLATILE     { 0x3D5ABD30, 0x4175, 0x87CE, { 0x6D, 0x64, 0xD2, 0xAD, 0xE5, 0x23, 0xC4, 0xBB }}
+#define EFI_ACPI_6_2_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_PERSISTENT { 0x5CEA02C9, 0x4D07, 0x69D3, { 0x26, 0x9F ,0x44, 0x96, 0xFB, 0xE0, 0x96, 0xF9 }}
+#define EFI_ACPI_6_2_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_PERSISTENT   { 0x08018188, 0x42CD, 0xBB48, { 0x10, 0x0F, 0x53, 0x87, 0xD5, 0x3D, 0xED, 0x3D }}
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      SPARangeStructureIndex;
+  UINT16                                      Flags;
+  UINT32                                      Reserved_8;
+  UINT32                                      ProximityDomain;
+  GUID                                        AddressRangeTypeGUID;
+  UINT64                                      SystemPhysicalAddressRangeBase;
+  UINT64                                      SystemPhysicalAddressRangeLength;
+  UINT64                                      AddressRangeMemoryMappingAttribute;
+} EFI_ACPI_6_2_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE;
+
+//
+// Definition for Memory Device to System Physical Address Range Mapping Structure
+//
+typedef struct {
+  UINT32                                      DIMMNumber:4;
+  UINT32                                      MemoryChannelNumber:4;
+  UINT32                                      MemoryControllerID:4;
+  UINT32                                      SocketID:4;
+  UINT32                                      NodeControllerID:12;
+  UINT32                                      Reserved_28:4;
+} EFI_ACPI_6_2_NFIT_DEVICE_HANDLE;
+
+#define EFI_ACPI_6_2_NFIT_MEMORY_DEVICE_STATE_FLAGS_PREVIOUS_SAVE_FAIL                                      BIT0
+#define EFI_ACPI_6_2_NFIT_MEMORY_DEVICE_STATE_FLAGS_LAST_RESTORE_FAIL                                       BIT1
+#define EFI_ACPI_6_2_NFIT_MEMORY_DEVICE_STATE_FLAGS_PLATFORM_FLUSH_FAIL                                     BIT2
+#define EFI_ACPI_6_2_NFIT_MEMORY_DEVICE_STATE_FLAGS_NOT_ARMED_PRIOR_TO_OSPM_HAND_OFF                        BIT3
+#define EFI_ACPI_6_2_NFIT_MEMORY_DEVICE_STATE_FLAGS_SMART_HEALTH_EVENTS_PRIOR_OSPM_HAND_OFF                 BIT4
+#define EFI_ACPI_6_2_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_ENABLED_TO_NOTIFY_OSPM_ON_SMART_HEALTH_EVENTS  BIT5
+#define EFI_ACPI_6_2_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_NOT_MAP_NVDIMM_TO_SPA                          BIT6
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_2_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NVDIMMPhysicalID;
+  UINT16                                      NVDIMMRegionID;
+  UINT16                                      SPARangeStructureIndex ;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT64                                      NVDIMMRegionSize;
+  UINT64                                      RegionOffset;
+  UINT64                                      NVDIMMPhysicalAddressRegionBase;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      InterleaveWays;
+  UINT16                                      NVDIMMStateFlags;
+  UINT16                                      Reserved_46;
+} EFI_ACPI_6_2_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE;
+
+//
+// Definition for Interleave Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      Reserved_6;
+  UINT32                                      NumberOfLines;
+  UINT32                                      LineSize;
+//UINT32                                      LineOffset[NumberOfLines];
+} EFI_ACPI_6_2_NFIT_INTERLEAVE_STRUCTURE;
+
+//
+// Definition for SMBIOS Management Information Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT32                                      Reserved_4;
+//UINT8                                       Data[];
+} EFI_ACPI_6_2_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE;
+
+//
+// Definition for NVDIMM Control Region Structure
+//
+#define EFI_ACPI_6_2_NFIT_NVDIMM_CONTROL_REGION_VALID_FIELDS_MANUFACTURING           BIT0
+
+#define EFI_ACPI_6_2_NFIT_NVDIMM_CONTROL_REGION_FLAGS_BLOCK_DATA_WINDOWS_BUFFERED    BIT0
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      VendorID;
+  UINT16                                      DeviceID;
+  UINT16                                      RevisionID;
+  UINT16                                      SubsystemVendorID;
+  UINT16                                      SubsystemDeviceID;
+  UINT16                                      SubsystemRevisionID;
+  UINT8                                       ValidFields;
+  UINT8                                       ManufacturingLocation;
+  UINT16                                      ManufacturingDate;
+  UINT8                                       Reserved_22[2];
+  UINT32                                      SerialNumber;
+  UINT16                                      RegionFormatInterfaceCode;
+  UINT16                                      NumberOfBlockControlWindows;
+  UINT64                                      SizeOfBlockControlWindow;
+  UINT64                                      CommandRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfCommandRegisterInBlockControlWindows;
+  UINT64                                      StatusRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfStatusRegisterInBlockControlWindows;
+  UINT16                                      NVDIMMControlRegionFlag;
+  UINT8                                       Reserved_74[6];
+} EFI_ACPI_6_2_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE;
+
+//
+// Definition for NVDIMM Block Data Window Region Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      NumberOfBlockDataWindows;
+  UINT64                                      BlockDataWindowStartOffset;
+  UINT64                                      SizeOfBlockDataWindow;
+  UINT64                                      BlockAccessibleMemoryCapacity;
+  UINT64                                      BeginningAddressOfFirstBlockInBlockAccessibleMemory;
+} EFI_ACPI_6_2_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE;
+
+//
+// Definition for Flush Hint Address Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_2_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NumberOfFlushHintAddresses;
+  UINT8                                       Reserved_10[6];
+//UINT64                                      FlushHintAddress[NumberOfFlushHintAddresses];
+} EFI_ACPI_6_2_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE;
+
+///
+/// Secure DEVices Table (SDEV)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+} EFI_ACPI_6_2_SECURE_DEVICES_TABLE_HEADER;
+
+///
+/// SDEV Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_SECURE_DEVICES_TABLE_REVISION      0x01
+
+///
+/// Secure Device types
+///
+#define EFI_ACPI_6_2_SDEV_TYPE_PCIE_ENDPOINT_DEVICE     0x01
+#define EFI_ACPI_6_2_SDEV_TYPE_ACPI_NAMESPACE_DEVICE    0x00
+
+///
+/// Secure Device flags
+///
+#define EFI_ACPI_6_2_SDEV_FLAG_ALLOW_HANDOFF            BIT0
+
+///
+/// SDEV Structure Header
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Flags;
+  UINT16                        Length;
+} EFI_ACPI_6_2_SDEV_STRUCTURE_HEADER;
+
+///
+/// PCIe Endpoint Device based Secure Device Structure
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Flags;
+  UINT16                        Length;
+  UINT16                        PciSegmentNumber;
+  UINT16                        StartBusNumber;
+  UINT16                        PciPathOffset;
+  UINT16                        PciPathLength;
+  UINT16                        VendorSpecificDataOffset;
+  UINT16                        VendorSpecificDataLength;
+} EFI_ACPI_6_2_SDEV_STRUCTURE_PCIE_ENDPOINT_DEVICE;
+
+///
+/// ACPI_NAMESPACE_DEVICE based Secure Device Structure
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Flags;
+  UINT16                        Length;
+  UINT16                        DeviceIdentifierOffset;
+  UINT16                        DeviceIdentifierLength;
+  UINT16                        VendorSpecificDataOffset;
+  UINT16                        VendorSpecificDataLength;
+} EFI_ACPI_6_2_SDEV_STRUCTURE_ACPI_NAMESPACE_DEVICE;
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_6_2_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_6_2_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_6_2_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_2_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_6_2_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_6_2_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_6_2_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_6_2_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+  UINT8    Timestamp[8];
+} EFI_ACPI_6_2_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0300
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_6_2_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_6_2_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_6_2_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_6_2_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_6_2_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_6_2_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_6_2_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_6_2_GENERIC_HARDWARE_ERROR                     0x09
+#define EFI_ACPI_6_2_GENERIC_HARDWARE_ERROR_VERSION_2           0x0A
+#define EFI_ACPI_6_2_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK   0x0B
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_6_2_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_6_2_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+#define EFI_ACPI_6_2_ERROR_SOURCE_FLAG_GHES_ASSIST          (1 << 2)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_6_2_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_6_2_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_6_2_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_6_2_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_6_2_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_POLLED                         0x00
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT             0x01
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT                0x02
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_SCI                            0x03
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_NMI                            0x04
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_CMCI                           0x05
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_MCE                            0x06
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_GPIO_SIGNAL                    0x07
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEA                      0x08
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEI                      0x09
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_GSIV                           0x0A
+#define EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_SOFTWARE_DELEGATED_EXCEPTION   0x0B
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_6_2_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_6_2_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_6_2_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_2_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_2_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_6_2_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Version 2 Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE                 ReadAckRegister;
+  UINT64                                                 ReadAckPreserve;
+  UINT64                                                 ReadAckWrite;
+} EFI_ACPI_6_2_GENERIC_HARDWARE_ERROR_SOURCE_VERSION_2_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_6_2_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_2_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// IA-32 Architecture Deferred Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                Type;
+  UINT16                                                SourceId;
+  UINT8                                                 Reserved0[2];
+  UINT8                                                 Flags;
+  UINT8                                                 Enabled;
+  UINT32                                                NumberOfRecordsToPreAllocate;
+  UINT32                                                MaxSectionsPerRecord;
+  EFI_ACPI_6_2_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
+  UINT8                                                 NumberOfHardwareBanks;
+  UINT8                                                 Reserved1[3];
+} EFI_ACPI_6_2_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK_STRUCTURE;;
+
+///
+/// HMAT - Heterogeneous Memory Attribute Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[4];
+} EFI_ACPI_6_2_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_HEADER;
+
+///
+/// HMAT Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_REVISION 0x01
+
+///
+/// HMAT types
+///
+#define EFI_ACPI_6_2_HMAT_TYPE_MEMORY_SUBSYSTEM_ADDRESS_RANGE               0x00
+#define EFI_ACPI_6_2_HMAT_TYPE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO   0x01
+#define EFI_ACPI_6_2_HMAT_TYPE_MEMORY_SIDE_CACHE_INFO                       0x02
+
+///
+/// HMAT Structure Header
+///
+typedef struct {
+  UINT16                        Type;
+  UINT8                         Reserved[2];
+  UINT32                        Length;
+} EFI_ACPI_6_2_HMAT_STRUCTURE_HEADER;
+
+///
+/// Memory Subsystem Address Range Structure flags
+///
+typedef struct {
+  UINT16                        ProcessorProximityDomainValid:1;
+  UINT16                        MemoryProximityDomainValid:1;
+  UINT16                        ReservationHint:1;
+  UINT16                        Reserved:13;
+} EFI_ACPI_6_2_HMAT_STRUCTURE_MEMORY_SUBSYSTEM_ADDRESS_RANGE_FLAGS;
+
+///
+/// Memory Subsystem Address Range Structure
+///
+typedef struct {
+  UINT16                                                            Type;
+  UINT8                                                             Reserved[2];
+  UINT32                                                            Length;
+  EFI_ACPI_6_2_HMAT_STRUCTURE_MEMORY_SUBSYSTEM_ADDRESS_RANGE_FLAGS  Flags;
+  UINT8                                                             Reserved1[2];
+  UINT32                                                            ProcessorProximityDomain;
+  UINT32                                                            MemoryProximityDomain;
+  UINT8                                                             Reserved2[4];
+  UINT64                                                            SystemPhysicalAddressRangeBase;
+  UINT64                                                            SystemPhysicalAddressRangeLength;
+} EFI_ACPI_6_2_HMAT_STRUCTURE_MEMORY_SUBSYSTEM_ADDRESS_RANGE;
+
+///
+/// System Locality Latency and Bandwidth Information Structure flags
+///
+typedef struct {
+  UINT8                         MemoryHierarchy:5;
+  UINT8                         Reserved:3;
+} EFI_ACPI_6_2_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS;
+
+///
+/// System Locality Latency and Bandwidth Information Structure
+///
+typedef struct {
+  UINT16                                                                        Type;
+  UINT8                                                                         Reserved[2];
+  UINT32                                                                        Length;
+  EFI_ACPI_6_2_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS  Flags;
+  UINT8                                                                         DataType;
+  UINT8                                                                         Reserved1[2];
+  UINT32                                                                        NumberOfInitiatorProximityDomains;
+  UINT32                                                                        NumberOfTargetProximityDomains;
+  UINT8                                                                         Reserved2[4];
+  UINT64                                                                        EntryBaseUnit;
+} EFI_ACPI_6_2_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO;
+
+///
+/// Memory Side Cache Information Structure cache attributes
+///
+typedef struct {
+  UINT32                        TotalCacheLevels:4;
+  UINT32                        CacheLevel:4;
+  UINT32                        CacheAssociativity:4;
+  UINT32                        WritePolicy:4;
+  UINT32                        CacheLineSize:16;
+} EFI_ACPI_6_2_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES;
+
+///
+/// Memory Side Cache Information Structure
+///
+typedef struct {
+  UINT16                                                                Type;
+  UINT8                                                                 Reserved[2];
+  UINT32                                                                Length;
+  UINT32                                                                MemoryProximityDomain;
+  UINT8                                                                 Reserved1[4];
+  UINT64                                                                MemorySideCacheSize;
+  EFI_ACPI_6_2_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES   CacheAttributes;
+  UINT8                                                                 Reserved2[2];
+  UINT16                                                                NumberOfSmbiosHandles;
+} EFI_ACPI_6_2_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_6_2_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_6_2_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_6_2_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_6_2_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_6_2_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_6_2_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_6_2_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_2_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_2_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_2_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_6_2_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_6_2_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_6_2_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_6_2_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_6_2_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_6_2_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+#define EFI_ACPI_6_2_ERST_GET_EXECUTE_OPERATION_TIMINGS            0x10
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_6_2_ERST_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_2_ERST_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_6_2_ERST_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_6_2_ERST_STATUS_FAILED                            0x03
+#define EFI_ACPI_6_2_ERST_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_6_2_ERST_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_6_2_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_6_2_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_2_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_2_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_2_ERST_NOOP                                     0x04
+#define EFI_ACPI_6_2_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_6_2_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_6_2_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_6_2_ERST_ADD                                      0x08
+#define EFI_ACPI_6_2_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_6_2_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_6_2_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_6_2_ERST_STALL                                    0x0C
+#define EFI_ACPI_6_2_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_6_2_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_6_2_ERST_GOTO                                     0x0F
+#define EFI_ACPI_6_2_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_6_2_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_6_2_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_6_2_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_2_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_6_2_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_6_2_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_6_2_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_6_2_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_6_2_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_6_2_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_6_2_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_2_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_2_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_2_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_6_2_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_2_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_6_2_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_6_2_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_6_2_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_6_2_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_6_2_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_6_2_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_6_2_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_6_2_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_6_2_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_6_2_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_6_2_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_6_2_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_6_2_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_6_2_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_6_2_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_2_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_2_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_2_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_6_2_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_2_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_6_2_EINJ_TRIGGER_ACTION_TABLE;
+
+///
+/// Platform Communications Channel Table (PCCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Flags;
+  UINT64                      Reserved;
+} EFI_ACPI_6_2_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;
+
+///
+/// PCCT Version (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION 0x02
+
+///
+/// PCCT Global Flags
+///
+#define EFI_ACPI_6_2_PCCT_FLAGS_PLATFORM_INTERRUPT  BIT0
+
+//
+// PCCT Subspace type
+//
+#define EFI_ACPI_6_2_PCCT_SUBSPACE_TYPE_GENERIC                         0x00
+#define EFI_ACPI_6_2_PCCT_SUBSPACE_TYPE_1_HW_REDUCED_COMMUNICATIONS     0x01
+#define EFI_ACPI_6_2_PCCT_SUBSPACE_TYPE_2_HW_REDUCED_COMMUNICATIONS     0x02
+#define EFI_ACPI_6_2_PCCT_SUBSPACE_TYPE_3_EXTENDED_PCC                  0x03
+#define EFI_ACPI_6_2_PCCT_SUBSPACE_TYPE_4_EXTENDED_PCC                  0x04
+
+///
+/// PCC Subspace Structure Header
+///
+typedef struct {
+  UINT8        Type;
+  UINT8        Length;
+} EFI_ACPI_6_2_PCCT_SUBSPACE_HEADER;
+
+///
+/// Generic Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT8                                    Reserved[6];
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_2_PCCT_SUBSPACE_GENERIC;
+
+///
+/// Generic Communications Channel Shared Memory Region
+///
+
+typedef struct {
+  UINT8                                    Command;
+  UINT8                                    Reserved:7;
+  UINT8                                    NotifyOnCompletion:1;
+} EFI_ACPI_6_2_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
+
+typedef struct {
+  UINT8                                    CommandComplete:1;
+  UINT8                                    PlatformInterrupt:1;
+  UINT8                                    Error:1;
+  UINT8                                    PlatformNotification:1;
+  UINT8                                    Reserved:4;
+  UINT8                                    Reserved1;
+} EFI_ACPI_6_2_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
+
+typedef struct {
+  UINT32                                                    Signature;
+  EFI_ACPI_6_2_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
+  EFI_ACPI_6_2_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
+} EFI_ACPI_6_2_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;
+
+#define EFI_ACPI_6_2_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_POLARITY    BIT0
+#define EFI_ACPI_6_2_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_MODE        BIT1
+
+///
+/// Type 1 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_2_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 2 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   PlatformInterruptAckRegister;
+  UINT64                                   PlatformInterruptAckPreserve;
+  UINT64                                   PlatformInterruptAckWrite;
+} EFI_ACPI_6_2_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 3 Extended PCC Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT32                                   AddressLength;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT32                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   PlatformInterruptAckRegister;
+  UINT64                                   PlatformInterruptAckPreserve;
+  UINT64                                   PlatformInterruptAckSet;
+  UINT8                                    Reserved1[8];
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   CommandCompleteCheckRegister;
+  UINT64                                   CommandCompleteCheckMask;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   CommandCompleteUpdateRegister;
+  UINT64                                   CommandCompleteUpdatePreserve;
+  UINT64                                   CommandCompleteUpdateSet;
+  EFI_ACPI_6_2_GENERIC_ADDRESS_STRUCTURE   ErrorStatusRegister;
+  UINT64                                   ErrorStatusMask;
+} EFI_ACPI_6_2_PCCT_SUBSPACE_3_EXTENDED_PCC;
+
+///
+/// Type 4 Extended PCC Subspace Structure
+///
+typedef EFI_ACPI_6_2_PCCT_SUBSPACE_3_EXTENDED_PCC EFI_ACPI_6_2_PCCT_SUBSPACE_4_EXTENDED_PCC;
+
+#define EFI_ACPI_6_2_PCCT_MASTER_SLAVE_COMMUNICATIONS_CHANNEL_FLAGS_NOTIFY_ON_COMPLETION BIT0
+
+typedef struct {
+  UINT32                                    Signature;
+  UINT32                                    Flags;
+  UINT32                                    Length;
+  UINT32                                    Command;
+} EFI_ACPI_6_2_PCCT_EXTENDED_PCC_SHARED_MEMORY_REGION_HEADER;
+
+///
+/// Platform Debug Trigger Table (PDTT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+  UINT8                         TriggerCount;
+  UINT8                         Reserved[3];
+  UINT32                        TriggerIdentifierArrayOffset;
+} EFI_ACPI_6_2_PLATFORM_DEBUG_TRIGGER_TABLE_HEADER;
+
+///
+/// PDTT Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_PLATFORM_DEBUG_TRIGGER_TABLE_REVISION 0x00
+
+///
+/// PDTT Platform Communication Channel Identifier Structure
+///
+typedef struct {
+  UINT16                        SubChannelIdentifer:8;
+  UINT16                        Runtime:1;
+  UINT16                        WaitForCompletion:1;
+  UINT16                        Reserved:6;
+} EFI_ACPI_6_2_PDTT_PCC_IDENTIFIER;
+
+///
+/// PCC Commands Codes used by Platform Debug Trigger Table
+///
+#define EFI_ACPI_6_2_PDTT_PCC_COMMAND_DOORBELL_ONLY     0x00
+#define EFI_ACPI_6_2_PDTT_PCC_COMMAND_VENDOR_SPECIFIC   0x01
+
+///
+/// PPTT Platform Communication Channel
+///
+typedef EFI_ACPI_6_2_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER EFI_ACPI_6_2_PDTT_PCC;
+
+///
+/// Processor Properties Topology Table (PPTT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+} EFI_ACPI_6_2_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_HEADER;
+
+///
+/// PPTT Revision (as defined in ACPI 6.2 spec.)
+///
+#define EFI_ACPI_6_2_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_REVISION 0x01
+
+///
+/// PPTT types
+///
+#define EFI_ACPI_6_2_PPTT_TYPE_PROCESSOR     0x00
+#define EFI_ACPI_6_2_PPTT_TYPE_CACHE         0x01
+#define EFI_ACPI_6_2_PPTT_TYPE_ID            0x02
+
+///
+/// PPTT Structure Header
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Length;
+  UINT8                         Reserved[2];
+} EFI_ACPI_6_2_PPTT_STRUCTURE_HEADER;
+
+///
+/// For PPTT struct processor flags
+///
+#define EFI_ACPI_6_2_PPTT_PROCESSOR_ID_INVALID 0x0
+#define EFI_ACPI_6_2_PPTT_PROCESSOR_ID_VALID   0x1
+
+///
+/// Processor hierarchy node structure flags
+///
+typedef struct {
+  UINT32                        PhysicalPackage:1;
+  UINT32                        AcpiProcessorIdValid:1;
+  UINT32                        Reserved:30;
+} EFI_ACPI_6_2_PPTT_STRUCTURE_PROCESSOR_FLAGS;
+
+///
+/// Processor hierarchy node structure
+///
+typedef struct {
+  UINT8                                         Type;
+  UINT8                                         Length;
+  UINT8                                         Reserved[2];
+  EFI_ACPI_6_2_PPTT_STRUCTURE_PROCESSOR_FLAGS   Flags;
+  UINT32                                        Parent;
+  UINT32                                        AcpiProcessorId;
+  UINT32                                        NumberOfPrivateResources;
+} EFI_ACPI_6_2_PPTT_STRUCTURE_PROCESSOR;
+
+///
+/// Cache Type Structure flags
+///
+typedef struct {
+  UINT32                        SizePropertyValid:1;
+  UINT32                        NumberOfSetsValid:1;
+  UINT32                        AssociativityValid:1;
+  UINT32                        AllocationTypeValid:1;
+  UINT32                        CacheTypeValid:1;
+  UINT32                        WritePolicyValid:1;
+  UINT32                        LineSizeValid:1;
+  UINT32                        Reserved:25;
+} EFI_ACPI_6_2_PPTT_STRUCTURE_CACHE_FLAGS;
+
+///
+/// For cache attributes
+///
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_ALLOCATION_READ            0x0
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_ALLOCATION_WRITE           0x1
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_ALLOCATION_READ_WRITE      0x2
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_CACHE_TYPE_DATA            0x0
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_CACHE_TYPE_INSTRUCTION     0x1
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_CACHE_TYPE_UNIFIED         0x2
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_BACK    0x0
+#define EFI_ACPI_6_2_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_THROUGH 0x1
+
+///
+/// Cache Type Structure cache attributes
+///
+typedef struct {
+  UINT8                         AllocationType:2;
+  UINT8                         CacheType:2;
+  UINT8                         WritePolicy:1;
+  UINT8                         Reserved:3;
+} EFI_ACPI_6_2_PPTT_STRUCTURE_CACHE_ATTRIBUTES;
+
+///
+/// Cache Type Structure
+///
+typedef struct {
+  UINT8                                         Type;
+  UINT8                                         Length;
+  UINT8                                         Reserved[2];
+  EFI_ACPI_6_2_PPTT_STRUCTURE_CACHE_FLAGS       Flags;
+  UINT32                                        NextLevelOfCache;
+  UINT32                                        Size;
+  UINT32                                        NumberOfSets;
+  UINT8                                         Associativity;
+  EFI_ACPI_6_2_PPTT_STRUCTURE_CACHE_ATTRIBUTES  Attributes;
+  UINT16                                        LineSize;
+} EFI_ACPI_6_2_PPTT_STRUCTURE_CACHE;
+
+///
+/// ID structure
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Length;
+  UINT8                         Reserved[2];
+  UINT32                        VendorId;
+  UINT64                        Level1Id;
+  UINT64                        Level2Id;
+  UINT16                        MajorRev;
+  UINT16                        MinorRev;
+  UINT16                        SpinRev;
+} EFI_ACPI_6_2_PPTT_STRUCTURE_ID;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_6_2_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_6_2_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_6_2_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "BGRT" Boot Graphics Resource Table
+///
+#define EFI_ACPI_6_2_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_6_2_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_6_2_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_6_2_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_6_2_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_6_2_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_6_2_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_6_2_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FPDT" Firmware Performance Data Table
+///
+#define EFI_ACPI_6_2_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')
+
+///
+/// "GTDT" Generic Timer Description Table
+///
+#define EFI_ACPI_6_2_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_6_2_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "HMAT" Heterogeneous Memory Attribute Table
+///
+#define EFI_ACPI_6_2_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_SIGNATURE  SIGNATURE_32('H', 'M', 'A', 'T')
+
+///
+/// "MPST" Memory Power State Table
+///
+#define EFI_ACPI_6_2_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_6_2_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "NFIT" NVDIMM Firmware Interface Table
+///
+#define EFI_ACPI_6_2_NVDIMM_FIRMWARE_INTERFACE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('N', 'F', 'I', 'T')
+
+///
+/// "PDTT" Platform Debug Trigger Table
+///
+#define EFI_ACPI_6_2_PLATFORM_DEBUG_TRIGGER_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'D', 'T', 'T')
+
+///
+/// "PMTT" Platform Memory Topology Table
+///
+#define EFI_ACPI_6_2_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')
+
+///
+/// "PPTT" Processor Properties Topology Table
+///
+#define EFI_ACPI_6_2_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'P', 'T', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_6_2_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RASF" ACPI RAS Feature Table
+///
+#define EFI_ACPI_6_2_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_6_2_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_6_2_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SDEV" Secure DEVices Table
+///
+#define EFI_ACPI_6_2_SECURE_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'V')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_6_2_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_6_2_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_6_2_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_6_2_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_6_2_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CSRT" MS Core System Resource Table
+///
+#define EFI_ACPI_6_2_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')
+
+///
+/// "DBG2" MS Debug Port 2 Spec
+///
+#define EFI_ACPI_6_2_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_6_2_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_6_2_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "DPPT" DMA Protection Policy Table
+///
+#define EFI_ACPI_6_2_DMA_PROTECTION_POLICY_TABLE_SIGNATURE  SIGNATURE_32('D', 'P', 'P', 'T')
+
+///
+/// "DRTM" Dynamic Root of Trust for Measurement Table
+///
+#define EFI_ACPI_6_2_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_6_2_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_6_2_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_6_2_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IORT" I/O Remapping Table
+///
+#define EFI_ACPI_6_2_IO_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('I', 'O', 'R', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_6_2_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "LPIT" Low Power Idle Table
+///
+#define EFI_ACPI_6_2_LOW_POWER_IDLE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('L', 'P', 'I', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_6_2_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_6_2_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "MSDM" MS Data Management Table
+///
+#define EFI_ACPI_6_2_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')
+
+///
+/// "PCCT" Platform Communications Channel Table
+///
+#define EFI_ACPI_6_2_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')
+
+///
+/// "SDEI" Software Delegated Exceptions Interface Table
+///
+#define EFI_ACPI_6_2_SOFTWARE_DELEGATED_EXCEPTIONS_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'I')
+
+///
+/// "SLIC" MS Software Licensing Table Specification
+///
+#define EFI_ACPI_6_2_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')
+
+///
+/// "SPCR" Serial Port Console Redirection Table
+///
+#define EFI_ACPI_6_2_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_6_2_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "STAO" _STA Override Table
+///
+#define EFI_ACPI_6_2_STA_OVERRIDE_TABLE_SIGNATURE  SIGNATURE_32('S', 'T', 'A', 'O')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_6_2_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "TPM2" Trusted Computing Platform 1 Table
+///
+#define EFI_ACPI_6_2_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_6_2_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Emulated Devices Table
+///
+#define EFI_ACPI_6_2_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_6_2_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_6_2_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WPBT" MS Platform Binary Table
+///
+#define EFI_ACPI_6_2_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')
+
+///
+/// "WSMT" Windows SMM Security Mitigation Table
+///
+#define EFI_ACPI_6_2_WINDOWS_SMM_SECURITY_MITIGATION_TABLE_SIGNATURE  SIGNATURE_32('W', 'S', 'M', 'T')
+
+///
+/// "XENV" Xen Project Table
+///
+#define EFI_ACPI_6_2_XEN_PROJECT_TABLE_SIGNATURE  SIGNATURE_32('X', 'E', 'N', 'V')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi63.h b/libedk2_tpm/include/IndustryStandard/Acpi63.h
new file mode 100644
index 0000000..431daac
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi63.h
@@ -0,0 +1,2960 @@
+/** @file
+  ACPI 6.3 definitions from the ACPI Specification Revision 6.3 Jan, 2019.
+
+  Copyright (c) 2017, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2019 - 2020, ARM Ltd. All rights reserved.<BR>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _ACPI_6_3_H_
+#define _ACPI_6_3_H_
+
+#include <IndustryStandard/Acpi62.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 6.3 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_6_3_SYSTEM_MEMORY                   0x00
+#define EFI_ACPI_6_3_SYSTEM_IO                       0x01
+#define EFI_ACPI_6_3_PCI_CONFIGURATION_SPACE         0x02
+#define EFI_ACPI_6_3_EMBEDDED_CONTROLLER             0x03
+#define EFI_ACPI_6_3_SMBUS                           0x04
+#define EFI_ACPI_6_3_SYSTEM_CMOS                     0x05
+#define EFI_ACPI_6_3_PCI_BAR_TARGET                  0x06
+#define EFI_ACPI_6_3_IPMI                            0x07
+#define EFI_ACPI_6_3_GENERAL_PURPOSE_IO              0x08
+#define EFI_ACPI_6_3_GENERIC_SERIAL_BUS              0x09
+#define EFI_ACPI_6_3_PLATFORM_COMMUNICATION_CHANNEL  0x0A
+#define EFI_ACPI_6_3_FUNCTIONAL_FIXED_HARDWARE       0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_6_3_UNDEFINED  0
+#define EFI_ACPI_6_3_BYTE       1
+#define EFI_ACPI_6_3_WORD       2
+#define EFI_ACPI_6_3_DWORD      3
+#define EFI_ACPI_6_3_QWORD      4
+
+//
+// ACPI 6.3 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_3_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 6.3) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_3_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT16                                  ArmBootArch;
+  UINT8                                   MinorVersion;
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  SleepControlReg;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  SleepStatusReg;
+  UINT64                                  HypervisorVendorIdentity;
+} EFI_ACPI_6_3_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x06
+#define EFI_ACPI_6_3_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION  0x03
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_6_3_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_6_3_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_6_3_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_6_3_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_6_3_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_6_3_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_6_3_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_6_3_PM_PROFILE_PERFORMANCE_SERVER  7
+#define EFI_ACPI_6_3_PM_PROFILE_TABLET              8
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_3_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_6_3_8042                        BIT1
+#define EFI_ACPI_6_3_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_6_3_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_6_3_PCIE_ASPM_CONTROLS          BIT4
+#define EFI_ACPI_6_3_CMOS_RTC_NOT_PRESENT        BIT5
+
+//
+// Fixed ACPI Description Table Arm Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_3_ARM_PSCI_COMPLIANT              BIT0
+#define EFI_ACPI_6_3_ARM_PSCI_USE_HVC                BIT1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_3_WBINVD                                 BIT0
+#define EFI_ACPI_6_3_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_6_3_PROC_C1                                BIT2
+#define EFI_ACPI_6_3_P_LVL2_UP                              BIT3
+#define EFI_ACPI_6_3_PWR_BUTTON                             BIT4
+#define EFI_ACPI_6_3_SLP_BUTTON                             BIT5
+#define EFI_ACPI_6_3_FIX_RTC                                BIT6
+#define EFI_ACPI_6_3_RTC_S4                                 BIT7
+#define EFI_ACPI_6_3_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_6_3_DCK_CAP                                BIT9
+#define EFI_ACPI_6_3_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_6_3_SEALED_CASE                            BIT11
+#define EFI_ACPI_6_3_HEADLESS                               BIT12
+#define EFI_ACPI_6_3_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_6_3_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_6_3_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_6_3_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_6_3_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_6_3_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_6_3_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+#define EFI_ACPI_6_3_HW_REDUCED_ACPI                        BIT20
+#define EFI_ACPI_6_3_LOW_POWER_S0_IDLE_CAPABLE              BIT21
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_6_3_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_3_S4BIOS_F                     BIT0
+#define EFI_ACPI_6_3_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_3_OSPM_64BIT_WAKE_F            BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_6_3_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_6_3_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_6_3_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x05
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_3_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x0D and 0x7F are reserved and
+// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
+//
+#define EFI_ACPI_6_3_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_6_3_IO_APIC                        0x01
+#define EFI_ACPI_6_3_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_6_3_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_6_3_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_6_3_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_6_3_IO_SAPIC                       0x06
+#define EFI_ACPI_6_3_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_6_3_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_6_3_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_6_3_LOCAL_X2APIC_NMI               0x0A
+#define EFI_ACPI_6_3_GIC                            0x0B
+#define EFI_ACPI_6_3_GICD                           0x0C
+#define EFI_ACPI_6_3_GIC_MSI_FRAME                  0x0D
+#define EFI_ACPI_6_3_GICR                           0x0E
+#define EFI_ACPI_6_3_GIC_ITS                        0x0F
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_6_3_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_LOCAL_APIC_ENABLED         BIT0
+#define EFI_ACPI_6_3_LOCAL_APIC_ONLINE_CAPABLE  BIT1
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_6_3_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_6_3_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_6_3_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_3_POLARITY      (3 << 0)
+#define EFI_ACPI_6_3_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_6_3_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_6_3_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_6_3_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_6_3_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_6_3_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_6_3_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_3_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_6_3_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_3_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// GIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  CPUInterfaceNumber;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ParkingProtocolVersion;
+  UINT32  PerformanceInterruptGsiv;
+  UINT64  ParkedAddress;
+  UINT64  PhysicalBaseAddress;
+  UINT64  GICV;
+  UINT64  GICH;
+  UINT32  VGICMaintenanceInterrupt;
+  UINT64  GICRBaseAddress;
+  UINT64  MPIDR;
+  UINT8   ProcessorPowerEfficiencyClass;
+  UINT8   Reserved2;
+  UINT16  SpeOverflowInterrupt;
+} EFI_ACPI_6_3_GIC_STRUCTURE;
+
+///
+/// GIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_GIC_ENABLED                              BIT0
+#define EFI_ACPI_6_3_PERFORMANCE_INTERRUPT_MODEL              BIT1
+#define EFI_ACPI_6_3_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS    BIT2
+
+///
+/// GIC Distributor Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  SystemVectorBase;
+  UINT8   GicVersion;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_3_GIC_DISTRIBUTOR_STRUCTURE;
+
+///
+/// GIC Version
+///
+#define EFI_ACPI_6_3_GIC_V1                                   0x01
+#define EFI_ACPI_6_3_GIC_V2                                   0x02
+#define EFI_ACPI_6_3_GIC_V3                                   0x03
+#define EFI_ACPI_6_3_GIC_V4                                   0x04
+
+///
+/// GIC MSI Frame Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicMsiFrameId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Flags;
+  UINT16  SPICount;
+  UINT16  SPIBase;
+} EFI_ACPI_6_3_GIC_MSI_FRAME_STRUCTURE;
+
+///
+/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_SPI_COUNT_BASE_SELECT                    BIT0
+
+///
+/// GICR Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  DiscoveryRangeBaseAddress;
+  UINT32  DiscoveryRangeLength;
+} EFI_ACPI_6_3_GICR_STRUCTURE;
+
+///
+/// GIC Interrupt Translation Service Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  GicItsId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Reserved2;
+} EFI_ACPI_6_3_GIC_ITS_STRUCTURE;
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_6_3_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_6_3_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT).  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_6_3_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x06 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_6_3_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_6_3_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_6_3_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+#define EFI_ACPI_6_3_GICC_AFFINITY                        0x03
+#define EFI_ACPI_6_3_GIC_ITS_AFFINITY                     0x04
+#define EFI_ACPI_6_3_GENERIC_INITIATOR_AFFINITY           0x05
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_6_3_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_6_3_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_6_3_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_6_3_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_6_3_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_6_3_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+} EFI_ACPI_6_3_GICC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_GICC_ENABLED (1 << 0)
+
+///
+/// GIC Interrupt Translation Service (ITS) Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT8   Reserved[2];
+  UINT32  ItsId;
+} EFI_ACPI_6_3_GIC_ITS_AFFINITY_STRUCTURE;
+
+//
+// Generic Initiator Affinity Structure Device Handle Types
+// All other values between 0x02 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_6_3_ACPI_DEVICE_HANDLE     0x00
+#define EFI_ACPI_6_3_PCI_DEVICE_HANDLE      0x01
+
+///
+/// Device Handle - ACPI
+///
+typedef struct {
+  UINT64  AcpiHid;
+  UINT32  AcpiUid;
+  UINT8   Reserved[4];
+} EFI_ACPI_6_3_DEVICE_HANDLE_ACPI;
+
+///
+/// Device Handle - PCI
+///
+typedef struct {
+  UINT16  PciSegment;
+  UINT16  PciBdfNumber;
+  UINT8   Reserved[12];
+} EFI_ACPI_6_3_DEVICE_HANDLE_PCI;
+
+///
+/// Generic Initiator Affinity Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1;
+  UINT8   DeviceHandleType;
+  UINT32  ProximityDomain;
+
+  union {
+    EFI_ACPI_6_3_DEVICE_HANDLE_ACPI   Acpi;
+    EFI_ACPI_6_3_DEVICE_HANDLE_PCI    Pci;
+  } DeviceHandle;
+
+  UINT32  Flags;
+  UINT8   Reserved2[4];
+} EFI_ACPI_6_3_GENERIC_INITIATOR_AFFINITY_STRUCTURE;
+
+///
+/// Generic Initiator Affinity Structure Flags. All other bits are reserved
+/// and must be 0.
+///
+#define EFI_ACPI_6_3_GENERIC_INITIATOR_AFFINITY_STRUCTURE_ENABLED (1 << 0)
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_6_3_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_6_3_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_6_3_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_6_3_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_6_3_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_6_3_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// ACPI RAS Feature Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier[12];
+} EFI_ACPI_6_3_RAS_FEATURE_TABLE;
+
+///
+/// RASF Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_RAS_FEATURE_TABLE_REVISION 0x01
+
+///
+/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT16                      Version;
+  UINT8                       RASCapabilities[16];
+  UINT8                       SetRASCapabilities[16];
+  UINT16                      NumberOfRASFParameterBlocks;
+  UINT32                      SetRASCapabilitiesStatus;
+} EFI_ACPI_6_3_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI RASF PCC command code
+///
+#define EFI_ACPI_6_3_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01
+
+///
+/// ACPI RASF Platform RAS Capabilities
+///
+#define EFI_ACPI_6_3_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED                         BIT0
+#define EFI_ACPI_6_3_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED_AND_EXPOSED_TO_SOFTWARE BIT1
+#define EFI_ACPI_6_3_RASF_PLATFORM_RAS_CAPABILITY_CPU_CACHE_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS            BIT2
+#define EFI_ACPI_6_3_RASF_PLATFORM_RAS_CAPABILITY_MEMORY_CONTROLLER_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS    BIT3
+#define EFI_ACPI_6_3_RASF_PLATFORM_RAS_CAPABILITY_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_HARDWARE_MIRRORING         BIT4
+
+///
+/// ACPI RASF Parameter Block structure for PATROL_SCRUB
+///
+typedef struct {
+  UINT16                      Type;
+  UINT16                      Version;
+  UINT16                      Length;
+  UINT16                      PatrolScrubCommand;
+  UINT64                      RequestedAddressRange[2];
+  UINT64                      ActualAddressRange[2];
+  UINT16                      Flags;
+  UINT8                       RequestedSpeed;
+} EFI_ACPI_6_3_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;
+
+///
+/// ACPI RASF Patrol Scrub command
+///
+#define EFI_ACPI_6_3_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS   0x01
+#define EFI_ACPI_6_3_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER   0x02
+#define EFI_ACPI_6_3_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER    0x03
+
+///
+/// Memory Power State Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier;
+  UINT8                       Reserved[3];
+// Memory Power Node Structure
+// Memory Power State Characteristics
+} EFI_ACPI_6_3_MEMORY_POWER_STATUS_TABLE;
+
+///
+/// MPST Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_MEMORY_POWER_STATE_TABLE_REVISION 0x01
+
+///
+/// MPST Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT32                      MemoryPowerCommandRegister;
+  UINT32                      MemoryPowerStatusRegister;
+  UINT32                      PowerStateId;
+  UINT32                      MemoryPowerNodeId;
+  UINT64                      MemoryEnergyConsumed;
+  UINT64                      ExpectedAveragePowerComsuned;
+} EFI_ACPI_6_3_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI MPST PCC command code
+///
+#define EFI_ACPI_6_3_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03
+
+///
+/// ACPI MPST Memory Power command
+///
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE       0x01
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE       0x02
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED   0x03
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED   0x04
+
+///
+/// MPST Memory Power Node Table
+///
+typedef struct {
+  UINT8                                             PowerStateValue;
+  UINT8                                             PowerStateInformationIndex;
+} EFI_ACPI_6_3_MPST_MEMORY_POWER_STATE;
+
+typedef struct {
+  UINT8                                             Flag;
+  UINT8                                             Reserved;
+  UINT16                                            MemoryPowerNodeId;
+  UINT32                                            Length;
+  UINT64                                            AddressBase;
+  UINT64                                            AddressLength;
+  UINT32                                            NumberOfPowerStates;
+  UINT32                                            NumberOfPhysicalComponents;
+//EFI_ACPI_6_3_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
+//UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
+} EFI_ACPI_6_3_MPST_MEMORY_POWER_STRUCTURE;
+
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE          0x01
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED   0x02
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE   0x04
+
+typedef struct {
+  UINT16                      MemoryPowerNodeCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_3_MPST_MEMORY_POWER_NODE_TABLE;
+
+///
+/// MPST Memory Power State Characteristics Table
+///
+typedef struct {
+  UINT8                                             PowerStateStructureID;
+  UINT8                                             Flag;
+  UINT16                                            Reserved;
+  UINT32                                            AveragePowerConsumedInMPS0;
+  UINT32                                            RelativePowerSavingToMPS0;
+  UINT64                                            ExitLatencyToMPS0;
+} EFI_ACPI_6_3_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;
+
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED              0x01
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY   0x02
+#define EFI_ACPI_6_3_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT    0x04
+
+typedef struct {
+  UINT16                      MemoryPowerStateCharacteristicsCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_3_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;
+
+///
+/// Memory Topology Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved;
+} EFI_ACPI_6_3_MEMORY_TOPOLOGY_TABLE;
+
+///
+/// PMTT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_MEMORY_TOPOLOGY_TABLE_REVISION 0x01
+
+///
+/// Common Memory Aggregator Device Structure.
+///
+typedef struct {
+  UINT8                       Type;
+  UINT8                       Reserved;
+  UINT16                      Length;
+  UINT16                      Flags;
+  UINT16                      Reserved1;
+} EFI_ACPI_6_3_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Memory Aggregator Device Type
+///
+#define EFI_ACPI_6_3_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_SOCKET            0x0
+#define EFI_ACPI_6_3_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_MEMORY_CONTROLLER 0x1
+#define EFI_ACPI_6_3_PMMT_MEMORY_AGGREGATOR_DEVICE_TYPE_DIMM              0x2
+
+///
+/// Socket Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_3_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       SocketIdentifier;
+  UINT16                                                       Reserved;
+//EFI_ACPI_6_3_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  MemoryController[];
+} EFI_ACPI_6_3_PMMT_SOCKET_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// MemoryController Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_3_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT32                                                       ReadLatency;
+  UINT32                                                       WriteLatency;
+  UINT32                                                       ReadBandwidth;
+  UINT32                                                       WriteBandwidth;
+  UINT16                                                       OptimalAccessUnit;
+  UINT16                                                       OptimalAccessAlignment;
+  UINT16                                                       Reserved;
+  UINT16                                                       NumberOfProximityDomains;
+//UINT32                                                       ProximityDomain[NumberOfProximityDomains];
+//EFI_ACPI_6_3_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE    PhysicalComponent[];
+} EFI_ACPI_6_3_PMMT_MEMORY_CONTROLLER_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// DIMM Memory Aggregator Device Structure.
+///
+typedef struct {
+  EFI_ACPI_6_3_PMMT_COMMON_MEMORY_AGGREGATOR_DEVICE_STRUCTURE  Header;
+  UINT16                                                       PhysicalComponentIdentifier;
+  UINT16                                                       Reserved;
+  UINT32                                                       SizeOfDimm;
+  UINT32                                                       SmbiosHandle;
+} EFI_ACPI_6_3_PMMT_DIMM_MEMORY_AGGREGATOR_DEVICE_STRUCTURE;
+
+///
+/// Boot Graphics Resource Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  ///
+  /// 2-bytes (16 bit) version ID. This value must be 1.
+  ///
+  UINT16                      Version;
+  ///
+  /// 1-byte status field indicating current status about the table.
+  ///     Bits[7:1] = Reserved (must be zero)
+  ///     Bit [0] = Valid. A one indicates the boot image graphic is valid.
+  ///
+  UINT8                       Status;
+  ///
+  /// 1-byte enumerated type field indicating format of the image.
+  ///     0 = Bitmap
+  ///     1 - 255  Reserved (for future use)
+  ///
+  UINT8                       ImageType;
+  ///
+  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
+  /// of the image bitmap.
+  ///
+  UINT64                      ImageAddress;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetX;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetY;
+} EFI_ACPI_6_3_BOOT_GRAPHICS_RESOURCE_TABLE;
+
+///
+/// BGRT Revision
+///
+#define EFI_ACPI_6_3_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION 1
+
+///
+/// BGRT Version
+///
+#define EFI_ACPI_6_3_BGRT_VERSION         0x01
+
+///
+/// BGRT Status
+///
+#define EFI_ACPI_6_3_BGRT_STATUS_NOT_DISPLAYED 0x00
+#define EFI_ACPI_6_3_BGRT_STATUS_DISPLAYED     0x01
+
+///
+/// BGRT Image Type
+///
+#define EFI_ACPI_6_3_BGRT_IMAGE_TYPE_BMP  0x00
+
+///
+/// FPDT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION 0x01
+
+///
+/// FPDT Performance Record Types
+///
+#define EFI_ACPI_6_3_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER      0x0000
+#define EFI_ACPI_6_3_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER     0x0001
+
+///
+/// FPDT Performance Record Revision
+///
+#define EFI_ACPI_6_3_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER  0x01
+#define EFI_ACPI_6_3_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER 0x01
+
+///
+/// FPDT Runtime Performance Record Types
+///
+#define EFI_ACPI_6_3_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME                0x0000
+#define EFI_ACPI_6_3_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND               0x0001
+#define EFI_ACPI_6_3_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT      0x0002
+
+///
+/// FPDT Runtime Performance Record Revision
+///
+#define EFI_ACPI_6_3_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
+#define EFI_ACPI_6_3_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
+#define EFI_ACPI_6_3_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02
+
+///
+/// FPDT Performance Record header
+///
+typedef struct {
+  UINT16           Type;
+  UINT8            Length;
+  UINT8            Revision;
+} EFI_ACPI_6_3_FPDT_PERFORMANCE_RECORD_HEADER;
+
+///
+/// FPDT Performance Table header
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_3_FPDT_PERFORMANCE_TABLE_HEADER;
+
+///
+/// FPDT Firmware Basic Boot Performance Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_3_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
+  ///
+  UINT64                                          BootPerformanceTablePointer;
+} EFI_ACPI_6_3_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT S3 Performance Table Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_3_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the S3 Performance Table.
+  ///
+  UINT64                                          S3PerformanceTablePointer;
+} EFI_ACPI_6_3_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_3_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// Timer value logged at the beginning of firmware image execution.
+  /// This may not always be zero or near zero.
+  ///
+  UINT64                                          ResetEnd;
+  ///
+  /// Timer value logged just prior to loading the OS boot loader into memory.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          OsLoaderLoadImageStart;
+  ///
+  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
+  /// For non-UEFI compatible boots, the timer value logged will be just prior
+  /// to the INT 19h handler invocation.
+  ///
+  UINT64                                          OsLoaderStartImageStart;
+  ///
+  /// Timer value logged at the point when the OS loader calls the
+  /// ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesEntry;
+  ///
+  /// Timer value logged at the point just prior towhen the OS loader gaining
+  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesExit;
+} EFI_ACPI_6_3_FPDT_FIRMWARE_BASIC_BOOT_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Table signature
+///
+#define EFI_ACPI_6_3_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')
+
+//
+// FPDT Firmware Basic Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_3_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_3_FPDT_FIRMWARE_BASIC_BOOT_TABLE;
+
+///
+/// FPDT "S3PT" S3 Performance Table
+///
+#define EFI_ACPI_6_3_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')
+
+//
+// FPDT Firmware S3 Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_3_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_3_FPDT_FIRMWARE_S3_BOOT_TABLE;
+
+///
+/// FPDT Basic S3 Resume Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_3_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// A count of the number of S3 resume cycles since the last full boot sequence.
+  ///
+  UINT32                                          ResumeCount;
+  ///
+  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
+  /// OS waking vector. Only the most recent resume cycle's time is retained.
+  ///
+  UINT64                                          FullResume;
+  ///
+  /// Average timer value of all resume cycles logged since the last full boot
+  /// sequence, including the most recent resume.  Note that the entire log of
+  /// timer values does not need to be retained in order to calculate this average.
+  ///
+  UINT64                                          AverageResume;
+} EFI_ACPI_6_3_FPDT_S3_RESUME_RECORD;
+
+///
+/// FPDT Basic S3 Suspend Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_3_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendStart;
+  ///
+  /// Timer value recorded at the final firmware write to SLP_TYP (or other
+  /// mechanism) used to trigger hardware entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendEnd;
+} EFI_ACPI_6_3_FPDT_S3_SUSPEND_RECORD;
+
+///
+/// Firmware Performance Record Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+} EFI_ACPI_6_3_FIRMWARE_PERFORMANCE_RECORD_TABLE;
+
+///
+/// Generic Timer Description Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      CntControlBasePhysicalAddress;
+  UINT32                      Reserved;
+  UINT32                      SecurePL1TimerGSIV;
+  UINT32                      SecurePL1TimerFlags;
+  UINT32                      NonSecurePL1TimerGSIV;
+  UINT32                      NonSecurePL1TimerFlags;
+  UINT32                      VirtualTimerGSIV;
+  UINT32                      VirtualTimerFlags;
+  UINT32                      NonSecurePL2TimerGSIV;
+  UINT32                      NonSecurePL2TimerFlags;
+  UINT64                      CntReadBasePhysicalAddress;
+  UINT32                      PlatformTimerCount;
+  UINT32                      PlatformTimerOffset;
+  UINT32                      VirtualPL2TimerGSIV;
+  UINT32                      VirtualPL2TimerFlags;
+} EFI_ACPI_6_3_GENERIC_TIMER_DESCRIPTION_TABLE;
+
+///
+/// GTDT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION 0x03
+
+///
+/// Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_3_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_3_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY          BIT2
+
+///
+/// Platform Timer Type
+///
+#define EFI_ACPI_6_3_GTDT_GT_BLOCK                       0
+#define EFI_ACPI_6_3_GTDT_SBSA_GENERIC_WATCHDOG          1
+
+///
+/// GT Block Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  CntCtlBase;
+  UINT32  GTBlockTimerCount;
+  UINT32  GTBlockTimerOffset;
+} EFI_ACPI_6_3_GTDT_GT_BLOCK_STRUCTURE;
+
+///
+/// GT Block Timer Structure
+///
+typedef struct {
+  UINT8   GTFrameNumber;
+  UINT8   Reserved[3];
+  UINT64  CntBaseX;
+  UINT64  CntEL0BaseX;
+  UINT32  GTxPhysicalTimerGSIV;
+  UINT32  GTxPhysicalTimerFlags;
+  UINT32  GTxVirtualTimerGSIV;
+  UINT32  GTxVirtualTimerFlags;
+  UINT32  GTxCommonFlags;
+} EFI_ACPI_6_3_GTDT_GT_BLOCK_TIMER_STRUCTURE;
+
+///
+/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_3_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+
+///
+/// Common Flags Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER              BIT0
+#define EFI_ACPI_6_3_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY      BIT1
+
+///
+/// SBSA Generic Watchdog Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  RefreshFramePhysicalAddress;
+  UINT64  WatchdogControlFramePhysicalAddress;
+  UINT32  WatchdogTimerGSIV;
+  UINT32  WatchdogTimerFlags;
+} EFI_ACPI_6_3_GTDT_SBSA_GENERIC_WATCHDOG_STRUCTURE;
+
+///
+/// SBSA Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_3_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_3_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_3_GTDT_SBSA_GENERIC_WATCHDOG_FLAG_SECURE_TIMER                  BIT2
+
+//
+// NVDIMM Firmware Interface Table definition.
+//
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER    Header;
+  UINT32                         Reserved;
+} EFI_ACPI_6_3_NVDIMM_FIRMWARE_INTERFACE_TABLE;
+
+//
+// NFIT Version (as defined in ACPI 6.3 spec.)
+//
+#define EFI_ACPI_6_3_NVDIMM_FIRMWARE_INTERFACE_TABLE_REVISION 0x1
+
+//
+// Definition for NFIT Table Structure Types
+//
+#define EFI_ACPI_6_3_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE_TYPE              0
+#define EFI_ACPI_6_3_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE_TYPE                      1
+#define EFI_ACPI_6_3_NFIT_INTERLEAVE_STRUCTURE_TYPE                                 2
+#define EFI_ACPI_6_3_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE_TYPE              3
+#define EFI_ACPI_6_3_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE_TYPE                      4
+#define EFI_ACPI_6_3_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE_TYPE            5
+#define EFI_ACPI_6_3_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE_TYPE                         6
+
+//
+// Definition for NFIT Structure Header
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+} EFI_ACPI_6_3_NFIT_STRUCTURE_HEADER;
+
+//
+// Definition for System Physical Address Range Structure
+//
+#define EFI_ACPI_6_3_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_CONTROL_REGION_FOR_MANAGEMENT      BIT0
+#define EFI_ACPI_6_3_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_PROXIMITY_DOMAIN_VALID             BIT1
+#define EFI_ACPI_6_3_NFIT_GUID_VOLATILE_MEMORY_REGION                             { 0x7305944F, 0xFDDA, 0x44E3, { 0xB1, 0x6C, 0x3F, 0x22, 0xD2, 0x52, 0xE5, 0xD0 }}
+#define EFI_ACPI_6_3_NFIT_GUID_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_REGION          { 0x66F0D379, 0xB4F3, 0x4074, { 0xAC, 0x43, 0x0D, 0x33, 0x18, 0xB7, 0x8C, 0xDB }}
+#define EFI_ACPI_6_3_NFIT_GUID_NVDIMM_CONTROL_REGION                              { 0x92F701F6, 0x13B4, 0x405D, { 0x91, 0x0B, 0x29, 0x93, 0x67, 0xE8, 0x23, 0x4C }}
+#define EFI_ACPI_6_3_NFIT_GUID_NVDIMM_BLOCK_DATA_WINDOW_REGION                    { 0x91AF0530, 0x5D86, 0x470E, { 0xA6, 0xB0, 0x0A, 0x2D, 0xB9, 0x40, 0x82, 0x49 }}
+#define EFI_ACPI_6_3_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_VOLATILE   { 0x77AB535A, 0x45FC, 0x624B, { 0x55, 0x60, 0xF7, 0xB2, 0x81, 0xD1, 0xF9, 0x6E }}
+#define EFI_ACPI_6_3_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_VOLATILE     { 0x3D5ABD30, 0x4175, 0x87CE, { 0x6D, 0x64, 0xD2, 0xAD, 0xE5, 0x23, 0xC4, 0xBB }}
+#define EFI_ACPI_6_3_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_PERSISTENT { 0x5CEA02C9, 0x4D07, 0x69D3, { 0x26, 0x9F ,0x44, 0x96, 0xFB, 0xE0, 0x96, 0xF9 }}
+#define EFI_ACPI_6_3_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_PERSISTENT   { 0x08018188, 0x42CD, 0xBB48, { 0x10, 0x0F, 0x53, 0x87, 0xD5, 0x3D, 0xED, 0x3D }}
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      SPARangeStructureIndex;
+  UINT16                                      Flags;
+  UINT32                                      Reserved_8;
+  UINT32                                      ProximityDomain;
+  GUID                                        AddressRangeTypeGUID;
+  UINT64                                      SystemPhysicalAddressRangeBase;
+  UINT64                                      SystemPhysicalAddressRangeLength;
+  UINT64                                      AddressRangeMemoryMappingAttribute;
+} EFI_ACPI_6_3_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE;
+
+//
+// Definition for Memory Device to System Physical Address Range Mapping Structure
+//
+typedef struct {
+  UINT32                                      DIMMNumber:4;
+  UINT32                                      MemoryChannelNumber:4;
+  UINT32                                      MemoryControllerID:4;
+  UINT32                                      SocketID:4;
+  UINT32                                      NodeControllerID:12;
+  UINT32                                      Reserved_28:4;
+} EFI_ACPI_6_3_NFIT_DEVICE_HANDLE;
+
+#define EFI_ACPI_6_3_NFIT_MEMORY_DEVICE_STATE_FLAGS_PREVIOUS_SAVE_FAIL                                      BIT0
+#define EFI_ACPI_6_3_NFIT_MEMORY_DEVICE_STATE_FLAGS_LAST_RESTORE_FAIL                                       BIT1
+#define EFI_ACPI_6_3_NFIT_MEMORY_DEVICE_STATE_FLAGS_PLATFORM_FLUSH_FAIL                                     BIT2
+#define EFI_ACPI_6_3_NFIT_MEMORY_DEVICE_STATE_FLAGS_NOT_ARMED_PRIOR_TO_OSPM_HAND_OFF                        BIT3
+#define EFI_ACPI_6_3_NFIT_MEMORY_DEVICE_STATE_FLAGS_SMART_HEALTH_EVENTS_PRIOR_OSPM_HAND_OFF                 BIT4
+#define EFI_ACPI_6_3_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_ENABLED_TO_NOTIFY_OSPM_ON_SMART_HEALTH_EVENTS  BIT5
+#define EFI_ACPI_6_3_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_NOT_MAP_NVDIMM_TO_SPA                          BIT6
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_3_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NVDIMMPhysicalID;
+  UINT16                                      NVDIMMRegionID;
+  UINT16                                      SPARangeStructureIndex ;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT64                                      NVDIMMRegionSize;
+  UINT64                                      RegionOffset;
+  UINT64                                      NVDIMMPhysicalAddressRegionBase;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      InterleaveWays;
+  UINT16                                      NVDIMMStateFlags;
+  UINT16                                      Reserved_46;
+} EFI_ACPI_6_3_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE;
+
+//
+// Definition for Interleave Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      Reserved_6;
+  UINT32                                      NumberOfLines;
+  UINT32                                      LineSize;
+//UINT32                                      LineOffset[NumberOfLines];
+} EFI_ACPI_6_3_NFIT_INTERLEAVE_STRUCTURE;
+
+//
+// Definition for SMBIOS Management Information Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT32                                      Reserved_4;
+//UINT8                                       Data[];
+} EFI_ACPI_6_3_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE;
+
+//
+// Definition for NVDIMM Control Region Structure
+//
+#define EFI_ACPI_6_3_NFIT_NVDIMM_CONTROL_REGION_VALID_FIELDS_MANUFACTURING           BIT0
+
+#define EFI_ACPI_6_3_NFIT_NVDIMM_CONTROL_REGION_FLAGS_BLOCK_DATA_WINDOWS_BUFFERED    BIT0
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      VendorID;
+  UINT16                                      DeviceID;
+  UINT16                                      RevisionID;
+  UINT16                                      SubsystemVendorID;
+  UINT16                                      SubsystemDeviceID;
+  UINT16                                      SubsystemRevisionID;
+  UINT8                                       ValidFields;
+  UINT8                                       ManufacturingLocation;
+  UINT16                                      ManufacturingDate;
+  UINT8                                       Reserved_22[2];
+  UINT32                                      SerialNumber;
+  UINT16                                      RegionFormatInterfaceCode;
+  UINT16                                      NumberOfBlockControlWindows;
+  UINT64                                      SizeOfBlockControlWindow;
+  UINT64                                      CommandRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfCommandRegisterInBlockControlWindows;
+  UINT64                                      StatusRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfStatusRegisterInBlockControlWindows;
+  UINT16                                      NVDIMMControlRegionFlag;
+  UINT8                                       Reserved_74[6];
+} EFI_ACPI_6_3_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE;
+
+//
+// Definition for NVDIMM Block Data Window Region Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      NumberOfBlockDataWindows;
+  UINT64                                      BlockDataWindowStartOffset;
+  UINT64                                      SizeOfBlockDataWindow;
+  UINT64                                      BlockAccessibleMemoryCapacity;
+  UINT64                                      BeginningAddressOfFirstBlockInBlockAccessibleMemory;
+} EFI_ACPI_6_3_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE;
+
+//
+// Definition for Flush Hint Address Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_3_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NumberOfFlushHintAddresses;
+  UINT8                                       Reserved_10[6];
+//UINT64                                      FlushHintAddress[NumberOfFlushHintAddresses];
+} EFI_ACPI_6_3_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE;
+
+///
+/// Secure DEVices Table (SDEV)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+} EFI_ACPI_6_3_SECURE_DEVICES_TABLE_HEADER;
+
+///
+/// SDEV Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_SECURE_DEVICES_TABLE_REVISION      0x01
+
+///
+/// Secure Devcice types
+///
+#define EFI_ACPI_6_3_SDEV_TYPE_PCIE_ENDPOINT_DEVICE     0x01
+#define EFI_ACPI_6_3_SDEV_TYPE_ACPI_NAMESPACE_DEVICE    0x00
+
+///
+/// Secure Devcice flags
+///
+#define EFI_ACPI_6_3_SDEV_FLAG_ALLOW_HANDOFF            BIT0
+
+///
+/// SDEV Structure Header
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Flags;
+  UINT16                        Length;
+} EFI_ACPI_6_3_SDEV_STRUCTURE_HEADER;
+
+///
+/// PCIe Endpoint Device based Secure Device Structure
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Flags;
+  UINT16                        Length;
+  UINT16                        PciSegmentNumber;
+  UINT16                        StartBusNumber;
+  UINT16                        PciPathOffset;
+  UINT16                        PciPathLength;
+  UINT16                        VendorSpecificDataOffset;
+  UINT16                        VendorSpecificDataLength;
+} EFI_ACPI_6_3_SDEV_STRUCTURE_PCIE_ENDPOINT_DEVICE;
+
+///
+/// ACPI_NAMESPACE_DEVICE based Secure Device Structure
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Flags;
+  UINT16                        Length;
+  UINT16                        DeviceIdentifierOffset;
+  UINT16                        DeviceIdentifierLength;
+  UINT16                        VendorSpecificDataOffset;
+  UINT16                        VendorSpecificDataLength;
+} EFI_ACPI_6_3_SDEV_STRUCTURE_ACPI_NAMESPACE_DEVICE;
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_6_3_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_6_3_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_6_3_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_3_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_6_3_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_6_3_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_6_3_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_6_3_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+  UINT8    Timestamp[8];
+} EFI_ACPI_6_3_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0300
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_6_3_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_6_3_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_6_3_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_6_3_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_6_3_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_6_3_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_6_3_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_6_3_GENERIC_HARDWARE_ERROR                     0x09
+#define EFI_ACPI_6_3_GENERIC_HARDWARE_ERROR_VERSION_2           0x0A
+#define EFI_ACPI_6_3_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK   0x0B
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_6_3_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_6_3_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+#define EFI_ACPI_6_3_ERROR_SOURCE_FLAG_GHES_ASSIST          (1 << 2)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_6_3_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_6_3_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_6_3_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_6_3_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_6_3_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_POLLED                         0x00
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT             0x01
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT                0x02
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_SCI                            0x03
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_NMI                            0x04
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_CMCI                           0x05
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_MCE                            0x06
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_GPIO_SIGNAL                    0x07
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEA                      0x08
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEI                      0x09
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_GSIV                           0x0A
+#define EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_SOFTWARE_DELEGATED_EXCEPTION   0x0B
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_6_3_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_6_3_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_6_3_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_3_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_3_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_6_3_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Version 2 Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE                 ReadAckRegister;
+  UINT64                                                 ReadAckPreserve;
+  UINT64                                                 ReadAckWrite;
+} EFI_ACPI_6_3_GENERIC_HARDWARE_ERROR_SOURCE_VERSION_2_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_6_3_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_3_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// IA-32 Architecture Deferred Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                Type;
+  UINT16                                                SourceId;
+  UINT8                                                 Reserved0[2];
+  UINT8                                                 Flags;
+  UINT8                                                 Enabled;
+  UINT32                                                NumberOfRecordsToPreAllocate;
+  UINT32                                                MaxSectionsPerRecord;
+  EFI_ACPI_6_3_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
+  UINT8                                                 NumberOfHardwareBanks;
+  UINT8                                                 Reserved1[3];
+} EFI_ACPI_6_3_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK_STRUCTURE;;
+
+///
+/// HMAT - Heterogeneous Memory Attribute Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[4];
+} EFI_ACPI_6_3_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_HEADER;
+
+///
+/// HMAT Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_REVISION 0x02
+
+///
+/// HMAT types
+///
+#define EFI_ACPI_6_3_HMAT_TYPE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES           0x00
+#define EFI_ACPI_6_3_HMAT_TYPE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO   0x01
+#define EFI_ACPI_6_3_HMAT_TYPE_MEMORY_SIDE_CACHE_INFO                       0x02
+
+///
+/// HMAT Structure Header
+///
+typedef struct {
+  UINT16                        Type;
+  UINT8                         Reserved[2];
+  UINT32                        Length;
+} EFI_ACPI_6_3_HMAT_STRUCTURE_HEADER;
+
+///
+/// Memory Proximity Domain Attributes Structure flags
+///
+typedef struct {
+  UINT16                        InitiatorProximityDomainValid:1;
+  UINT16                        Reserved:15;
+} EFI_ACPI_6_3_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES_FLAGS;
+
+///
+/// Memory Proximity Domain Attributes Structure
+///
+typedef struct {
+  UINT16                                                                Type;
+  UINT8                                                                 Reserved[2];
+  UINT32                                                                Length;
+  EFI_ACPI_6_3_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES_FLAGS  Flags;
+  UINT8                                                                 Reserved1[2];
+  UINT32                                                                InitiatorProximityDomain;
+  UINT32                                                                MemoryProximityDomain;
+  UINT8                                                                 Reserved2[20];
+} EFI_ACPI_6_3_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES;
+
+///
+/// System Locality Latency and Bandwidth Information Structure flags
+///
+typedef struct {
+  UINT8                         MemoryHierarchy:4;
+  UINT8                         Reserved:4;
+} EFI_ACPI_6_3_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS;
+
+///
+/// System Locality Latency and Bandwidth Information Structure
+///
+typedef struct {
+  UINT16                                                                        Type;
+  UINT8                                                                         Reserved[2];
+  UINT32                                                                        Length;
+  EFI_ACPI_6_3_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS  Flags;
+  UINT8                                                                         DataType;
+  UINT8                                                                         Reserved1[2];
+  UINT32                                                                        NumberOfInitiatorProximityDomains;
+  UINT32                                                                        NumberOfTargetProximityDomains;
+  UINT8                                                                         Reserved2[4];
+  UINT64                                                                        EntryBaseUnit;
+} EFI_ACPI_6_3_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO;
+
+///
+/// Memory Side Cache Information Structure cache attributes
+///
+typedef struct {
+  UINT32                        TotalCacheLevels:4;
+  UINT32                        CacheLevel:4;
+  UINT32                        CacheAssociativity:4;
+  UINT32                        WritePolicy:4;
+  UINT32                        CacheLineSize:16;
+} EFI_ACPI_6_3_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES;
+
+///
+/// Memory Side Cache Information Structure
+///
+typedef struct {
+  UINT16                                                                Type;
+  UINT8                                                                 Reserved[2];
+  UINT32                                                                Length;
+  UINT32                                                                MemoryProximityDomain;
+  UINT8                                                                 Reserved1[4];
+  UINT64                                                                MemorySideCacheSize;
+  EFI_ACPI_6_3_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES   CacheAttributes;
+  UINT8                                                                 Reserved2[2];
+  UINT16                                                                NumberOfSmbiosHandles;
+} EFI_ACPI_6_3_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_6_3_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_6_3_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_6_3_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_6_3_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_6_3_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_6_3_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_6_3_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_3_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_3_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_3_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_6_3_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_6_3_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_6_3_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_6_3_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_6_3_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_6_3_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+#define EFI_ACPI_6_3_ERST_GET_EXECUTE_OPERATION_TIMINGS            0x10
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_6_3_ERST_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_3_ERST_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_6_3_ERST_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_6_3_ERST_STATUS_FAILED                            0x03
+#define EFI_ACPI_6_3_ERST_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_6_3_ERST_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_6_3_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_6_3_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_3_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_3_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_3_ERST_NOOP                                     0x04
+#define EFI_ACPI_6_3_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_6_3_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_6_3_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_6_3_ERST_ADD                                      0x08
+#define EFI_ACPI_6_3_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_6_3_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_6_3_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_6_3_ERST_STALL                                    0x0C
+#define EFI_ACPI_6_3_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_6_3_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_6_3_ERST_GOTO                                     0x0F
+#define EFI_ACPI_6_3_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_6_3_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_6_3_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_6_3_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_3_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_6_3_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_6_3_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_6_3_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_6_3_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_6_3_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_6_3_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_6_3_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_3_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_3_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_3_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_6_3_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_3_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_6_3_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_6_3_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_6_3_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_6_3_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_6_3_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_6_3_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_6_3_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_6_3_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_6_3_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_6_3_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_6_3_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_6_3_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_6_3_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_6_3_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_6_3_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_3_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_3_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_3_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_6_3_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_3_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_6_3_EINJ_TRIGGER_ACTION_TABLE;
+
+///
+/// Platform Communications Channel Table (PCCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Flags;
+  UINT64                      Reserved;
+} EFI_ACPI_6_3_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;
+
+///
+/// PCCT Version (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION 0x02
+
+///
+/// PCCT Global Flags
+///
+#define EFI_ACPI_6_3_PCCT_FLAGS_PLATFORM_INTERRUPT  BIT0
+
+//
+// PCCT Subspace type
+//
+#define EFI_ACPI_6_3_PCCT_SUBSPACE_TYPE_GENERIC                         0x00
+#define EFI_ACPI_6_3_PCCT_SUBSPACE_TYPE_1_HW_REDUCED_COMMUNICATIONS     0x01
+#define EFI_ACPI_6_3_PCCT_SUBSPACE_TYPE_2_HW_REDUCED_COMMUNICATIONS     0x02
+#define EFI_ACPI_6_3_PCCT_SUBSPACE_TYPE_3_EXTENDED_PCC                  0x03
+#define EFI_ACPI_6_3_PCCT_SUBSPACE_TYPE_4_EXTENDED_PCC                  0x04
+
+///
+/// PCC Subspace Structure Header
+///
+typedef struct {
+  UINT8        Type;
+  UINT8        Length;
+} EFI_ACPI_6_3_PCCT_SUBSPACE_HEADER;
+
+///
+/// Generic Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT8                                    Reserved[6];
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_3_PCCT_SUBSPACE_GENERIC;
+
+///
+/// Generic Communications Channel Shared Memory Region
+///
+
+typedef struct {
+  UINT8                                    Command;
+  UINT8                                    Reserved:7;
+  UINT8                                    NotifyOnCompletion:1;
+} EFI_ACPI_6_3_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
+
+typedef struct {
+  UINT8                                    CommandComplete:1;
+  UINT8                                    PlatformInterrupt:1;
+  UINT8                                    Error:1;
+  UINT8                                    PlatformNotification:1;
+  UINT8                                    Reserved:4;
+  UINT8                                    Reserved1;
+} EFI_ACPI_6_3_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
+
+typedef struct {
+  UINT32                                                    Signature;
+  EFI_ACPI_6_3_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
+  EFI_ACPI_6_3_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
+} EFI_ACPI_6_3_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;
+
+#define EFI_ACPI_6_3_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_POLARITY    BIT0
+#define EFI_ACPI_6_3_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_MODE        BIT1
+
+///
+/// Type 1 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_3_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 2 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   PlatformInterruptAckRegister;
+  UINT64                                   PlatformInterruptAckPreserve;
+  UINT64                                   PlatformInterruptAckWrite;
+} EFI_ACPI_6_3_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 3 Extended PCC Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT32                                   AddressLength;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT32                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   PlatformInterruptAckRegister;
+  UINT64                                   PlatformInterruptAckPreserve;
+  UINT64                                   PlatformInterruptAckSet;
+  UINT8                                    Reserved1[8];
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   CommandCompleteCheckRegister;
+  UINT64                                   CommandCompleteCheckMask;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   CommandCompleteUpdateRegister;
+  UINT64                                   CommandCompleteUpdatePreserve;
+  UINT64                                   CommandCompleteUpdateSet;
+  EFI_ACPI_6_3_GENERIC_ADDRESS_STRUCTURE   ErrorStatusRegister;
+  UINT64                                   ErrorStatusMask;
+} EFI_ACPI_6_3_PCCT_SUBSPACE_3_EXTENDED_PCC;
+
+///
+/// Type 4 Extended PCC Subspace Structure
+///
+typedef EFI_ACPI_6_3_PCCT_SUBSPACE_3_EXTENDED_PCC EFI_ACPI_6_3_PCCT_SUBSPACE_4_EXTENDED_PCC;
+
+#define EFI_ACPI_6_3_PCCT_MASTER_SLAVE_COMMUNICATIONS_CHANNEL_FLAGS_NOTIFY_ON_COMPLETION BIT0
+
+typedef struct {
+  UINT32                                    Signature;
+  UINT32                                    Flags;
+  UINT32                                    Length;
+  UINT32                                    Command;
+} EFI_ACPI_6_3_PCCT_EXTENDED_PCC_SHARED_MEMORY_REGION_HEADER;
+
+///
+/// Platform Debug Trigger Table (PDTT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+  UINT8                         TriggerCount;
+  UINT8                         Reserved[3];
+  UINT32                        TriggerIdentifierArrayOffset;
+} EFI_ACPI_6_3_PLATFORM_DEBUG_TRIGGER_TABLE_HEADER;
+
+///
+/// PDTT Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_PLATFORM_DEBUG_TRIGGER_TABLE_REVISION 0x00
+
+///
+/// PDTT Platform Communication Channel Identifier Structure
+///
+typedef struct {
+  UINT16                        SubChannelIdentifer:8;
+  UINT16                        Runtime:1;
+  UINT16                        WaitForCompletion:1;
+  UINT16                        TriggerOrder:1;
+  UINT16                        Reserved:5;
+} EFI_ACPI_6_3_PDTT_PCC_IDENTIFIER;
+
+///
+/// PCC Commands Codes used by Platform Debug Trigger Table
+///
+#define EFI_ACPI_6_3_PDTT_PCC_COMMAND_DOORBELL_ONLY     0x00
+#define EFI_ACPI_6_3_PDTT_PCC_COMMAND_VENDOR_SPECIFIC   0x01
+
+///
+/// PPTT Platform Communication Channel
+///
+typedef EFI_ACPI_6_3_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER EFI_ACPI_6_3_PDTT_PCC;
+
+///
+/// Processor Properties Topology Table (PPTT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+} EFI_ACPI_6_3_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_HEADER;
+
+///
+/// PPTT Revision (as defined in ACPI 6.3 spec.)
+///
+#define EFI_ACPI_6_3_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_REVISION 0x02
+
+///
+/// PPTT types
+///
+#define EFI_ACPI_6_3_PPTT_TYPE_PROCESSOR     0x00
+#define EFI_ACPI_6_3_PPTT_TYPE_CACHE         0x01
+#define EFI_ACPI_6_3_PPTT_TYPE_ID            0x02
+
+///
+/// PPTT Structure Header
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Length;
+  UINT8                         Reserved[2];
+} EFI_ACPI_6_3_PPTT_STRUCTURE_HEADER;
+
+///
+/// For PPTT struct processor flags
+///
+#define EFI_ACPI_6_3_PPTT_PACKAGE_NOT_PHYSICAL          0x0
+#define EFI_ACPI_6_3_PPTT_PACKAGE_PHYSICAL              0x1
+#define EFI_ACPI_6_3_PPTT_PROCESSOR_ID_INVALID          0x0
+#define EFI_ACPI_6_3_PPTT_PROCESSOR_ID_VALID            0x1
+#define EFI_ACPI_6_3_PPTT_PROCESSOR_IS_NOT_THREAD       0x0
+#define EFI_ACPI_6_3_PPTT_PROCESSOR_IS_THREAD           0x1
+#define EFI_ACPI_6_3_PPTT_NODE_IS_NOT_LEAF              0x0
+#define EFI_ACPI_6_3_PPTT_NODE_IS_LEAF                  0x1
+#define EFI_ACPI_6_3_PPTT_IMPLEMENTATION_NOT_IDENTICAL  0x0
+#define EFI_ACPI_6_3_PPTT_IMPLEMENTATION_IDENTICAL      0x1
+
+///
+/// Processor hierarchy node structure flags
+///
+typedef struct {
+  UINT32                        PhysicalPackage:1;
+  UINT32                        AcpiProcessorIdValid:1;
+  UINT32                        ProcessorIsAThread:1;
+  UINT32                        NodeIsALeaf:1;
+  UINT32                        IdenticalImplementation:1;
+  UINT32                        Reserved:27;
+} EFI_ACPI_6_3_PPTT_STRUCTURE_PROCESSOR_FLAGS;
+
+///
+/// Processor hierarchy node structure
+///
+typedef struct {
+  UINT8                                         Type;
+  UINT8                                         Length;
+  UINT8                                         Reserved[2];
+  EFI_ACPI_6_3_PPTT_STRUCTURE_PROCESSOR_FLAGS   Flags;
+  UINT32                                        Parent;
+  UINT32                                        AcpiProcessorId;
+  UINT32                                        NumberOfPrivateResources;
+} EFI_ACPI_6_3_PPTT_STRUCTURE_PROCESSOR;
+
+///
+/// For PPTT struct cache flags
+///
+#define EFI_ACPI_6_3_PPTT_CACHE_SIZE_INVALID        0x0
+#define EFI_ACPI_6_3_PPTT_CACHE_SIZE_VALID          0x1
+#define EFI_ACPI_6_3_PPTT_NUMBER_OF_SETS_INVALID    0x0
+#define EFI_ACPI_6_3_PPTT_NUMBER_OF_SETS_VALID      0x1
+#define EFI_ACPI_6_3_PPTT_ASSOCIATIVITY_INVALID     0x0
+#define EFI_ACPI_6_3_PPTT_ASSOCIATIVITY_VALID       0x1
+#define EFI_ACPI_6_3_PPTT_ALLOCATION_TYPE_INVALID   0x0
+#define EFI_ACPI_6_3_PPTT_ALLOCATION_TYPE_VALID     0x1
+#define EFI_ACPI_6_3_PPTT_CACHE_TYPE_INVALID        0x0
+#define EFI_ACPI_6_3_PPTT_CACHE_TYPE_VALID          0x1
+#define EFI_ACPI_6_3_PPTT_WRITE_POLICY_INVALID      0x0
+#define EFI_ACPI_6_3_PPTT_WRITE_POLICY_VALID        0x1
+#define EFI_ACPI_6_3_PPTT_LINE_SIZE_INVALID         0x0
+#define EFI_ACPI_6_3_PPTT_LINE_SIZE_VALID           0x1
+
+///
+/// Cache Type Structure flags
+///
+typedef struct {
+  UINT32                        SizePropertyValid:1;
+  UINT32                        NumberOfSetsValid:1;
+  UINT32                        AssociativityValid:1;
+  UINT32                        AllocationTypeValid:1;
+  UINT32                        CacheTypeValid:1;
+  UINT32                        WritePolicyValid:1;
+  UINT32                        LineSizeValid:1;
+  UINT32                        Reserved:25;
+} EFI_ACPI_6_3_PPTT_STRUCTURE_CACHE_FLAGS;
+
+///
+/// For cache attributes
+///
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_ALLOCATION_READ            0x0
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_ALLOCATION_WRITE           0x1
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_ALLOCATION_READ_WRITE      0x2
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_CACHE_TYPE_DATA            0x0
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_CACHE_TYPE_INSTRUCTION     0x1
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_CACHE_TYPE_UNIFIED         0x2
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_BACK    0x0
+#define EFI_ACPI_6_3_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_THROUGH 0x1
+
+///
+/// Cache Type Structure cache attributes
+///
+typedef struct {
+  UINT8                         AllocationType:2;
+  UINT8                         CacheType:2;
+  UINT8                         WritePolicy:1;
+  UINT8                         Reserved:3;
+} EFI_ACPI_6_3_PPTT_STRUCTURE_CACHE_ATTRIBUTES;
+
+///
+/// Cache Type Structure
+///
+typedef struct {
+  UINT8                                         Type;
+  UINT8                                         Length;
+  UINT8                                         Reserved[2];
+  EFI_ACPI_6_3_PPTT_STRUCTURE_CACHE_FLAGS       Flags;
+  UINT32                                        NextLevelOfCache;
+  UINT32                                        Size;
+  UINT32                                        NumberOfSets;
+  UINT8                                         Associativity;
+  EFI_ACPI_6_3_PPTT_STRUCTURE_CACHE_ATTRIBUTES  Attributes;
+  UINT16                                        LineSize;
+} EFI_ACPI_6_3_PPTT_STRUCTURE_CACHE;
+
+///
+/// ID structure
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Length;
+  UINT8                         Reserved[2];
+  UINT32                        VendorId;
+  UINT64                        Level1Id;
+  UINT64                        Level2Id;
+  UINT16                        MajorRev;
+  UINT16                        MinorRev;
+  UINT16                        SpinRev;
+} EFI_ACPI_6_3_PPTT_STRUCTURE_ID;
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_6_3_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_6_3_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_6_3_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "BGRT" Boot Graphics Resource Table
+///
+#define EFI_ACPI_6_3_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')
+
+///
+/// "CDIT" Component Distance Information Table
+///
+#define EFI_ACPI_6_3_COMPONENT_DISTANCE_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('C', 'D', 'I', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_6_3_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "CRAT" Component Resource Attribute Table
+///
+#define EFI_ACPI_6_3_COMPONENT_RESOURCE_ATTRIBUTE_TABLE_SIGNATURE  SIGNATURE_32('C', 'R', 'A', 'T')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_6_3_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_6_3_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_6_3_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_6_3_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_6_3_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_6_3_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FPDT" Firmware Performance Data Table
+///
+#define EFI_ACPI_6_3_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')
+
+///
+/// "GTDT" Generic Timer Description Table
+///
+#define EFI_ACPI_6_3_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_6_3_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "HMAT" Heterogeneous Memory Attribute Table
+///
+#define EFI_ACPI_6_3_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_SIGNATURE  SIGNATURE_32('H', 'M', 'A', 'T')
+
+///
+/// "MPST" Memory Power State Table
+///
+#define EFI_ACPI_6_3_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_6_3_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "NFIT" NVDIMM Firmware Interface Table
+///
+#define EFI_ACPI_6_3_NVDIMM_FIRMWARE_INTERFACE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('N', 'F', 'I', 'T')
+
+///
+/// "PDTT" Platform Debug Trigger Table
+///
+#define EFI_ACPI_6_3_PLATFORM_DEBUG_TRIGGER_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'D', 'T', 'T')
+
+///
+/// "PMTT" Platform Memory Topology Table
+///
+#define EFI_ACPI_6_3_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')
+
+///
+/// "PPTT" Processor Properties Topology Table
+///
+#define EFI_ACPI_6_3_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'P', 'T', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_6_3_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RASF" ACPI RAS Feature Table
+///
+#define EFI_ACPI_6_3_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_6_3_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_6_3_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SDEV" Secure DEVices Table
+///
+#define EFI_ACPI_6_3_SECURE_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'V')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_6_3_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_6_3_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_6_3_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_6_3_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_6_3_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CSRT" MS Core System Resource Table
+///
+#define EFI_ACPI_6_3_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')
+
+///
+/// "DBG2" MS Debug Port 2 Spec
+///
+#define EFI_ACPI_6_3_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_6_3_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_6_3_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "DPPT" DMA Protection Policy Table
+///
+#define EFI_ACPI_6_3_DMA_PROTECTION_POLICY_TABLE_SIGNATURE  SIGNATURE_32('D', 'P', 'P', 'T')
+
+///
+/// "DRTM" Dynamic Root of Trust for Measurement Table
+///
+#define EFI_ACPI_6_3_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_6_3_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_6_3_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_6_3_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IORT" I/O Remapping Table
+///
+#define EFI_ACPI_6_3_IO_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('I', 'O', 'R', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_6_3_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "LPIT" Low Power Idle Table
+///
+#define EFI_ACPI_6_3_LOW_POWER_IDLE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('L', 'P', 'I', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_6_3_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_6_3_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "MSDM" MS Data Management Table
+///
+#define EFI_ACPI_6_3_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')
+
+///
+/// "PCCT" Platform Communications Channel Table
+///
+#define EFI_ACPI_6_3_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')
+
+///
+/// "SDEI" Software Delegated Exceptions Interface Table
+///
+#define EFI_ACPI_6_3_SOFTWARE_DELEGATED_EXCEPTIONS_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'I')
+
+///
+/// "SLIC" MS Software Licensing Table Specification
+///
+#define EFI_ACPI_6_3_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')
+
+///
+/// "SPCR" Serial Port Concole Redirection Table
+///
+#define EFI_ACPI_6_3_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_6_3_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "STAO" _STA Override Table
+///
+#define EFI_ACPI_6_3_STA_OVERRIDE_TABLE_SIGNATURE  SIGNATURE_32('S', 'T', 'A', 'O')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_6_3_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "TPM2" Trusted Computing Platform 1 Table
+///
+#define EFI_ACPI_6_3_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_6_3_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Emulated Devices Table
+///
+#define EFI_ACPI_6_3_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_6_3_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_6_3_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WPBT" MS Platform Binary Table
+///
+#define EFI_ACPI_6_3_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')
+
+///
+/// "WSMT" Windows SMM Security Mitigation Table
+///
+#define EFI_ACPI_6_3_WINDOWS_SMM_SECURITY_MITIGATION_TABLE_SIGNATURE  SIGNATURE_32('W', 'S', 'M', 'T')
+
+///
+/// "XENV" Xen Project Table
+///
+#define EFI_ACPI_6_3_XEN_PROJECT_TABLE_SIGNATURE  SIGNATURE_32('X', 'E', 'N', 'V')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Acpi64.h b/libedk2_tpm/include/IndustryStandard/Acpi64.h
new file mode 100644
index 0000000..706e795
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Acpi64.h
@@ -0,0 +1,3148 @@
+/** @file
+  ACPI 6.4 definitions from the ACPI Specification Revision 6.4 Jan, 2021.
+
+  Copyright (c) 2017, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2019 - 2021, ARM Ltd. All rights reserved.<BR>
+
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef ACPI_6_4_H_
+#define ACPI_6_4_H_
+
+#include <IndustryStandard/Acpi63.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// ACPI 6.4 Generic Address Space definition
+///
+typedef struct {
+  UINT8   AddressSpaceId;
+  UINT8   RegisterBitWidth;
+  UINT8   RegisterBitOffset;
+  UINT8   AccessSize;
+  UINT64  Address;
+} EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE;
+
+//
+// Generic Address Space Address IDs
+//
+#define EFI_ACPI_6_4_SYSTEM_MEMORY                   0x00
+#define EFI_ACPI_6_4_SYSTEM_IO                       0x01
+#define EFI_ACPI_6_4_PCI_CONFIGURATION_SPACE         0x02
+#define EFI_ACPI_6_4_EMBEDDED_CONTROLLER             0x03
+#define EFI_ACPI_6_4_SMBUS                           0x04
+#define EFI_ACPI_6_4_SYSTEM_CMOS                     0x05
+#define EFI_ACPI_6_4_PCI_BAR_TARGET                  0x06
+#define EFI_ACPI_6_4_IPMI                            0x07
+#define EFI_ACPI_6_4_GENERAL_PURPOSE_IO              0x08
+#define EFI_ACPI_6_4_GENERIC_SERIAL_BUS              0x09
+#define EFI_ACPI_6_4_PLATFORM_COMMUNICATION_CHANNEL  0x0A
+#define EFI_ACPI_6_4_FUNCTIONAL_FIXED_HARDWARE       0x7F
+
+//
+// Generic Address Space Access Sizes
+//
+#define EFI_ACPI_6_4_UNDEFINED  0
+#define EFI_ACPI_6_4_BYTE       1
+#define EFI_ACPI_6_4_WORD       2
+#define EFI_ACPI_6_4_DWORD      3
+#define EFI_ACPI_6_4_QWORD      4
+
+//
+// ACPI 6.4 table structures
+//
+
+///
+/// Root System Description Pointer Structure
+///
+typedef struct {
+  UINT64  Signature;
+  UINT8   Checksum;
+  UINT8   OemId[6];
+  UINT8   Revision;
+  UINT32  RsdtAddress;
+  UINT32  Length;
+  UINT64  XsdtAddress;
+  UINT8   ExtendedChecksum;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_4_ROOT_SYSTEM_DESCRIPTION_POINTER;
+
+///
+/// RSD_PTR Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_ROOT_SYSTEM_DESCRIPTION_POINTER_REVISION 0x02  ///< ACPISpec (Revision 6.4) says current value is 2
+
+///
+/// Common table header, this prefaces all ACPI tables, including FACS, but
+/// excluding the RSD PTR structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_4_COMMON_HEADER;
+
+//
+// Root System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT32 table pointers.
+//
+
+///
+/// RSDT Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_ROOT_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+//
+// Extended System Description Table
+// No definition needed as it is a common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a variable number of UINT64 table pointers.
+//
+
+///
+/// XSDT Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_EXTENDED_SYSTEM_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Fixed ACPI Description Table Structure (FADT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  FirmwareCtrl;
+  UINT32                                  Dsdt;
+  UINT8                                   Reserved0;
+  UINT8                                   PreferredPmProfile;
+  UINT16                                  SciInt;
+  UINT32                                  SmiCmd;
+  UINT8                                   AcpiEnable;
+  UINT8                                   AcpiDisable;
+  UINT8                                   S4BiosReq;
+  UINT8                                   PstateCnt;
+  UINT32                                  Pm1aEvtBlk;
+  UINT32                                  Pm1bEvtBlk;
+  UINT32                                  Pm1aCntBlk;
+  UINT32                                  Pm1bCntBlk;
+  UINT32                                  Pm2CntBlk;
+  UINT32                                  PmTmrBlk;
+  UINT32                                  Gpe0Blk;
+  UINT32                                  Gpe1Blk;
+  UINT8                                   Pm1EvtLen;
+  UINT8                                   Pm1CntLen;
+  UINT8                                   Pm2CntLen;
+  UINT8                                   PmTmrLen;
+  UINT8                                   Gpe0BlkLen;
+  UINT8                                   Gpe1BlkLen;
+  UINT8                                   Gpe1Base;
+  UINT8                                   CstCnt;
+  UINT16                                  PLvl2Lat;
+  UINT16                                  PLvl3Lat;
+  UINT16                                  FlushSize;
+  UINT16                                  FlushStride;
+  UINT8                                   DutyOffset;
+  UINT8                                   DutyWidth;
+  UINT8                                   DayAlrm;
+  UINT8                                   MonAlrm;
+  UINT8                                   Century;
+  UINT16                                  IaPcBootArch;
+  UINT8                                   Reserved1;
+  UINT32                                  Flags;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  ResetReg;
+  UINT8                                   ResetValue;
+  UINT16                                  ArmBootArch;
+  UINT8                                   MinorVersion;
+  UINT64                                  XFirmwareCtrl;
+  UINT64                                  XDsdt;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XPm1aEvtBlk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XPm1bEvtBlk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XPm1aCntBlk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XPm1bCntBlk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XPm2CntBlk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XPmTmrBlk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XGpe0Blk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  XGpe1Blk;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  SleepControlReg;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  SleepStatusReg;
+  UINT64                                  HypervisorVendorIdentity;
+} EFI_ACPI_6_4_FIXED_ACPI_DESCRIPTION_TABLE;
+
+///
+/// FADT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_FIXED_ACPI_DESCRIPTION_TABLE_REVISION  0x06
+#define EFI_ACPI_6_4_FIXED_ACPI_DESCRIPTION_TABLE_MINOR_REVISION  0x04
+
+//
+// Fixed ACPI Description Table Preferred Power Management Profile
+//
+#define EFI_ACPI_6_4_PM_PROFILE_UNSPECIFIED         0
+#define EFI_ACPI_6_4_PM_PROFILE_DESKTOP             1
+#define EFI_ACPI_6_4_PM_PROFILE_MOBILE              2
+#define EFI_ACPI_6_4_PM_PROFILE_WORKSTATION         3
+#define EFI_ACPI_6_4_PM_PROFILE_ENTERPRISE_SERVER   4
+#define EFI_ACPI_6_4_PM_PROFILE_SOHO_SERVER         5
+#define EFI_ACPI_6_4_PM_PROFILE_APPLIANCE_PC        6
+#define EFI_ACPI_6_4_PM_PROFILE_PERFORMANCE_SERVER  7
+#define EFI_ACPI_6_4_PM_PROFILE_TABLET              8
+
+//
+// Fixed ACPI Description Table Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_4_LEGACY_DEVICES              BIT0
+#define EFI_ACPI_6_4_8042                        BIT1
+#define EFI_ACPI_6_4_VGA_NOT_PRESENT             BIT2
+#define EFI_ACPI_6_4_MSI_NOT_SUPPORTED           BIT3
+#define EFI_ACPI_6_4_PCIE_ASPM_CONTROLS          BIT4
+#define EFI_ACPI_6_4_CMOS_RTC_NOT_PRESENT        BIT5
+
+//
+// Fixed ACPI Description Table Arm Boot Architecture Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_4_ARM_PSCI_COMPLIANT              BIT0
+#define EFI_ACPI_6_4_ARM_PSCI_USE_HVC                BIT1
+
+//
+// Fixed ACPI Description Table Fixed Feature Flags
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_4_WBINVD                                 BIT0
+#define EFI_ACPI_6_4_WBINVD_FLUSH                           BIT1
+#define EFI_ACPI_6_4_PROC_C1                                BIT2
+#define EFI_ACPI_6_4_P_LVL2_UP                              BIT3
+#define EFI_ACPI_6_4_PWR_BUTTON                             BIT4
+#define EFI_ACPI_6_4_SLP_BUTTON                             BIT5
+#define EFI_ACPI_6_4_FIX_RTC                                BIT6
+#define EFI_ACPI_6_4_RTC_S4                                 BIT7
+#define EFI_ACPI_6_4_TMR_VAL_EXT                            BIT8
+#define EFI_ACPI_6_4_DCK_CAP                                BIT9
+#define EFI_ACPI_6_4_RESET_REG_SUP                          BIT10
+#define EFI_ACPI_6_4_SEALED_CASE                            BIT11
+#define EFI_ACPI_6_4_HEADLESS                               BIT12
+#define EFI_ACPI_6_4_CPU_SW_SLP                             BIT13
+#define EFI_ACPI_6_4_PCI_EXP_WAK                            BIT14
+#define EFI_ACPI_6_4_USE_PLATFORM_CLOCK                     BIT15
+#define EFI_ACPI_6_4_S4_RTC_STS_VALID                       BIT16
+#define EFI_ACPI_6_4_REMOTE_POWER_ON_CAPABLE                BIT17
+#define EFI_ACPI_6_4_FORCE_APIC_CLUSTER_MODEL               BIT18
+#define EFI_ACPI_6_4_FORCE_APIC_PHYSICAL_DESTINATION_MODE   BIT19
+#define EFI_ACPI_6_4_HW_REDUCED_ACPI                        BIT20
+#define EFI_ACPI_6_4_LOW_POWER_S0_IDLE_CAPABLE              BIT21
+
+///
+/// Firmware ACPI Control Structure
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+  UINT32  HardwareSignature;
+  UINT32  FirmwareWakingVector;
+  UINT32  GlobalLock;
+  UINT32  Flags;
+  UINT64  XFirmwareWakingVector;
+  UINT8   Version;
+  UINT8   Reserved0[3];
+  UINT32  OspmFlags;
+  UINT8   Reserved1[24];
+} EFI_ACPI_6_4_FIRMWARE_ACPI_CONTROL_STRUCTURE;
+
+///
+/// FACS Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_FIRMWARE_ACPI_CONTROL_STRUCTURE_VERSION  0x02
+
+///
+/// Firmware Control Structure Feature Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_4_S4BIOS_F                     BIT0
+#define EFI_ACPI_6_4_64BIT_WAKE_SUPPORTED_F       BIT1
+
+///
+/// OSPM Enabled Firmware Control Structure Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_4_OSPM_64BIT_WAKE_F            BIT0
+
+//
+// Differentiated System Description Table,
+// Secondary System Description Table
+// and Persistent System Description Table,
+// no definition needed as they are common description table header, the same with
+// EFI_ACPI_DESCRIPTION_HEADER, followed by a definition block.
+//
+#define EFI_ACPI_6_4_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_REVISION   0x02
+#define EFI_ACPI_6_4_SECONDARY_SYSTEM_DESCRIPTION_TABLE_REVISION        0x02
+
+///
+/// Multiple APIC Description Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      LocalApicAddress;
+  UINT32                      Flags;
+} EFI_ACPI_6_4_MULTIPLE_APIC_DESCRIPTION_TABLE_HEADER;
+
+///
+/// MADT Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_MULTIPLE_APIC_DESCRIPTION_TABLE_REVISION 0x05
+
+///
+/// Multiple APIC Flags
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_4_PCAT_COMPAT         BIT0
+
+//
+// Multiple APIC Description Table APIC structure types
+// All other values between 0x10 and 0x7F are reserved and
+// will be ignored by OSPM. 0x80 ~ 0xFF are reserved for OEM.
+//
+#define EFI_ACPI_6_4_PROCESSOR_LOCAL_APIC           0x00
+#define EFI_ACPI_6_4_IO_APIC                        0x01
+#define EFI_ACPI_6_4_INTERRUPT_SOURCE_OVERRIDE      0x02
+#define EFI_ACPI_6_4_NON_MASKABLE_INTERRUPT_SOURCE  0x03
+#define EFI_ACPI_6_4_LOCAL_APIC_NMI                 0x04
+#define EFI_ACPI_6_4_LOCAL_APIC_ADDRESS_OVERRIDE    0x05
+#define EFI_ACPI_6_4_IO_SAPIC                       0x06
+#define EFI_ACPI_6_4_LOCAL_SAPIC                    0x07
+#define EFI_ACPI_6_4_PLATFORM_INTERRUPT_SOURCES     0x08
+#define EFI_ACPI_6_4_PROCESSOR_LOCAL_X2APIC         0x09
+#define EFI_ACPI_6_4_LOCAL_X2APIC_NMI               0x0A
+#define EFI_ACPI_6_4_GIC                            0x0B
+#define EFI_ACPI_6_4_GICD                           0x0C
+#define EFI_ACPI_6_4_GIC_MSI_FRAME                  0x0D
+#define EFI_ACPI_6_4_GICR                           0x0E
+#define EFI_ACPI_6_4_GIC_ITS                        0x0F
+#define EFI_ACPI_6_4_MULTIPROCESSOR_WAKEUP          0x10
+
+//
+// APIC Structure Definitions
+//
+
+///
+/// Processor Local APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT8   ApicId;
+  UINT32  Flags;
+} EFI_ACPI_6_4_PROCESSOR_LOCAL_APIC_STRUCTURE;
+
+///
+/// Local APIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_LOCAL_APIC_ENABLED         BIT0
+#define EFI_ACPI_6_4_LOCAL_APIC_ONLINE_CAPABLE  BIT1
+
+///
+/// IO APIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  IoApicAddress;
+  UINT32  GlobalSystemInterruptBase;
+} EFI_ACPI_6_4_IO_APIC_STRUCTURE;
+
+///
+/// Interrupt Source Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Bus;
+  UINT8   Source;
+  UINT32  GlobalSystemInterrupt;
+  UINT16  Flags;
+} EFI_ACPI_6_4_INTERRUPT_SOURCE_OVERRIDE_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+  UINT8   CpeiProcessorOverride;
+  UINT8   Reserved[31];
+} EFI_ACPI_6_4_PLATFORM_INTERRUPT_APIC_STRUCTURE;
+
+//
+// MPS INTI flags.
+// All other bits are reserved and must be set to 0.
+//
+#define EFI_ACPI_6_4_POLARITY      (3 << 0)
+#define EFI_ACPI_6_4_TRIGGER_MODE  (3 << 2)
+
+///
+/// Non-Maskable Interrupt Source Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  GlobalSystemInterrupt;
+} EFI_ACPI_6_4_NON_MASKABLE_INTERRUPT_SOURCE_STRUCTURE;
+
+///
+/// Local APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorUid;
+  UINT16  Flags;
+  UINT8   LocalApicLint;
+} EFI_ACPI_6_4_LOCAL_APIC_NMI_STRUCTURE;
+
+///
+/// Local APIC Address Override Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  LocalApicAddress;
+} EFI_ACPI_6_4_LOCAL_APIC_ADDRESS_OVERRIDE_STRUCTURE;
+
+///
+/// IO SAPIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   IoApicId;
+  UINT8   Reserved;
+  UINT32  GlobalSystemInterruptBase;
+  UINT64  IoSapicAddress;
+} EFI_ACPI_6_4_IO_SAPIC_STRUCTURE;
+
+///
+/// Local SAPIC Structure
+/// This struct followed by a null-terminated ASCII string - ACPI Processor UID String
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   AcpiProcessorId;
+  UINT8   LocalSapicId;
+  UINT8   LocalSapicEid;
+  UINT8   Reserved[3];
+  UINT32  Flags;
+  UINT32  ACPIProcessorUIDValue;
+} EFI_ACPI_6_4_PROCESSOR_LOCAL_SAPIC_STRUCTURE;
+
+///
+/// Platform Interrupt Sources Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT8   InterruptType;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT8   IoSapicVector;
+  UINT32  GlobalSystemInterrupt;
+  UINT32  PlatformInterruptSourceFlags;
+} EFI_ACPI_6_4_PLATFORM_INTERRUPT_SOURCES_STRUCTURE;
+
+///
+/// Platform Interrupt Source Flags.
+/// All other bits are reserved and must be set to 0.
+///
+#define EFI_ACPI_6_4_CPEI_PROCESSOR_OVERRIDE          BIT0
+
+///
+/// Processor Local x2APIC Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved[2];
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  AcpiProcessorUid;
+} EFI_ACPI_6_4_PROCESSOR_LOCAL_X2APIC_STRUCTURE;
+
+///
+/// Local x2APIC NMI Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Flags;
+  UINT32  AcpiProcessorUid;
+  UINT8   LocalX2ApicLint;
+  UINT8   Reserved[3];
+} EFI_ACPI_6_4_LOCAL_X2APIC_NMI_STRUCTURE;
+
+///
+/// GIC Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  CPUInterfaceNumber;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ParkingProtocolVersion;
+  UINT32  PerformanceInterruptGsiv;
+  UINT64  ParkedAddress;
+  UINT64  PhysicalBaseAddress;
+  UINT64  GICV;
+  UINT64  GICH;
+  UINT32  VGICMaintenanceInterrupt;
+  UINT64  GICRBaseAddress;
+  UINT64  MPIDR;
+  UINT8   ProcessorPowerEfficiencyClass;
+  UINT8   Reserved2;
+  UINT16  SpeOverflowInterrupt;
+} EFI_ACPI_6_4_GIC_STRUCTURE;
+
+///
+/// GIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_GIC_ENABLED                              BIT0
+#define EFI_ACPI_6_4_PERFORMANCE_INTERRUPT_MODEL              BIT1
+#define EFI_ACPI_6_4_VGIC_MAINTENANCE_INTERRUPT_MODE_FLAGS    BIT2
+
+///
+/// GIC Distributor Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  SystemVectorBase;
+  UINT8   GicVersion;
+  UINT8   Reserved2[3];
+} EFI_ACPI_6_4_GIC_DISTRIBUTOR_STRUCTURE;
+
+///
+/// GIC Version
+///
+#define EFI_ACPI_6_4_GIC_V1                                   0x01
+#define EFI_ACPI_6_4_GIC_V2                                   0x02
+#define EFI_ACPI_6_4_GIC_V3                                   0x03
+#define EFI_ACPI_6_4_GIC_V4                                   0x04
+
+///
+/// GIC MSI Frame Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved1;
+  UINT32  GicMsiFrameId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Flags;
+  UINT16  SPICount;
+  UINT16  SPIBase;
+} EFI_ACPI_6_4_GIC_MSI_FRAME_STRUCTURE;
+
+///
+/// GIC MSI Frame Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_SPI_COUNT_BASE_SELECT                    BIT0
+
+///
+/// GICR Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT64  DiscoveryRangeBaseAddress;
+  UINT32  DiscoveryRangeLength;
+} EFI_ACPI_6_4_GICR_STRUCTURE;
+
+///
+/// GIC Interrupt Translation Service Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  Reserved;
+  UINT32  GicItsId;
+  UINT64  PhysicalBaseAddress;
+  UINT32  Reserved2;
+} EFI_ACPI_6_4_GIC_ITS_STRUCTURE;
+
+///
+/// Multiprocessor Wakeup Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT16  MailBoxVersion;
+  UINT32  Reserved;
+  UINT64  MailBoxAddress;
+} EFI_ACPI_6_4_MULTIPROCESSOR_WAKEUP_STRUCTURE;
+
+///
+/// Multiprocessor Wakeup Mailbox Structure
+///
+typedef struct {
+  UINT16  Command;
+  UINT16  Reserved;
+  UINT32  AcpiId;
+  UINT64  WakeupVector;
+  UINT8   ReservedForOs[2032];
+  UINT8   ReservedForFirmware[2048];
+} EFI_ACPI_6_4_MULTIPROCESSOR_WAKEUP_MAILBOX_STRUCTURE;
+
+#define EFI_ACPI_6_4_MULTIPROCESSOR_WAKEUP_MAILBOX_COMMAND_NOOP     0x0000
+#define EFI_ACPI_6_4_MULTIPROCESSOR_WAKEUP_MAILBOX_COMMAND_WAKEUP   0x0001
+
+///
+/// Smart Battery Description Table (SBST)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      WarningEnergyLevel;
+  UINT32                      LowEnergyLevel;
+  UINT32                      CriticalEnergyLevel;
+} EFI_ACPI_6_4_SMART_BATTERY_DESCRIPTION_TABLE;
+
+///
+/// SBST Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_SMART_BATTERY_DESCRIPTION_TABLE_REVISION 0x01
+
+///
+/// Embedded Controller Boot Resources Table (ECDT)
+/// The table is followed by a null terminated ASCII string that contains
+/// a fully qualified reference to the name space object.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  EcControl;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  EcData;
+  UINT32                                  Uid;
+  UINT8                                   GpeBit;
+} EFI_ACPI_6_4_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE;
+
+///
+/// ECDT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_REVISION  0x01
+
+///
+/// System Resource Affinity Table (SRAT).  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Reserved1;  ///< Must be set to 1
+  UINT64                      Reserved2;
+} EFI_ACPI_6_4_SYSTEM_RESOURCE_AFFINITY_TABLE_HEADER;
+
+///
+/// SRAT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_SYSTEM_RESOURCE_AFFINITY_TABLE_REVISION  0x03
+
+//
+// SRAT structure types.
+// All other values between 0x06 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_6_4_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY  0x00
+#define EFI_ACPI_6_4_MEMORY_AFFINITY                      0x01
+#define EFI_ACPI_6_4_PROCESSOR_LOCAL_X2APIC_AFFINITY      0x02
+#define EFI_ACPI_6_4_GICC_AFFINITY                        0x03
+#define EFI_ACPI_6_4_GIC_ITS_AFFINITY                     0x04
+#define EFI_ACPI_6_4_GENERIC_INITIATOR_AFFINITY           0x05
+
+///
+/// Processor Local APIC/SAPIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProximityDomain7To0;
+  UINT8   ApicId;
+  UINT32  Flags;
+  UINT8   LocalSapicEid;
+  UINT8   ProximityDomain31To8[3];
+  UINT32  ClockDomain;
+} EFI_ACPI_6_4_PROCESSOR_LOCAL_APIC_SAPIC_AFFINITY_STRUCTURE;
+
+///
+/// Local APIC/SAPIC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_PROCESSOR_LOCAL_APIC_SAPIC_ENABLED (1 << 0)
+
+///
+/// Memory Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT16  Reserved1;
+  UINT32  AddressBaseLow;
+  UINT32  AddressBaseHigh;
+  UINT32  LengthLow;
+  UINT32  LengthHigh;
+  UINT32  Reserved2;
+  UINT32  Flags;
+  UINT64  Reserved3;
+} EFI_ACPI_6_4_MEMORY_AFFINITY_STRUCTURE;
+
+//
+// Memory Flags.  All other bits are reserved and must be 0.
+//
+#define EFI_ACPI_6_4_MEMORY_ENABLED       (1 << 0)
+#define EFI_ACPI_6_4_MEMORY_HOT_PLUGGABLE (1 << 1)
+#define EFI_ACPI_6_4_MEMORY_NONVOLATILE   (1 << 2)
+
+///
+/// Processor Local x2APIC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   Reserved1[2];
+  UINT32  ProximityDomain;
+  UINT32  X2ApicId;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+  UINT8   Reserved2[4];
+} EFI_ACPI_6_4_PROCESSOR_LOCAL_X2APIC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT32  AcpiProcessorUid;
+  UINT32  Flags;
+  UINT32  ClockDomain;
+} EFI_ACPI_6_4_GICC_AFFINITY_STRUCTURE;
+
+///
+/// GICC Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_GICC_ENABLED (1 << 0)
+
+///
+/// GIC Interrupt Translation Service (ITS) Affinity Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT32  ProximityDomain;
+  UINT8   Reserved[2];
+  UINT32  ItsId;
+} EFI_ACPI_6_4_GIC_ITS_AFFINITY_STRUCTURE;
+
+//
+// Generic Initiator Affinity Structure Device Handle Types
+// All other values between 0x02 an 0xFF are reserved and
+// will be ignored by OSPM.
+//
+#define EFI_ACPI_6_4_ACPI_DEVICE_HANDLE     0x00
+#define EFI_ACPI_6_4_PCI_DEVICE_HANDLE      0x01
+
+///
+/// Device Handle - ACPI
+///
+typedef struct {
+  UINT64  AcpiHid;
+  UINT32  AcpiUid;
+  UINT8   Reserved[4];
+} EFI_ACPI_6_4_DEVICE_HANDLE_ACPI;
+
+///
+/// Device Handle - PCI
+///
+typedef struct {
+  UINT16  PciSegment;
+  UINT16  PciBdfNumber;
+  UINT8   Reserved[12];
+} EFI_ACPI_6_4_DEVICE_HANDLE_PCI;
+
+///
+/// Device Handle
+///
+typedef union {
+    EFI_ACPI_6_4_DEVICE_HANDLE_ACPI   Acpi;
+    EFI_ACPI_6_4_DEVICE_HANDLE_PCI    Pci;
+} EFI_ACPI_6_4_DEVICE_HANDLE;
+
+///
+/// Generic Initiator Affinity Structure
+///
+typedef struct {
+  UINT8                       Type;
+  UINT8                       Length;
+  UINT8                       Reserved1;
+  UINT8                       DeviceHandleType;
+  UINT32                      ProximityDomain;
+  EFI_ACPI_6_4_DEVICE_HANDLE  DeviceHandle;
+  UINT32                      Flags;
+  UINT8                       Reserved2[4];
+} EFI_ACPI_6_4_GENERIC_INITIATOR_AFFINITY_STRUCTURE;
+
+///
+/// Generic Initiator Affinity Structure Flags. All other bits are reserved
+/// and must be 0.
+///
+#define EFI_ACPI_6_4_GENERIC_INITIATOR_AFFINITY_STRUCTURE_ENABLED                     BIT0
+#define EFI_ACPI_6_4_GENERIC_INITIATOR_AFFINITY_STRUCTURE_ARCHITECTURAL_TRANSACTIONS  BIT1
+
+///
+/// System Locality Distance Information Table (SLIT).
+/// The rest of the table is a matrix.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      NumberOfSystemLocalities;
+} EFI_ACPI_6_4_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_HEADER;
+
+///
+/// SLIT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_SYSTEM_LOCALITY_DISTANCE_INFORMATION_TABLE_REVISION  0x01
+
+///
+/// Corrected Platform Error Polling Table (CPEP)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[8];
+} EFI_ACPI_6_4_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_HEADER;
+
+///
+/// CPEP Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_REVISION 0x01
+
+//
+// CPEP processor structure types.
+//
+#define EFI_ACPI_6_4_CPEP_PROCESSOR_APIC_SAPIC  0x00
+
+///
+/// Corrected Platform Error Polling Processor Structure Definition
+///
+typedef struct {
+  UINT8   Type;
+  UINT8   Length;
+  UINT8   ProcessorId;
+  UINT8   ProcessorEid;
+  UINT32  PollingInterval;
+} EFI_ACPI_6_4_CPEP_PROCESSOR_APIC_SAPIC_STRUCTURE;
+
+///
+/// Maximum System Characteristics Table (MSCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      OffsetProxDomInfo;
+  UINT32                      MaximumNumberOfProximityDomains;
+  UINT32                      MaximumNumberOfClockDomains;
+  UINT64                      MaximumPhysicalAddress;
+} EFI_ACPI_6_4_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_HEADER;
+
+///
+/// MSCT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_REVISION 0x01
+
+///
+/// Maximum Proximity Domain Information Structure Definition
+///
+typedef struct {
+  UINT8   Revision;
+  UINT8   Length;
+  UINT32  ProximityDomainRangeLow;
+  UINT32  ProximityDomainRangeHigh;
+  UINT32  MaximumProcessorCapacity;
+  UINT64  MaximumMemoryCapacity;
+} EFI_ACPI_6_4_MAXIMUM_PROXIMITY_DOMAIN_INFORMATION_STRUCTURE;
+
+///
+/// ACPI RAS Feature Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier[12];
+} EFI_ACPI_6_4_RAS_FEATURE_TABLE;
+
+///
+/// RASF Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_RAS_FEATURE_TABLE_REVISION 0x01
+
+///
+/// ACPI RASF Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT16                      Version;
+  UINT8                       RASCapabilities[16];
+  UINT8                       SetRASCapabilities[16];
+  UINT16                      NumberOfRASFParameterBlocks;
+  UINT32                      SetRASCapabilitiesStatus;
+} EFI_ACPI_6_4_RASF_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI RASF PCC command code
+///
+#define EFI_ACPI_6_4_RASF_PCC_COMMAND_CODE_EXECUTE_RASF_COMMAND  0x01
+
+///
+/// ACPI RASF Platform RAS Capabilities
+///
+#define EFI_ACPI_6_4_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED                         BIT0
+#define EFI_ACPI_6_4_RASF_PLATFORM_RAS_CAPABILITY_HARDWARE_BASED_PATROL_SCRUB_SUPPORTED_AND_EXPOSED_TO_SOFTWARE BIT1
+#define EFI_ACPI_6_4_RASF_PLATFORM_RAS_CAPABILITY_CPU_CACHE_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS            BIT2
+#define EFI_ACPI_6_4_RASF_PLATFORM_RAS_CAPABILITY_MEMORY_CONTROLLER_FLUSH_TO_NVDIMM_DURABILITY_ON_POWER_LOSS    BIT3
+#define EFI_ACPI_6_4_RASF_PLATFORM_RAS_CAPABILITY_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_HARDWARE_MIRRORING         BIT4
+
+///
+/// ACPI RASF Parameter Block structure for PATROL_SCRUB
+///
+typedef struct {
+  UINT16                      Type;
+  UINT16                      Version;
+  UINT16                      Length;
+  UINT16                      PatrolScrubCommand;
+  UINT64                      RequestedAddressRange[2];
+  UINT64                      ActualAddressRange[2];
+  UINT16                      Flags;
+  UINT8                       RequestedSpeed;
+} EFI_ACPI_6_4_RASF_PATROL_SCRUB_PLATFORM_BLOCK_STRUCTURE;
+
+///
+/// ACPI RASF Patrol Scrub command
+///
+#define EFI_ACPI_6_4_RASF_PATROL_SCRUB_COMMAND_GET_PATROL_PARAMETERS   0x01
+#define EFI_ACPI_6_4_RASF_PATROL_SCRUB_COMMAND_START_PATROL_SCRUBBER   0x02
+#define EFI_ACPI_6_4_RASF_PATROL_SCRUB_COMMAND_STOP_PATROL_SCRUBBER    0x03
+
+///
+/// Memory Power State Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       PlatformCommunicationChannelIdentifier;
+  UINT8                       Reserved[3];
+// Memory Power Node Structure
+// Memory Power State Characteristics
+} EFI_ACPI_6_4_MEMORY_POWER_STATUS_TABLE;
+
+///
+/// MPST Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_MEMORY_POWER_STATE_TABLE_REVISION 0x01
+
+///
+/// MPST Platform Communication Channel Shared Memory Region definition.
+///
+typedef struct {
+  UINT32                      Signature;
+  UINT16                      Command;
+  UINT16                      Status;
+  UINT32                      MemoryPowerCommandRegister;
+  UINT32                      MemoryPowerStatusRegister;
+  UINT32                      PowerStateId;
+  UINT32                      MemoryPowerNodeId;
+  UINT64                      MemoryEnergyConsumed;
+  UINT64                      ExpectedAveragePowerComsuned;
+} EFI_ACPI_6_4_MPST_PLATFORM_COMMUNICATION_CHANNEL_SHARED_MEMORY_REGION;
+
+///
+/// ACPI MPST PCC command code
+///
+#define EFI_ACPI_6_4_MPST_PCC_COMMAND_CODE_EXECUTE_MPST_COMMAND  0x03
+
+///
+/// ACPI MPST Memory Power command
+///
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_POWER_STATE       0x01
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_COMMAND_SET_MEMORY_POWER_STATE       0x02
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_COMMAND_GET_AVERAGE_POWER_CONSUMED   0x03
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_COMMAND_GET_MEMORY_ENERGY_CONSUMED   0x04
+
+///
+/// MPST Memory Power Node Table
+///
+typedef struct {
+  UINT8                                             PowerStateValue;
+  UINT8                                             PowerStateInformationIndex;
+} EFI_ACPI_6_4_MPST_MEMORY_POWER_STATE;
+
+typedef struct {
+  UINT8                                             Flag;
+  UINT8                                             Reserved;
+  UINT16                                            MemoryPowerNodeId;
+  UINT32                                            Length;
+  UINT64                                            AddressBase;
+  UINT64                                            AddressLength;
+  UINT32                                            NumberOfPowerStates;
+  UINT32                                            NumberOfPhysicalComponents;
+//EFI_ACPI_6_4_MPST_MEMORY_POWER_STATE              MemoryPowerState[NumberOfPowerStates];
+//UINT16                                            PhysicalComponentIdentifier[NumberOfPhysicalComponents];
+} EFI_ACPI_6_4_MPST_MEMORY_POWER_STRUCTURE;
+
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_STRUCTURE_FLAG_ENABLE          0x01
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_STRUCTURE_FLAG_POWER_MANAGED   0x02
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_STRUCTURE_FLAG_HOT_PLUGGABLE   0x04
+
+typedef struct {
+  UINT16                      MemoryPowerNodeCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_4_MPST_MEMORY_POWER_NODE_TABLE;
+
+///
+/// MPST Memory Power State Characteristics Table
+///
+typedef struct {
+  UINT8                                             PowerStateStructureID;
+  UINT8                                             Flag;
+  UINT16                                            Reserved;
+  UINT32                                            AveragePowerConsumedInMPS0;
+  UINT32                                            RelativePowerSavingToMPS0;
+  UINT64                                            ExitLatencyToMPS0;
+} EFI_ACPI_6_4_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE;
+
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_MEMORY_CONTENT_PRESERVED              0x01
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_ENTRY   0x02
+#define EFI_ACPI_6_4_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_STRUCTURE_FLAG_AUTONOMOUS_MEMORY_POWER_STATE_EXIT    0x04
+
+typedef struct {
+  UINT16                      MemoryPowerStateCharacteristicsCount;
+  UINT8                       Reserved[2];
+} EFI_ACPI_6_4_MPST_MEMORY_POWER_STATE_CHARACTERISTICS_TABLE;
+
+///
+/// Platform Memory Topology Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  NumberOfMemoryDevices;
+//EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[NumberOfMemoryDevices];
+} EFI_ACPI_6_4_PLATFORM_MEMORY_TOPOLOGY_TABLE;
+
+///
+/// PMTT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_MEMORY_TOPOLOGY_TABLE_REVISION 0x02
+
+///
+/// Common Memory Device.
+///
+typedef struct {
+  UINT8                                   Type;
+  UINT8                                   Reserved;
+  UINT16                                  Length;
+  UINT16                                  Flags;
+  UINT16                                  Reserved1;
+  UINT32                                  NumberOfMemoryDevices;
+//UINT8                                   TypeSpecificData[];
+//EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[NumberOfMemoryDevices];
+} EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE;
+
+///
+/// Memory Device Type.
+///
+#define EFI_ACPI_6_4_PMTT_MEMORY_DEVICE_TYPE_SOCKET               0x0
+#define EFI_ACPI_6_4_PMTT_MEMORY_DEVICE_TYPE_MEMORY_CONTROLLER    0x1
+#define EFI_ACPI_6_4_PMTT_MEMORY_DEVICE_TYPE_DIMM                 0x2
+#define EFI_ACPI_6_4_PMTT_MEMORY_DEVICE_TYPE_VENDOR_SPECIFIC_TYPE 0xFF
+
+///
+/// Socket Type Data.
+///
+typedef struct {
+  EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE  CommonMemoryDeviceHeader;
+  UINT16                                  SocketIdentifier;
+  UINT16                                  Reserved;
+//EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[];
+} EFI_ACPI_6_4_PMTT_SOCKET_TYPE_DATA;
+
+///
+/// Memory Controller Type Data.
+///
+typedef struct {
+  EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE  CommonMemoryDeviceHeader;
+  UINT16                                  MemoryControllerIdentifier;
+  UINT16                                  Reserved;
+//EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE  MemoryDeviceStructure[];
+} EFI_ACPI_6_4_PMTT_MEMORY_CONTROLLER_TYPE_DATA;
+
+///
+/// DIMM Type Specific Data.
+///
+typedef struct {
+  EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE  CommonMemoryDeviceHeader;
+  UINT32                                  SmbiosHandle;
+} EFI_ACPI_6_4_PMTT_DIMM_TYPE_SPECIFIC_DATA;
+
+///
+/// Vendor Specific Type Data.
+///
+typedef struct {
+  EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE        CommonMemoryDeviceHeader;
+  UINT8                                         TypeUuid[16];
+//EFI_ACPI_6_4_PMTT_VENDOR_SPECIFIC_TYPE_DATA   VendorSpecificData[];
+//EFI_ACPI_6_4_PMTT_COMMON_MEMORY_DEVICE        MemoryDeviceStructure[];
+} EFI_ACPI_6_4_PMTT_VENDOR_SPECIFIC_TYPE_DATA;
+
+///
+/// Boot Graphics Resource Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  ///
+  /// 2-bytes (16 bit) version ID. This value must be 1.
+  ///
+  UINT16                      Version;
+  ///
+  /// 1-byte status field indicating current status about the table.
+  ///     Bits[7:3] = Reserved (must be zero)
+  ///     Bits[2:1] = Orientation Offset. These bits describe the clockwise
+  ///                 degree offset from the image's default orientation.
+  ///                 [00] = 0, no offset
+  ///                 [01] = 90
+  ///                 [10] = 180
+  ///                 [11] = 270
+  ///     Bit [0] = Displayed. A one indicates the boot image graphic is
+  ///               displayed.
+  ///
+  UINT8                       Status;
+  ///
+  /// 1-byte enumerated type field indicating format of the image.
+  ///     0 = Bitmap
+  ///     1 - 255  Reserved (for future use)
+  ///
+  UINT8                       ImageType;
+  ///
+  /// 8-byte (64 bit) physical address pointing to the firmware's in-memory copy
+  /// of the image bitmap.
+  ///
+  UINT64                      ImageAddress;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display X-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetX;
+  ///
+  /// A 4-byte (32-bit) unsigned long describing the display Y-offset of the boot image.
+  /// (X, Y) display offset of the top left corner of the boot image.
+  /// The top left corner of the display is at offset (0, 0).
+  ///
+  UINT32                      ImageOffsetY;
+} EFI_ACPI_6_4_BOOT_GRAPHICS_RESOURCE_TABLE;
+
+///
+/// BGRT Revision
+///
+#define EFI_ACPI_6_4_BOOT_GRAPHICS_RESOURCE_TABLE_REVISION 1
+
+///
+/// BGRT Version
+///
+#define EFI_ACPI_6_4_BGRT_VERSION         0x01
+
+///
+/// BGRT Status
+///
+#define EFI_ACPI_6_4_BGRT_STATUS_NOT_DISPLAYED 0x00
+#define EFI_ACPI_6_4_BGRT_STATUS_DISPLAYED     0x01
+
+///
+/// BGRT Image Type
+///
+#define EFI_ACPI_6_4_BGRT_IMAGE_TYPE_BMP  0x00
+
+///
+/// FPDT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_FIRMWARE_PERFORMANCE_DATA_TABLE_REVISION 0x01
+
+///
+/// FPDT Performance Record Types
+///
+#define EFI_ACPI_6_4_FPDT_RECORD_TYPE_FIRMWARE_BASIC_BOOT_POINTER      0x0000
+#define EFI_ACPI_6_4_FPDT_RECORD_TYPE_S3_PERFORMANCE_TABLE_POINTER     0x0001
+
+///
+/// FPDT Performance Record Revision
+///
+#define EFI_ACPI_6_4_FPDT_RECORD_REVISION_FIRMWARE_BASIC_BOOT_POINTER  0x01
+#define EFI_ACPI_6_4_FPDT_RECORD_REVISION_S3_PERFORMANCE_TABLE_POINTER 0x01
+
+///
+/// FPDT Runtime Performance Record Types
+///
+#define EFI_ACPI_6_4_FPDT_RUNTIME_RECORD_TYPE_S3_RESUME                0x0000
+#define EFI_ACPI_6_4_FPDT_RUNTIME_RECORD_TYPE_S3_SUSPEND               0x0001
+#define EFI_ACPI_6_4_FPDT_RUNTIME_RECORD_TYPE_FIRMWARE_BASIC_BOOT      0x0002
+
+///
+/// FPDT Runtime Performance Record Revision
+///
+#define EFI_ACPI_6_4_FPDT_RUNTIME_RECORD_REVISION_S3_RESUME            0x01
+#define EFI_ACPI_6_4_FPDT_RUNTIME_RECORD_REVISION_S3_SUSPEND           0x01
+#define EFI_ACPI_6_4_FPDT_RUNTIME_RECORD_REVISION_FIRMWARE_BASIC_BOOT  0x02
+
+///
+/// FPDT Performance Record header
+///
+typedef struct {
+  UINT16           Type;
+  UINT8            Length;
+  UINT8            Revision;
+} EFI_ACPI_6_4_FPDT_PERFORMANCE_RECORD_HEADER;
+
+///
+/// FPDT Performance Table header
+///
+typedef struct {
+  UINT32  Signature;
+  UINT32  Length;
+} EFI_ACPI_6_4_FPDT_PERFORMANCE_TABLE_HEADER;
+
+///
+/// FPDT Firmware Basic Boot Performance Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_4_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the Basic Boot Performance Table.
+  ///
+  UINT64                                          BootPerformanceTablePointer;
+} EFI_ACPI_6_4_FPDT_BOOT_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT S3 Performance Table Pointer Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_4_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// 64-bit processor-relative physical address of the S3 Performance Table.
+  ///
+  UINT64                                          S3PerformanceTablePointer;
+} EFI_ACPI_6_4_FPDT_S3_PERFORMANCE_TABLE_POINTER_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Record Structure
+///
+typedef struct {
+  EFI_ACPI_6_4_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  UINT32                                          Reserved;
+  ///
+  /// Timer value logged at the beginning of firmware image execution.
+  /// This may not always be zero or near zero.
+  ///
+  UINT64                                          ResetEnd;
+  ///
+  /// Timer value logged just prior to loading the OS boot loader into memory.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          OsLoaderLoadImageStart;
+  ///
+  /// Timer value logged just prior to launching the previously loaded OS boot loader image.
+  /// For non-UEFI compatible boots, the timer value logged will be just prior
+  /// to the INT 19h handler invocation.
+  ///
+  UINT64                                          OsLoaderStartImageStart;
+  ///
+  /// Timer value logged at the point when the OS loader calls the
+  /// ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesEntry;
+  ///
+  /// Timer value logged at the point just prior towhen the OS loader gaining
+  /// control back from calls the ExitBootServices function for UEFI compatible firmware.
+  /// For non-UEFI compatible boots, this field must be zero.
+  ///
+  UINT64                                          ExitBootServicesExit;
+} EFI_ACPI_6_4_FPDT_FIRMWARE_BASIC_BOOT_RECORD;
+
+///
+/// FPDT Firmware Basic Boot Performance Table signature
+///
+#define EFI_ACPI_6_4_FPDT_BOOT_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('F', 'B', 'P', 'T')
+
+//
+// FPDT Firmware Basic Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_4_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_4_FPDT_FIRMWARE_BASIC_BOOT_TABLE;
+
+///
+/// FPDT "S3PT" S3 Performance Table
+///
+#define EFI_ACPI_6_4_FPDT_S3_PERFORMANCE_TABLE_SIGNATURE  SIGNATURE_32('S', '3', 'P', 'T')
+
+//
+// FPDT Firmware S3 Boot Performance Table
+//
+typedef struct {
+  EFI_ACPI_6_4_FPDT_PERFORMANCE_TABLE_HEADER      Header;
+  //
+  // one or more Performance Records.
+  //
+} EFI_ACPI_6_4_FPDT_FIRMWARE_S3_BOOT_TABLE;
+
+///
+/// FPDT Basic S3 Resume Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_4_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// A count of the number of S3 resume cycles since the last full boot sequence.
+  ///
+  UINT32                                          ResumeCount;
+  ///
+  /// Timer recorded at the end of BIOS S3 resume, just prior to handoff to the
+  /// OS waking vector. Only the most recent resume cycle's time is retained.
+  ///
+  UINT64                                          FullResume;
+  ///
+  /// Average timer value of all resume cycles logged since the last full boot
+  /// sequence, including the most recent resume.  Note that the entire log of
+  /// timer values does not need to be retained in order to calculate this average.
+  ///
+  UINT64                                          AverageResume;
+} EFI_ACPI_6_4_FPDT_S3_RESUME_RECORD;
+
+///
+/// FPDT Basic S3 Suspend Performance Record
+///
+typedef struct {
+  EFI_ACPI_6_4_FPDT_PERFORMANCE_RECORD_HEADER     Header;
+  ///
+  /// Timer value recorded at the OS write to SLP_TYP upon entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendStart;
+  ///
+  /// Timer value recorded at the final firmware write to SLP_TYP (or other
+  /// mechanism) used to trigger hardware entry to S3.
+  /// Only the most recent suspend cycle's timer value is retained.
+  ///
+  UINT64                                          SuspendEnd;
+} EFI_ACPI_6_4_FPDT_S3_SUSPEND_RECORD;
+
+///
+/// Firmware Performance Record Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+} EFI_ACPI_6_4_FIRMWARE_PERFORMANCE_RECORD_TABLE;
+
+///
+/// Generic Timer Description Table definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT64                      CntControlBasePhysicalAddress;
+  UINT32                      Reserved;
+  UINT32                      SecurePL1TimerGSIV;
+  UINT32                      SecurePL1TimerFlags;
+  UINT32                      NonSecurePL1TimerGSIV;
+  UINT32                      NonSecurePL1TimerFlags;
+  UINT32                      VirtualTimerGSIV;
+  UINT32                      VirtualTimerFlags;
+  UINT32                      NonSecurePL2TimerGSIV;
+  UINT32                      NonSecurePL2TimerFlags;
+  UINT64                      CntReadBasePhysicalAddress;
+  UINT32                      PlatformTimerCount;
+  UINT32                      PlatformTimerOffset;
+  UINT32                      VirtualPL2TimerGSIV;
+  UINT32                      VirtualPL2TimerFlags;
+} EFI_ACPI_6_4_GENERIC_TIMER_DESCRIPTION_TABLE;
+
+///
+/// GTDT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_GENERIC_TIMER_DESCRIPTION_TABLE_REVISION 0x03
+
+///
+/// Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_GTDT_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_4_GTDT_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_4_GTDT_TIMER_FLAG_ALWAYS_ON_CAPABILITY          BIT2
+
+///
+/// Platform Timer Type
+///
+#define EFI_ACPI_6_4_GTDT_GT_BLOCK                       0
+#define EFI_ACPI_6_4_GTDT_ARM_GENERIC_WATCHDOG           1
+
+///
+/// GT Block Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  CntCtlBase;
+  UINT32  GTBlockTimerCount;
+  UINT32  GTBlockTimerOffset;
+} EFI_ACPI_6_4_GTDT_GT_BLOCK_STRUCTURE;
+
+///
+/// GT Block Timer Structure
+///
+typedef struct {
+  UINT8   GTFrameNumber;
+  UINT8   Reserved[3];
+  UINT64  CntBaseX;
+  UINT64  CntEL0BaseX;
+  UINT32  GTxPhysicalTimerGSIV;
+  UINT32  GTxPhysicalTimerFlags;
+  UINT32  GTxVirtualTimerGSIV;
+  UINT32  GTxVirtualTimerFlags;
+  UINT32  GTxCommonFlags;
+} EFI_ACPI_6_4_GTDT_GT_BLOCK_TIMER_STRUCTURE;
+
+///
+/// GT Block Physical Timers and Virtual Timers Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_4_GTDT_GT_BLOCK_TIMER_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+
+///
+/// Common Flags Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_GTDT_GT_BLOCK_COMMON_FLAG_SECURE_TIMER              BIT0
+#define EFI_ACPI_6_4_GTDT_GT_BLOCK_COMMON_FLAG_ALWAYS_ON_CAPABILITY      BIT1
+
+///
+/// Arm Generic Watchdog Structure
+///
+typedef struct {
+  UINT8   Type;
+  UINT16  Length;
+  UINT8   Reserved;
+  UINT64  RefreshFramePhysicalAddress;
+  UINT64  WatchdogControlFramePhysicalAddress;
+  UINT32  WatchdogTimerGSIV;
+  UINT32  WatchdogTimerFlags;
+} EFI_ACPI_6_4_GTDT_ARM_GENERIC_WATCHDOG_STRUCTURE;
+
+///
+/// Arm Generic Watchdog Timer Flags.  All other bits are reserved and must be 0.
+///
+#define EFI_ACPI_6_4_GTDT_ARM_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_MODE          BIT0
+#define EFI_ACPI_6_4_GTDT_ARM_GENERIC_WATCHDOG_FLAG_TIMER_INTERRUPT_POLARITY      BIT1
+#define EFI_ACPI_6_4_GTDT_ARM_GENERIC_WATCHDOG_FLAG_SECURE_TIMER                  BIT2
+
+//
+// NVDIMM Firmware Interface Table definition.
+//
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER    Header;
+  UINT32                         Reserved;
+} EFI_ACPI_6_4_NVDIMM_FIRMWARE_INTERFACE_TABLE;
+
+//
+// NFIT Version (as defined in ACPI 6.4 spec.)
+//
+#define EFI_ACPI_6_4_NVDIMM_FIRMWARE_INTERFACE_TABLE_REVISION 0x1
+
+//
+// Definition for NFIT Table Structure Types
+//
+#define EFI_ACPI_6_4_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE_TYPE              0
+#define EFI_ACPI_6_4_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE_TYPE                      1
+#define EFI_ACPI_6_4_NFIT_INTERLEAVE_STRUCTURE_TYPE                                 2
+#define EFI_ACPI_6_4_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE_TYPE              3
+#define EFI_ACPI_6_4_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE_TYPE                      4
+#define EFI_ACPI_6_4_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE_TYPE            5
+#define EFI_ACPI_6_4_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE_TYPE                         6
+
+//
+// Definition for NFIT Structure Header
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+} EFI_ACPI_6_4_NFIT_STRUCTURE_HEADER;
+
+//
+// Definition for System Physical Address Range Structure
+//
+#define EFI_ACPI_6_4_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_CONTROL_REGION_FOR_MANAGEMENT      BIT0
+#define EFI_ACPI_6_4_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_PROXIMITY_DOMAIN_VALID             BIT1
+#define EFI_ACPI_6_4_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_FLAGS_SPA_LOCATION_COOKIE_VALID          BIT2
+
+#define EFI_ACPI_6_4_NFIT_GUID_VOLATILE_MEMORY_REGION                             { 0x7305944F, 0xFDDA, 0x44E3, { 0xB1, 0x6C, 0x3F, 0x22, 0xD2, 0x52, 0xE5, 0xD0 }}
+#define EFI_ACPI_6_4_NFIT_GUID_BYTE_ADDRESSABLE_PERSISTENT_MEMORY_REGION          { 0x66F0D379, 0xB4F3, 0x4074, { 0xAC, 0x43, 0x0D, 0x33, 0x18, 0xB7, 0x8C, 0xDB }}
+#define EFI_ACPI_6_4_NFIT_GUID_NVDIMM_CONTROL_REGION                              { 0x92F701F6, 0x13B4, 0x405D, { 0x91, 0x0B, 0x29, 0x93, 0x67, 0xE8, 0x23, 0x4C }}
+#define EFI_ACPI_6_4_NFIT_GUID_NVDIMM_BLOCK_DATA_WINDOW_REGION                    { 0x91AF0530, 0x5D86, 0x470E, { 0xA6, 0xB0, 0x0A, 0x2D, 0xB9, 0x40, 0x82, 0x49 }}
+#define EFI_ACPI_6_4_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_VOLATILE   { 0x77AB535A, 0x45FC, 0x624B, { 0x55, 0x60, 0xF7, 0xB2, 0x81, 0xD1, 0xF9, 0x6E }}
+#define EFI_ACPI_6_4_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_VOLATILE     { 0x3D5ABD30, 0x4175, 0x87CE, { 0x6D, 0x64, 0xD2, 0xAD, 0xE5, 0x23, 0xC4, 0xBB }}
+#define EFI_ACPI_6_4_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_DISK_REGION_PERSISTENT { 0x5CEA02C9, 0x4D07, 0x69D3, { 0x26, 0x9F ,0x44, 0x96, 0xFB, 0xE0, 0x96, 0xF9 }}
+#define EFI_ACPI_6_4_NFIT_GUID_RAM_DISK_SUPPORTING_VIRTUAL_CD_REGION_PERSISTENT   { 0x08018188, 0x42CD, 0xBB48, { 0x10, 0x0F, 0x53, 0x87, 0xD5, 0x3D, 0xED, 0x3D }}
+
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      SPARangeStructureIndex;
+  UINT16                                      Flags;
+  UINT32                                      Reserved_8;
+  UINT32                                      ProximityDomain;
+  GUID                                        AddressRangeTypeGUID;
+  UINT64                                      SystemPhysicalAddressRangeBase;
+  UINT64                                      SystemPhysicalAddressRangeLength;
+  UINT64                                      AddressRangeMemoryMappingAttribute;
+  UINT64                                      SPALocationCookie;
+} EFI_ACPI_6_4_NFIT_SYSTEM_PHYSICAL_ADDRESS_RANGE_STRUCTURE;
+
+//
+// Definition for Memory Device to System Physical Address Range Mapping Structure
+//
+typedef struct {
+  UINT32                                      DIMMNumber:4;
+  UINT32                                      MemoryChannelNumber:4;
+  UINT32                                      MemoryControllerID:4;
+  UINT32                                      SocketID:4;
+  UINT32                                      NodeControllerID:12;
+  UINT32                                      Reserved_28:4;
+} EFI_ACPI_6_4_NFIT_DEVICE_HANDLE;
+
+#define EFI_ACPI_6_4_NFIT_MEMORY_DEVICE_STATE_FLAGS_PREVIOUS_SAVE_FAIL                                      BIT0
+#define EFI_ACPI_6_4_NFIT_MEMORY_DEVICE_STATE_FLAGS_LAST_RESTORE_FAIL                                       BIT1
+#define EFI_ACPI_6_4_NFIT_MEMORY_DEVICE_STATE_FLAGS_PLATFORM_FLUSH_FAIL                                     BIT2
+#define EFI_ACPI_6_4_NFIT_MEMORY_DEVICE_STATE_FLAGS_NOT_ARMED_PRIOR_TO_OSPM_HAND_OFF                        BIT3
+#define EFI_ACPI_6_4_NFIT_MEMORY_DEVICE_STATE_FLAGS_SMART_HEALTH_EVENTS_PRIOR_OSPM_HAND_OFF                 BIT4
+#define EFI_ACPI_6_4_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_ENABLED_TO_NOTIFY_OSPM_ON_SMART_HEALTH_EVENTS  BIT5
+#define EFI_ACPI_6_4_NFIT_MEMORY_DEVICE_STATE_FLAGS_FIRMWARE_NOT_MAP_NVDIMM_TO_SPA                          BIT6
+
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_4_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NVDIMMPhysicalID;
+  UINT16                                      NVDIMMRegionID;
+  UINT16                                      SPARangeStructureIndex ;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT64                                      NVDIMMRegionSize;
+  UINT64                                      RegionOffset;
+  UINT64                                      NVDIMMPhysicalAddressRegionBase;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      InterleaveWays;
+  UINT16                                      NVDIMMStateFlags;
+  UINT16                                      Reserved_46;
+} EFI_ACPI_6_4_NFIT_NVDIMM_REGION_MAPPING_STRUCTURE;
+
+//
+// Definition for Interleave Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      InterleaveStructureIndex;
+  UINT16                                      Reserved_6;
+  UINT32                                      NumberOfLines;
+  UINT32                                      LineSize;
+//UINT32                                      LineOffset[NumberOfLines];
+} EFI_ACPI_6_4_NFIT_INTERLEAVE_STRUCTURE;
+
+//
+// Definition for SMBIOS Management Information Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT32                                      Reserved_4;
+//UINT8                                       Data[];
+} EFI_ACPI_6_4_NFIT_SMBIOS_MANAGEMENT_INFORMATION_STRUCTURE;
+
+//
+// Definition for NVDIMM Control Region Structure
+//
+#define EFI_ACPI_6_4_NFIT_NVDIMM_CONTROL_REGION_VALID_FIELDS_MANUFACTURING           BIT0
+
+#define EFI_ACPI_6_4_NFIT_NVDIMM_CONTROL_REGION_FLAGS_BLOCK_DATA_WINDOWS_BUFFERED    BIT0
+
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      VendorID;
+  UINT16                                      DeviceID;
+  UINT16                                      RevisionID;
+  UINT16                                      SubsystemVendorID;
+  UINT16                                      SubsystemDeviceID;
+  UINT16                                      SubsystemRevisionID;
+  UINT8                                       ValidFields;
+  UINT8                                       ManufacturingLocation;
+  UINT16                                      ManufacturingDate;
+  UINT8                                       Reserved_22[2];
+  UINT32                                      SerialNumber;
+  UINT16                                      RegionFormatInterfaceCode;
+  UINT16                                      NumberOfBlockControlWindows;
+  UINT64                                      SizeOfBlockControlWindow;
+  UINT64                                      CommandRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfCommandRegisterInBlockControlWindows;
+  UINT64                                      StatusRegisterOffsetInBlockControlWindow;
+  UINT64                                      SizeOfStatusRegisterInBlockControlWindows;
+  UINT16                                      NVDIMMControlRegionFlag;
+  UINT8                                       Reserved_74[6];
+} EFI_ACPI_6_4_NFIT_NVDIMM_CONTROL_REGION_STRUCTURE;
+
+//
+// Definition for NVDIMM Block Data Window Region Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  UINT16                                      NVDIMMControlRegionStructureIndex;
+  UINT16                                      NumberOfBlockDataWindows;
+  UINT64                                      BlockDataWindowStartOffset;
+  UINT64                                      SizeOfBlockDataWindow;
+  UINT64                                      BlockAccessibleMemoryCapacity;
+  UINT64                                      BeginningAddressOfFirstBlockInBlockAccessibleMemory;
+} EFI_ACPI_6_4_NFIT_NVDIMM_BLOCK_DATA_WINDOW_REGION_STRUCTURE;
+
+//
+// Definition for Flush Hint Address Structure
+//
+typedef struct {
+  UINT16                                      Type;
+  UINT16                                      Length;
+  EFI_ACPI_6_4_NFIT_DEVICE_HANDLE             NFITDeviceHandle;
+  UINT16                                      NumberOfFlushHintAddresses;
+  UINT8                                       Reserved_10[6];
+//UINT64                                      FlushHintAddress[NumberOfFlushHintAddresses];
+} EFI_ACPI_6_4_NFIT_FLUSH_HINT_ADDRESS_STRUCTURE;
+
+///
+/// Secure DEVices Table (SDEV)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+} EFI_ACPI_6_4_SECURE_DEVICES_TABLE_HEADER;
+
+///
+/// SDEV Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_SECURE_DEVICES_TABLE_REVISION      0x01
+
+///
+/// Secure Device types
+///
+#define EFI_ACPI_6_4_SDEV_TYPE_ACPI_NAMESPACE_DEVICE    0x00
+#define EFI_ACPI_6_4_SDEV_TYPE_PCIE_ENDPOINT_DEVICE     0x01
+
+///
+/// Secure Device flags
+///
+#define EFI_ACPI_6_4_SDEV_FLAG_ALLOW_HANDOFF                      BIT0
+#define EFI_ACPI_6_4_SDEV_FLAG_SECURE_ACCESS_COMPONENTS_PRESENT   BIT1
+
+///
+/// SDEV Structure Header
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Flags;
+  UINT16                        Length;
+} EFI_ACPI_6_4_SDEV_STRUCTURE_HEADER;
+
+///
+/// ACPI_NAMESPACE_DEVICE based Secure Device Structure
+///
+typedef struct {
+  EFI_ACPI_6_4_SDEV_STRUCTURE_HEADER  Header;
+  UINT16                              DeviceIdentifierOffset;
+  UINT16                              DeviceIdentifierLength;
+  UINT16                              VendorSpecificDataOffset;
+  UINT16                              VendorSpecificDataLength;
+  UINT16                              SecureAccessComponentsOffset;
+  UINT16                              SecureAccessComponentsLength;
+} EFI_ACPI_6_4_SDEV_STRUCTURE_ACPI_NAMESPACE_DEVICE;
+
+///
+/// Secure Access Component Types
+///
+#define EFI_ACPI_6_4_SDEV_SECURE_ACCESS_COMPONENT_TYPE_IDENTIFICATION   0x00
+#define EFI_ACPI_6_4_SDEV_SECURE_ACCESS_COMPONENT_TYPE_MEMORY           0x01
+
+///
+/// Identification Based Secure Access Component
+///
+typedef struct {
+  EFI_ACPI_6_4_SDEV_STRUCTURE_HEADER  Header;
+  UINT16                              HardwareIdentifierOffset;
+  UINT16                              HardwareIdentifierLength;
+  UINT16                              SubsystemIdentifierOffset;
+  UINT16                              SubsystemIdentifierLength;
+  UINT16                              HardwareRevision;
+  UINT8                               HardwareRevisionPresent;
+  UINT8                               ClassCodePresent;
+  UINT8                               PciCompatibleBaseClass;
+  UINT8                               PciCompatibleSubClass;
+  UINT8                               PciCompatibleProgrammingInterface;
+} EFI_ACPI_6_4_SDEV_SECURE_ACCESS_COMPONENT_IDENTIFICATION_STRUCTURE;
+
+///
+/// Memory-based Secure Access Component
+///
+typedef struct {
+  EFI_ACPI_6_4_SDEV_STRUCTURE_HEADER  Header;
+  UINT32                              Reserved;
+  UINT64                              MemoryAddressBase;
+  UINT64                              MemoryLength;
+} EFI_ACPI_6_4_SDEV_SECURE_ACCESS_COMPONENT_MEMORY_STRUCTURE;
+
+///
+/// PCIe Endpoint Device based Secure Device Structure
+///
+typedef struct {
+  EFI_ACPI_6_4_SDEV_STRUCTURE_HEADER  Header;
+  UINT16                              PciSegmentNumber;
+  UINT16                              StartBusNumber;
+  UINT16                              PciPathOffset;
+  UINT16                              PciPathLength;
+  UINT16                              VendorSpecificDataOffset;
+  UINT16                              VendorSpecificDataLength;
+} EFI_ACPI_6_4_SDEV_STRUCTURE_PCIE_ENDPOINT_DEVICE;
+
+///
+/// Boot Error Record Table (BERT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      BootErrorRegionLength;
+  UINT64                      BootErrorRegion;
+} EFI_ACPI_6_4_BOOT_ERROR_RECORD_TABLE_HEADER;
+
+///
+/// BERT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_BOOT_ERROR_RECORD_TABLE_REVISION 0x01
+
+///
+/// Boot Error Region Block Status Definition
+///
+typedef struct {
+  UINT32       UncorrectableErrorValid:1;
+  UINT32       CorrectableErrorValid:1;
+  UINT32       MultipleUncorrectableErrors:1;
+  UINT32       MultipleCorrectableErrors:1;
+  UINT32       ErrorDataEntryCount:10;
+  UINT32       Reserved:18;
+} EFI_ACPI_6_4_ERROR_BLOCK_STATUS;
+
+///
+/// Boot Error Region Definition
+///
+typedef struct {
+  EFI_ACPI_6_4_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_4_BOOT_ERROR_REGION_STRUCTURE;
+
+//
+// Boot Error Severity types
+//
+#define EFI_ACPI_6_4_ERROR_SEVERITY_CORRECTABLE  0x00
+#define EFI_ACPI_6_4_ERROR_SEVERITY_FATAL        0x01
+#define EFI_ACPI_6_4_ERROR_SEVERITY_CORRECTED    0x02
+#define EFI_ACPI_6_4_ERROR_SEVERITY_NONE         0x03
+
+///
+/// Generic Error Data Entry Definition
+///
+typedef struct {
+  UINT8    SectionType[16];
+  UINT32   ErrorSeverity;
+  UINT16   Revision;
+  UINT8    ValidationBits;
+  UINT8    Flags;
+  UINT32   ErrorDataLength;
+  UINT8    FruId[16];
+  UINT8    FruText[20];
+  UINT8    Timestamp[8];
+} EFI_ACPI_6_4_GENERIC_ERROR_DATA_ENTRY_STRUCTURE;
+
+///
+/// Generic Error Data Entry Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_GENERIC_ERROR_DATA_ENTRY_REVISION  0x0300
+
+///
+/// HEST - Hardware Error Source Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      ErrorSourceCount;
+} EFI_ACPI_6_4_HARDWARE_ERROR_SOURCE_TABLE_HEADER;
+
+///
+/// HEST Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_HARDWARE_ERROR_SOURCE_TABLE_REVISION 0x01
+
+//
+// Error Source structure types.
+//
+#define EFI_ACPI_6_4_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION  0x00
+#define EFI_ACPI_6_4_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK  0x01
+#define EFI_ACPI_6_4_IA32_ARCHITECTURE_NMI_ERROR                0x02
+#define EFI_ACPI_6_4_PCI_EXPRESS_ROOT_PORT_AER                  0x06
+#define EFI_ACPI_6_4_PCI_EXPRESS_DEVICE_AER                     0x07
+#define EFI_ACPI_6_4_PCI_EXPRESS_BRIDGE_AER                     0x08
+#define EFI_ACPI_6_4_GENERIC_HARDWARE_ERROR                     0x09
+#define EFI_ACPI_6_4_GENERIC_HARDWARE_ERROR_VERSION_2           0x0A
+#define EFI_ACPI_6_4_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK   0x0B
+
+//
+// Error Source structure flags.
+//
+#define EFI_ACPI_6_4_ERROR_SOURCE_FLAG_FIRMWARE_FIRST       (1 << 0)
+#define EFI_ACPI_6_4_ERROR_SOURCE_FLAG_GLOBAL               (1 << 1)
+#define EFI_ACPI_6_4_ERROR_SOURCE_FLAG_GHES_ASSIST          (1 << 2)
+
+///
+/// IA-32 Architecture Machine Check Exception Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT64  GlobalCapabilityInitData;
+  UINT64  GlobalControlInitData;
+  UINT8   NumberOfHardwareBanks;
+  UINT8   Reserved1[7];
+} EFI_ACPI_6_4_IA32_ARCHITECTURE_MACHINE_CHECK_EXCEPTION_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure Definition
+///
+typedef struct {
+  UINT8   BankNumber;
+  UINT8   ClearStatusOnInitialization;
+  UINT8   StatusDataFormat;
+  UINT8   Reserved0;
+  UINT32  ControlRegisterMsrAddress;
+  UINT64  ControlInitData;
+  UINT32  StatusRegisterMsrAddress;
+  UINT32  AddressRegisterMsrAddress;
+  UINT32  MiscRegisterMsrAddress;
+} EFI_ACPI_6_4_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_BANK_STRUCTURE;
+
+///
+/// IA-32 Architecture Machine Check Bank Structure MCA data format
+///
+#define EFI_ACPI_6_4_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_IA32      0x00
+#define EFI_ACPI_6_4_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_INTEL64   0x01
+#define EFI_ACPI_6_4_IA32_ARCHITECTURE_MACHINE_CHECK_ERROR_DATA_FORMAT_AMD64     0x02
+
+//
+// Hardware Error Notification types. All other values are reserved
+//
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_POLLED                         0x00
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_EXTERNAL_INTERRUPT             0x01
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_LOCAL_INTERRUPT                0x02
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_SCI                            0x03
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_NMI                            0x04
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_CMCI                           0x05
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_MCE                            0x06
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_GPIO_SIGNAL                    0x07
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEA                      0x08
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_ARMV8_SEI                      0x09
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_GSIV                           0x0A
+#define EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_SOFTWARE_DELEGATED_EXCEPTION   0x0B
+
+///
+/// Hardware Error Notification Configuration Write Enable Structure Definition
+///
+typedef struct {
+  UINT16    Type:1;
+  UINT16    PollInterval:1;
+  UINT16    SwitchToPollingThresholdValue:1;
+  UINT16    SwitchToPollingThresholdWindow:1;
+  UINT16    ErrorThresholdValue:1;
+  UINT16    ErrorThresholdWindow:1;
+  UINT16    Reserved:10;
+} EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE;
+
+///
+/// Hardware Error Notification Structure Definition
+///
+typedef struct {
+  UINT8                                                                          Type;
+  UINT8                                                                          Length;
+  EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_CONFIGURATION_WRITE_ENABLE_STRUCTURE  ConfigurationWriteEnable;
+  UINT32                                                                         PollInterval;
+  UINT32                                                                         Vector;
+  UINT32                                                                         SwitchToPollingThresholdValue;
+  UINT32                                                                         SwitchToPollingThresholdWindow;
+  UINT32                                                                         ErrorThresholdValue;
+  UINT32                                                                         ErrorThresholdWindow;
+} EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_STRUCTURE;
+
+///
+/// IA-32 Architecture Corrected Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT8                                                  Reserved0[2];
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT8                                                  NumberOfHardwareBanks;
+  UINT8                                                  Reserved1[3];
+} EFI_ACPI_6_4_IA32_ARCHITECTURE_CORRECTED_MACHINE_CHECK_STRUCTURE;
+
+///
+/// IA-32 Architecture NMI Error Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  MaxRawDataLength;
+} EFI_ACPI_6_4_IA32_ARCHITECTURE_NMI_ERROR_STRUCTURE;
+
+///
+/// PCI Express Root Port AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  RootErrorCommand;
+} EFI_ACPI_6_4_PCI_EXPRESS_ROOT_PORT_AER_STRUCTURE;
+
+///
+/// PCI Express Device AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_4_PCI_EXPRESS_DEVICE_AER_STRUCTURE;
+
+///
+/// PCI Express Bridge AER Structure Definition
+///
+typedef struct {
+  UINT16  Type;
+  UINT16  SourceId;
+  UINT8   Reserved0[2];
+  UINT8   Flags;
+  UINT8   Enabled;
+  UINT32  NumberOfRecordsToPreAllocate;
+  UINT32  MaxSectionsPerRecord;
+  UINT32  Bus;
+  UINT16  Device;
+  UINT16  Function;
+  UINT16  DeviceControl;
+  UINT8   Reserved1[2];
+  UINT32  UncorrectableErrorMask;
+  UINT32  UncorrectableErrorSeverity;
+  UINT32  CorrectableErrorMask;
+  UINT32  AdvancedErrorCapabilitiesAndControl;
+  UINT32  SecondaryUncorrectableErrorMask;
+  UINT32  SecondaryUncorrectableErrorSeverity;
+  UINT32  SecondaryAdvancedErrorCapabilitiesAndControl;
+} EFI_ACPI_6_4_PCI_EXPRESS_BRIDGE_AER_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+} EFI_ACPI_6_4_GENERIC_HARDWARE_ERROR_SOURCE_STRUCTURE;
+
+///
+/// Generic Hardware Error Source Version 2 Structure Definition
+///
+typedef struct {
+  UINT16                                                 Type;
+  UINT16                                                 SourceId;
+  UINT16                                                 RelatedSourceId;
+  UINT8                                                  Flags;
+  UINT8                                                  Enabled;
+  UINT32                                                 NumberOfRecordsToPreAllocate;
+  UINT32                                                 MaxSectionsPerRecord;
+  UINT32                                                 MaxRawDataLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE                 ErrorStatusAddress;
+  EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_STRUCTURE     NotificationStructure;
+  UINT32                                                 ErrorStatusBlockLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE                 ReadAckRegister;
+  UINT64                                                 ReadAckPreserve;
+  UINT64                                                 ReadAckWrite;
+} EFI_ACPI_6_4_GENERIC_HARDWARE_ERROR_SOURCE_VERSION_2_STRUCTURE;
+
+///
+/// Generic Error Status Definition
+///
+typedef struct {
+  EFI_ACPI_6_4_ERROR_BLOCK_STATUS              BlockStatus;
+  UINT32                                       RawDataOffset;
+  UINT32                                       RawDataLength;
+  UINT32                                       DataLength;
+  UINT32                                       ErrorSeverity;
+} EFI_ACPI_6_4_GENERIC_ERROR_STATUS_STRUCTURE;
+
+///
+/// IA-32 Architecture Deferred Machine Check Structure Definition
+///
+typedef struct {
+  UINT16                                                Type;
+  UINT16                                                SourceId;
+  UINT8                                                 Reserved0[2];
+  UINT8                                                 Flags;
+  UINT8                                                 Enabled;
+  UINT32                                                NumberOfRecordsToPreAllocate;
+  UINT32                                                MaxSectionsPerRecord;
+  EFI_ACPI_6_4_HARDWARE_ERROR_NOTIFICATION_STRUCTURE    NotificationStructure;
+  UINT8                                                 NumberOfHardwareBanks;
+  UINT8                                                 Reserved1[3];
+} EFI_ACPI_6_4_IA32_ARCHITECTURE_DEFERRED_MACHINE_CHECK_STRUCTURE;;
+
+///
+/// HMAT - Heterogeneous Memory Attribute Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT8                       Reserved[4];
+} EFI_ACPI_6_4_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_HEADER;
+
+///
+/// HMAT Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_REVISION 0x02
+
+///
+/// HMAT types
+///
+#define EFI_ACPI_6_4_HMAT_TYPE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES           0x00
+#define EFI_ACPI_6_4_HMAT_TYPE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO   0x01
+#define EFI_ACPI_6_4_HMAT_TYPE_MEMORY_SIDE_CACHE_INFO                       0x02
+
+///
+/// HMAT Structure Header
+///
+typedef struct {
+  UINT16                        Type;
+  UINT8                         Reserved[2];
+  UINT32                        Length;
+} EFI_ACPI_6_4_HMAT_STRUCTURE_HEADER;
+
+///
+/// Memory Proximity Domain Attributes Structure flags
+///
+typedef struct {
+  UINT16                        InitiatorProximityDomainValid:1;
+  UINT16                        Reserved:15;
+} EFI_ACPI_6_4_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES_FLAGS;
+
+///
+/// Memory Proximity Domain Attributes Structure
+///
+typedef struct {
+  UINT16                                                                Type;
+  UINT8                                                                 Reserved[2];
+  UINT32                                                                Length;
+  EFI_ACPI_6_4_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES_FLAGS  Flags;
+  UINT8                                                                 Reserved1[2];
+  UINT32                                                                InitiatorProximityDomain;
+  UINT32                                                                MemoryProximityDomain;
+  UINT8                                                                 Reserved2[20];
+} EFI_ACPI_6_4_HMAT_STRUCTURE_MEMORY_PROXIMITY_DOMAIN_ATTRIBUTES;
+
+///
+/// System Locality Latency and Bandwidth Information Structure flags
+///
+typedef struct {
+  UINT8                         MemoryHierarchy:4;
+  UINT8                         AccessAttributes:2;
+  UINT8                         Reserved:2;
+} EFI_ACPI_6_4_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS;
+
+///
+/// System Locality Latency and Bandwidth Information Structure
+///
+typedef struct {
+  UINT16                                                                        Type;
+  UINT8                                                                         Reserved[2];
+  UINT32                                                                        Length;
+  EFI_ACPI_6_4_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO_FLAGS  Flags;
+  UINT8                                                                         DataType;
+  UINT8                                                                         MinTransferSize;
+  UINT8                                                                         Reserved1;
+  UINT32                                                                        NumberOfInitiatorProximityDomains;
+  UINT32                                                                        NumberOfTargetProximityDomains;
+  UINT8                                                                         Reserved2[4];
+  UINT64                                                                        EntryBaseUnit;
+} EFI_ACPI_6_4_HMAT_STRUCTURE_SYSTEM_LOCALITY_LATENCY_AND_BANDWIDTH_INFO;
+
+///
+/// Memory Side Cache Information Structure cache attributes
+///
+typedef struct {
+  UINT32                        TotalCacheLevels:4;
+  UINT32                        CacheLevel:4;
+  UINT32                        CacheAssociativity:4;
+  UINT32                        WritePolicy:4;
+  UINT32                        CacheLineSize:16;
+} EFI_ACPI_6_4_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES;
+
+///
+/// Memory Side Cache Information Structure
+///
+typedef struct {
+  UINT16                                                                Type;
+  UINT8                                                                 Reserved[2];
+  UINT32                                                                Length;
+  UINT32                                                                MemoryProximityDomain;
+  UINT8                                                                 Reserved1[4];
+  UINT64                                                                MemorySideCacheSize;
+  EFI_ACPI_6_4_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO_CACHE_ATTRIBUTES   CacheAttributes;
+  UINT8                                                                 Reserved2[2];
+  UINT16                                                                NumberOfSmbiosHandles;
+} EFI_ACPI_6_4_HMAT_STRUCTURE_MEMORY_SIDE_CACHE_INFO;
+
+///
+/// ERST - Error Record Serialization Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      SerializationHeaderSize;
+  UINT8                       Reserved0[4];
+  UINT32                      InstructionEntryCount;
+} EFI_ACPI_6_4_ERROR_RECORD_SERIALIZATION_TABLE_HEADER;
+
+///
+/// ERST Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_ERROR_RECORD_SERIALIZATION_TABLE_REVISION 0x01
+
+///
+/// ERST Serialization Actions
+///
+#define EFI_ACPI_6_4_ERST_BEGIN_WRITE_OPERATION                    0x00
+#define EFI_ACPI_6_4_ERST_BEGIN_READ_OPERATION                     0x01
+#define EFI_ACPI_6_4_ERST_BEGIN_CLEAR_OPERATION                    0x02
+#define EFI_ACPI_6_4_ERST_END_OPERATION                            0x03
+#define EFI_ACPI_6_4_ERST_SET_RECORD_OFFSET                        0x04
+#define EFI_ACPI_6_4_ERST_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_4_ERST_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_4_ERST_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_4_ERST_GET_RECORD_IDENTIFIER                    0x08
+#define EFI_ACPI_6_4_ERST_SET_RECORD_IDENTIFIER                    0x09
+#define EFI_ACPI_6_4_ERST_GET_RECORD_COUNT                         0x0A
+#define EFI_ACPI_6_4_ERST_BEGIN_DUMMY_WRITE_OPERATION              0x0B
+#define EFI_ACPI_6_4_ERST_GET_ERROR_LOG_ADDRESS_RANGE              0x0D
+#define EFI_ACPI_6_4_ERST_GET_ERROR_LOG_ADDRESS_RANGE_LENGTH       0x0E
+#define EFI_ACPI_6_4_ERST_GET_ERROR_LOG_ADDRESS_RANGE_ATTRIBUTES   0x0F
+#define EFI_ACPI_6_4_ERST_GET_EXECUTE_OPERATION_TIMINGS            0x10
+
+///
+/// ERST Action Command Status
+///
+#define EFI_ACPI_6_4_ERST_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_4_ERST_STATUS_NOT_ENOUGH_SPACE                  0x01
+#define EFI_ACPI_6_4_ERST_STATUS_HARDWARE_NOT_AVAILABLE            0x02
+#define EFI_ACPI_6_4_ERST_STATUS_FAILED                            0x03
+#define EFI_ACPI_6_4_ERST_STATUS_RECORD_STORE_EMPTY                0x04
+#define EFI_ACPI_6_4_ERST_STATUS_RECORD_NOT_FOUND                  0x05
+
+///
+/// ERST Serialization Instructions
+///
+#define EFI_ACPI_6_4_ERST_READ_REGISTER                            0x00
+#define EFI_ACPI_6_4_ERST_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_4_ERST_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_4_ERST_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_4_ERST_NOOP                                     0x04
+#define EFI_ACPI_6_4_ERST_LOAD_VAR1                                0x05
+#define EFI_ACPI_6_4_ERST_LOAD_VAR2                                0x06
+#define EFI_ACPI_6_4_ERST_STORE_VAR1                               0x07
+#define EFI_ACPI_6_4_ERST_ADD                                      0x08
+#define EFI_ACPI_6_4_ERST_SUBTRACT                                 0x09
+#define EFI_ACPI_6_4_ERST_ADD_VALUE                                0x0A
+#define EFI_ACPI_6_4_ERST_SUBTRACT_VALUE                           0x0B
+#define EFI_ACPI_6_4_ERST_STALL                                    0x0C
+#define EFI_ACPI_6_4_ERST_STALL_WHILE_TRUE                         0x0D
+#define EFI_ACPI_6_4_ERST_SKIP_NEXT_INSTRUCTION_IF_TRUE            0x0E
+#define EFI_ACPI_6_4_ERST_GOTO                                     0x0F
+#define EFI_ACPI_6_4_ERST_SET_SRC_ADDRESS_BASE                     0x10
+#define EFI_ACPI_6_4_ERST_SET_DST_ADDRESS_BASE                     0x11
+#define EFI_ACPI_6_4_ERST_MOVE_DATA                                0x12
+
+///
+/// ERST Instruction Flags
+///
+#define EFI_ACPI_6_4_ERST_PRESERVE_REGISTER                        0x01
+
+///
+/// ERST Serialization Instruction Entry
+///
+typedef struct {
+  UINT8                                    SerializationAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_4_ERST_SERIALIZATION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ - Error Injection Table
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      InjectionHeaderSize;
+  UINT8                       InjectionFlags;
+  UINT8                       Reserved0[3];
+  UINT32                      InjectionEntryCount;
+} EFI_ACPI_6_4_ERROR_INJECTION_TABLE_HEADER;
+
+///
+/// EINJ Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_ERROR_INJECTION_TABLE_REVISION 0x01
+
+///
+/// EINJ Error Injection Actions
+///
+#define EFI_ACPI_6_4_EINJ_BEGIN_INJECTION_OPERATION                0x00
+#define EFI_ACPI_6_4_EINJ_GET_TRIGGER_ERROR_ACTION_TABLE           0x01
+#define EFI_ACPI_6_4_EINJ_SET_ERROR_TYPE                           0x02
+#define EFI_ACPI_6_4_EINJ_GET_ERROR_TYPE                           0x03
+#define EFI_ACPI_6_4_EINJ_END_OPERATION                            0x04
+#define EFI_ACPI_6_4_EINJ_EXECUTE_OPERATION                        0x05
+#define EFI_ACPI_6_4_EINJ_CHECK_BUSY_STATUS                        0x06
+#define EFI_ACPI_6_4_EINJ_GET_COMMAND_STATUS                       0x07
+#define EFI_ACPI_6_4_EINJ_TRIGGER_ERROR                            0xFF
+
+///
+/// EINJ Action Command Status
+///
+#define EFI_ACPI_6_4_EINJ_STATUS_SUCCESS                           0x00
+#define EFI_ACPI_6_4_EINJ_STATUS_UNKNOWN_FAILURE                   0x01
+#define EFI_ACPI_6_4_EINJ_STATUS_INVALID_ACCESS                    0x02
+
+///
+/// EINJ Error Type Definition
+///
+#define EFI_ACPI_6_4_EINJ_ERROR_PROCESSOR_CORRECTABLE                 (1 << 0)
+#define EFI_ACPI_6_4_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_NONFATAL      (1 << 1)
+#define EFI_ACPI_6_4_EINJ_ERROR_PROCESSOR_UNCORRECTABLE_FATAL         (1 << 2)
+#define EFI_ACPI_6_4_EINJ_ERROR_MEMORY_CORRECTABLE                    (1 << 3)
+#define EFI_ACPI_6_4_EINJ_ERROR_MEMORY_UNCORRECTABLE_NONFATAL         (1 << 4)
+#define EFI_ACPI_6_4_EINJ_ERROR_MEMORY_UNCORRECTABLE_FATAL            (1 << 5)
+#define EFI_ACPI_6_4_EINJ_ERROR_PCI_EXPRESS_CORRECTABLE               (1 << 6)
+#define EFI_ACPI_6_4_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_NONFATAL    (1 << 7)
+#define EFI_ACPI_6_4_EINJ_ERROR_PCI_EXPRESS_UNCORRECTABLE_FATAL       (1 << 8)
+#define EFI_ACPI_6_4_EINJ_ERROR_PLATFORM_CORRECTABLE                  (1 << 9)
+#define EFI_ACPI_6_4_EINJ_ERROR_PLATFORM_UNCORRECTABLE_NONFATAL       (1 << 10)
+#define EFI_ACPI_6_4_EINJ_ERROR_PLATFORM_UNCORRECTABLE_FATAL          (1 << 11)
+
+///
+/// EINJ Injection Instructions
+///
+#define EFI_ACPI_6_4_EINJ_READ_REGISTER                            0x00
+#define EFI_ACPI_6_4_EINJ_READ_REGISTER_VALUE                      0x01
+#define EFI_ACPI_6_4_EINJ_WRITE_REGISTER                           0x02
+#define EFI_ACPI_6_4_EINJ_WRITE_REGISTER_VALUE                     0x03
+#define EFI_ACPI_6_4_EINJ_NOOP                                     0x04
+
+///
+/// EINJ Instruction Flags
+///
+#define EFI_ACPI_6_4_EINJ_PRESERVE_REGISTER                        0x01
+
+///
+/// EINJ Injection Instruction Entry
+///
+typedef struct {
+  UINT8                                    InjectionAction;
+  UINT8                                    Instruction;
+  UINT8                                    Flags;
+  UINT8                                    Reserved0;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   RegisterRegion;
+  UINT64                                   Value;
+  UINT64                                   Mask;
+} EFI_ACPI_6_4_EINJ_INJECTION_INSTRUCTION_ENTRY;
+
+///
+/// EINJ Trigger Action Table
+///
+typedef struct {
+  UINT32  HeaderSize;
+  UINT32  Revision;
+  UINT32  TableSize;
+  UINT32  EntryCount;
+} EFI_ACPI_6_4_EINJ_TRIGGER_ACTION_TABLE;
+
+///
+/// Platform Communications Channel Table (PCCT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  UINT32                      Flags;
+  UINT64                      Reserved;
+} EFI_ACPI_6_4_PLATFORM_COMMUNICATION_CHANNEL_TABLE_HEADER;
+
+///
+/// PCCT Version (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_PLATFORM_COMMUNICATION_CHANNEL_TABLE_REVISION 0x02
+
+///
+/// PCCT Global Flags
+///
+#define EFI_ACPI_6_4_PCCT_FLAGS_PLATFORM_INTERRUPT  BIT0
+
+//
+// PCCT Subspace type
+//
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_TYPE_GENERIC                         0x00
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_TYPE_1_HW_REDUCED_COMMUNICATIONS     0x01
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_TYPE_2_HW_REDUCED_COMMUNICATIONS     0x02
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_TYPE_3_EXTENDED_PCC                  0x03
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_TYPE_4_EXTENDED_PCC                  0x04
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_TYPE_5_HW_REGISTERS_COMMUNICATIONS   0x05
+
+///
+/// PCC Subspace Structure Header
+///
+typedef struct {
+  UINT8        Type;
+  UINT8        Length;
+} EFI_ACPI_6_4_PCCT_SUBSPACE_HEADER;
+
+///
+/// Generic Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT8                                    Reserved[6];
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_4_PCCT_SUBSPACE_GENERIC;
+
+///
+/// Generic Communications Channel Shared Memory Region
+///
+
+typedef struct {
+  UINT8                                    Command;
+  UINT8                                    Reserved:7;
+  UINT8                                    NotifyOnCompletion:1;
+} EFI_ACPI_6_4_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND;
+
+typedef struct {
+  UINT8                                    CommandComplete:1;
+  UINT8                                    PlatformInterrupt:1;
+  UINT8                                    Error:1;
+  UINT8                                    PlatformNotification:1;
+  UINT8                                    Reserved:4;
+  UINT8                                    Reserved1;
+} EFI_ACPI_6_4_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS;
+
+typedef struct {
+  UINT32                                                    Signature;
+  EFI_ACPI_6_4_PCCT_GENERIC_SHARED_MEMORY_REGION_COMMAND    Command;
+  EFI_ACPI_6_4_PCCT_GENERIC_SHARED_MEMORY_REGION_STATUS     Status;
+} EFI_ACPI_6_4_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER;
+
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_POLARITY    BIT0
+#define EFI_ACPI_6_4_PCCT_SUBSPACE_PLATFORM_INTERRUPT_FLAGS_MODE        BIT1
+
+///
+/// Type 1 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_4_PCCT_SUBSPACE_1_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 2 HW-Reduced Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT64                                   AddressLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT16                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   PlatformInterruptAckRegister;
+  UINT64                                   PlatformInterruptAckPreserve;
+  UINT64                                   PlatformInterruptAckWrite;
+} EFI_ACPI_6_4_PCCT_SUBSPACE_2_HW_REDUCED_COMMUNICATIONS;
+
+///
+/// Type 3 Extended PCC Subspace Structure
+///
+typedef struct {
+  UINT8                                    Type;
+  UINT8                                    Length;
+  UINT32                                   PlatformInterrupt;
+  UINT8                                    PlatformInterruptFlags;
+  UINT8                                    Reserved;
+  UINT64                                   BaseAddress;
+  UINT32                                   AddressLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   DoorbellRegister;
+  UINT64                                   DoorbellPreserve;
+  UINT64                                   DoorbellWrite;
+  UINT32                                   NominalLatency;
+  UINT32                                   MaximumPeriodicAccessRate;
+  UINT32                                   MinimumRequestTurnaroundTime;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   PlatformInterruptAckRegister;
+  UINT64                                   PlatformInterruptAckPreserve;
+  UINT64                                   PlatformInterruptAckSet;
+  UINT8                                    Reserved1[8];
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   CommandCompleteCheckRegister;
+  UINT64                                   CommandCompleteCheckMask;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   CommandCompleteUpdateRegister;
+  UINT64                                   CommandCompleteUpdatePreserve;
+  UINT64                                   CommandCompleteUpdateSet;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE   ErrorStatusRegister;
+  UINT64                                   ErrorStatusMask;
+} EFI_ACPI_6_4_PCCT_SUBSPACE_3_EXTENDED_PCC;
+
+///
+/// Type 4 Extended PCC Subspace Structure
+///
+typedef EFI_ACPI_6_4_PCCT_SUBSPACE_3_EXTENDED_PCC EFI_ACPI_6_4_PCCT_SUBSPACE_4_EXTENDED_PCC;
+
+#define EFI_ACPI_6_4_PCCT_MASTER_SLAVE_COMMUNICATIONS_CHANNEL_FLAGS_NOTIFY_ON_COMPLETION BIT0
+
+typedef struct {
+  UINT32                                    Signature;
+  UINT32                                    Flags;
+  UINT32                                    Length;
+  UINT32                                    Command;
+} EFI_ACPI_6_4_PCCT_EXTENDED_PCC_SHARED_MEMORY_REGION_HEADER;
+
+///
+/// Type 5 HW Registers based Communications Subspace Structure
+///
+typedef struct {
+  UINT8                                   Type;
+  UINT8                                   Length;
+  UINT16                                  Version;
+  UINT64                                  BaseAddress;
+  UINT64                                  SharedMemoryRangeLength;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  DoorbellRegister;
+  UINT64                                  DoorbellPreserve;
+  UINT64                                  DoorbellWrite;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  CommandCompleteCheckRegister;
+  UINT64                                  CommandCompleteCheckMask;
+  EFI_ACPI_6_4_GENERIC_ADDRESS_STRUCTURE  ErrorStatusRegister;
+  UINT64                                  ErrorStatusMask;
+  UINT32                                  NominalLatency;
+  UINT32                                  MinimumRequestTurnaroundTime;
+} EFI_ACPI_6_4_PCCT_SUBSPACE_5_HW_REGISTERS_COMMUNICATIONS;
+
+///
+/// Reduced PCC Subspace Shared Memory Region
+///
+typedef struct {
+  UINT32      Signature;
+//UINT8       CommunicationSubspace[];
+} EFI_6_4_PCCT_REDUCED_PCC_SUBSPACE_SHARED_MEMORY_REGION;
+
+///
+/// Platform Debug Trigger Table (PDTT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+  UINT8                         TriggerCount;
+  UINT8                         Reserved[3];
+  UINT32                        TriggerIdentifierArrayOffset;
+} EFI_ACPI_6_4_PLATFORM_DEBUG_TRIGGER_TABLE_HEADER;
+
+///
+/// PDTT Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_PLATFORM_DEBUG_TRIGGER_TABLE_REVISION 0x00
+
+///
+/// PDTT Platform Communication Channel Identifier Structure
+///
+typedef struct {
+  UINT16                        SubChannelIdentifer:8;
+  UINT16                        Runtime:1;
+  UINT16                        WaitForCompletion:1;
+  UINT16                        TriggerOrder:1;
+  UINT16                        Reserved:5;
+} EFI_ACPI_6_4_PDTT_PCC_IDENTIFIER;
+
+///
+/// PCC Commands Codes used by Platform Debug Trigger Table
+///
+#define EFI_ACPI_6_4_PDTT_PCC_COMMAND_DOORBELL_ONLY     0x00
+#define EFI_ACPI_6_4_PDTT_PCC_COMMAND_VENDOR_SPECIFIC   0x01
+
+///
+/// PDTT Platform Communication Channel
+///
+typedef EFI_ACPI_6_4_PCCT_GENERIC_SHARED_MEMORY_REGION_HEADER EFI_ACPI_6_4_PDTT_PCC;
+
+///
+/// Processor Properties Topology Table (PPTT)
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+} EFI_ACPI_6_4_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_HEADER;
+
+///
+/// PPTT Revision (as defined in ACPI 6.4 spec.)
+///
+#define EFI_ACPI_6_4_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_REVISION 0x03
+
+///
+/// PPTT types
+///
+#define EFI_ACPI_6_4_PPTT_TYPE_PROCESSOR     0x00
+#define EFI_ACPI_6_4_PPTT_TYPE_CACHE         0x01
+#define EFI_ACPI_6_4_PPTT_TYPE_ID            0x02
+
+///
+/// PPTT Structure Header
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Length;
+  UINT8                         Reserved[2];
+} EFI_ACPI_6_4_PPTT_STRUCTURE_HEADER;
+
+///
+/// For PPTT struct processor flags
+///
+#define EFI_ACPI_6_4_PPTT_PACKAGE_NOT_PHYSICAL          0x0
+#define EFI_ACPI_6_4_PPTT_PACKAGE_PHYSICAL              0x1
+#define EFI_ACPI_6_4_PPTT_PROCESSOR_ID_INVALID          0x0
+#define EFI_ACPI_6_4_PPTT_PROCESSOR_ID_VALID            0x1
+#define EFI_ACPI_6_4_PPTT_PROCESSOR_IS_NOT_THREAD       0x0
+#define EFI_ACPI_6_4_PPTT_PROCESSOR_IS_THREAD           0x1
+#define EFI_ACPI_6_4_PPTT_NODE_IS_NOT_LEAF              0x0
+#define EFI_ACPI_6_4_PPTT_NODE_IS_LEAF                  0x1
+#define EFI_ACPI_6_4_PPTT_IMPLEMENTATION_NOT_IDENTICAL  0x0
+#define EFI_ACPI_6_4_PPTT_IMPLEMENTATION_IDENTICAL      0x1
+
+///
+/// Processor hierarchy node structure flags
+///
+typedef struct {
+  UINT32                        PhysicalPackage:1;
+  UINT32                        AcpiProcessorIdValid:1;
+  UINT32                        ProcessorIsAThread:1;
+  UINT32                        NodeIsALeaf:1;
+  UINT32                        IdenticalImplementation:1;
+  UINT32                        Reserved:27;
+} EFI_ACPI_6_4_PPTT_STRUCTURE_PROCESSOR_FLAGS;
+
+///
+/// Processor hierarchy node structure
+///
+typedef struct {
+  UINT8                                         Type;
+  UINT8                                         Length;
+  UINT8                                         Reserved[2];
+  EFI_ACPI_6_4_PPTT_STRUCTURE_PROCESSOR_FLAGS   Flags;
+  UINT32                                        Parent;
+  UINT32                                        AcpiProcessorId;
+  UINT32                                        NumberOfPrivateResources;
+} EFI_ACPI_6_4_PPTT_STRUCTURE_PROCESSOR;
+
+///
+/// For PPTT struct cache flags
+///
+#define EFI_ACPI_6_4_PPTT_CACHE_SIZE_INVALID        0x0
+#define EFI_ACPI_6_4_PPTT_CACHE_SIZE_VALID          0x1
+#define EFI_ACPI_6_4_PPTT_NUMBER_OF_SETS_INVALID    0x0
+#define EFI_ACPI_6_4_PPTT_NUMBER_OF_SETS_VALID      0x1
+#define EFI_ACPI_6_4_PPTT_ASSOCIATIVITY_INVALID     0x0
+#define EFI_ACPI_6_4_PPTT_ASSOCIATIVITY_VALID       0x1
+#define EFI_ACPI_6_4_PPTT_ALLOCATION_TYPE_INVALID   0x0
+#define EFI_ACPI_6_4_PPTT_ALLOCATION_TYPE_VALID     0x1
+#define EFI_ACPI_6_4_PPTT_CACHE_TYPE_INVALID        0x0
+#define EFI_ACPI_6_4_PPTT_CACHE_TYPE_VALID          0x1
+#define EFI_ACPI_6_4_PPTT_WRITE_POLICY_INVALID      0x0
+#define EFI_ACPI_6_4_PPTT_WRITE_POLICY_VALID        0x1
+#define EFI_ACPI_6_4_PPTT_LINE_SIZE_INVALID         0x0
+#define EFI_ACPI_6_4_PPTT_LINE_SIZE_VALID           0x1
+
+///
+/// Cache Type Structure flags
+///
+typedef struct {
+  UINT32                        SizePropertyValid:1;
+  UINT32                        NumberOfSetsValid:1;
+  UINT32                        AssociativityValid:1;
+  UINT32                        AllocationTypeValid:1;
+  UINT32                        CacheTypeValid:1;
+  UINT32                        WritePolicyValid:1;
+  UINT32                        LineSizeValid:1;
+  UINT32                        CacheIdValid:1;
+  UINT32                        Reserved:24;
+} EFI_ACPI_6_4_PPTT_STRUCTURE_CACHE_FLAGS;
+
+///
+/// For cache attributes
+///
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_ALLOCATION_READ            0x0
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_ALLOCATION_WRITE           0x1
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_ALLOCATION_READ_WRITE      0x2
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_CACHE_TYPE_DATA            0x0
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_CACHE_TYPE_INSTRUCTION     0x1
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_CACHE_TYPE_UNIFIED         0x2
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_BACK    0x0
+#define EFI_ACPI_6_4_CACHE_ATTRIBUTES_WRITE_POLICY_WRITE_THROUGH 0x1
+
+///
+/// Cache Type Structure cache attributes
+///
+typedef struct {
+  UINT8                         AllocationType:2;
+  UINT8                         CacheType:2;
+  UINT8                         WritePolicy:1;
+  UINT8                         Reserved:3;
+} EFI_ACPI_6_4_PPTT_STRUCTURE_CACHE_ATTRIBUTES;
+
+///
+/// Cache Type Structure
+///
+typedef struct {
+  UINT8                                         Type;
+  UINT8                                         Length;
+  UINT8                                         Reserved[2];
+  EFI_ACPI_6_4_PPTT_STRUCTURE_CACHE_FLAGS       Flags;
+  UINT32                                        NextLevelOfCache;
+  UINT32                                        Size;
+  UINT32                                        NumberOfSets;
+  UINT8                                         Associativity;
+  EFI_ACPI_6_4_PPTT_STRUCTURE_CACHE_ATTRIBUTES  Attributes;
+  UINT16                                        LineSize;
+  UINT32                                        CacheId;
+} EFI_ACPI_6_4_PPTT_STRUCTURE_CACHE;
+
+///
+/// ID structure
+///
+typedef struct {
+  UINT8                         Type;
+  UINT8                         Length;
+  UINT8                         Reserved[2];
+  UINT32                        VendorId;
+  UINT64                        Level1Id;
+  UINT64                        Level2Id;
+  UINT16                        MajorRev;
+  UINT16                        MinorRev;
+  UINT16                        SpinRev;
+} EFI_ACPI_6_4_PPTT_STRUCTURE_ID;
+
+///
+/// Platform Health Assessment Table (PHAT) Format
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER   Header;
+//UINT8                         PlatformTelemetryRecords[];
+} EFI_ACPI_6_4_PLATFORM_HEALTH_ASSESSMENT_TABLE;
+
+#define EFI_ACPI_6_4_PLATFORM_HEALTH_ASSESSMENT_TABLE_REVISION 0x01
+
+///
+/// PHAT Record Format
+///
+typedef struct {
+  UINT16  PlatformHealthAssessmentRecordType;
+  UINT16  RecordLength;
+  UINT8   Revision;
+//UINT8   Data[];
+} EFI_ACPI_6_4_PHAT_RECORD;
+
+///
+/// PHAT Record Type Format
+///
+#define EFI_ACPI_6_4_PHAT_RECORD_TYPE_FIRMWARE_VERSION_DATA_RECORD  0x0000
+#define EFI_ACPI_6_4_PHAT_RECORD_TYPE_FIRMWARE_HEALTH_DATA_RECORD   0x0001
+
+///
+/// PHAT Version Element
+///
+typedef struct {
+  GUID    ComponentId;
+  UINT64  VersionValue;
+  UINT32  ProducerId;
+} EFI_ACPI_6_4_PHAT_VERSION_ELEMENT;
+
+///
+/// PHAT Firmware Version Data Record
+///
+typedef struct {
+  UINT16  PlatformRecordType;
+  UINT16  RecordLength;
+  UINT8   Revision;
+  UINT8   Reserved[3];
+  UINT32  RecordCount;
+//UINT8   PhatVersionElement[];
+} EFI_ACPI_6_4_PHAT_FIRMWARE_VERISON_DATA_RECORD;
+
+#define EFI_ACPI_6_4_PHAT_FIRMWARE_VERSION_DATA_RECORD_REVISION   0x01
+
+///
+/// Firmware Health Data Record Structure
+///
+typedef struct {
+  UINT16  PlatformRecordType;
+  UINT16  RecordLength;
+  UINT8   Revision;
+  UINT16  Reserved;
+  UINT8   AmHealthy;
+  GUID    DeviceSignature;
+  UINT32  DeviceSpecificDataOffset;
+//UINT8   DevicePath[];
+//UINT8   DeviceSpecificData[];
+} EFI_ACPI_6_4_PHAT_FIRMWARE_HEALTH_DATA_RECORD_STRUCTURE;
+
+#define EFI_ACPI_6_4_PHAT_FIRMWARE_HEALTH_DATA_RECORD_REVISION  0x01
+
+///
+/// Firmware Health Data Record device health state
+///
+#define EFI_ACPI_6_4_PHAT_FIRMWARE_HEALTH_DATA_RECORD_ERRORS_FOUND      0x00
+#define EFI_ACPI_6_4_PHAT_FIRMWARE_HEALTH_DATA_RECORD_NO_ERRORS_FOUND   0x01
+#define EFI_ACPI_6_4_PHAT_FIRMWARE_HEALTH_DATA_RECORD_UNKNOWN           0x02
+#define EFI_ACPI_6_4_PHAT_FIRMWARE_HEALTH_DATA_RECORD_ADVISORY          0x03
+
+//
+// Known table signatures
+//
+
+///
+/// "RSD PTR " Root System Description Pointer
+///
+#define EFI_ACPI_6_4_ROOT_SYSTEM_DESCRIPTION_POINTER_SIGNATURE  SIGNATURE_64('R', 'S', 'D', ' ', 'P', 'T', 'R', ' ')
+
+///
+/// "APIC" Multiple APIC Description Table
+///
+#define EFI_ACPI_6_4_MULTIPLE_APIC_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('A', 'P', 'I', 'C')
+
+///
+/// "BERT" Boot Error Record Table
+///
+#define EFI_ACPI_6_4_BOOT_ERROR_RECORD_TABLE_SIGNATURE  SIGNATURE_32('B', 'E', 'R', 'T')
+
+///
+/// "BGRT" Boot Graphics Resource Table
+///
+#define EFI_ACPI_6_4_BOOT_GRAPHICS_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('B', 'G', 'R', 'T')
+
+///
+/// "CDIT" Component Distance Information Table
+///
+#define EFI_ACPI_6_4_COMPONENT_DISTANCE_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('C', 'D', 'I', 'T')
+
+///
+/// "CPEP" Corrected Platform Error Polling Table
+///
+#define EFI_ACPI_6_4_CORRECTED_PLATFORM_ERROR_POLLING_TABLE_SIGNATURE  SIGNATURE_32('C', 'P', 'E', 'P')
+
+///
+/// "CRAT" Component Resource Attribute Table
+///
+#define EFI_ACPI_6_4_COMPONENT_RESOURCE_ATTRIBUTE_TABLE_SIGNATURE  SIGNATURE_32('C', 'R', 'A', 'T')
+
+///
+/// "DSDT" Differentiated System Description Table
+///
+#define EFI_ACPI_6_4_DIFFERENTIATED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('D', 'S', 'D', 'T')
+
+///
+/// "ECDT" Embedded Controller Boot Resources Table
+///
+#define EFI_ACPI_6_4_EMBEDDED_CONTROLLER_BOOT_RESOURCES_TABLE_SIGNATURE  SIGNATURE_32('E', 'C', 'D', 'T')
+
+///
+/// "EINJ" Error Injection Table
+///
+#define EFI_ACPI_6_4_ERROR_INJECTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'I', 'N', 'J')
+
+///
+/// "ERST" Error Record Serialization Table
+///
+#define EFI_ACPI_6_4_ERROR_RECORD_SERIALIZATION_TABLE_SIGNATURE  SIGNATURE_32('E', 'R', 'S', 'T')
+
+///
+/// "FACP" Fixed ACPI Description Table
+///
+#define EFI_ACPI_6_4_FIXED_ACPI_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'P')
+
+///
+/// "FACS" Firmware ACPI Control Structure
+///
+#define EFI_ACPI_6_4_FIRMWARE_ACPI_CONTROL_STRUCTURE_SIGNATURE  SIGNATURE_32('F', 'A', 'C', 'S')
+
+///
+/// "FPDT" Firmware Performance Data Table
+///
+#define EFI_ACPI_6_4_FIRMWARE_PERFORMANCE_DATA_TABLE_SIGNATURE  SIGNATURE_32('F', 'P', 'D', 'T')
+
+///
+/// "GTDT" Generic Timer Description Table
+///
+#define EFI_ACPI_6_4_GENERIC_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('G', 'T', 'D', 'T')
+
+///
+/// "HEST" Hardware Error Source Table
+///
+#define EFI_ACPI_6_4_HARDWARE_ERROR_SOURCE_TABLE_SIGNATURE  SIGNATURE_32('H', 'E', 'S', 'T')
+
+///
+/// "HMAT" Heterogeneous Memory Attribute Table
+///
+#define EFI_ACPI_6_4_HETEROGENEOUS_MEMORY_ATTRIBUTE_TABLE_SIGNATURE  SIGNATURE_32('H', 'M', 'A', 'T')
+
+///
+/// "MPST" Memory Power State Table
+///
+#define EFI_ACPI_6_4_MEMORY_POWER_STATE_TABLE_SIGNATURE  SIGNATURE_32('M', 'P', 'S', 'T')
+
+///
+/// "MSCT" Maximum System Characteristics Table
+///
+#define EFI_ACPI_6_4_MAXIMUM_SYSTEM_CHARACTERISTICS_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'C', 'T')
+
+///
+/// "NFIT" NVDIMM Firmware Interface Table
+///
+#define EFI_ACPI_6_4_NVDIMM_FIRMWARE_INTERFACE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('N', 'F', 'I', 'T')
+
+///
+/// "PDTT" Platform Debug Trigger Table
+///
+#define EFI_ACPI_6_4_PLATFORM_DEBUG_TRIGGER_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'D', 'T', 'T')
+
+///
+/// "PMTT" Platform Memory Topology Table
+///
+#define EFI_ACPI_6_4_PLATFORM_MEMORY_TOPOLOGY_TABLE_SIGNATURE  SIGNATURE_32('P', 'M', 'T', 'T')
+
+///
+/// "PPTT" Processor Properties Topology Table
+///
+#define EFI_ACPI_6_4_PROCESSOR_PROPERTIES_TOPOLOGY_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('P', 'P', 'T', 'T')
+
+///
+/// "PSDT" Persistent System Description Table
+///
+#define EFI_ACPI_6_4_PERSISTENT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('P', 'S', 'D', 'T')
+
+///
+/// "RASF" ACPI RAS Feature Table
+///
+#define EFI_ACPI_6_4_ACPI_RAS_FEATURE_TABLE_SIGNATURE  SIGNATURE_32('R', 'A', 'S', 'F')
+
+///
+/// "RSDT" Root System Description Table
+///
+#define EFI_ACPI_6_4_ROOT_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('R', 'S', 'D', 'T')
+
+///
+/// "SBST" Smart Battery Specification Table
+///
+#define EFI_ACPI_6_4_SMART_BATTERY_SPECIFICATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'B', 'S', 'T')
+
+///
+/// "SDEV" Secure DEVices Table
+///
+#define EFI_ACPI_6_4_SECURE_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'V')
+
+///
+/// "SLIT" System Locality Information Table
+///
+#define EFI_ACPI_6_4_SYSTEM_LOCALITY_INFORMATION_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'T')
+
+///
+/// "SRAT" System Resource Affinity Table
+///
+#define EFI_ACPI_6_4_SYSTEM_RESOURCE_AFFINITY_TABLE_SIGNATURE  SIGNATURE_32('S', 'R', 'A', 'T')
+
+///
+/// "SSDT" Secondary System Description Table
+///
+#define EFI_ACPI_6_4_SECONDARY_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'S', 'D', 'T')
+
+///
+/// "XSDT" Extended System Description Table
+///
+#define EFI_ACPI_6_4_EXTENDED_SYSTEM_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('X', 'S', 'D', 'T')
+
+///
+/// "BOOT" MS Simple Boot Spec
+///
+#define EFI_ACPI_6_4_SIMPLE_BOOT_FLAG_TABLE_SIGNATURE  SIGNATURE_32('B', 'O', 'O', 'T')
+
+///
+/// "CSRT" MS Core System Resource Table
+///
+#define EFI_ACPI_6_4_CORE_SYSTEM_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('C', 'S', 'R', 'T')
+
+///
+/// "DBG2" MS Debug Port 2 Spec
+///
+#define EFI_ACPI_6_4_DEBUG_PORT_2_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', '2')
+
+///
+/// "DBGP" MS Debug Port Spec
+///
+#define EFI_ACPI_6_4_DEBUG_PORT_TABLE_SIGNATURE  SIGNATURE_32('D', 'B', 'G', 'P')
+
+///
+/// "DMAR" DMA Remapping Table
+///
+#define EFI_ACPI_6_4_DMA_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('D', 'M', 'A', 'R')
+
+///
+/// "DRTM" Dynamic Root of Trust for Measurement Table
+///
+#define EFI_ACPI_6_4_DYNAMIC_ROOT_OF_TRUST_FOR_MEASUREMENT_TABLE_SIGNATURE  SIGNATURE_32('D', 'R', 'T', 'M')
+
+///
+/// "ETDT" Event Timer Description Table
+///
+#define EFI_ACPI_6_4_EVENT_TIMER_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('E', 'T', 'D', 'T')
+
+///
+/// "HPET" IA-PC High Precision Event Timer Table
+///
+#define EFI_ACPI_6_4_HIGH_PRECISION_EVENT_TIMER_TABLE_SIGNATURE  SIGNATURE_32('H', 'P', 'E', 'T')
+
+///
+/// "iBFT" iSCSI Boot Firmware Table
+///
+#define EFI_ACPI_6_4_ISCSI_BOOT_FIRMWARE_TABLE_SIGNATURE  SIGNATURE_32('i', 'B', 'F', 'T')
+
+///
+/// "IORT" I/O Remapping Table
+///
+#define EFI_ACPI_6_4_IO_REMAPPING_TABLE_SIGNATURE  SIGNATURE_32('I', 'O', 'R', 'T')
+
+///
+/// "IVRS" I/O Virtualization Reporting Structure
+///
+#define EFI_ACPI_6_4_IO_VIRTUALIZATION_REPORTING_STRUCTURE_SIGNATURE  SIGNATURE_32('I', 'V', 'R', 'S')
+
+///
+/// "LPIT" Low Power Idle Table
+///
+#define EFI_ACPI_6_4_LOW_POWER_IDLE_TABLE_STRUCTURE_SIGNATURE  SIGNATURE_32('L', 'P', 'I', 'T')
+
+///
+/// "MCFG" PCI Express Memory Mapped Configuration Space Base Address Description Table
+///
+#define EFI_ACPI_6_4_PCI_EXPRESS_MEMORY_MAPPED_CONFIGURATION_SPACE_BASE_ADDRESS_DESCRIPTION_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'F', 'G')
+
+///
+/// "MCHI" Management Controller Host Interface Table
+///
+#define EFI_ACPI_6_4_MANAGEMENT_CONTROLLER_HOST_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('M', 'C', 'H', 'I')
+
+///
+/// "MSDM" MS Data Management Table
+///
+#define EFI_ACPI_6_4_DATA_MANAGEMENT_TABLE_SIGNATURE  SIGNATURE_32('M', 'S', 'D', 'M')
+
+///
+/// "PCCT" Platform Communications Channel Table
+///
+#define EFI_ACPI_6_4_PLATFORM_COMMUNICATIONS_CHANNEL_TABLE_SIGNATURE  SIGNATURE_32('P', 'C', 'C', 'T')
+
+///
+/// "PHAT" Platform Health Assessment Table
+///
+#define EFI_ACPI_6_4_PLATFORM_HEALTH_ASSESSMENT_TABLE_SIGNATURE SIGNATURE_32('P', 'H', 'A', 'T')
+
+///
+/// "SDEI" Software Delegated Exceptions Interface Table
+///
+#define EFI_ACPI_6_4_SOFTWARE_DELEGATED_EXCEPTIONS_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'D', 'E', 'I')
+
+///
+/// "SLIC" MS Software Licensing Table Specification
+///
+#define EFI_ACPI_6_4_SOFTWARE_LICENSING_TABLE_SIGNATURE  SIGNATURE_32('S', 'L', 'I', 'C')
+
+///
+/// "SPCR" Serial Port Concole Redirection Table
+///
+#define EFI_ACPI_6_4_SERIAL_PORT_CONSOLE_REDIRECTION_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'C', 'R')
+
+///
+/// "SPMI" Server Platform Management Interface Table
+///
+#define EFI_ACPI_6_4_SERVER_PLATFORM_MANAGEMENT_INTERFACE_TABLE_SIGNATURE  SIGNATURE_32('S', 'P', 'M', 'I')
+
+///
+/// "STAO" _STA Override Table
+///
+#define EFI_ACPI_6_4_STA_OVERRIDE_TABLE_SIGNATURE  SIGNATURE_32('S', 'T', 'A', 'O')
+
+///
+/// "TCPA" Trusted Computing Platform Alliance Capabilities Table
+///
+#define EFI_ACPI_6_4_TRUSTED_COMPUTING_PLATFORM_ALLIANCE_CAPABILITIES_TABLE_SIGNATURE  SIGNATURE_32('T', 'C', 'P', 'A')
+
+///
+/// "TPM2" Trusted Computing Platform 1 Table
+///
+#define EFI_ACPI_6_4_TRUSTED_COMPUTING_PLATFORM_2_TABLE_SIGNATURE  SIGNATURE_32('T', 'P', 'M', '2')
+
+///
+/// "UEFI" UEFI ACPI Data Table
+///
+#define EFI_ACPI_6_4_UEFI_ACPI_DATA_TABLE_SIGNATURE  SIGNATURE_32('U', 'E', 'F', 'I')
+
+///
+/// "WAET" Windows ACPI Emulated Devices Table
+///
+#define EFI_ACPI_6_4_WINDOWS_ACPI_EMULATED_DEVICES_TABLE_SIGNATURE  SIGNATURE_32('W', 'A', 'E', 'T')
+
+///
+/// "WDAT" Watchdog Action Table
+///
+#define EFI_ACPI_6_4_WATCHDOG_ACTION_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'A', 'T')
+
+///
+/// "WDRT" Watchdog Resource Table
+///
+#define EFI_ACPI_6_4_WATCHDOG_RESOURCE_TABLE_SIGNATURE  SIGNATURE_32('W', 'D', 'R', 'T')
+
+///
+/// "WPBT" MS Platform Binary Table
+///
+#define EFI_ACPI_6_4_PLATFORM_BINARY_TABLE_SIGNATURE  SIGNATURE_32('W', 'P', 'B', 'T')
+
+///
+/// "WSMT" Windows SMM Security Mitigation Table
+///
+#define EFI_ACPI_6_4_WINDOWS_SMM_SECURITY_MITIGATION_TABLE_SIGNATURE  SIGNATURE_32('W', 'S', 'M', 'T')
+
+///
+/// "XENV" Xen Project Table
+///
+#define EFI_ACPI_6_4_XEN_PROJECT_TABLE_SIGNATURE  SIGNATURE_32('X', 'E', 'N', 'V')
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/AcpiAml.h b/libedk2_tpm/include/IndustryStandard/AcpiAml.h
new file mode 100644
index 0000000..7aae14b
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/AcpiAml.h
@@ -0,0 +1,184 @@
+/** @file
+  This file contains AML code definition in the latest ACPI spec.
+
+  Copyright (c) 2011, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2019 - 2021, Arm Limited. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _ACPI_AML_H_
+#define _ACPI_AML_H_
+
+//
+// ACPI AML definition
+//
+
+//
+// Primary OpCode
+//
+#define AML_ZERO_OP                  0x00
+#define AML_ONE_OP                   0x01
+#define AML_ALIAS_OP                 0x06
+#define AML_NAME_OP                  0x08
+#define AML_BYTE_PREFIX              0x0a
+#define AML_WORD_PREFIX              0x0b
+#define AML_DWORD_PREFIX             0x0c
+#define AML_STRING_PREFIX            0x0d
+#define AML_QWORD_PREFIX             0x0e
+#define AML_SCOPE_OP                 0x10
+#define AML_BUFFER_OP                0x11
+#define AML_PACKAGE_OP               0x12
+#define AML_VAR_PACKAGE_OP           0x13
+#define AML_METHOD_OP                0x14
+#define AML_EXTERNAL_OP              0x15
+#define AML_DUAL_NAME_PREFIX         0x2e
+#define AML_MULTI_NAME_PREFIX        0x2f
+#define AML_NAME_CHAR_A              0x41
+#define AML_NAME_CHAR_B              0x42
+#define AML_NAME_CHAR_C              0x43
+#define AML_NAME_CHAR_D              0x44
+#define AML_NAME_CHAR_E              0x45
+#define AML_NAME_CHAR_F              0x46
+#define AML_NAME_CHAR_G              0x47
+#define AML_NAME_CHAR_H              0x48
+#define AML_NAME_CHAR_I              0x49
+#define AML_NAME_CHAR_J              0x4a
+#define AML_NAME_CHAR_K              0x4b
+#define AML_NAME_CHAR_L              0x4c
+#define AML_NAME_CHAR_M              0x4d
+#define AML_NAME_CHAR_N              0x4e
+#define AML_NAME_CHAR_O              0x4f
+#define AML_NAME_CHAR_P              0x50
+#define AML_NAME_CHAR_Q              0x51
+#define AML_NAME_CHAR_R              0x52
+#define AML_NAME_CHAR_S              0x53
+#define AML_NAME_CHAR_T              0x54
+#define AML_NAME_CHAR_U              0x55
+#define AML_NAME_CHAR_V              0x56
+#define AML_NAME_CHAR_W              0x57
+#define AML_NAME_CHAR_X              0x58
+#define AML_NAME_CHAR_Y              0x59
+#define AML_NAME_CHAR_Z              0x5a
+#define AML_ROOT_CHAR                0x5c
+#define AML_PARENT_PREFIX_CHAR       0x5e
+#define AML_NAME_CHAR__              0x5f
+#define AML_LOCAL0                   0x60
+#define AML_LOCAL1                   0x61
+#define AML_LOCAL2                   0x62
+#define AML_LOCAL3                   0x63
+#define AML_LOCAL4                   0x64
+#define AML_LOCAL5                   0x65
+#define AML_LOCAL6                   0x66
+#define AML_LOCAL7                   0x67
+#define AML_ARG0                     0x68
+#define AML_ARG1                     0x69
+#define AML_ARG2                     0x6a
+#define AML_ARG3                     0x6b
+#define AML_ARG4                     0x6c
+#define AML_ARG5                     0x6d
+#define AML_ARG6                     0x6e
+#define AML_STORE_OP                 0x70
+#define AML_REF_OF_OP                0x71
+#define AML_ADD_OP                   0x72
+#define AML_CONCAT_OP                0x73
+#define AML_SUBTRACT_OP              0x74
+#define AML_INCREMENT_OP             0x75
+#define AML_DECREMENT_OP             0x76
+#define AML_MULTIPLY_OP              0x77
+#define AML_DIVIDE_OP                0x78
+#define AML_SHIFT_LEFT_OP            0x79
+#define AML_SHIFT_RIGHT_OP           0x7a
+#define AML_AND_OP                   0x7b
+#define AML_NAND_OP                  0x7c
+#define AML_OR_OP                    0x7d
+#define AML_NOR_OP                   0x7e
+#define AML_XOR_OP                   0x7f
+#define AML_NOT_OP                   0x80
+#define AML_FIND_SET_LEFT_BIT_OP     0x81
+#define AML_FIND_SET_RIGHT_BIT_OP    0x82
+#define AML_DEREF_OF_OP              0x83
+#define AML_CONCAT_RES_OP            0x84
+#define AML_MOD_OP                   0x85
+#define AML_NOTIFY_OP                0x86
+#define AML_SIZE_OF_OP               0x87
+#define AML_INDEX_OP                 0x88
+#define AML_MATCH_OP                 0x89
+#define AML_CREATE_DWORD_FIELD_OP    0x8a
+#define AML_CREATE_WORD_FIELD_OP     0x8b
+#define AML_CREATE_BYTE_FIELD_OP     0x8c
+#define AML_CREATE_BIT_FIELD_OP      0x8d
+#define AML_OBJECT_TYPE_OP           0x8e
+#define AML_CREATE_QWORD_FIELD_OP    0x8f
+#define AML_LAND_OP                  0x90
+#define AML_LOR_OP                   0x91
+#define AML_LNOT_OP                  0x92
+#define AML_LEQUAL_OP                0x93
+#define AML_LGREATER_OP              0x94
+#define AML_LLESS_OP                 0x95
+#define AML_TO_BUFFER_OP             0x96
+#define AML_TO_DEC_STRING_OP         0x97
+#define AML_TO_HEX_STRING_OP         0x98
+#define AML_TO_INTEGER_OP            0x99
+#define AML_TO_STRING_OP             0x9c
+#define AML_COPY_OBJECT_OP           0x9d
+#define AML_MID_OP                   0x9e
+#define AML_CONTINUE_OP              0x9f
+#define AML_IF_OP                    0xa0
+#define AML_ELSE_OP                  0xa1
+#define AML_WHILE_OP                 0xa2
+#define AML_NOOP_OP                  0xa3
+#define AML_RETURN_OP                0xa4
+#define AML_BREAK_OP                 0xa5
+#define AML_BREAK_POINT_OP           0xcc
+#define AML_ONES_OP                  0xff
+
+//
+// Extended OpCode
+//
+#define AML_EXT_OP                   0x5b
+
+#define AML_EXT_MUTEX_OP             0x01
+#define AML_EXT_EVENT_OP             0x02
+#define AML_EXT_COND_REF_OF_OP       0x12
+#define AML_EXT_CREATE_FIELD_OP      0x13
+#define AML_EXT_LOAD_TABLE_OP        0x1f
+#define AML_EXT_LOAD_OP              0x20
+#define AML_EXT_STALL_OP             0x21
+#define AML_EXT_SLEEP_OP             0x22
+#define AML_EXT_ACQUIRE_OP           0x23
+#define AML_EXT_SIGNAL_OP            0x24
+#define AML_EXT_WAIT_OP              0x25
+#define AML_EXT_RESET_OP             0x26
+#define AML_EXT_RELEASE_OP           0x27
+#define AML_EXT_FROM_BCD_OP          0x28
+#define AML_EXT_TO_BCD_OP            0x29
+#define AML_EXT_UNLOAD_OP            0x2a
+#define AML_EXT_REVISION_OP          0x30
+#define AML_EXT_DEBUG_OP             0x31
+#define AML_EXT_FATAL_OP             0x32
+#define AML_EXT_TIMER_OP             0x33
+#define AML_EXT_REGION_OP            0x80
+#define AML_EXT_FIELD_OP             0x81
+#define AML_EXT_DEVICE_OP            0x82
+#define AML_EXT_PROCESSOR_OP         0x83
+#define AML_EXT_POWER_RES_OP         0x84
+#define AML_EXT_THERMAL_ZONE_OP      0x85
+#define AML_EXT_INDEX_FIELD_OP       0x86
+#define AML_EXT_BANK_FIELD_OP        0x87
+#define AML_EXT_DATA_REGION_OP       0x88
+
+//
+// FieldElement OpCode
+//
+#define AML_FIELD_RESERVED_OP        0x00
+#define AML_FIELD_ACCESS_OP          0x01
+#define AML_FIELD_CONNECTION_OP      0x02
+#define AML_FIELD_EXT_ACCESS_OP      0x03
+
+//
+// AML Name segment definitions
+//
+#define AML_NAME_SEG_SIZE            4
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Atapi.h b/libedk2_tpm/include/IndustryStandard/Atapi.h
new file mode 100644
index 0000000..a886f59
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Atapi.h
@@ -0,0 +1,851 @@
+/** @file
+  This file contains just some basic definitions that are needed by drivers
+  that dealing with ATA/ATAPI interface.
+
+Copyright (c) 2007 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _ATAPI_H_
+#define _ATAPI_H_
+
+#pragma pack(1)
+
+///
+/// ATA5_IDENTIFY_DATA is defined in ATA-5.
+/// (This structure is provided mainly for backward-compatibility support.
+/// Old drivers may reference fields that are marked "obsolete" in
+/// ATA_IDENTIFY_DATA, which currently conforms to ATA-8.)
+///
+typedef struct {
+  UINT16  config;             ///< General Configuration.
+  UINT16  cylinders;          ///< Number of Cylinders.
+  UINT16  reserved_2;
+  UINT16  heads;              ///< Number of logical heads.
+  UINT16  vendor_data1;
+  UINT16  vendor_data2;
+  UINT16  sectors_per_track;
+  UINT16  vendor_specific_7_9[3];
+  CHAR8   SerialNo[20];       ///< ASCII
+  UINT16  vendor_specific_20_21[2];
+  UINT16  ecc_bytes_available;
+  CHAR8   FirmwareVer[8];     ///< ASCII
+  CHAR8   ModelName[40];      ///< ASCII
+  UINT16  multi_sector_cmd_max_sct_cnt;
+  UINT16  reserved_48;
+  UINT16  capabilities;
+  UINT16  reserved_50;
+  UINT16  pio_cycle_timing;
+  UINT16  reserved_52;
+  UINT16  field_validity;
+  UINT16  current_cylinders;
+  UINT16  current_heads;
+  UINT16  current_sectors;
+  UINT16  CurrentCapacityLsb;
+  UINT16  CurrentCapacityMsb;
+  UINT16  reserved_59;
+  UINT16  user_addressable_sectors_lo;
+  UINT16  user_addressable_sectors_hi;
+  UINT16  reserved_62;
+  UINT16  multi_word_dma_mode;
+  UINT16  advanced_pio_modes;
+  UINT16  min_multi_word_dma_cycle_time;
+  UINT16  rec_multi_word_dma_cycle_time;
+  UINT16  min_pio_cycle_time_without_flow_control;
+  UINT16  min_pio_cycle_time_with_flow_control;
+  UINT16  reserved_69_79[11];
+  UINT16  major_version_no;
+  UINT16  minor_version_no;
+  UINT16  command_set_supported_82;    ///< word 82
+  UINT16  command_set_supported_83;    ///< word 83
+  UINT16  command_set_feature_extn;    ///< word 84
+  UINT16  command_set_feature_enb_85;  ///< word 85
+  UINT16  command_set_feature_enb_86;  ///< word 86
+  UINT16  command_set_feature_default; ///< word 87
+  UINT16  ultra_dma_mode;              ///< word 88
+  UINT16  reserved_89_127[39];
+  UINT16  security_status;
+  UINT16  vendor_data_129_159[31];
+  UINT16  reserved_160_255[96];
+} ATA5_IDENTIFY_DATA;
+
+///
+/// ATA_IDENTIFY_DATA strictly complies with ATA/ATAPI-8 Spec
+/// to define the data returned by an ATA device upon successful
+/// completion of the ATA IDENTIFY_DEVICE command.
+///
+typedef struct {
+  UINT16  config;                                  ///< General Configuration.
+  UINT16  obsolete_1;
+  UINT16  specific_config;                         ///< Specific Configuration.
+  UINT16  obsolete_3;
+  UINT16  retired_4_5[2];
+  UINT16  obsolete_6;
+  UINT16  cfa_reserved_7_8[2];
+  UINT16  retired_9;
+  CHAR8   SerialNo[20];                            ///< word 10~19
+  UINT16  retired_20_21[2];
+  UINT16  obsolete_22;
+  CHAR8   FirmwareVer[8];                          ///< word 23~26
+  CHAR8   ModelName[40];                           ///< word 27~46
+  UINT16  multi_sector_cmd_max_sct_cnt;
+  UINT16  trusted_computing_support;
+  UINT16  capabilities_49;
+  UINT16  capabilities_50;
+  UINT16  obsolete_51_52[2];
+  UINT16  field_validity;
+  UINT16  obsolete_54_58[5];
+  UINT16  multi_sector_setting;
+  UINT16  user_addressable_sectors_lo;
+  UINT16  user_addressable_sectors_hi;
+  UINT16  obsolete_62;
+  UINT16  multi_word_dma_mode;
+  UINT16  advanced_pio_modes;
+  UINT16  min_multi_word_dma_cycle_time;
+  UINT16  rec_multi_word_dma_cycle_time;
+  UINT16  min_pio_cycle_time_without_flow_control;
+  UINT16  min_pio_cycle_time_with_flow_control;
+  UINT16  additional_supported;                    ///< word 69
+  UINT16  reserved_70;
+  UINT16  reserved_71_74[4];                       ///< Reserved for IDENTIFY PACKET DEVICE cmd.
+  UINT16  queue_depth;
+  UINT16  serial_ata_capabilities;
+  UINT16  reserved_77;                             ///< Reserved for Serial ATA
+  UINT16  serial_ata_features_supported;
+  UINT16  serial_ata_features_enabled;
+  UINT16  major_version_no;
+  UINT16  minor_version_no;
+  UINT16  command_set_supported_82;                ///< word 82
+  UINT16  command_set_supported_83;                ///< word 83
+  UINT16  command_set_feature_extn;                ///< word 84
+  UINT16  command_set_feature_enb_85;              ///< word 85
+  UINT16  command_set_feature_enb_86;              ///< word 86
+  UINT16  command_set_feature_default;             ///< word 87
+  UINT16  ultra_dma_mode;                          ///< word 88
+  UINT16  time_for_security_erase_unit;
+  UINT16  time_for_enhanced_security_erase_unit;
+  UINT16  advanced_power_management_level;
+  UINT16  master_password_identifier;
+  UINT16  hardware_configuration_test_result;
+  UINT16  obsolete_94;
+  UINT16  stream_minimum_request_size;
+  UINT16  streaming_transfer_time_for_dma;
+  UINT16  streaming_access_latency_for_dma_and_pio;
+  UINT16  streaming_performance_granularity[2];    ///< word 98~99
+  UINT16  maximum_lba_for_48bit_addressing[4];     ///< word 100~103
+  UINT16  streaming_transfer_time_for_pio;
+  UINT16  max_no_of_512byte_blocks_per_data_set_cmd;
+  UINT16  phy_logic_sector_support;                ///< word 106
+  UINT16  interseek_delay_for_iso7779;
+  UINT16  world_wide_name[4];                      ///< word 108~111
+  UINT16  reserved_for_128bit_wwn_112_115[4];
+  UINT16  reserved_for_technical_report;
+  UINT16  logic_sector_size_lo;                    ///< word 117
+  UINT16  logic_sector_size_hi;                    ///< word 118
+  UINT16  features_and_command_sets_supported_ext; ///< word 119
+  UINT16  features_and_command_sets_enabled_ext;   ///< word 120
+  UINT16  reserved_121_126[6];
+  UINT16  obsolete_127;
+  UINT16  security_status;                         ///< word 128
+  UINT16  vendor_specific_129_159[31];
+  UINT16  cfa_power_mode;                          ///< word 160
+  UINT16  reserved_for_compactflash_161_167[7];
+  UINT16  device_nominal_form_factor;
+  UINT16  is_data_set_cmd_supported;
+  CHAR8   additional_product_identifier[8];
+  UINT16  reserved_174_175[2];
+  CHAR8   media_serial_number[60];                 ///< word 176~205
+  UINT16  sct_command_transport;                   ///< word 206
+  UINT16  reserved_207_208[2];
+  UINT16  alignment_logic_in_phy_blocks;           ///< word 209
+  UINT16  write_read_verify_sector_count_mode3[2]; ///< word 210~211
+  UINT16  verify_sector_count_mode2[2];
+  UINT16  nv_cache_capabilities;
+  UINT16  nv_cache_size_in_logical_block_lsw;      ///< word 215
+  UINT16  nv_cache_size_in_logical_block_msw;      ///< word 216
+  UINT16  nominal_media_rotation_rate;
+  UINT16  reserved_218;
+  UINT16  nv_cache_options;                        ///< word 219
+  UINT16  write_read_verify_mode;                  ///< word 220
+  UINT16  reserved_221;
+  UINT16  transport_major_revision_number;
+  UINT16  transport_minor_revision_number;
+  UINT16  reserved_224_229[6];
+  UINT64  extended_no_of_addressable_sectors;
+  UINT16  min_number_per_download_microcode_mode3; ///< word 234
+  UINT16  max_number_per_download_microcode_mode3; ///< word 235
+  UINT16  reserved_236_254[19];
+  UINT16  integrity_word;
+} ATA_IDENTIFY_DATA;
+
+///
+/// ATAPI_IDENTIFY_DATA strictly complies with ATA/ATAPI-8 Spec
+/// to define the data returned by an ATAPI device upon successful
+/// completion of the ATA IDENTIFY_PACKET_DEVICE command.
+///
+typedef struct {
+  UINT16  config;                                  ///< General Configuration.
+  UINT16  reserved_1;
+  UINT16  specific_config;                         ///< Specific Configuration.
+  UINT16  reserved_3_9[7];
+  CHAR8   SerialNo[20];                            ///< word 10~19
+  UINT16  reserved_20_22[3];
+  CHAR8   FirmwareVer[8];                          ///< word 23~26
+  CHAR8   ModelName[40];                           ///< word 27~46
+  UINT16  reserved_47_48[2];
+  UINT16  capabilities_49;
+  UINT16  capabilities_50;
+  UINT16  obsolete_51;
+  UINT16  reserved_52;
+  UINT16  field_validity;                          ///< word 53
+  UINT16  reserved_54_61[8];
+  UINT16  dma_dir;
+  UINT16  multi_word_dma_mode;                     ///< word 63
+  UINT16  advanced_pio_modes;                      ///< word 64
+  UINT16  min_multi_word_dma_cycle_time;
+  UINT16  rec_multi_word_dma_cycle_time;
+  UINT16  min_pio_cycle_time_without_flow_control;
+  UINT16  min_pio_cycle_time_with_flow_control;
+  UINT16  reserved_69_70[2];
+  UINT16  obsolete_71_72[2];
+  UINT16  reserved_73_74[2];
+  UINT16  obsolete_75;
+  UINT16  serial_ata_capabilities;
+  UINT16  reserved_77;                             ///< Reserved for Serial ATA
+  UINT16  serial_ata_features_supported;
+  UINT16  serial_ata_features_enabled;
+  UINT16  major_version_no;                        ///< word 80
+  UINT16  minor_version_no;                        ///< word 81
+  UINT16  cmd_set_support_82;
+  UINT16  cmd_set_support_83;
+  UINT16  cmd_feature_support;
+  UINT16  cmd_feature_enable_85;
+  UINT16  cmd_feature_enable_86;
+  UINT16  cmd_feature_default;
+  UINT16  ultra_dma_select;
+  UINT16  time_required_for_sec_erase;             ///< word 89
+  UINT16  time_required_for_enhanced_sec_erase;    ///< word 90
+  UINT16  advanced_power_management_level;
+  UINT16  master_pwd_revison_code;
+  UINT16  hardware_reset_result;                   ///< word 93
+  UINT16  obsolete_94;
+  UINT16  reserved_95_107[13];
+  UINT16  world_wide_name[4];                      ///< word 108~111
+  UINT16  reserved_for_128bit_wwn_112_115[4];
+  UINT16  reserved_116_118[3];
+  UINT16  command_and_feature_sets_supported;      ///< word 119
+  UINT16  command_and_feature_sets_supported_enabled;
+  UINT16  reserved_121_124[4];
+  UINT16  atapi_byte_count_0_behavior;             ///< word 125
+  UINT16  obsolete_126_127[2];
+  UINT16  security_status;
+  UINT16  reserved_129_159[31];
+  UINT16  cfa_reserved_160_175[16];
+  UINT16  reserved_176_221[46];
+  UINT16  transport_major_version;
+  UINT16  transport_minor_version;
+  UINT16  reserved_224_254[31];
+  UINT16  integrity_word;
+} ATAPI_IDENTIFY_DATA;
+
+
+///
+/// Standard Quiry Data format, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 peripheral_type;
+  UINT8 RMB;
+  UINT8 version;
+  UINT8 response_data_format;
+  UINT8 addnl_length;     ///< n - 4, Numbers of bytes following this one.
+  UINT8 reserved_5;
+  UINT8 reserved_6;
+  UINT8 reserved_7;
+  UINT8 vendor_info[8];
+  UINT8 product_id[16];
+  UINT8 product_revision_level[4];
+  UINT8 vendor_specific_36_55[55 - 36 + 1];
+  UINT8 reserved_56_95[95 - 56 + 1];
+  ///
+  /// Vendor-specific parameters fields. The sizeof (ATAPI_INQUIRY_DATA) is 254
+  /// since allocation_length is one byte in ATAPI_INQUIRY_CMD.
+  ///
+  UINT8 vendor_specific_96_253[253 - 96 + 1];
+} ATAPI_INQUIRY_DATA;
+
+///
+/// Request Sense Standard Data, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 error_code : 7;
+  UINT8 valid : 1;
+  UINT8 reserved_1;
+  UINT8 sense_key : 4;
+  UINT8 reserved_2 : 1;
+  UINT8 Vendor_specifc_1 : 3;
+  UINT8 vendor_specific_3;
+  UINT8 vendor_specific_4;
+  UINT8 vendor_specific_5;
+  UINT8 vendor_specific_6;
+  UINT8 addnl_sense_length;           ///< n - 7
+  UINT8 vendor_specific_8;
+  UINT8 vendor_specific_9;
+  UINT8 vendor_specific_10;
+  UINT8 vendor_specific_11;
+  UINT8 addnl_sense_code;             ///< mandatory
+  UINT8 addnl_sense_code_qualifier;   ///< mandatory
+  UINT8 field_replaceable_unit_code;  ///< optional
+  UINT8 sense_key_specific_15 : 7;
+  UINT8 SKSV : 1;
+  UINT8 sense_key_specific_16;
+  UINT8 sense_key_specific_17;
+} ATAPI_REQUEST_SENSE_DATA;
+
+///
+/// READ CAPACITY Data, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 LastLba3;
+  UINT8 LastLba2;
+  UINT8 LastLba1;
+  UINT8 LastLba0;
+  UINT8 BlockSize3;
+  UINT8 BlockSize2;
+  UINT8 BlockSize1;
+  UINT8 BlockSize0;
+} ATAPI_READ_CAPACITY_DATA;
+
+///
+/// Capacity List Header + Current/Maximum Capacity Descriptor,
+/// defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 reserved_0;
+  UINT8 reserved_1;
+  UINT8 reserved_2;
+  UINT8 Capacity_Length;
+  UINT8 LastLba3;
+  UINT8 LastLba2;
+  UINT8 LastLba1;
+  UINT8 LastLba0;
+  UINT8 DesCode : 2;
+  UINT8 reserved_9 : 6;
+  UINT8 BlockSize2;
+  UINT8 BlockSize1;
+  UINT8 BlockSize0;
+} ATAPI_READ_FORMAT_CAPACITY_DATA;
+
+///
+/// Test Unit Ready Command, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 opcode;
+  UINT8 reserved_1;
+  UINT8 reserved_2;
+  UINT8 reserved_3;
+  UINT8 reserved_4;
+  UINT8 reserved_5;
+  UINT8 reserved_6;
+  UINT8 reserved_7;
+  UINT8 reserved_8;
+  UINT8 reserved_9;
+  UINT8 reserved_10;
+  UINT8 reserved_11;
+} ATAPI_TEST_UNIT_READY_CMD;
+
+///
+/// INQUIRY Command, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 opcode;
+  UINT8 reserved_1 : 5;
+  UINT8 lun : 3;
+  UINT8 page_code;        ///< defined in SFF8090i, V6
+  UINT8 reserved_3;
+  UINT8 allocation_length;
+  UINT8 reserved_5;
+  UINT8 reserved_6;
+  UINT8 reserved_7;
+  UINT8 reserved_8;
+  UINT8 reserved_9;
+  UINT8 reserved_10;
+  UINT8 reserved_11;
+} ATAPI_INQUIRY_CMD;
+
+///
+/// REQUEST SENSE Command, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 opcode;
+  UINT8 reserved_1 : 5;
+  UINT8 lun : 3;
+  UINT8 reserved_2;
+  UINT8 reserved_3;
+  UINT8 allocation_length;
+  UINT8 reserved_5;
+  UINT8 reserved_6;
+  UINT8 reserved_7;
+  UINT8 reserved_8;
+  UINT8 reserved_9;
+  UINT8 reserved_10;
+  UINT8 reserved_11;
+} ATAPI_REQUEST_SENSE_CMD;
+
+///
+/// READ (10) Command, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 opcode;
+  UINT8 reserved_1 : 5;
+  UINT8 lun : 3;
+  UINT8 Lba0;
+  UINT8 Lba1;
+  UINT8 Lba2;
+  UINT8 Lba3;
+  UINT8 reserved_6;
+  UINT8 TranLen0;
+  UINT8 TranLen1;
+  UINT8 reserved_9;
+  UINT8 reserved_10;
+  UINT8 reserved_11;
+} ATAPI_READ10_CMD;
+
+///
+/// READ Format Capacity Command, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 opcode;
+  UINT8 reserved_1 : 5;
+  UINT8 lun : 3;
+  UINT8 reserved_2;
+  UINT8 reserved_3;
+  UINT8 reserved_4;
+  UINT8 reserved_5;
+  UINT8 reserved_6;
+  UINT8 allocation_length_hi;
+  UINT8 allocation_length_lo;
+  UINT8 reserved_9;
+  UINT8 reserved_10;
+  UINT8 reserved_11;
+} ATAPI_READ_FORMAT_CAP_CMD;
+
+///
+/// MODE SENSE Command, defined in SFF-8070i(ATAPI Removable Rewritable Specification).
+///
+typedef struct {
+  UINT8 opcode;
+  UINT8 reserved_1 : 5;
+  UINT8 lun : 3;
+  UINT8 page_code : 6;
+  UINT8 page_control : 2;
+  UINT8 reserved_3;
+  UINT8 reserved_4;
+  UINT8 reserved_5;
+  UINT8 reserved_6;
+  UINT8 parameter_list_length_hi;
+  UINT8 parameter_list_length_lo;
+  UINT8 reserved_9;
+  UINT8 reserved_10;
+  UINT8 reserved_11;
+} ATAPI_MODE_SENSE_CMD;
+
+///
+/// ATAPI_PACKET_COMMAND is not defined in the ATA specification.
+/// We add it here for the convenience of ATA/ATAPI module writers.
+///
+typedef union {
+  UINT16                    Data16[6];
+  ATAPI_TEST_UNIT_READY_CMD TestUnitReady;
+  ATAPI_READ10_CMD          Read10;
+  ATAPI_REQUEST_SENSE_CMD   RequestSence;
+  ATAPI_INQUIRY_CMD         Inquiry;
+  ATAPI_MODE_SENSE_CMD      ModeSense;
+  ATAPI_READ_FORMAT_CAP_CMD ReadFormatCapacity;
+} ATAPI_PACKET_COMMAND;
+
+#pragma pack()
+
+
+#define ATAPI_MAX_DMA_EXT_CMD_SECTORS                   0x10000
+#define ATAPI_MAX_DMA_CMD_SECTORS                       0x100
+
+//  ATA/ATAPI Signature equates
+#define ATA_SIGNATURE                                   0x0101       ///< defined in ACS-3
+#define ATAPI_SIGNATURE                                 0xeb14       ///< defined in ACS-3
+#define ATAPI_SIGNATURE_32                              0xeb140101   ///< defined in ACS-3
+
+//  Spin Up Configuration definitions
+#define ATA_SPINUP_CFG_REQUIRED_IDD_INCOMPLETE          0x37c8   ///< defined in ACS-3
+#define ATA_SPINUP_CFG_REQUIRED_IDD_COMPLETE            0x738c   ///< defined in ACS-3
+#define ATA_SPINUP_CFG_NOT_REQUIRED_IDD_INCOMPLETE      0x8c73   ///< defined in ACS-3
+#define ATA_SPINUP_CFG_NOT_REQUIRED_IDD_COMPLETE        0xc837   ///< defined in ACS-3
+
+//
+// ATA Packet Command Code
+//
+#define ATA_CMD_FORMAT_UNIT                             0x04   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_SOFT_RESET                              0x08   ///< defined from ATA-3
+#define ATA_CMD_PACKET                                  0xA0   ///< defined from ATA-3
+#define ATA_CMD_IDENTIFY_DEVICE                         0xA1   ///< defined from ATA-3
+#define ATA_CMD_SERVICE                                 0xA2   ///< defined from ATA-3
+#define ATA_CMD_TEST_UNIT_READY                         0x00   ///< defined from ATA-1
+#define ATA_CMD_REQUEST_SENSE                           0x03   ///< defined from ATA-4
+#define ATA_CMD_INQUIRY                                 0x12   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_READ_FORMAT_CAPACITY                    0x23   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_READ_CAPACITY                           0x25   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_READ_10                                 0x28   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_WRITE_10                                0x2A   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_ATAPI_SEEK                              0x2B   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_WRITE_AND_VERIFY                        0x2E   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_VERIFY                                  0x2F   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_READ_12                                 0xA8   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_WRITE_12                                0xAA   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_START_STOP_UNIT                         0x1B   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_PREVENT_ALLOW_MEDIA_REMOVAL             0x1E   ///< defined in ATAPI Removable Rewritable Media Devices
+#define ATA_CMD_MODE_SELECT                             0x55   ///< defined in ATAPI Removable Rewritable Media Devices
+
+#define ATA_CMD_MODE_SENSE                              0x5A   ///< defined in ATAPI Removable Rewritable Media Devices
+    #define ATA_PAGE_CODE_READ_WRITE_ERROR                  0x01   ///< defined in ATAPI Removable Rewritable Media Devices
+    #define ATA_PAGE_CODE_CACHING_PAGE                      0x08   ///< defined in ATAPI Removable Rewritable Media Devices
+    #define ATA_PAGE_CODE_REMOVABLE_BLOCK_CAPABILITIES      0x1B   ///< defined in ATAPI Removable Rewritable Media Devices
+    #define ATA_PAGE_CODE_TIMER_PROTECT_PAGE                0x1C   ///< defined in ATAPI Removable Rewritable Media Devices
+    #define ATA_PAGE_CODE_RETURN_ALL_PAGES                  0x3F   ///< defined in ATAPI Removable Rewritable Media Devices
+
+#define ATA_CMD_GET_CONFIGURATION                       0x46   ///< defined in ATAPI Multimedia Devices
+   #define ATA_GCCD_RT_FIELD_VALUE_ALL                      0x00   ///< defined in ATAPI Multimedia Devices
+   #define ATA_GCCD_RT_FIELD_VALUE_CURRENT                  0x01   ///< defined in ATAPI Multimedia Devices
+   #define ATA_GCCD_RT_FIELD_VALUE_SINGLE                   0x02   ///< defined in ATAPI Multimedia Devices
+   #define ATA_GCCD_RT_FIELD_VALUE_RESERVED                 0x03   ///< defined in ATAPI Multimedia Devices
+
+   #define ATA_FEATURE_LIST_PROFILE_LIST                    0x0000   ///< defined in ATAPI Multimedia Devices
+   #define ATA_FEATURE_LIST_CORE                            0x0001   ///< defined in ATAPI Multimedia Devices
+   #define ATA_FEATURE_LIST_MORPHING                        0x0002   ///< defined in ATAPI Multimedia Devices
+   #define ATA_FEATURE_LIST_REMOVEABLE_MEDIUM               0x0003   ///< defined in ATAPI Multimedia Devices
+   #define ATA_FEATURE_LIST_WRITE_PROTECT                   0x0004   ///< defined in ATAPI Multimedia Devices
+
+///
+/// Start/Stop and Eject Operations
+///
+///@{
+#define ATA_CMD_SUBOP_STOP_DISC                         0x00   ///< Stop the Disc
+#define ATA_CMD_SUBOP_START_DISC                        0x01   ///< Start the Disc and acquire the format type
+#define ATA_CMD_SUBOP_EJECT_DISC                        0x02   ///< Eject the Disc if possible
+#define ATA_CMD_SUBOP_CLOSE_TRAY                        0x03   ///< Load the Disc (Close Tray)
+///@}
+
+//
+// ATA Commands Code
+//
+
+//
+// Class 1: PIO Data-In Commands
+//
+#define ATA_CMD_IDENTIFY_DRIVE                          0xec   ///< defined from ATA-3
+#define ATA_CMD_READ_BUFFER                             0xe4   ///< defined from ATA-1
+#define ATA_CMD_READ_SECTORS                            0x20   ///< defined from ATA-1
+#define ATA_CMD_READ_SECTORS_WITH_RETRY                 0x21   ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_READ_LONG                               0x22   ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_READ_LONG_WITH_RETRY                    0x23   ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_READ_SECTORS_EXT                        0x24   ///< defined from ATA-6
+#define ATA_CMD_READ_MULTIPLE                           0xc4   ///< defined in ACS-3
+#define ATA_CMD_READ_MULTIPLE_EXT                       0x29   ///< defined in ACS-3
+#define ATA_CMD_READ_LOG_EXT                            0x2f   ///< defined in ACS-3
+
+//
+// Class 2: PIO Data-Out Commands
+//
+#define ATA_CMD_FORMAT_TRACK                            0x50  ///< defined from ATA-1, obsoleted from ATA-4
+#define ATA_CMD_WRITE_BUFFER                            0xe8  ///< defined from ATA-1
+#define ATA_CMD_WRITE_SECTORS                           0x30  ///< defined from ATA-1
+#define ATA_CMD_WRITE_SECTORS_WITH_RETRY                0x31  ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_WRITE_LONG                              0x32  ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_WRITE_LONG_WITH_RETRY                   0x33  ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_WRITE_VERIFY                            0x3c  ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_WRITE_SECTORS_EXT                       0x34  ///< defined from ATA-6
+#define ATA_CMD_WRITE_MULTIPLE                          0xc5  ///< defined in ACS-3
+#define ATA_CMD_WRITE_MULTIPLE_EXT                      0x39  ///< defined in ACS-3
+
+//
+// Class 3 No Data Command
+//
+#define ATA_CMD_ACK_MEDIA_CHANGE                        0xdb  ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_BOOT_POST_BOOT                          0xdc  ///< defined from ATA-1, obsoleted from ATA-3
+#define ATA_CMD_BOOT_PRE_BOOT                           0xdd  ///< defined from ATA-1, obsoleted from ATA-3
+#define ATA_CMD_CHECK_POWER_MODE                        0x98  ///< defined from ATA-1, obsoleted from ATA-4
+#define ATA_CMD_CHECK_POWER_MODE_ALIAS                  0xe5  ///< defined from ATA-1
+#define ATA_CMD_DOOR_LOCK                               0xde  ///< defined from ATA-1
+#define ATA_CMD_DOOR_UNLOCK                             0xdf  ///< defined from ATA-1
+#define ATA_CMD_EXEC_DRIVE_DIAG                         0x90  ///< defined from ATA-1
+#define ATA_CMD_IDLE_ALIAS                              0x97  ///< defined from ATA-1, obsoleted from ATA-4
+#define ATA_CMD_IDLE                                    0xe3  ///< defined from ATA-1
+#define ATA_CMD_IDLE_IMMEDIATE                          0x95  ///< defined from ATA-1, obsoleted from ATA-4
+#define ATA_CMD_IDLE_IMMEDIATE_ALIAS                    0xe1  ///< defined from ATA-1
+#define ATA_CMD_INIT_DRIVE_PARAM                        0x91  ///< defined from ATA-1, obsoleted from ATA-6
+#define ATA_CMD_RECALIBRATE                             0x10  ///< defined from ATA-1, obsoleted from ATA-4
+#define ATA_CMD_READ_DRIVE_STATE                        0xe9  ///< defined from ATA-1, obsoleted from ATA-3
+#define ATA_CMD_SET_MULTIPLE_MODE                       0xC6  ///< defined from ATA-2
+#define ATA_CMD_READ_VERIFY                             0x40  ///< defined from ATA-1
+#define ATA_CMD_READ_VERIFY_WITH_RETRY                  0x41  ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_SEEK                                    0x70  ///< defined from ATA-1
+#define ATA_CMD_SET_FEATURES                            0xef  ///< defined from ATA-1
+#define ATA_CMD_STANDBY                                 0x96  ///< defined from ATA-1, obsoleted from ATA-4
+#define ATA_CMD_STANDBY_ALIAS                           0xe2  ///< defined from ATA-1
+#define ATA_CMD_STANDBY_IMMEDIATE                       0x94  ///< defined from ATA-1, obsoleted from ATA-4
+#define ATA_CMD_STANDBY_IMMEDIATE_ALIAS                 0xe0  ///< defined from ATA-1
+#define ATA_CMD_SLEEP                                   0xe6  ///< defined in ACS-3
+#define ATA_CMD_READ_NATIVE_MAX_ADDRESS                 0xf8  ///< defined in ATA-6
+#define ATA_CMD_READ_NATIVE_MAX_ADDRESS_EXT             0x27  ///< defined in ATA-6
+
+//
+// Set Features Sub Command
+//
+#define ATA_SUB_CMD_ENABLE_VOLATILE_WRITE_CACHE             0x02   ///< defined in ACS-3
+#define ATA_SUB_CMD_SET_TRANSFER_MODE                       0x03   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_APM                              0x05   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_PUIS                             0x06   ///< defined in ACS-3
+#define ATA_SUB_CMD_PUIS_SET_DEVICE_SPINUP                  0x07   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_WRITE_READ_VERIFY                0x0b   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_SATA_FEATURE                     0x10   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_MEDIA_STATUS_NOTIFICATION       0x31   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_FREE_FALL_CONTROL                0x41   ///< defined in ACS-3
+#define ATA_SUB_CMD_ACOUSTIC_MANAGEMENT_ENABLE              0x42   ///< defined in ACS-3
+#define ATA_SUB_CMD_SET_MAX_HOST_INTERFACE_SECTOR_TIMES     0x43   ///< defined in ACS-3
+#define ATA_SUB_CMD_EXTENDED_POWER_CONDITIONS               0x4a   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_READ_LOOK_AHEAD                 0x55   ///< defined in ACS-3
+#define ATA_SUB_CMD_EN_DIS_DSN_FEATURE                      0x63   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_REVERT_TO_POWER_ON_DEFAULTS     0x66   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_VOLATILE_WRITE_CACHE            0x82   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_APM                             0x85   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_PUIS                            0x86   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_WRITE_READ_VERIFY               0x8b   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_SATA_FEATURE                    0x90   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_MEDIA_STATUS_NOTIFICATION        0x95   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_READ_LOOK_AHEAD                  0xaa   ///< defined in ACS-3
+#define ATA_SUB_CMD_DISABLE_FREE_FALL_CONTROL               0xc1   ///< defined in ACS-3
+#define ATA_SUB_CMD_ACOUSTIC_MANAGEMENT_DISABLE             0xc2   ///< defined in ACS-3
+#define ATA_SUB_CMD_EN_DIS_SENSE_DATA_REPORTING             0xc3   ///< defined in ACS-3
+#define ATA_SUB_CMD_ENABLE_REVERT_TO_POWER_ON_DEFAULTS      0xcc   ///< defined in ACS-3
+
+//
+// S.M.A.R.T
+//
+#define ATA_CMD_SMART                                   0xb0  ///< defined from ATA-3
+#define ATA_CONSTANT_C2                                 0xc2  ///< reserved
+#define ATA_CONSTANT_4F                                 0x4f  ///< reserved
+
+#define ATA_SMART_READ_DATA                             0xd0   ///< defined in ACS-3
+
+#define ATA_SMART_AUTOSAVE                              0xd2  ///< defined in ACS-3
+    #define ATA_AUTOSAVE_DISABLE_ATTR                       0x00
+    #define ATA_AUTOSAVE_ENABLE_ATTR                        0xf1
+
+#define ATA_SMART_EXECUTE_OFFLINE_IMMEDIATE             0xd4  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_OFFLINE_ROUTINE               0x00  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_OFFLINE_SHORT_SELFTEST        0x01  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_OFFLINE_EXTENDED_SELFTEST     0x02  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_OFFLINE_CONVEYANCE_SELFTEST   0x03  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_OFFLINE_SELECTIVE_SELFTEST    0x04  ///< defined in ACS-3
+    #define ATA_SMART_ABORT_SELF_TEST_SUBROUTINE            0x7f  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_CAPTIVE_SHORT_SELFTEST        0x81  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_CAPTIVE_EXTENDED_SELFTEST     0x82  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_CAPTIVE_CONVEYANCE_SELFTEST   0x83  ///< defined in ACS-3
+    #define ATA_EXECUTE_SMART_CAPTIVE_SELECTIVE_SELFTEST    0x84  ///< defined in ACS-3
+
+#define ATA_SMART_READLOG                               0xd5  ///< defined in ACS-3
+#define ATA_SMART_WRITELOG                              0xd6  ///< defined in ACS-3
+#define ATA_SMART_ENABLE_OPERATION                      0xd8  ///< reserved
+#define ATA_SMART_DISABLE_OPERATION                     0xd9  ///< defined in ACS-3
+#define ATA_SMART_RETURN_STATUS                         0xda  ///< defined from ATA-3
+
+#define ATA_SMART_THRESHOLD_NOT_EXCEEDED_VALUE              0xc24f  ///< defined in ACS-3
+#define ATA_SMART_THRESHOLD_EXCEEDED_VALUE                  0x2cf4  ///< defined in ACS-3
+
+// SMART Log Definitions
+#define ATA_SMART_LOG_DIRECTORY                             0x00  ///< defined in ACS-3
+#define ATA_SMART_SUM_SMART_ERROR_LOG                       0x01  ///< defined in ACS-3
+#define ATA_SMART_COMP_SMART_ERROR_LOG                      0x02  ///< defined in ACS-3
+#define ATA_SMART_EXT_COMP_SMART_ERROR_LOG                  0x03  ///< defined in ACS-3
+#define ATA_SMART_SMART_SELFTEST_LOG                        0x06  ///< defined in ACS-3
+#define ATA_SMART_EXT_SMART_SELFTEST_LOG                    0x07  ///< defined in ACS-3
+#define ATA_SMART_SELECTIVE_SELFTEST_LOG                    0x09  ///< defined in ACS-3
+#define ATA_SMART_HOST_VENDOR_SPECIFIC                      0x80  ///< defined in ACS-3
+#define ATA_SMART_DEVICE_VENDOR_SPECIFIC                    0xa0  ///< defined in ACS-3
+
+//
+// Class 4: DMA Command
+//
+#define ATA_CMD_READ_DMA                                0xc8   ///< defined from ATA-1
+#define ATA_CMD_READ_DMA_WITH_RETRY                     0xc9   ///< defined from ATA-1, obsoleted from ATA-5
+#define ATA_CMD_READ_DMA_EXT                            0x25   ///< defined from ATA-6
+#define ATA_CMD_WRITE_DMA                               0xca   ///< defined from ATA-1
+#define ATA_CMD_WRITE_DMA_WITH_RETRY                    0xcb   ///< defined from ATA-1, obsoleted from ATA-
+#define ATA_CMD_WRITE_DMA_EXT                           0x35   ///< defined from ATA-6
+
+//
+//  ATA Security commands
+//
+#define ATA_CMD_SECURITY_SET_PASSWORD                   0xf1  ///< defined in ACS-3
+#define ATA_CMD_SECURITY_UNLOCK                         0xf2  ///< defined in ACS-3
+#define ATA_CMD_SECURITY_ERASE_PREPARE                  0xf3  ///< defined in ACS-3
+#define ATA_CMD_SECURITY_ERASE_UNIT                     0xf4  ///< defined in ACS-3
+#define ATA_CMD_SECURITY_FREEZE_LOCK                    0xf5  ///< defined in ACS-3
+#define ATA_CMD_SECURITY_DISABLE_PASSWORD               0xf6  ///< defined in ACS-3
+
+#define ATA_SECURITY_BUFFER_LENGTH                          512  ///< defined in ACS-3
+
+//
+//  ATA Device Config Overlay
+//
+#define ATA_CMD_DEV_CONFIG_OVERLAY                      0xb1   ///< defined from ATA-6
+    #define ATA_CMD_DEV_CONFIG_RESTORE_FEATURE              0xc0   ///< defined from ATA-6
+    #define ATA_CMD_DEV_CONFIG_FREEZELOCK_FEATURE           0xc1   ///< defined from ATA-6
+    #define ATA_CMD_DEV_CONFIG_IDENTIFY_FEATURE             0xc2   ///< defined from ATA-6
+    #define ATA_CMD_DEV_CONFIG_SET_FEATURE                  0xc3   ///< defined from ATA-6
+
+//
+//  ATA Trusted Computing Feature Set Commands
+//
+#define ATA_CMD_TRUSTED_NON_DATA                        0x5b  ///< defined in ACS-3
+#define ATA_CMD_TRUSTED_RECEIVE                         0x5c  ///< defined in ACS-3
+#define ATA_CMD_TRUSTED_RECEIVE_DMA                     0x5d  ///< defined in ACS-3
+#define ATA_CMD_TRUSTED_SEND                            0x5e  ///< defined in ACS-3
+#define ATA_CMD_TRUSTED_SEND_DMA                        0x5f  ///< defined in ACS-3
+
+//
+//  ATA Trusted Receive Fields
+//
+#define ATA_TR_RETURN_SECURITY_PROTOCOL_INFORMATION     0x00  ///< defined in ACS-3
+#define ATA_TR_SECURITY_PROTOCOL_JEDEC_RESERVED         0xec  ///< defined in ACS-3
+#define ATA_TR_SECURITY_PROTOCOL_SDCARD_RESERVED        0xed  ///< defined in ACS-3
+#define ATA_TR_SECURITY_PROTOCOL_IEEE1667_RESERVED      0xee  ///< defined in ACS-3
+
+//
+//  Equates used for Acoustic Flags
+//
+#define ATA_ACOUSTIC_LEVEL_BYPASS                       0xff   ///< defined from ATA-6
+#define ATA_ACOUSTIC_LEVEL_MAXIMUM_PERFORMANCE          0xfe   ///< defined from ATA-6
+#define ATA_ACOUSTIC_LEVEL_QUIET                        0x80   ///< defined from ATA-6
+
+//
+//  Equates used for DiPM Support
+//
+#define ATA_CMD_DIPM_SUB                                0x03   // defined in ACS-3 : Count value in SetFeature identification : 03h  Device-initiated interface power state transitions
+    #define ATA_DIPM_ENABLE                                 0x10   // defined in ACS-3
+    #define ATA_DIPM_DISABLE                                0x90   // defined in ACS-3
+
+//
+//  Equates used for DevSleep Support
+//
+#define ATA_CMD_DEVSLEEP_SUB                            0x09   // defined in SATA 3.2 Gold Spec :  Count value in SetFeature identification : 09h  Device Sleep
+    #define ATA_DEVSLEEP_ENABLE                             0x10   // defined in SATA 3.2 Gold Spec
+    #define ATA_DEVSLEEP_DISABLE                            0x90   // defined in SATA 3.2 Gold Spec
+
+#define ATA_DEVSLP_EXIT_TIMEOUT                             20 // MDAT - 20 ms
+#define ATA_DEVSLP_MINIMUM_DETECTION_TIME                   10 // DMDT - 10 us
+#define ATA_DEVSLP_MINIMUM_ASSERTION_TIME                   10 // DETO - 10 ms
+
+//
+//  Set MAX Commands
+//
+#define ATA_CMD_SET_MAX_ADDRESS_EXT                     0x37   ///< defined from ATA-6
+#define ATA_CMD_SET_MAX_ADDRESS                         0xf9   ///< defined from ATA-6
+    #define ATA_SET_MAX_SET_PASSWORD                        0x01   ///< defined from ATA-6
+    #define ATA_SET_MAX_LOCK                                0x02   ///< defined from ATA-6
+    #define ATA_SET_MAX_UNLOCK                              0x03   ///< defined from ATA-6
+    #define ATA_SET_MAX_FREEZE_LOCK                         0x04   ///< defined from ATA-6
+
+///
+/// Default content of device control register, disable INT,
+/// Bit3 is set to 1 according ATA-1
+///
+#define ATA_DEFAULT_CTL                                 (0x0a)
+///
+/// Default context of Device/Head Register,
+/// Bit7 and Bit5 are set to 1 for back-compatibilities.
+///
+#define ATA_DEFAULT_CMD                                 (0xa0)
+
+#define ATAPI_MAX_BYTE_COUNT                            (0xfffe)
+
+#define ATA_REQUEST_SENSE_ERROR                         (0x70) ///< defined in SFF-8070i
+
+//
+// Sense Key, Additional Sense Codes and Additional Sense Code Qualifier
+// defined in MultiMedia Commands (MMC, MMC-2)
+//
+// Sense Key
+//
+#define ATA_SK_NO_SENSE                                 (0x0)
+#define ATA_SK_RECOVERY_ERROR                           (0x1)
+#define ATA_SK_NOT_READY                                (0x2)
+#define ATA_SK_MEDIUM_ERROR                             (0x3)
+#define ATA_SK_HARDWARE_ERROR                           (0x4)
+#define ATA_SK_ILLEGAL_REQUEST                          (0x5)
+#define ATA_SK_UNIT_ATTENTION                           (0x6)
+#define ATA_SK_DATA_PROTECT                             (0x7)
+#define ATA_SK_BLANK_CHECK                              (0x8)
+#define ATA_SK_VENDOR_SPECIFIC                          (0x9)
+#define ATA_SK_RESERVED_A                               (0xA)
+#define ATA_SK_ABORT                                    (0xB)
+#define ATA_SK_RESERVED_C                               (0xC)
+#define ATA_SK_OVERFLOW                                 (0xD)
+#define ATA_SK_MISCOMPARE                               (0xE)
+#define ATA_SK_RESERVED_F                               (0xF)
+
+//
+// Additional Sense Codes
+//
+#define ATA_ASC_NOT_READY                               (0x04)
+#define ATA_ASC_MEDIA_ERR1                              (0x10)
+#define ATA_ASC_MEDIA_ERR2                              (0x11)
+#define ATA_ASC_MEDIA_ERR3                              (0x14)
+#define ATA_ASC_MEDIA_ERR4                              (0x30)
+#define ATA_ASC_MEDIA_UPSIDE_DOWN                       (0x06)
+#define ATA_ASC_INVALID_CMD                             (0x20)
+#define ATA_ASC_LBA_OUT_OF_RANGE                        (0x21)
+#define ATA_ASC_INVALID_FIELD                           (0x24)
+#define ATA_ASC_WRITE_PROTECTED                         (0x27)
+#define ATA_ASC_MEDIA_CHANGE                            (0x28)
+#define ATA_ASC_RESET                                   (0x29)  ///< Power On Reset or Bus Reset occurred.
+#define ATA_ASC_ILLEGAL_FIELD                           (0x26)
+#define ATA_ASC_NO_MEDIA                                (0x3A)
+#define ATA_ASC_ILLEGAL_MODE_FOR_THIS_TRACK             (0x64)
+
+//
+// Additional Sense Code Qualifier
+//
+#define ATA_ASCQ_IN_PROGRESS                            (0x01)
+
+//
+// Error Register
+//
+#define ATA_ERRREG_BBK                                  BIT7  ///< Bad block detected      defined from ATA-1, obsoleted from ATA-2
+#define ATA_ERRREG_UNC                                  BIT6  ///< Uncorrectable Data      defined from ATA-1, obsoleted from ATA-4
+#define ATA_ERRREG_MC                                   BIT5  ///< Media Change            defined from ATA-1, obsoleted from ATA-4
+#define ATA_ERRREG_IDNF                                 BIT4  ///< ID Not Found            defined from ATA-1, obsoleted from ATA-4
+#define ATA_ERRREG_MCR                                  BIT3  ///< Media Change Requested  defined from ATA-1, obsoleted from ATA-4
+#define ATA_ERRREG_ABRT                                 BIT2  ///< Aborted Command         defined from ATA-1
+#define ATA_ERRREG_TK0NF                                BIT1  ///< Track 0 Not Found       defined from ATA-1, obsoleted from ATA-4
+#define ATA_ERRREG_AMNF                                 BIT0  ///< Address Mark Not Found  defined from ATA-1, obsoleted from ATA-4
+
+//
+// Status Register
+//
+#define ATA_STSREG_BSY                                  BIT7  ///< Controller Busy         defined from ATA-1
+#define ATA_STSREG_DRDY                                 BIT6  ///< Drive Ready             defined from ATA-1
+#define ATA_STSREG_DWF                                  BIT5  ///< Drive Write Fault       defined from ATA-1, obsoleted from ATA-4
+#define ATA_STSREG_DF                                   BIT5  ///< Drive Fault             defined from ATA-6
+#define ATA_STSREG_DSC                                  BIT4  ///< Disk Seek Complete      defined from ATA-1, obsoleted from ATA-4
+#define ATA_STSREG_DRQ                                  BIT3  ///< Data Request            defined from ATA-1
+#define ATA_STSREG_CORR                                 BIT2  ///< Corrected Data          defined from ATA-1, obsoleted from ATA-4
+#define ATA_STSREG_IDX                                  BIT1  ///< Index                   defined from ATA-1, obsoleted from ATA-4
+#define ATA_STSREG_ERR                                  BIT0  ///< Error                   defined from ATA-1
+
+//
+// Device Control Register
+//
+#define ATA_CTLREG_SRST                                 BIT2  ///< Software Reset.
+#define ATA_CTLREG_IEN_L                                BIT1  ///< Interrupt Enable #.
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Bluetooth.h b/libedk2_tpm/include/IndustryStandard/Bluetooth.h
new file mode 100644
index 0000000..9694012
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Bluetooth.h
@@ -0,0 +1,56 @@
+/** @file
+  This file contains the Bluetooth definitions that are consumed by drivers.
+  These definitions are from Bluetooth Core Specification Version 4.0 June, 2010
+
+  Copyright (c) 2015 - 2017, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _BLUETOOTH_H_
+#define _BLUETOOTH_H_
+
+#pragma pack(1)
+
+///
+/// BLUETOOTH_ADDRESS
+///
+typedef struct {
+  ///
+  /// 48bit Bluetooth device address.
+  ///
+  UINT8      Address[6];
+} BLUETOOTH_ADDRESS;
+
+///
+/// BLUETOOTH_CLASS_OF_DEVICE. See Bluetooth specification for detail.
+///
+typedef struct {
+  UINT8      FormatType:2;
+  UINT8      MinorDeviceClass: 6;
+  UINT16     MajorDeviceClass: 5;
+  UINT16     MajorServiceClass:11;
+} BLUETOOTH_CLASS_OF_DEVICE;
+
+///
+/// BLUETOOTH_LE_ADDRESS
+///
+typedef struct {
+  ///
+  /// 48-bit Bluetooth device address
+  ///
+  UINT8      Address[6];
+  ///
+  /// 0x00 - Public Device Address
+  /// 0x01 - Random Device Address
+  ///
+  UINT8      Type;
+} BLUETOOTH_LE_ADDRESS;
+
+#pragma pack()
+
+#define BLUETOOTH_HCI_COMMAND_LOCAL_READABLE_NAME_MAX_SIZE    248
+
+#define BLUETOOTH_HCI_LINK_KEY_SIZE                           16
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Bmp.h b/libedk2_tpm/include/IndustryStandard/Bmp.h
new file mode 100644
index 0000000..36f7194
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Bmp.h
@@ -0,0 +1,42 @@
+/** @file
+  This file defines BMP file header data structures.
+
+Copyright (c) 2006 - 2011, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _BMP_H_
+#define _BMP_H_
+
+#pragma pack(1)
+
+typedef struct {
+  UINT8   Blue;
+  UINT8   Green;
+  UINT8   Red;
+  UINT8   Reserved;
+} BMP_COLOR_MAP;
+
+typedef struct {
+  CHAR8         CharB;
+  CHAR8         CharM;
+  UINT32        Size;
+  UINT16        Reserved[2];
+  UINT32        ImageOffset;
+  UINT32        HeaderSize;
+  UINT32        PixelWidth;
+  UINT32        PixelHeight;
+  UINT16        Planes;          ///< Must be 1
+  UINT16        BitPerPixel;     ///< 1, 4, 8, or 24
+  UINT32        CompressionType;
+  UINT32        ImageSize;       ///< Compressed image size in bytes
+  UINT32        XPixelsPerMeter;
+  UINT32        YPixelsPerMeter;
+  UINT32        NumberOfColors;
+  UINT32        ImportantColors;
+} BMP_IMAGE_HEADER;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/DmaRemappingReportingTable.h b/libedk2_tpm/include/IndustryStandard/DmaRemappingReportingTable.h
new file mode 100644
index 0000000..a36df39
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/DmaRemappingReportingTable.h
@@ -0,0 +1,291 @@
+/** @file
+  DMA Remapping Reporting (DMAR) ACPI table definition from Intel(R)
+  Virtualization Technology for Directed I/O (VT-D) Architecture Specification.
+
+  Copyright (c) 2016 - 2020, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+  @par Revision Reference:
+    - Intel(R) Virtualization Technology for Directed I/O (VT-D) Architecture
+      Specification v3.2, Dated October 2020.
+      https://software.intel.com/content/dam/develop/external/us/en/documents/vt-directed-io-spec.pdf
+
+  @par Glossary:
+    - HPET - High Precision Event Timer
+    - NUMA - Non-uniform Memory Access
+**/
+#ifndef _DMA_REMAPPING_REPORTING_TABLE_H_
+#define _DMA_REMAPPING_REPORTING_TABLE_H_
+
+#include <IndustryStandard/Acpi.h>
+
+#pragma pack(1)
+
+///
+/// DMA-Remapping Reporting Structure definitions from section 8.1
+///@{
+#define EFI_ACPI_DMAR_REVISION                             0x01
+
+#define EFI_ACPI_DMAR_FLAGS_INTR_REMAP                     BIT0
+#define EFI_ACPI_DMAR_FLAGS_X2APIC_OPT_OUT                 BIT1
+#define EFI_ACPI_DMAR_FLAGS_DMA_CTRL_PLATFORM_OPT_IN_FLAG  BIT2
+///@}
+
+///
+/// Remapping Structure Types definitions from section 8.2
+///@{
+#define EFI_ACPI_DMAR_TYPE_DRHD                   0x00
+#define EFI_ACPI_DMAR_TYPE_RMRR                   0x01
+#define EFI_ACPI_DMAR_TYPE_ATSR                   0x02
+#define EFI_ACPI_DMAR_TYPE_RHSA                   0x03
+#define EFI_ACPI_DMAR_TYPE_ANDD                   0x04
+#define EFI_ACPI_DMAR_TYPE_SATC                   0x05
+///@}
+
+///
+/// DMA-Remapping Hardware Unit definitions from section 8.3
+///
+#define EFI_ACPI_DMAR_DRHD_FLAGS_INCLUDE_PCI_ALL  BIT0
+
+///
+/// DMA-Remapping Device Scope Entry Structure definitions from section 8.3.1
+///@{
+#define EFI_ACPI_DEVICE_SCOPE_ENTRY_TYPE_PCI_ENDPOINT           0x01
+#define EFI_ACPI_DEVICE_SCOPE_ENTRY_TYPE_PCI_BRIDGE             0x02
+#define EFI_ACPI_DEVICE_SCOPE_ENTRY_TYPE_IOAPIC                 0x03
+#define EFI_ACPI_DEVICE_SCOPE_ENTRY_TYPE_MSI_CAPABLE_HPET       0x04
+#define EFI_ACPI_DEVICE_SCOPE_ENTRY_TYPE_ACPI_NAMESPACE_DEVICE  0x05
+///@}
+
+///
+/// Root Port ATS Capability Reporting Structure definitions from section 8.5
+///
+#define EFI_ACPI_DMAR_ATSR_FLAGS_ALL_PORTS                      BIT0
+
+///
+/// Definition for DMA Remapping Structure Header
+///
+typedef struct {
+  UINT16        Type;
+  UINT16        Length;
+} EFI_ACPI_DMAR_STRUCTURE_HEADER;
+
+///
+/// Definition for DMA-Remapping PCI Path
+///
+typedef struct {
+  UINT8         Device;
+  UINT8         Function;
+} EFI_ACPI_DMAR_PCI_PATH;
+
+///
+/// Device Scope Structure is defined in section 8.3.1
+///
+typedef struct {
+  UINT8         Type;
+  UINT8         Length;
+  UINT16        Reserved2;
+  UINT8         EnumerationId;
+  UINT8         StartBusNumber;
+} EFI_ACPI_DMAR_DEVICE_SCOPE_STRUCTURE_HEADER;
+
+/**
+  DMA-remapping hardware unit definition (DRHD) structure is defined in
+  section 8.3. This uniquely represents a remapping hardware unit present
+  in the platform. There must be at least one instance of this structure
+  for each PCI segment in the platform.
+**/
+typedef struct {
+  EFI_ACPI_DMAR_STRUCTURE_HEADER  Header;
+  /**
+    - Bit[0]: INCLUDE_PCI_ALL
+              - If Set, this remapping hardware unit has under its scope all
+                PCI compatible devices in the specified Segment, except devices
+                reported under the scope of other remapping hardware units for
+                the same Segment.
+              - If Clear, this remapping hardware unit has under its scope only
+                devices in the specified Segment that are explicitly identified
+                through the DeviceScope field.
+    - Bits[7:1] Reserved.
+  **/
+  UINT8                           Flags;
+  UINT8                           Reserved;
+  ///
+  /// The PCI Segment associated with this unit.
+  ///
+  UINT16                          SegmentNumber;
+  ///
+  /// Base address of remapping hardware register-set for this unit.
+  ///
+  UINT64                          RegisterBaseAddress;
+} EFI_ACPI_DMAR_DRHD_HEADER;
+
+/**
+  Reserved Memory Region Reporting Structure (RMRR) is described in section 8.4
+  Reserved memory ranges that may be DMA targets may be reported through the
+  RMRR structures, along with the devices that requires access to the specified
+  reserved memory region.
+**/
+typedef struct {
+  EFI_ACPI_DMAR_STRUCTURE_HEADER  Header;
+  UINT8                           Reserved[2];
+  ///
+  /// PCI Segment Number associated with devices identified through
+  /// the Device Scope field.
+  ///
+  UINT16                          SegmentNumber;
+  ///
+  /// Base address of 4KB-aligned reserved memory region
+  ///
+  UINT64                          ReservedMemoryRegionBaseAddress;
+  /**
+    Last address of the reserved memory region. Value in this field must be
+    greater than the value in Reserved Memory Region Base Address field.
+    The reserved memory region size (Limit - Base + 1) must be an integer
+    multiple of 4KB.
+  **/
+  UINT64                          ReservedMemoryRegionLimitAddress;
+} EFI_ACPI_DMAR_RMRR_HEADER;
+
+/**
+  Root Port ATS Capability Reporting (ATSR) structure is defined in section 8.5.
+  This structure is applicable only for platforms supporting Device-TLBs as
+  reported through the Extended Capability Register. For each PCI Segment in
+  the platform that supports Device-TLBs, BIOS provides an ATSR structure. The
+  ATSR structures identifies PCI-Express Root-Ports supporting Address
+  Translation Services (ATS) transactions. Software must enable ATS on endpoint
+  devices behind a Root Port only if the Root Port is reported as supporting
+  ATS transactions.
+**/
+typedef struct {
+  EFI_ACPI_DMAR_STRUCTURE_HEADER  Header;
+  /**
+    - Bit[0]: ALL_PORTS:
+              - If Set, indicates all PCI Express Root Ports in the specified
+                PCI Segment supports ATS transactions.
+              - If Clear, indicates ATS transactions are supported only on
+                Root Ports identified through the Device Scope field.
+    - Bits[7:1] Reserved.
+  **/
+  UINT8                           Flags;
+  UINT8                           Reserved;
+  ///
+  /// The PCI Segment associated with this ATSR structure
+  ///
+  UINT16                          SegmentNumber;
+} EFI_ACPI_DMAR_ATSR_HEADER;
+
+/**
+  Remapping Hardware Static Affinity (RHSA) is an optional structure defined
+  in section 8.6. This is intended to be used only on NUMA platforms with
+  Remapping hardware units and memory spanned across multiple nodes.
+  When used, there must be a RHSA structure for each Remapping hardware unit
+  reported through DRHD structure.
+**/
+typedef struct {
+  EFI_ACPI_DMAR_STRUCTURE_HEADER  Header;
+  UINT8                           Reserved[4];
+  ///
+  /// Register Base Address of this Remap hardware unit reported in the
+  /// corresponding DRHD structure.
+  ///
+  UINT64                          RegisterBaseAddress;
+  ///
+  /// Proximity Domain to which the Remap hardware unit identified by the
+  /// Register Base Address field belongs.
+  ///
+  UINT32                          ProximityDomain;
+} EFI_ACPI_DMAR_RHSA_HEADER;
+
+/**
+  An ACPI Name-space Device Declaration (ANDD) structure is defined in section
+  8.7 and uniquely represents an ACPI name-space enumerated device capable of
+  issuing DMA requests in the platform. ANDD structures are used in conjunction
+  with Device-Scope entries of type ACPI_NAMESPACE_DEVICE.
+**/
+typedef struct {
+  EFI_ACPI_DMAR_STRUCTURE_HEADER  Header;
+  UINT8                           Reserved[3];
+  /**
+    Each ACPI device enumerated through an ANDD structure must have a unique
+    value for this field. To report an ACPI device with ACPI Device Number
+    value of X, under the scope of a DRHD unit, a Device-Scope entry of type
+    ACPI_NAMESPACE_DEVICE is used with value of X in the Enumeration ID field.
+    The Start Bus Number and Path fields in the Device-Scope together
+    provides the 16-bit source-id allocated by platform for the ACPI device.
+  **/
+  UINT8                           AcpiDeviceNumber;
+} EFI_ACPI_DMAR_ANDD_HEADER;
+
+/**
+  An SoC Integrated Address Translation Cache (SATC) reporting structure is
+  defined in section 8.8.
+**/
+typedef struct {
+  EFI_ACPI_DMAR_STRUCTURE_HEADER  Header;
+  /**
+    - Bit[0]: ATC_REQUIRED:
+              - If Set, indicates that every SoC integrated device enumerated
+                in this table has a functional requirement to enable its ATC
+                (via the ATS capability) for device operation.
+              - If Clear, any device enumerated in this table can operate when
+                its respective ATC is not enabled (albeit with reduced
+                performance or functionality).
+    - Bits[7:1] Reserved.
+  **/
+  UINT8                           Flags;
+  UINT8                           Reserved;
+  ///
+  /// The PCI Segment associated with this SATC structure. All SoC integrated
+  /// devices within a PCI segment with same value for Flags field must be
+  /// enumerated in the same SATC structure.
+  ///
+  UINT16                          SegmentNumber;
+} EFI_ACPI_DMAR_SATC_HEADER;
+
+/**
+  DMA Remapping Reporting Structure Header as defined in section 8.1
+  This header will be followed by list of Remapping Structures listed below
+    - DMA Remapping Hardware Unit Definition (DRHD)
+    - Reserved Memory Region Reporting (RMRR)
+    - Root Port ATS Capability Reporting (ATSR)
+    - Remapping Hardware Static Affinity (RHSA)
+    - ACPI Name-space Device Declaration (ANDD)
+    - SoC Integrated Address Translation Cache reporting (SATC)
+  These structure types must by reported in numerical order.
+  i.e., All remapping structures of type 0 (DRHD) enumerated before remapping
+  structures of type 1 (RMRR), and so forth.
+**/
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER     Header;
+  /**
+    This field indicates the maximum DMA physical addressability supported by
+    this platform. The system address map reported by the BIOS indicates what
+    portions of this addresses are populated. The Host Address Width (HAW) of
+    the platform is computed as (N+1), where N is the value reported in this
+    field.
+    For example, for a platform supporting 40 bits of physical addressability,
+    the value of 100111b is reported in this field.
+  **/
+  UINT8                           HostAddressWidth;
+  /**
+    - Bit[0]:   INTR_REMAP - If Clear, the platform does not support interrupt
+                remapping. If Set, the platform supports interrupt remapping.
+    - Bit[1]:   X2APIC_OPT_OUT - For firmware compatibility reasons, platform
+                firmware may Set this field to request system software to opt
+                out of enabling Extended xAPIC (X2APIC) mode. This field is
+                valid only when the INTR_REMAP field (bit 0) is Set.
+    - Bit[2]:   DMA_CTRL_PLATFORM_OPT_IN_FLAG - Platform firmware is
+                recommended to Set this field to report any platform initiated
+                DMA is restricted to only reserved memory regions (reported in
+                RMRR structures) when transferring control to system software
+                such as on ExitBootServices().
+    - Bits[7:3] Reserved.
+  **/
+  UINT8                           Flags;
+  UINT8                           Reserved[10];
+} EFI_ACPI_DMAR_HEADER;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/ElTorito.h b/libedk2_tpm/include/IndustryStandard/ElTorito.h
new file mode 100644
index 0000000..e9b870f
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/ElTorito.h
@@ -0,0 +1,141 @@
+/** @file
+  ElTorito Partitions Format Definition.
+  This file includes some definitions from
+  1. "El Torito" Bootable CD-ROM Format Specification, Version 1.0.
+  2. Volume and File Structure of CDROM for Information Interchange,
+     Standard ECMA-119. (IS0 9660)
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _ELTORITO_H_
+#define _ELTORITO_H_
+
+//
+// CDROM_VOLUME_DESCRIPTOR.Types, defined in ISO 9660
+//
+#define CDVOL_TYPE_STANDARD 0x0
+#define CDVOL_TYPE_CODED    0x1
+#define CDVOL_TYPE_END      0xFF
+
+///
+/// CDROM_VOLUME_DESCRIPTOR.Id
+///
+#define CDVOL_ID  "CD001"
+
+///
+/// CDROM_VOLUME_DESCRIPTOR.SystemId
+///
+#define CDVOL_ELTORITO_ID "EL TORITO SPECIFICATION"
+
+//
+// Indicator types
+//
+#define ELTORITO_ID_CATALOG               0x01
+#define ELTORITO_ID_SECTION_BOOTABLE      0x88
+#define ELTORITO_ID_SECTION_NOT_BOOTABLE  0x00
+#define ELTORITO_ID_SECTION_HEADER        0x90
+#define ELTORITO_ID_SECTION_HEADER_FINAL  0x91
+
+//
+// ELTORITO_CATALOG.Boot.MediaTypes
+//
+#define ELTORITO_NO_EMULATION 0x00
+#define ELTORITO_12_DISKETTE  0x01
+#define ELTORITO_14_DISKETTE  0x02
+#define ELTORITO_28_DISKETTE  0x03
+#define ELTORITO_HARD_DISK    0x04
+
+
+#pragma pack(1)
+
+///
+/// CD-ROM Volume Descriptor
+///
+typedef union {
+  struct {
+    UINT8   Type;
+    CHAR8   Id[5];           ///< "CD001"
+    CHAR8   Reserved[82];
+  } Unknown;
+
+  ///
+  /// Boot Record Volume Descriptor, defined in "El Torito" Specification.
+  ///
+  struct {
+    UINT8   Type;            ///< Must be 0
+    CHAR8   Id[5];           ///< "CD001"
+    UINT8   Version;         ///< Must be 1
+    CHAR8   SystemId[32];    ///< "EL TORITO SPECIFICATION"
+    CHAR8   Unused[32];      ///< Must be 0
+    UINT8   EltCatalog[4];   ///< Absolute pointer to first sector of Boot Catalog
+    CHAR8   Unused2[13];     ///< Must be 0
+  } BootRecordVolume;
+
+  ///
+  /// Primary Volume Descriptor, defined in ISO 9660.
+  ///
+  struct {
+    UINT8   Type;
+    CHAR8   Id[5];           ///< "CD001"
+    UINT8   Version;
+    UINT8   Unused;          ///< Must be 0
+    CHAR8   SystemId[32];
+    CHAR8   VolumeId[32];
+    UINT8   Unused2[8];      ///< Must be 0
+    UINT32  VolSpaceSize[2]; ///< the number of Logical Blocks
+  } PrimaryVolume;
+
+} CDROM_VOLUME_DESCRIPTOR;
+
+///
+/// Catalog Entry
+///
+typedef union {
+  struct {
+    CHAR8       Reserved[0x20];
+  } Unknown;
+
+  ///
+  /// Catalog validation entry (Catalog header)
+  ///
+  struct {
+    UINT8   Indicator;       ///< Must be 01
+    UINT8   PlatformId;
+    UINT16  Reserved;
+    CHAR8   ManufacId[24];
+    UINT16  Checksum;
+    UINT16  Id55AA;
+  } Catalog;
+
+  ///
+  /// Initial/Default Entry or Section Entry
+  ///
+  struct {
+    UINT8   Indicator;       ///< 88 = Bootable, 00 = Not Bootable
+    UINT8   MediaType : 4;
+    UINT8   Reserved1 : 4;   ///< Must be 0
+    UINT16  LoadSegment;
+    UINT8   SystemType;
+    UINT8   Reserved2;       ///< Must be 0
+    UINT16  SectorCount;
+    UINT32  Lba;
+  } Boot;
+
+  ///
+  /// Section Header Entry
+  ///
+  struct {
+    UINT8   Indicator;       ///< 90 - Header, more header follw, 91 - Final Header
+    UINT8   PlatformId;
+    UINT16  SectionEntries;  ///< Number of section entries following this header
+    CHAR8   Id[28];
+  } Section;
+
+} ELTORITO_CATALOG;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Emmc.h b/libedk2_tpm/include/IndustryStandard/Emmc.h
new file mode 100644
index 0000000..0987f6c
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Emmc.h
@@ -0,0 +1,291 @@
+/** @file
+  Header file for eMMC support.
+
+  This header file contains some definitions defined in EMMC4.5/EMMC5.0 spec.
+
+  Copyright (c) 2015, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __EMMC_H__
+#define __EMMC_H__
+
+//
+// EMMC command index
+//
+#define  EMMC_GO_IDLE_STATE           0
+#define  EMMC_SEND_OP_COND            1
+#define  EMMC_ALL_SEND_CID            2
+#define  EMMC_SET_RELATIVE_ADDR       3
+#define  EMMC_SET_DSR                 4
+#define  EMMC_SLEEP_AWAKE             5
+#define  EMMC_SWITCH                  6
+#define  EMMC_SELECT_DESELECT_CARD    7
+#define  EMMC_SEND_EXT_CSD            8
+#define  EMMC_SEND_CSD                9
+#define  EMMC_SEND_CID                10
+#define  EMMC_STOP_TRANSMISSION       12
+#define  EMMC_SEND_STATUS             13
+#define  EMMC_BUSTEST_R               14
+#define  EMMC_GO_INACTIVE_STATE       15
+#define  EMMC_SET_BLOCKLEN            16
+#define  EMMC_READ_SINGLE_BLOCK       17
+#define  EMMC_READ_MULTIPLE_BLOCK     18
+#define  EMMC_BUSTEST_W               19
+#define  EMMC_SEND_TUNING_BLOCK       21
+#define  EMMC_SET_BLOCK_COUNT         23
+#define  EMMC_WRITE_BLOCK             24
+#define  EMMC_WRITE_MULTIPLE_BLOCK    25
+#define  EMMC_PROGRAM_CID             26
+#define  EMMC_PROGRAM_CSD             27
+#define  EMMC_SET_WRITE_PROT          28
+#define  EMMC_CLR_WRITE_PROT          29
+#define  EMMC_SEND_WRITE_PROT         30
+#define  EMMC_SEND_WRITE_PROT_TYPE    31
+#define  EMMC_ERASE_GROUP_START       35
+#define  EMMC_ERASE_GROUP_END         36
+#define  EMMC_ERASE                   38
+#define  EMMC_FAST_IO                 39
+#define  EMMC_GO_IRQ_STATE            40
+#define  EMMC_LOCK_UNLOCK             42
+#define  EMMC_SET_TIME                49
+#define  EMMC_PROTOCOL_RD             53
+#define  EMMC_PROTOCOL_WR             54
+#define  EMMC_APP_CMD                 55
+#define  EMMC_GEN_CMD                 56
+
+typedef enum {
+  EmmcPartitionUserData              = 0,
+  EmmcPartitionBoot1                 = 1,
+  EmmcPartitionBoot2                 = 2,
+  EmmcPartitionRPMB                  = 3,
+  EmmcPartitionGP1                   = 4,
+  EmmcPartitionGP2                   = 5,
+  EmmcPartitionGP3                   = 6,
+  EmmcPartitionGP4                   = 7,
+  EmmcPartitionUnknown
+} EMMC_PARTITION_TYPE;
+
+#pragma pack(1)
+typedef struct {
+  UINT8   NotUsed:1;                              // Not used [0:0]
+  UINT8   Crc:7;                                  // CRC [7:1]
+  UINT8   ManufacturingDate;                      // Manufacturing date [15:8]
+  UINT8   ProductSerialNumber[4];                 // Product serial number [47:16]
+  UINT8   ProductRevision;                        // Product revision [55:48]
+  UINT8   ProductName[6];                         // Product name [103:56]
+  UINT8   OemId;                                  // OEM/Application ID [111:104]
+  UINT8   DeviceType:2;                           // Device/BGA [113:112]
+  UINT8   Reserved:6;                             // Reserved [119:114]
+  UINT8   ManufacturerId;                         // Manufacturer ID [127:120]
+} EMMC_CID;
+
+typedef struct {
+  UINT32  NotUsed:1;                              // Not used [0:0]
+  UINT32  Crc:7;                                  // CRC [7:1]
+  UINT32  Ecc:2;                                  // ECC code [9:8]
+  UINT32  FileFormat:2;                           // File format [11:10]
+  UINT32  TmpWriteProtect:1;                      // Temporary write protection [12:12]
+  UINT32  PermWriteProtect:1;                     // Permanent write protection [13:13]
+  UINT32  Copy:1;                                 // Copy flag (OTP) [14:14]
+  UINT32  FileFormatGrp:1;                        // File format group [15:15]
+  UINT32  ContentProtApp:1;                       // Content protection application [16:16]
+  UINT32  Reserved:4;                             // Reserved [20:17]
+  UINT32  WriteBlPartial:1;                       // Partial blocks for write allowed [21:21]
+  UINT32  WriteBlLen:4;                           // Max. write data block length [25:22]
+  UINT32  R2WFactor:3;                            // Write speed factor [28:26]
+  UINT32  DefaultEcc:2;                           // Manufacturer default ECC [30:29]
+  UINT32  WpGrpEnable:1;                          // Write protect group enable [31:31]
+
+  UINT32  WpGrpSize:5;                            // Write protect group size [36:32]
+  UINT32  EraseGrpMult:5;                         // Erase group size multiplier [41:37]
+  UINT32  EraseGrpSize:5;                         // Erase group size [46:42]
+  UINT32  CSizeMult:3;                            // Device size multiplier [49:47]
+  UINT32  VddWCurrMax:3;                          // Max. write current @ VDD max [52:50]
+  UINT32  VddWCurrMin:3;                          // Max. write current @ VDD min [55:53]
+  UINT32  VddRCurrMax:3;                          // Max. read current @ VDD max [58:56]
+  UINT32  VddRCurrMin:3;                          // Max. read current @ VDD min [61:59]
+  UINT32  CSizeLow:2;                             // Device size low two bits [63:62]
+
+  UINT32  CSizeHigh:10;                           // Device size high eight bits [73:64]
+  UINT32  Reserved1:2;                            // Reserved [75:74]
+  UINT32  DsrImp:1;                               // DSR implemented [76:76]
+  UINT32  ReadBlkMisalign:1;                      // Read block misalignment [77:77]
+  UINT32  WriteBlkMisalign:1;                     // Write block misalignment [78:78]
+  UINT32  ReadBlPartial:1;                        // Partial blocks for read allowed [79:79]
+  UINT32  ReadBlLen:4;                            // Max. read data block length [83:80]
+  UINT32  Ccc:12;                                 // Device command classes [95:84]
+
+  UINT32  TranSpeed:8;                            // Max. bus clock frequency [103:96]
+  UINT32  Nsac:8;                                 // Data read access-time 2 in CLK cycles (NSAC*100) [111:104]
+  UINT32  Taac:8;                                 // Data read access-time 1 [119:112]
+  UINT32  Reserved2:2;                            // Reserved [121:120]
+  UINT32  SpecVers:4;                             // System specification version [125:122]
+  UINT32  CsdStructure:2;                         // CSD structure [127:126]
+} EMMC_CSD;
+
+typedef struct {
+  //
+  // Modes Segment
+  //
+  UINT8   Reserved[16];                           // Reserved [15:0]
+  UINT8   SecureRemovalType;                      // Secure Removal Type R/W & R [16]
+  UINT8   ProductStateAwarenessEnablement;        // Product state awareness enablement R/W/E & R [17]
+  UINT8   MaxPreLoadingDataSize[4];               // Max pre loading data size R [21:18]
+  UINT8   PreLoadingDataSize[4];                  // Pre loading data size R/W/EP [25:22]
+  UINT8   FfuStatus;                              // FFU status R [26]
+  UINT8   Reserved1[2];                           // Reserved [28:27]
+  UINT8   ModeOperationCodes;                     // Mode operation codes W/EP [29]
+  UINT8   ModeConfig;                             // Mode config R/W/EP [30]
+  UINT8   Reserved2;                              // Reserved [31]
+  UINT8   FlushCache;                             // Flushing of the cache W/EP [32]
+  UINT8   CacheCtrl;                              // Control to turn the Cache ON/OFF R/W/EP [33]
+  UINT8   PowerOffNotification;                   // Power Off Notification R/W/EP [34]
+  UINT8   PackedFailureIndex;                     // Packed command failure index R [35]
+  UINT8   PackedCommandStatus;                    // Packed command status R [36]
+  UINT8   ContextConf[15];                        // Context configuration R/W/EP [51:37]
+  UINT8   ExtPartitionsAttribute[2];              // Extended Partitions Attribute R/W [53:52]
+  UINT8   ExceptionEventsStatus[2];               // Exception events status R [55:54]
+  UINT8   ExceptionEventsCtrl[2];                 // Exception events control R/W/EP [57:56]
+  UINT8   DyncapNeeded;                           // Number of addressed group to be Released R [58]
+  UINT8   Class6Ctrl;                             // Class 6 commands control R/W/EP [59]
+  UINT8   IniTimeoutEmu;                          // 1st initialization after disabling sector size emulation R [60]
+  UINT8   DataSectorSize;                         // Sector size R [61]
+  UINT8   UseNativeSector;                        // Sector size emulation R/W [62]
+  UINT8   NativeSectorSize;                       // Native sector size R [63]
+  UINT8   VendorSpecificField[64];                // Vendor Specific Fields <vendor specific> [127:64]
+  UINT8   Reserved3[2];                           // Reserved [129:128]
+  UINT8   ProgramCidCsdDdrSupport;                // Program CID/CSD in DDR mode support R [130]
+  UINT8   PeriodicWakeup;                         // Periodic Wake-up R/W/E [131]
+  UINT8   TcaseSupport;                           // Package Case Temperature is controlled W/EP [132]
+  UINT8   ProductionStateAwareness;               // Production state awareness R/W/E [133]
+  UINT8   SecBadBlkMgmnt;                         // Bad Block Management mode R/W [134]
+  UINT8   Reserved4;                              // Reserved [135]
+  UINT8   EnhStartAddr[4];                        // Enhanced User Data Start Address R/W [139:136]
+  UINT8   EnhSizeMult[3];                         // Enhanced User Data Area Size R/W [142:140]
+  UINT8   GpSizeMult[12];                         // General Purpose Partition Size R/W [154:143]
+  UINT8   PartitionSettingCompleted;              // Partitioning Setting R/W [155]
+  UINT8   PartitionsAttribute;                    // Partitions attribute R/W [156]
+  UINT8   MaxEnhSizeMult[3];                      // Max Enhanced Area Size R [159:157]
+  UINT8   PartitioningSupport;                    // Partitioning Support R [160]
+  UINT8   HpiMgmt;                                // HPI management R/W/EP [161]
+  UINT8   RstFunction;                            // H/W reset function R/W [162]
+  UINT8   BkopsEn;                                // Enable background operations handshake R/W [163]
+  UINT8   BkopsStart;                             // Manually start background operations W/EP [164]
+  UINT8   SanitizeStart;                          // Start Sanitize operation W/EP [165]
+  UINT8   WrRelParam;                             // Write reliability parameter register R [166]
+  UINT8   WrRelSet;                               // Write reliability setting register R/W [167]
+  UINT8   RpmbSizeMult;                           // RPMB Size R [168]
+  UINT8   FwConfig;                               // FW configuration R/W [169]
+  UINT8   Reserved5;                              // Reserved [170]
+  UINT8   UserWp;                                 // User area write protection register R/W,R/W/CP&R/W/EP [171]
+  UINT8   Reserved6;                              // Reserved [172]
+  UINT8   BootWp;                                 // Boot area write protection register R/W&R/W/CP[173]
+  UINT8   BootWpStatus;                           // Boot write protection status registers R [174]
+  UINT8   EraseGroupDef;                          // High-density erase group definition R/W/EP [175]
+  UINT8   Reserved7;                              // Reserved [176]
+  UINT8   BootBusConditions;                      // Boot bus Conditions R/W/E [177]
+  UINT8   BootConfigProt;                         // Boot config protection R/W&R/W/CP[178]
+  UINT8   PartitionConfig;                        // Partition configuration R/W/E&R/W/EP[179]
+  UINT8   Reserved8;                              // Reserved [180]
+  UINT8   ErasedMemCont;                          // Erased memory content R [181]
+  UINT8   Reserved9;                              // Reserved [182]
+  UINT8   BusWidth;                               // Bus width mode W/EP [183]
+  UINT8   Reserved10;                             // Reserved [184]
+  UINT8   HsTiming;                               // High-speed interface timing R/W/EP [185]
+  UINT8   Reserved11;                             // Reserved [186]
+  UINT8   PowerClass;                             // Power class R/W/EP [187]
+  UINT8   Reserved12;                             // Reserved [188]
+  UINT8   CmdSetRev;                              // Command set revision R [189]
+  UINT8   Reserved13;                             // Reserved [190]
+  UINT8   CmdSet;                                 // Command set R/W/EP [191]
+  //
+  // Properties Segment
+  //
+  UINT8   ExtCsdRev;                              // Extended CSD revision [192]
+  UINT8   Reserved14;                             // Reserved [193]
+  UINT8   CsdStructure;                           // CSD STRUCTURE [194]
+  UINT8   Reserved15;                             // Reserved [195]
+  UINT8   DeviceType;                             // Device type [196]
+  UINT8   DriverStrength;                         // I/O Driver Strength [197]
+  UINT8   OutOfInterruptTime;                     // Out-of-interrupt busy timing[198]
+  UINT8   PartitionSwitchTime;                    // Partition switching timing [199]
+  UINT8   PwrCl52M195V;                           // Power class for 52MHz at 1.95V [200]
+  UINT8   PwrCl26M195V;                           // Power class for 26MHz at 1.95V [201]
+  UINT8   PwrCl52M360V;                           // Power class for 52MHz at 3.6V [202]
+  UINT8   PwrCl26M360V;                           // Power class for 26MHz at 3.6V [203]
+  UINT8   Reserved16;                             // Reserved [204]
+  UINT8   MinPerfR4B26M;                          // Minimum Read Performance for 4bit at 26MHz [205]
+  UINT8   MinPerfW4B26M;                          // Minimum Write Performance for 4bit at 26MHz [206]
+  UINT8   MinPerfR8B26M4B52M;                     // Minimum Read Performance for 8bit at 26MHz, for 4bit at 52MHz [207]
+  UINT8   MinPerfW8B26M4B52M;                     // Minimum Write Performance for 8bit at 26MHz, for 4bit at 52MHz [208]
+  UINT8   MinPerfR8B52M;                          // Minimum Read Performance for 8bit at 52MHz [209]
+  UINT8   MinPerfW8B52M;                          // Minimum Write Performance for 8bit at 52MHz [210]
+  UINT8   Reserved17;                             // Reserved [211]
+  UINT8   SecCount[4];                            // Sector Count [215:212]
+  UINT8   SleepNotificationTime;                  // Sleep Notification Timeout [216]
+  UINT8   SATimeout;                              // Sleep/awake timeout [217]
+  UINT8   ProductionStateAwarenessTimeout;        // Production state awareness timeout [218]
+  UINT8   SCVccq;                                 // Sleep current (VCCQ) [219]
+  UINT8   SCVcc;                                  // Sleep current (VCC) [220]
+  UINT8   HcWpGrpSize;                            // High-capacity write protect group size [221]
+  UINT8   RelWrSecC;                              // Reliable write sector count [222]
+  UINT8   EraseTimeoutMult;                       // High-capacity erase timeout [223]
+  UINT8   HcEraseGrpSize;                         // High-capacity erase unit size [224]
+  UINT8   AccSize;                                // Access size [225]
+  UINT8   BootSizeMult;                           // Boot partition size [226]
+  UINT8   Reserved18;                             // Reserved [227]
+  UINT8   BootInfo;                               // Boot information [228]
+  UINT8   SecTrimMult;                            // Secure TRIM Multiplier [229]
+  UINT8   SecEraseMult;                           // Secure Erase Multiplier [230]
+  UINT8   SecFeatureSupport;                      // Secure Feature support [231]
+  UINT8   TrimMult;                               // TRIM Multiplier [232]
+  UINT8   Reserved19;                             // Reserved [233]
+  UINT8   MinPerfDdrR8b52M;                       // Minimum Read Performance for 8bit at 52MHz in DDR mode [234]
+  UINT8   MinPerfDdrW8b52M;                       // Minimum Write Performance for 8bit at 52MHz in DDR mode [235]
+  UINT8   PwrCl200M130V;                          // Power class for 200MHz, at VCCQ=1.3V, VCC = 3.6V [236]
+  UINT8   PwrCl200M195V;                          // Power class for 200MHz at VCCQ=1.95V, VCC = 3.6V [237]
+  UINT8   PwrClDdr52M195V;                        // Power class for 52MHz, DDR at VCC= 1.95V [238]
+  UINT8   PwrClDdr52M360V;                        // Power class for 52MHz, DDR at VCC= 3.6V [239]
+  UINT8   Reserved20;                             // Reserved [240]
+  UINT8   IniTimeoutAp;                           // 1st initialization time after partitioning [241]
+  UINT8   CorrectlyPrgSectorsNum[4];              // Number of correctly programmed sectors [245:242]
+  UINT8   BkopsStatus;                            // Background operations status [246]
+  UINT8   PowerOffLongTime;                       // Power off notification(long) timeout [247]
+  UINT8   GenericCmd6Time;                        // Generic CMD6 timeout [248]
+  UINT8   CacheSize[4];                           // Cache size [252:249]
+  UINT8   PwrClDdr200M360V;                       // Power class for 200MHz, DDR at VCC= 3.6V [253]
+  UINT8   FirmwareVersion[8];                     // Firmware version [261:254]
+  UINT8   DeviceVersion[2];                       // Device version [263:262]
+  UINT8   OptimalTrimUnitSize;                    // Optimal trim unit size[264]
+  UINT8   OptimalWriteSize;                       // Optimal write size [265]
+  UINT8   OptimalReadSize;                        // Optimal read size [266]
+  UINT8   PreEolInfo;                             // Pre EOL information [267]
+  UINT8   DeviceLifeTimeEstTypA;                  // Device life time estimation type A [268]
+  UINT8   DeviceLifeTimeEstTypB;                  // Device life time estimation type B [269]
+  UINT8   VendorProprietaryHealthReport[32];      // Vendor proprietary health report [301:270]
+  UINT8   NumOfFwSectorsProgrammed[4];            // Number of FW sectors correctly programmed [305:302]
+  UINT8   Reserved21[181];                        // Reserved [486:306]
+  UINT8   FfuArg[4];                              // FFU Argument [490:487]
+  UINT8   OperationCodeTimeout;                   // Operation codes timeout [491]
+  UINT8   FfuFeatures;                            // FFU features [492]
+  UINT8   SupportedModes;                         // Supported modes [493]
+  UINT8   ExtSupport;                             // Extended partitions attribute support [494]
+  UINT8   LargeUnitSizeM1;                        // Large Unit size [495]
+  UINT8   ContextCapabilities;                    // Context management capabilities [496]
+  UINT8   TagResSize;                             // Tag Resources Size [497]
+  UINT8   TagUnitSize;                            // Tag Unit Size [498]
+  UINT8   DataTagSupport;                         // Data Tag Support [499]
+  UINT8   MaxPackedWrites;                        // Max packed write commands [500]
+  UINT8   MaxPackedReads;                         // Max packed read commands[501]
+  UINT8   BkOpsSupport;                           // Background operations support [502]
+  UINT8   HpiFeatures;                            // HPI features [503]
+  UINT8   SupportedCmdSet;                        // Supported Command Sets [504]
+  UINT8   ExtSecurityErr;                         // Extended Security Commands Error [505]
+  UINT8   Reserved22[6];                          // Reserved [511:506]
+} EMMC_EXT_CSD;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/HighPrecisionEventTimerTable.h b/libedk2_tpm/include/IndustryStandard/HighPrecisionEventTimerTable.h
new file mode 100644
index 0000000..d2bc6d5
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/HighPrecisionEventTimerTable.h
@@ -0,0 +1,62 @@
+/** @file
+  ACPI high precision event timer table definition, at www.intel.com
+  Specification name is IA-PC HPET (High Precision Event Timers) Specification.
+
+  Copyright (c) 2007 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _HIGH_PRECISION_EVENT_TIMER_TABLE_H_
+#define _HIGH_PRECISION_EVENT_TIMER_TABLE_H_
+
+#include <IndustryStandard/Acpi.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// HPET Event Timer Block ID described in IA-PC HPET Specification, 3.2.4.
+///
+typedef union {
+  struct {
+    UINT32 Revision       : 8;
+    UINT32 NumberOfTimers : 5;
+    UINT32 CounterSize    : 1;
+    UINT32 Reserved       : 1;
+    UINT32 LegacyRoute    : 1;
+    UINT32 VendorId       : 16;
+  }      Bits;
+  UINT32 Uint32;
+} EFI_ACPI_HIGH_PRECISION_EVENT_TIMER_BLOCK_ID;
+
+
+///
+/// High Precision Event Timer Table header definition.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER             Header;
+  UINT32                                  EventTimerBlockId;
+  EFI_ACPI_2_0_GENERIC_ADDRESS_STRUCTURE  BaseAddressLower32Bit;
+  UINT8                                   HpetNumber;
+  UINT16                                  MainCounterMinimumClockTickInPeriodicMode;
+  UINT8                                   PageProtectionAndOemAttribute;
+} EFI_ACPI_HIGH_PRECISION_EVENT_TIMER_TABLE_HEADER;
+
+///
+/// HPET Revision (defined in spec)
+///
+#define EFI_ACPI_HIGH_PRECISION_EVENT_TIMER_TABLE_REVISION  0x01
+
+//
+// Page protection setting
+// Values 3 through 15 are reserved for use by the specification
+//
+#define EFI_ACPI_NO_PAGE_PROTECTION   0
+#define EFI_ACPI_4KB_PAGE_PROTECTION  1
+#define EFI_ACPI_64KB_PAGE_PROTECTION 2
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/LowPowerIdleTable.h b/libedk2_tpm/include/IndustryStandard/LowPowerIdleTable.h
new file mode 100644
index 0000000..8de0cbf
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/LowPowerIdleTable.h
@@ -0,0 +1,76 @@
+/** @file
+  ACPI Low Power Idle Table (LPIT) definitions
+
+  Copyright (c) 2016, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+  @par Revision Reference:
+    - ACPI Low Power Idle Table (LPIT) Revision 001, dated July 2014
+      http://www.uefi.org/sites/default/files/resources/ACPI_Low_Power_Idle_Table.pdf
+
+  @par Glossary:
+    - GAS - Generic Address Structure
+    - LPI - Low Power Idle
+**/
+#ifndef _LOW_POWER_IDLE_TABLE_H_
+#define _LOW_POWER_IDLE_TABLE_H_
+
+#include <IndustryStandard/Acpi.h>
+
+#pragma pack(1)
+
+///
+/// LPI Structure Types
+///
+#define ACPI_LPI_STRUCTURE_TYPE_NATIVE_CSTATE     0x00
+
+///
+/// Low Power Idle (LPI) State Flags
+///
+typedef union {
+  struct {
+    UINT32 Disabled           : 1;  ///< If set, LPI state is not used
+    /**
+      If set, Residency counter is not available for this LPI state and
+      Residency Counter Frequency is invalid
+    **/
+    UINT32 CounterUnavailable : 1;
+    UINT32 Reserved           : 30; ///< Reserved for future use. Must be zero
+  } Bits;
+  UINT32 Data32;
+} ACPI_LPI_STATE_FLAGS;
+
+///
+/// Low Power Idle (LPI) structure with Native C-state instruction entry trigger descriptor
+///
+typedef struct {
+  UINT32                                  Type;   ///< LPI State descriptor Type 0
+  UINT32                                  Length; ///< Length of LPI state Descriptor Structure
+  ///
+  /// Unique LPI state identifier: zero based, monotonically increasing identifier
+  ///
+  UINT16                                  UniqueId;
+  UINT8                                   Reserved[2];  ///< Must be Zero
+  ACPI_LPI_STATE_FLAGS                    Flags;        ///< LPI state flags
+  /**
+    The LPI entry trigger, matching an existing _CST.Register object, represented as a
+    Generic Address Structure. All processors must request this state or deeper to trigger.
+  **/
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  EntryTrigger;
+  UINT32                                  Residency;  ///< Minimum residency or break-even in uSec
+  UINT32                                  Latency;    ///< Worst case exit latency in uSec
+  /**
+    [optional] Residency counter, represented as a Generic Address Structure.
+    If not present, Flags[1] bit should be set.
+  **/
+  EFI_ACPI_6_1_GENERIC_ADDRESS_STRUCTURE  ResidencyCounter;
+  /**
+    [optional] Residency counter frequency in cycles per second. Value 0 indicates that
+    counter runs at TSC frequency. Valid only if Residency Counter is present.
+  **/
+  UINT64                                  ResidencyCounterFrequency;
+} ACPI_LPI_NATIVE_CSTATE_DESCRIPTOR;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Mbr.h b/libedk2_tpm/include/IndustryStandard/Mbr.h
new file mode 100644
index 0000000..2d8c1f1
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Mbr.h
@@ -0,0 +1,54 @@
+/** @file
+  Legacy Master Boot Record Format Definition.
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _MBR_H_
+#define _MBR_H_
+
+#define MBR_SIGNATURE               0xaa55
+
+#define EXTENDED_DOS_PARTITION      0x05
+#define EXTENDED_WINDOWS_PARTITION  0x0F
+
+#define MAX_MBR_PARTITIONS          4
+
+#define PMBR_GPT_PARTITION          0xEE
+#define EFI_PARTITION               0xEF
+
+#define MBR_SIZE                    512
+
+#pragma pack(1)
+///
+/// MBR Partition Entry
+///
+typedef struct {
+  UINT8 BootIndicator;
+  UINT8 StartHead;
+  UINT8 StartSector;
+  UINT8 StartTrack;
+  UINT8 OSIndicator;
+  UINT8 EndHead;
+  UINT8 EndSector;
+  UINT8 EndTrack;
+  UINT8 StartingLBA[4];
+  UINT8 SizeInLBA[4];
+} MBR_PARTITION_RECORD;
+
+///
+/// MBR Partition Table
+///
+typedef struct {
+  UINT8                 BootStrapCode[440];
+  UINT8                 UniqueMbrSignature[4];
+  UINT8                 Unknown[2];
+  MBR_PARTITION_RECORD  Partition[MAX_MBR_PARTITIONS];
+  UINT16                Signature;
+} MASTER_BOOT_RECORD;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/MemoryMappedConfigurationSpaceAccessTable.h b/libedk2_tpm/include/IndustryStandard/MemoryMappedConfigurationSpaceAccessTable.h
new file mode 100644
index 0000000..4bc163e
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/MemoryMappedConfigurationSpaceAccessTable.h
@@ -0,0 +1,49 @@
+/** @file
+  ACPI memory mapped configuration space access table definition, defined at
+  in the PCI Firmware Specification, version 3.0.
+  Specification is available at http://www.pcisig.com.
+
+  Copyright (c) 2007 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+#ifndef _MEMORY_MAPPED_CONFIGURATION_SPACE_ACCESS_TABLE_H_
+#define _MEMORY_MAPPED_CONFIGURATION_SPACE_ACCESS_TABLE_H_
+
+#include <IndustryStandard/Acpi.h>
+
+//
+// Ensure proper structure formats
+//
+#pragma pack(1)
+
+///
+/// Memory Mapped Configuration Space Access Table (MCFG)
+/// This table is a basic description table header followed by
+/// a number of base address allocation structures.
+///
+typedef struct {
+  UINT64  BaseAddress;
+  UINT16  PciSegmentGroupNumber;
+  UINT8   StartBusNumber;
+  UINT8   EndBusNumber;
+  UINT32  Reserved;
+} EFI_ACPI_MEMORY_MAPPED_ENHANCED_CONFIGURATION_SPACE_BASE_ADDRESS_ALLOCATION_STRUCTURE;
+
+///
+/// MCFG Table header definition.  The rest of the table
+/// must be defined in a platform specific manner.
+///
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER                       Header;
+  UINT64                                            Reserved;
+} EFI_ACPI_MEMORY_MAPPED_CONFIGURATION_BASE_ADDRESS_TABLE_HEADER;
+
+///
+/// MCFG Revision (defined in spec)
+///
+#define EFI_ACPI_MEMORY_MAPPED_CONFIGURATION_SPACE_ACCESS_TABLE_REVISION  0x01
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Nvme.h b/libedk2_tpm/include/IndustryStandard/Nvme.h
new file mode 100644
index 0000000..4601a59
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Nvme.h
@@ -0,0 +1,942 @@
+/** @file
+  Definitions based on NVMe spec. version 1.1.
+
+  (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
+  Copyright (c) 2017, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+  @par Specification Reference:
+  NVMe Specification 1.1
+
+**/
+
+#ifndef __NVM_E_H__
+#define __NVM_E_H__
+
+#pragma pack(1)
+
+//
+// controller register offsets
+//
+#define NVME_CAP_OFFSET          0x0000  // Controller Capabilities
+#define NVME_VER_OFFSET          0x0008  // Version
+#define NVME_INTMS_OFFSET        0x000c  // Interrupt Mask Set
+#define NVME_INTMC_OFFSET        0x0010  // Interrupt Mask Clear
+#define NVME_CC_OFFSET           0x0014  // Controller Configuration
+#define NVME_CSTS_OFFSET         0x001c  // Controller Status
+#define NVME_NSSR_OFFSET         0x0020  // NVM Subsystem Reset
+#define NVME_AQA_OFFSET          0x0024  // Admin Queue Attributes
+#define NVME_ASQ_OFFSET          0x0028  // Admin Submission Queue Base Address
+#define NVME_ACQ_OFFSET          0x0030  // Admin Completion Queue Base Address
+#define NVME_SQ0_OFFSET          0x1000  // Submission Queue 0 (admin) Tail Doorbell
+#define NVME_CQ0_OFFSET          0x1004  // Completion Queue 0 (admin) Head Doorbell
+
+//
+// These register offsets are defined as 0x1000 + (N * (4 << CAP.DSTRD))
+// Get the doorbell stride bit shift value from the controller capabilities.
+//
+#define NVME_SQTDBL_OFFSET(QID, DSTRD)    0x1000 + ((2 * (QID)) * (4 << (DSTRD)))       // Submission Queue y (NVM) Tail Doorbell
+#define NVME_CQHDBL_OFFSET(QID, DSTRD)    0x1000 + (((2 * (QID)) + 1) * (4 << (DSTRD))) // Completion Queue y (NVM) Head Doorbell
+
+
+#pragma pack(1)
+
+//
+// 3.1.1 Offset 00h: CAP - Controller Capabilities
+//
+typedef struct {
+  UINT16 Mqes;      // Maximum Queue Entries Supported
+  UINT8  Cqr:1;     // Contiguous Queues Required
+  UINT8  Ams:2;     // Arbitration Mechanism Supported
+  UINT8  Rsvd1:5;
+  UINT8  To;        // Timeout
+  UINT16 Dstrd:4;
+  UINT16 Nssrs:1;   // NVM Subsystem Reset Supported NSSRS
+  UINT16 Css:4;     // Command Sets Supported - Bit 37
+  UINT16 Rsvd3:7;
+  UINT8  Mpsmin:4;
+  UINT8  Mpsmax:4;
+  UINT8  Rsvd4;
+} NVME_CAP;
+
+//
+// 3.1.2 Offset 08h: VS - Version
+//
+typedef struct {
+  UINT16 Mnr;       // Minor version number
+  UINT16 Mjr;       // Major version number
+} NVME_VER;
+
+//
+// 3.1.5 Offset 14h: CC - Controller Configuration
+//
+typedef struct {
+  UINT16 En:1;       // Enable
+  UINT16 Rsvd1:3;
+  UINT16 Css:3;      // I/O Command Set Selected
+  UINT16 Mps:4;      // Memory Page Size
+  UINT16 Ams:3;      // Arbitration Mechanism Selected
+  UINT16 Shn:2;      // Shutdown Notification
+  UINT8  Iosqes:4;   // I/O Submission Queue Entry Size
+  UINT8  Iocqes:4;   // I/O Completion Queue Entry Size
+  UINT8  Rsvd2;
+} NVME_CC;
+#define NVME_CC_SHN_NORMAL_SHUTDOWN    1
+#define NVME_CC_SHN_ABRUPT_SHUTDOWN    2
+
+//
+// 3.1.6 Offset 1Ch: CSTS - Controller Status
+//
+typedef struct {
+  UINT32 Rdy:1;      // Ready
+  UINT32 Cfs:1;      // Controller Fatal Status
+  UINT32 Shst:2;     // Shutdown Status
+  UINT32 Nssro:1;    // NVM Subsystem Reset Occurred
+  UINT32 Rsvd1:27;
+} NVME_CSTS;
+#define NVME_CSTS_SHST_SHUTDOWN_OCCURRING 1
+#define NVME_CSTS_SHST_SHUTDOWN_COMPLETED 2
+//
+// 3.1.8 Offset 24h: AQA - Admin Queue Attributes
+//
+typedef struct {
+  UINT16 Asqs:12;    // Submission Queue Size
+  UINT16 Rsvd1:4;
+  UINT16 Acqs:12;    // Completion Queue Size
+  UINT16 Rsvd2:4;
+} NVME_AQA;
+
+//
+// 3.1.9 Offset 28h: ASQ - Admin Submission Queue Base Address
+//
+#define NVME_ASQ      UINT64
+//
+// 3.1.10 Offset 30h: ACQ - Admin Completion Queue Base Address
+//
+#define NVME_ACQ      UINT64
+
+//
+// 3.1.11 Offset (1000h + ((2y) * (4 << CAP.DSTRD))): SQyTDBL - Submission Queue y Tail Doorbell
+//
+typedef struct {
+  UINT16 Sqt;
+  UINT16 Rsvd1;
+} NVME_SQTDBL;
+
+//
+// 3.1.12 Offset (1000h + ((2y + 1) * (4 << CAP.DSTRD))): CQyHDBL - Completion Queue y Head Doorbell
+//
+typedef struct {
+  UINT16 Cqh;
+  UINT16 Rsvd1;
+} NVME_CQHDBL;
+
+//
+// NVM command set structures
+//
+// Read Command
+//
+typedef struct {
+  //
+  // CDW 10, 11
+  //
+  UINT64 Slba;                /* Starting Sector Address */
+  //
+  // CDW 12
+  //
+  UINT16 Nlb;                 /* Number of Sectors */
+  UINT16 Rsvd1:10;
+  UINT16 Prinfo:4;            /* Protection Info Check */
+  UINT16 Fua:1;               /* Force Unit Access */
+  UINT16 Lr:1;                /* Limited Retry */
+  //
+  // CDW 13
+  //
+  UINT32 Af:4;                /* Access Frequency */
+  UINT32 Al:2;                /* Access Latency */
+  UINT32 Sr:1;                /* Sequential Request */
+  UINT32 In:1;                /* Incompressible */
+  UINT32 Rsvd2:24;
+  //
+  // CDW 14
+  //
+  UINT32 Eilbrt;              /* Expected Initial Logical Block Reference Tag */
+  //
+  // CDW 15
+  //
+  UINT16 Elbat;               /* Expected Logical Block Application Tag */
+  UINT16 Elbatm;              /* Expected Logical Block Application Tag Mask */
+} NVME_READ;
+
+//
+// Write Command
+//
+typedef struct {
+  //
+  // CDW 10, 11
+  //
+  UINT64 Slba;                /* Starting Sector Address */
+  //
+  // CDW 12
+  //
+  UINT16 Nlb;                 /* Number of Sectors */
+  UINT16 Rsvd1:10;
+  UINT16 Prinfo:4;            /* Protection Info Check */
+  UINT16 Fua:1;               /* Force Unit Access */
+  UINT16 Lr:1;                /* Limited Retry */
+  //
+  // CDW 13
+  //
+  UINT32 Af:4;                /* Access Frequency */
+  UINT32 Al:2;                /* Access Latency */
+  UINT32 Sr:1;                /* Sequential Request */
+  UINT32 In:1;                /* Incompressible */
+  UINT32 Rsvd2:24;
+  //
+  // CDW 14
+  //
+  UINT32 Ilbrt;               /* Initial Logical Block Reference Tag */
+  //
+  // CDW 15
+  //
+  UINT16 Lbat;                /* Logical Block Application Tag */
+  UINT16 Lbatm;               /* Logical Block Application Tag Mask */
+} NVME_WRITE;
+
+//
+// Flush
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Flush;               /* Flush */
+} NVME_FLUSH;
+
+//
+// Write Uncorrectable command
+//
+typedef struct {
+  //
+  // CDW 10, 11
+  //
+  UINT64 Slba;                /* Starting LBA */
+  //
+  // CDW 12
+  //
+  UINT32 Nlb:16;              /* Number of  Logical Blocks */
+  UINT32 Rsvd1:16;
+} NVME_WRITE_UNCORRECTABLE;
+
+//
+// Write Zeroes command
+//
+typedef struct {
+  //
+  // CDW 10, 11
+  //
+  UINT64 Slba;                /* Starting LBA */
+  //
+  // CDW 12
+  //
+  UINT16 Nlb;                 /* Number of Logical Blocks */
+  UINT16 Rsvd1:10;
+  UINT16 Prinfo:4;            /* Protection Info Check */
+  UINT16 Fua:1;               /* Force Unit Access */
+  UINT16 Lr:1;                /* Limited Retry */
+  //
+  // CDW 13
+  //
+  UINT32 Rsvd2;
+  //
+  // CDW 14
+  //
+  UINT32 Ilbrt;               /* Initial Logical Block Reference Tag */
+  //
+  // CDW 15
+  //
+  UINT16 Lbat;                /* Logical Block Application Tag */
+  UINT16 Lbatm;               /* Logical Block Application Tag Mask */
+} NVME_WRITE_ZEROES;
+
+//
+// Compare command
+//
+typedef struct {
+  //
+  // CDW 10, 11
+  //
+  UINT64 Slba;                /* Starting LBA */
+  //
+  // CDW 12
+  //
+  UINT16 Nlb;                 /* Number of Logical Blocks */
+  UINT16 Rsvd1:10;
+  UINT16 Prinfo:4;            /* Protection Info Check */
+  UINT16 Fua:1;               /* Force Unit Access */
+  UINT16 Lr:1;                /* Limited Retry */
+  //
+  // CDW 13
+  //
+  UINT32 Rsvd2;
+  //
+  // CDW 14
+  //
+  UINT32 Eilbrt;              /* Expected Initial Logical Block Reference Tag */
+  //
+  // CDW 15
+  //
+  UINT16 Elbat;               /* Expected Logical Block Application Tag */
+  UINT16 Elbatm;              /* Expected Logical Block Application Tag Mask */
+} NVME_COMPARE;
+
+typedef union {
+  NVME_READ                   Read;
+  NVME_WRITE                  Write;
+  NVME_FLUSH                  Flush;
+  NVME_WRITE_UNCORRECTABLE    WriteUncorrectable;
+  NVME_WRITE_ZEROES           WriteZeros;
+  NVME_COMPARE                Compare;
+} NVME_CMD;
+
+typedef struct {
+  UINT16 Mp;                /* Maximum Power */
+  UINT8  Rsvd1;             /* Reserved as of Nvm Express 1.1 Spec */
+  UINT8  Mps:1;             /* Max Power Scale */
+  UINT8  Nops:1;            /* Non-Operational State */
+  UINT8  Rsvd2:6;           /* Reserved as of Nvm Express 1.1 Spec */
+  UINT32 Enlat;             /* Entry Latency */
+  UINT32 Exlat;             /* Exit Latency */
+  UINT8  Rrt:5;             /* Relative Read Throughput */
+  UINT8  Rsvd3:3;           /* Reserved as of Nvm Express 1.1 Spec */
+  UINT8  Rrl:5;             /* Relative Read Latency */
+  UINT8  Rsvd4:3;           /* Reserved as of Nvm Express 1.1 Spec */
+  UINT8  Rwt:5;             /* Relative Write Throughput */
+  UINT8  Rsvd5:3;           /* Reserved as of Nvm Express 1.1 Spec */
+  UINT8  Rwl:5;             /* Relative Write Latency */
+  UINT8  Rsvd6:3;           /* Reserved as of Nvm Express 1.1 Spec */
+  UINT8  Rsvd7[16];         /* Reserved as of Nvm Express 1.1 Spec */
+} NVME_PSDESCRIPTOR;
+
+//
+//  Identify Controller Data
+//
+typedef struct {
+  //
+  // Controller Capabilities and Features 0-255
+  //
+  UINT16 Vid;                 /* PCI Vendor ID */
+  UINT16 Ssvid;               /* PCI sub-system vendor ID */
+  UINT8  Sn[20];              /* Product serial number */
+
+  UINT8  Mn[40];              /* Product model number */
+  UINT8  Fr[8];               /* Firmware Revision */
+  UINT8  Rab;                 /* Recommended Arbitration Burst */
+  UINT8  Ieee_oui[3];         /* Organization Unique Identifier */
+  UINT8  Cmic;                /* Multi-interface Capabilities */
+  UINT8  Mdts;                /* Maximum Data Transfer Size */
+  UINT8  Cntlid[2];           /* Controller ID */
+  UINT8  Rsvd1[176];          /* Reserved as of Nvm Express 1.1 Spec */
+  //
+  // Admin Command Set Attributes
+  //
+  UINT16 Oacs;                /* Optional Admin Command Support */
+    #define NAMESPACE_MANAGEMENT_SUPPORTED  BIT3
+    #define FW_DOWNLOAD_ACTIVATE_SUPPORTED  BIT2
+    #define FORMAT_NVM_SUPPORTED            BIT1
+    #define SECURITY_SEND_RECEIVE_SUPPORTED BIT0
+  UINT8  Acl;                 /* Abort Command Limit */
+  UINT8  Aerl;                /* Async Event Request Limit */
+  UINT8  Frmw;                /* Firmware updates */
+  UINT8  Lpa;                 /* Log Page Attributes */
+  UINT8  Elpe;                /* Error Log Page Entries */
+  UINT8  Npss;                /* Number of Power States Support */
+  UINT8  Avscc;               /* Admin Vendor Specific Command Configuration */
+  UINT8  Apsta;               /* Autonomous Power State Transition Attributes */
+  //
+  // Below fields before Rsvd2 are defined in NVM Express 1.3 Spec
+  //
+  UINT16 Wctemp;              /* Warning Composite Temperature Threshold */
+  UINT16 Cctemp;              /* Critical Composite Temperature Threshold */
+  UINT16 Mtfa;                /* Maximum Time for Firmware Activation */
+  UINT32 Hmpre;               /* Host Memory Buffer Preferred Size */
+  UINT32 Hmmin;               /* Host Memory Buffer Minimum Size */
+  UINT8  Tnvmcap[16];         /* Total NVM Capacity */
+  UINT8  Rsvd2[216];          /* Reserved as of NVM Express */
+  //
+  // NVM Command Set Attributes
+  //
+  UINT8  Sqes;                /* Submission Queue Entry Size */
+  UINT8  Cqes;                /* Completion Queue Entry Size */
+  UINT16 Rsvd3;               /* Reserved as of Nvm Express 1.1 Spec */
+  UINT32 Nn;                  /* Number of Namespaces */
+  UINT16 Oncs;                /* Optional NVM Command Support */
+  UINT16 Fuses;               /* Fused Operation Support */
+  UINT8  Fna;                 /* Format NVM Attributes */
+  UINT8  Vwc;                 /* Volatile Write Cache */
+  UINT16 Awun;                /* Atomic Write Unit Normal */
+  UINT16 Awupf;               /* Atomic Write Unit Power Fail */
+  UINT8  Nvscc;               /* NVM Vendor Specific Command Configuration */
+  UINT8  Rsvd4;               /* Reserved as of Nvm Express 1.1 Spec */
+  UINT16 Acwu;                /* Atomic Compare & Write Unit */
+  UINT16 Rsvd5;               /* Reserved as of Nvm Express 1.1 Spec */
+  UINT32 Sgls;                /* SGL Support  */
+  UINT8  Rsvd6[164];          /* Reserved as of Nvm Express 1.1 Spec */
+  //
+  // I/O Command set Attributes
+  //
+  UINT8 Rsvd7[1344];          /* Reserved as of Nvm Express 1.1 Spec */
+  //
+  // Power State Descriptors
+  //
+  NVME_PSDESCRIPTOR PsDescriptor[32];
+
+  UINT8  VendorData[1024];    /* Vendor specific data */
+} NVME_ADMIN_CONTROLLER_DATA;
+
+typedef struct {
+  UINT16 Ms;                /* Metadata Size */
+  UINT8  Lbads;             /* LBA Data Size */
+  UINT8  Rp:2;              /* Relative Performance */
+    #define LBAF_RP_BEST      00b
+    #define LBAF_RP_BETTER    01b
+    #define LBAF_RP_GOOD      10b
+    #define LBAF_RP_DEGRADED  11b
+  UINT8  Rsvd1:6;           /* Reserved as of Nvm Express 1.1 Spec */
+} NVME_LBAFORMAT;
+
+//
+// Identify Namespace Data
+//
+typedef struct {
+  //
+  // NVM Command Set Specific
+  //
+  UINT64 Nsze;                /* Namespace Size (total number of blocks in formatted namespace) */
+  UINT64 Ncap;                /* Namespace Capacity (max number of logical blocks) */
+  UINT64 Nuse;                /* Namespace Utilization */
+  UINT8  Nsfeat;              /* Namespace Features */
+  UINT8  Nlbaf;               /* Number of LBA Formats */
+  UINT8  Flbas;               /* Formatted LBA size */
+  UINT8  Mc;                  /* Metadata Capabilities */
+  UINT8  Dpc;                 /* End-to-end Data Protection capabilities */
+  UINT8  Dps;                 /* End-to-end Data Protection Type Settings */
+  UINT8  Nmic;                /* Namespace Multi-path I/O and Namespace Sharing Capabilities */
+  UINT8  Rescap;              /* Reservation Capabilities */
+  UINT8  Rsvd1[88];           /* Reserved as of Nvm Express 1.1 Spec */
+  UINT64 Eui64;               /* IEEE Extended Unique Identifier */
+  //
+  // LBA Format
+  //
+  NVME_LBAFORMAT LbaFormat[16];
+
+  UINT8 Rsvd2[192];           /* Reserved as of Nvm Express 1.1 Spec */
+  UINT8 VendorData[3712];     /* Vendor specific data */
+} NVME_ADMIN_NAMESPACE_DATA;
+
+//
+// NvmExpress Admin Identify Cmd
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Cns:2;
+  UINT32 Rsvd1:30;
+} NVME_ADMIN_IDENTIFY;
+
+//
+// NvmExpress Admin Create I/O Completion Queue
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Qid:16;              /* Queue Identifier */
+  UINT32 Qsize:16;            /* Queue Size */
+
+  //
+  // CDW 11
+  //
+  UINT32 Pc:1;                /* Physically Contiguous */
+  UINT32 Ien:1;               /* Interrupts Enabled */
+  UINT32 Rsvd1:14;            /* reserved as of Nvm Express 1.1 Spec */
+  UINT32 Iv:16;               /* Interrupt Vector for MSI-X or MSI*/
+} NVME_ADMIN_CRIOCQ;
+
+//
+// NvmExpress Admin Create I/O Submission Queue
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Qid:16;              /* Queue Identifier */
+  UINT32 Qsize:16;            /* Queue Size */
+
+  //
+  // CDW 11
+  //
+  UINT32 Pc:1;                /* Physically Contiguous */
+  UINT32 Qprio:2;             /* Queue Priority */
+  UINT32 Rsvd1:13;            /* Reserved as of Nvm Express 1.1 Spec */
+  UINT32 Cqid:16;             /* Completion Queue ID */
+} NVME_ADMIN_CRIOSQ;
+
+//
+// NvmExpress Admin Delete I/O Completion Queue
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT16 Qid;
+  UINT16 Rsvd1;
+} NVME_ADMIN_DEIOCQ;
+
+//
+// NvmExpress Admin Delete I/O Submission Queue
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT16 Qid;
+  UINT16 Rsvd1;
+} NVME_ADMIN_DEIOSQ;
+
+//
+// NvmExpress Admin Abort Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Sqid:16;             /* Submission Queue identifier */
+  UINT32 Cid:16;              /* Command Identifier */
+} NVME_ADMIN_ABORT;
+
+//
+// NvmExpress Admin Firmware Activate Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Fs:3;                /* Submission Queue identifier */
+  UINT32 Aa:2;                /* Command Identifier */
+  UINT32 Rsvd1:27;
+} NVME_ADMIN_FIRMWARE_ACTIVATE;
+
+//
+// NvmExpress Admin Firmware Image Download Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Numd;                /* Number of Dwords */
+  //
+  // CDW 11
+  //
+  UINT32 Ofst;                /* Offset */
+} NVME_ADMIN_FIRMWARE_IMAGE_DOWNLOAD;
+
+//
+// NvmExpress Admin Get Features Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Fid:8;                /* Feature Identifier */
+  UINT32 Sel:3;                /* Select */
+  UINT32 Rsvd1:21;
+} NVME_ADMIN_GET_FEATURES;
+
+//
+// NvmExpress Admin Get Log Page Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Lid:8;               /* Log Page Identifier */
+    #define LID_ERROR_INFO   0x1
+    #define LID_SMART_INFO   0x2
+    #define LID_FW_SLOT_INFO 0x3
+  UINT32 Rsvd1:8;
+  UINT32 Numd:12;             /* Number of Dwords */
+  UINT32 Rsvd2:4;             /* Reserved as of Nvm Express 1.1 Spec */
+} NVME_ADMIN_GET_LOG_PAGE;
+
+//
+// NvmExpress Admin Set Features Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Fid:8;               /* Feature Identifier */
+  UINT32 Rsvd1:23;
+  UINT32 Sv:1;                /* Save */
+} NVME_ADMIN_SET_FEATURES;
+
+//
+// NvmExpress Admin Format NVM Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Lbaf:4;              /* LBA Format */
+  UINT32 Ms:1;                /* Metadata Settings */
+  UINT32 Pi:3;                /* Protection Information */
+  UINT32 Pil:1;               /* Protection Information Location */
+  UINT32 Ses:3;               /* Secure Erase Settings */
+  UINT32 Rsvd1:20;
+} NVME_ADMIN_FORMAT_NVM;
+
+//
+// NvmExpress Admin Security Receive Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Rsvd1:8;
+  UINT32 Spsp:16;             /* SP Specific */
+  UINT32 Secp:8;              /* Security Protocol */
+  //
+  // CDW 11
+  //
+  UINT32 Al;                  /* Allocation Length */
+} NVME_ADMIN_SECURITY_RECEIVE;
+
+//
+// NvmExpress Admin Security Send Command
+//
+typedef struct {
+  //
+  // CDW 10
+  //
+  UINT32 Rsvd1:8;
+  UINT32 Spsp:16;             /* SP Specific */
+  UINT32 Secp:8;              /* Security Protocol */
+  //
+  // CDW 11
+  //
+  UINT32 Tl;                  /* Transfer Length */
+} NVME_ADMIN_SECURITY_SEND;
+
+typedef union {
+  NVME_ADMIN_IDENTIFY                   Identify;
+  NVME_ADMIN_CRIOCQ                     CrIoCq;
+  NVME_ADMIN_CRIOSQ                     CrIoSq;
+  NVME_ADMIN_DEIOCQ                     DeIoCq;
+  NVME_ADMIN_DEIOSQ                     DeIoSq;
+  NVME_ADMIN_ABORT                      Abort;
+  NVME_ADMIN_FIRMWARE_ACTIVATE          Activate;
+  NVME_ADMIN_FIRMWARE_IMAGE_DOWNLOAD    FirmwareImageDownload;
+  NVME_ADMIN_GET_FEATURES               GetFeatures;
+  NVME_ADMIN_GET_LOG_PAGE               GetLogPage;
+  NVME_ADMIN_SET_FEATURES               SetFeatures;
+  NVME_ADMIN_FORMAT_NVM                 FormatNvm;
+  NVME_ADMIN_SECURITY_RECEIVE           SecurityReceive;
+  NVME_ADMIN_SECURITY_SEND              SecuritySend;
+} NVME_ADMIN_CMD;
+
+typedef struct {
+  UINT32 Cdw10;
+  UINT32 Cdw11;
+  UINT32 Cdw12;
+  UINT32 Cdw13;
+  UINT32 Cdw14;
+  UINT32 Cdw15;
+} NVME_RAW;
+
+typedef union {
+  NVME_ADMIN_CMD Admin;   // Union of Admin commands
+  NVME_CMD       Nvm;     // Union of Nvm commands
+  NVME_RAW       Raw;
+} NVME_PAYLOAD;
+
+//
+// Submission Queue
+//
+typedef struct {
+  //
+  // CDW 0, Common to all commands
+  //
+  UINT8  Opc;               // Opcode
+  UINT8  Fuse:2;            // Fused Operation
+  UINT8  Rsvd1:5;
+  UINT8  Psdt:1;            // PRP or SGL for Data Transfer
+  UINT16 Cid;               // Command Identifier
+
+  //
+  // CDW 1
+  //
+  UINT32 Nsid;              // Namespace Identifier
+
+  //
+  // CDW 2,3
+  //
+  UINT64 Rsvd2;
+
+  //
+  // CDW 4,5
+  //
+  UINT64 Mptr;              // Metadata Pointer
+
+  //
+  // CDW 6-9
+  //
+  UINT64 Prp[2];            // First and second PRP entries
+
+  NVME_PAYLOAD Payload;
+
+} NVME_SQ;
+
+//
+// Completion Queue
+//
+typedef struct {
+  //
+  // CDW 0
+  //
+  UINT32 Dword0;
+  //
+  // CDW 1
+  //
+  UINT32 Rsvd1;
+  //
+  // CDW 2
+  //
+  UINT16 Sqhd;              // Submission Queue Head Pointer
+  UINT16 Sqid;              // Submission Queue Identifier
+  //
+  // CDW 3
+  //
+  UINT16 Cid;               // Command Identifier
+  UINT16 Pt:1;              // Phase Tag
+  UINT16 Sc:8;              // Status Code
+  UINT16 Sct:3;             // Status Code Type
+  UINT16 Rsvd2:2;
+  UINT16 Mo:1;              // More
+  UINT16 Dnr:1;             // Do Not Retry
+} NVME_CQ;
+
+//
+// Nvm Express Admin cmd opcodes
+//
+#define NVME_ADMIN_DEIOSQ_CMD                0x00
+#define NVME_ADMIN_CRIOSQ_CMD                0x01
+#define NVME_ADMIN_GET_LOG_PAGE_CMD          0x02
+#define NVME_ADMIN_DEIOCQ_CMD                0x04
+#define NVME_ADMIN_CRIOCQ_CMD                0x05
+#define NVME_ADMIN_IDENTIFY_CMD              0x06
+#define NVME_ADMIN_ABORT_CMD                 0x08
+#define NVME_ADMIN_SET_FEATURES_CMD          0x09
+#define NVME_ADMIN_GET_FEATURES_CMD          0x0A
+#define NVME_ADMIN_ASYNC_EVENT_REQUEST_CMD   0x0C
+#define NVME_ADMIN_NAMESACE_MANAGEMENT_CMD   0x0D
+#define NVME_ADMIN_FW_COMMIT_CMD             0x10
+#define NVME_ADMIN_FW_IAMGE_DOWNLOAD_CMD     0x11
+#define NVME_ADMIN_NAMESACE_ATTACHMENT_CMD   0x15
+#define NVME_ADMIN_FORMAT_NVM_CMD            0x80
+#define NVME_ADMIN_SECURITY_SEND_CMD         0x81
+#define NVME_ADMIN_SECURITY_RECEIVE_CMD      0x82
+
+#define NVME_IO_FLUSH_OPC                    0
+#define NVME_IO_WRITE_OPC                    1
+#define NVME_IO_READ_OPC                     2
+
+typedef enum {
+  DeleteIOSubmissionQueueOpcode = NVME_ADMIN_DEIOSQ_CMD,
+  CreateIOSubmissionQueueOpcode = NVME_ADMIN_CRIOSQ_CMD,
+  GetLogPageOpcode = NVME_ADMIN_GET_LOG_PAGE_CMD,
+  DeleteIOCompletionQueueOpcode = NVME_ADMIN_DEIOCQ_CMD,
+  CreateIOCompletionQueueOpcode = NVME_ADMIN_CRIOCQ_CMD,
+  IdentifyOpcode = NVME_ADMIN_IDENTIFY_CMD,
+  AbortOpcode = NVME_ADMIN_ABORT_CMD,
+  SetFeaturesOpcode = NVME_ADMIN_SET_FEATURES_CMD,
+  GetFeaturesOpcode = NVME_ADMIN_GET_FEATURES_CMD,
+  AsyncEventRequestOpcode = NVME_ADMIN_ASYNC_EVENT_REQUEST_CMD,
+  NamespaceManagementOpcode = NVME_ADMIN_NAMESACE_MANAGEMENT_CMD,
+  FirmwareCommitOpcode = NVME_ADMIN_FW_COMMIT_CMD,
+  FirmwareImageDownloadOpcode = NVME_ADMIN_FW_IAMGE_DOWNLOAD_CMD,
+  NamespaceAttachmentOpcode = NVME_ADMIN_NAMESACE_ATTACHMENT_CMD,
+  FormatNvmOpcode = NVME_ADMIN_FORMAT_NVM_CMD,
+  SecuritySendOpcode = NVME_ADMIN_SECURITY_SEND_CMD,
+  SecurityReceiveOpcode = NVME_ADMIN_SECURITY_RECEIVE_CMD
+} NVME_ADMIN_COMMAND_OPCODE;
+
+//
+// Controller or Namespace Structure (CNS) field
+// (ref. spec. v1.1 figure 82).
+//
+typedef enum {
+IdentifyNamespaceCns = 0x0,
+IdentifyControllerCns = 0x1,
+IdentifyActiveNsListCns = 0x2
+} NVME_ADMIN_IDENTIFY_CNS;
+
+//
+// Commit Action
+// (ref. spec. 1.1 figure 60).
+//
+typedef enum {
+  ActivateActionReplace = 0x0,
+  ActivateActionReplaceActivate = 0x1,
+  ActivateActionActivate = 0x2
+} NVME_FW_ACTIVATE_ACTION;
+
+//
+// Firmware Slot
+// (ref. spec. 1.1 Figure 60).
+//
+typedef enum {
+  FirmwareSlotCtrlChooses = 0x0,
+  FirmwareSlot1 = 0x1,
+  FirmwareSlot2 = 0x2,
+  FirmwareSlot3 = 0x3,
+  FirmwareSlot4 = 0x4,
+  FirmwareSlot5 = 0x5,
+  FirmwareSlot6 = 0x6,
+  FirmwareSlot7 = 0x7
+} NVME_FW_ACTIVATE_SLOT;
+
+//
+// Get Log Page ? Log Page Identifiers
+// (ref. spec. v1.1 Figure 73).
+//
+typedef enum {
+  ErrorInfoLogID = LID_ERROR_INFO,
+  SmartHealthInfoLogID = LID_SMART_INFO,
+  FirmwareSlotInfoLogID = LID_FW_SLOT_INFO
+} NVME_LOG_ID;
+
+//
+// Get Log Page ? Firmware Slot Information Log
+// (ref. spec. v1.1 Figure 77).
+//
+typedef struct {
+  //
+  // Indicates the firmware slot from which the actively running firmware revision was loaded.
+  //
+  UINT8 ActivelyRunningFwSlot:3;
+  UINT8 :1;
+  //
+  // Indicates the firmware slot that is going to be activated at the next controller reset. If this field is 0h, then the controller does not indicate the firmware slot that is going to be activated at the next controller reset.
+  //
+  UINT8 NextActiveFwSlot:3;
+  UINT8 :1;
+} NVME_ACTIVE_FW_INFO;
+
+//
+// Get Log Page ? Firmware Slot Information Log
+// (ref. spec. v1.1 Figure 77).
+//
+typedef struct {
+  //
+  // Specifies information about the active firmware revision.
+  //s
+  NVME_ACTIVE_FW_INFO  ActiveFwInfo;
+  UINT8                Reserved1[7];
+  //
+  // Contains the revision of the firmware downloaded to firmware slot 1/7. If no valid firmware revision is present or if this slot is unsupported, all zeros shall be returned.
+  //
+  CHAR8                FwRevisionSlot[7][8];
+  UINT8                Reserved2[448];
+} NVME_FW_SLOT_INFO_LOG;
+
+//
+// SMART / Health Information (Log Identifier 02h)
+// (ref. spec. v1.1 5.10.1.2)
+//
+typedef struct {
+  //
+  // This field indicates critical warnings for the state of the controller.
+  //
+  UINT8  CriticalWarningAvailableSpare:1;
+  UINT8  CriticalWarningTemperature:1;
+  UINT8  CriticalWarningReliability:1;
+  UINT8  CriticalWarningMediaReadOnly:1;
+  UINT8  CriticalWarningVolatileBackup:1;
+  UINT8  CriticalWarningReserved:3;
+  //
+  // Contains a value corresponding to a temperature in degrees Kelvin that represents the current composite temperature of the controller and namespace(s) associated with that controller. The manner in which this value is computed is implementation specific and may not represent the actual temperature of any physical point in the NVM subsystem.
+  //
+  UINT16 CompositeTemp;
+  //
+  // Contains a normalized percentage (0 to 100%) of the remaining spare capacity available.
+  //
+  UINT8  AvailableSpare;
+  //
+  // When the Available Spare falls below the threshold indicated in this field, an asynchronous event completion may occur. The value is indicated as a normalized percentage (0 to 100%).
+  //
+  UINT8  AvailableSpareThreshold;
+  //
+  // Contains a vendor specific estimate of the percentage of NVM subsystem life used based on the actual usage and the manufacturer's prediction of NVM life. A value of 100 indicates that the estimated endurance of the NVM in the NVM subsystem has been consumed, but may not indicate an NVM subsystem failure. The value is allowed to exceed 100. Percentages greater than 254 shall be represented as 255. This value shall be updated once per power-on hour (when the controller is not in a sleep state).
+  //
+  UINT8  PercentageUsed;
+  UINT8  Reserved1[26];
+  //
+  // Contains the number of 512 byte data units the host has read from the controller; this value does not include metadata.
+  //
+  UINT8  DataUnitsRead[16];
+  //
+  // Contains the number of 512 byte data units the host has written to the controller; this value does not include metadata.
+  //
+  UINT8  DataUnitsWritten[16];
+  //
+  // Contains the number of read commands completed by the controller.
+  //
+  UINT8  HostReadCommands[16];
+  //
+  // Contains the number of write commands completed by the controller.
+  //
+  UINT8  HostWriteCommands[16];
+  //
+  // Contains the amount of time the controller is busy with I/O commands. This value is reported in minutes.
+  //
+  UINT8  ControllerBusyTime[16];
+  //
+  // Contains the number of power cycles.
+  //
+  UINT8  PowerCycles[16];
+  //
+  // Contains the number of power-on hours.
+  //
+  UINT8  PowerOnHours[16];
+  //
+  // Contains the number of unsafe shutdowns.
+  //
+  UINT8  UnsafeShutdowns[16];
+  //
+  // Contains the number of occurrences where the controller detected an unrecovered data integrity error.
+  //
+  UINT8  MediaAndDataIntegrityErrors[16];
+  //
+  // Contains the number of Error Information log entries over the life of the controller.
+  //
+  UINT8  NumberErrorInformationLogEntries[16];
+  //
+  // Contains the amount of time in minutes that the controller is operational and the Composite Temperature is greater than or equal to the Warning Composite Temperature Threshold (WCTEMP) field and less than the Critical Composite Temperature Threshold (CCTEMP) field in the Identify Controller data structure in Figure 90.
+  //
+  UINT32 WarningCompositeTemperatureTime;
+  //
+  // Contains the amount of time in minutes that the controller is operational and the Composite Temperature is greater the Critical Composite Temperature Threshold (CCTEMP) field in the Identify Controller data structure in Figure 90.
+  //
+  UINT32 CriticalCompositeTemperatureTime;
+  //
+  // Contains the current temperature in degrees Kelvin reported by the temperature sensor.  An implementation that does not implement the temperature sensor reports a temperature of zero degrees Kelvin.
+  //
+  UINT16 TemperatureSensor[8];
+  UINT8  Reserved2[296];
+} NVME_SMART_HEALTH_INFO_LOG;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Pci.h b/libedk2_tpm/include/IndustryStandard/Pci.h
new file mode 100644
index 0000000..2cd95d7
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Pci.h
@@ -0,0 +1,15 @@
+/** @file
+  Support for the latest PCI standard.
+
+Copyright (c) 2006 - 2020, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCI_H_
+#define _PCI_H_
+
+#include <IndustryStandard/PciExpress50.h>
+#include <IndustryStandard/PciCodeId.h>
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Pci22.h b/libedk2_tpm/include/IndustryStandard/Pci22.h
new file mode 100644
index 0000000..69e15f7
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Pci22.h
@@ -0,0 +1,861 @@
+/** @file
+  Support for PCI 2.2 standard.
+
+  This file includes the definitions in the following specifications,
+    PCI Local Bus Specification, 2.2
+    PCI-to-PCI Bridge Architecture Specification, Revision 1.2
+    PC Card Standard, 8.0
+    PCI Power Management Interface Specification, Revision 1.2
+
+  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+  Copyright (c) 2014 - 2015, Hewlett-Packard Development Company, L.P.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCI22_H_
+#define _PCI22_H_
+
+#define PCI_MAX_BUS     255
+#define PCI_MAX_DEVICE  31
+#define PCI_MAX_FUNC    7
+
+#pragma pack(1)
+
+///
+/// Common header region in PCI Configuration Space
+/// Section 6.1, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  UINT16  VendorId;
+  UINT16  DeviceId;
+  UINT16  Command;
+  UINT16  Status;
+  UINT8   RevisionID;
+  UINT8   ClassCode[3];
+  UINT8   CacheLineSize;
+  UINT8   LatencyTimer;
+  UINT8   HeaderType;
+  UINT8   BIST;
+} PCI_DEVICE_INDEPENDENT_REGION;
+
+///
+/// PCI Device header region in PCI Configuration Space
+/// Section 6.1, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  UINT32  Bar[6];
+  UINT32  CISPtr;
+  UINT16  SubsystemVendorID;
+  UINT16  SubsystemID;
+  UINT32  ExpansionRomBar;
+  UINT8   CapabilityPtr;
+  UINT8   Reserved1[3];
+  UINT32  Reserved2;
+  UINT8   InterruptLine;
+  UINT8   InterruptPin;
+  UINT8   MinGnt;
+  UINT8   MaxLat;
+} PCI_DEVICE_HEADER_TYPE_REGION;
+
+///
+/// PCI Device Configuration Space
+/// Section 6.1, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  PCI_DEVICE_INDEPENDENT_REGION Hdr;
+  PCI_DEVICE_HEADER_TYPE_REGION Device;
+} PCI_TYPE00;
+
+///
+/// PCI-PCI Bridge header region in PCI Configuration Space
+/// Section 3.2, PCI-PCI Bridge Architecture, Version 1.2
+///
+typedef struct {
+  UINT32  Bar[2];
+  UINT8   PrimaryBus;
+  UINT8   SecondaryBus;
+  UINT8   SubordinateBus;
+  UINT8   SecondaryLatencyTimer;
+  UINT8   IoBase;
+  UINT8   IoLimit;
+  UINT16  SecondaryStatus;
+  UINT16  MemoryBase;
+  UINT16  MemoryLimit;
+  UINT16  PrefetchableMemoryBase;
+  UINT16  PrefetchableMemoryLimit;
+  UINT32  PrefetchableBaseUpper32;
+  UINT32  PrefetchableLimitUpper32;
+  UINT16  IoBaseUpper16;
+  UINT16  IoLimitUpper16;
+  UINT8   CapabilityPtr;
+  UINT8   Reserved[3];
+  UINT32  ExpansionRomBAR;
+  UINT8   InterruptLine;
+  UINT8   InterruptPin;
+  UINT16  BridgeControl;
+} PCI_BRIDGE_CONTROL_REGISTER;
+
+///
+/// PCI-to-PCI Bridge Configuration Space
+/// Section 3.2, PCI-PCI Bridge Architecture, Version 1.2
+///
+typedef struct {
+  PCI_DEVICE_INDEPENDENT_REGION Hdr;
+  PCI_BRIDGE_CONTROL_REGISTER   Bridge;
+} PCI_TYPE01;
+
+typedef union {
+  PCI_TYPE00  Device;
+  PCI_TYPE01  Bridge;
+} PCI_TYPE_GENERIC;
+
+///
+/// CardBus Controller Configuration Space,
+/// Section 4.5.1, PC Card Standard. 8.0
+///
+typedef struct {
+  UINT32  CardBusSocketReg;     ///< Cardbus Socket/ExCA Base
+  UINT8   Cap_Ptr;
+  UINT8   Reserved;
+  UINT16  SecondaryStatus;      ///< Secondary Status
+  UINT8   PciBusNumber;         ///< PCI Bus Number
+  UINT8   CardBusBusNumber;     ///< CardBus Bus Number
+  UINT8   SubordinateBusNumber; ///< Subordinate Bus Number
+  UINT8   CardBusLatencyTimer;  ///< CardBus Latency Timer
+  UINT32  MemoryBase0;          ///< Memory Base Register 0
+  UINT32  MemoryLimit0;         ///< Memory Limit Register 0
+  UINT32  MemoryBase1;
+  UINT32  MemoryLimit1;
+  UINT32  IoBase0;
+  UINT32  IoLimit0;             ///< I/O Base Register 0
+  UINT32  IoBase1;              ///< I/O Limit Register 0
+  UINT32  IoLimit1;
+  UINT8   InterruptLine;        ///< Interrupt Line
+  UINT8   InterruptPin;         ///< Interrupt Pin
+  UINT16  BridgeControl;        ///< Bridge Control
+} PCI_CARDBUS_CONTROL_REGISTER;
+
+//
+// Definitions of PCI class bytes and manipulation macros.
+//
+#define PCI_CLASS_OLD                 0x00
+#define   PCI_CLASS_OLD_OTHER           0x00
+#define   PCI_CLASS_OLD_VGA             0x01
+
+#define PCI_CLASS_MASS_STORAGE        0x01
+#define   PCI_CLASS_MASS_STORAGE_SCSI   0x00
+#define   PCI_CLASS_MASS_STORAGE_IDE    0x01
+#define   PCI_CLASS_MASS_STORAGE_FLOPPY 0x02
+#define   PCI_CLASS_MASS_STORAGE_IPI    0x03
+#define   PCI_CLASS_MASS_STORAGE_RAID   0x04
+#define   PCI_CLASS_MASS_STORAGE_OTHER  0x80
+
+#define PCI_CLASS_NETWORK             0x02
+#define   PCI_CLASS_NETWORK_ETHERNET    0x00
+#define   PCI_CLASS_NETWORK_TOKENRING   0x01
+#define   PCI_CLASS_NETWORK_FDDI        0x02
+#define   PCI_CLASS_NETWORK_ATM         0x03
+#define   PCI_CLASS_NETWORK_ISDN        0x04
+#define   PCI_CLASS_NETWORK_OTHER       0x80
+
+#define PCI_CLASS_DISPLAY             0x03
+#define   PCI_CLASS_DISPLAY_VGA         0x00
+#define     PCI_IF_VGA_VGA                0x00
+#define     PCI_IF_VGA_8514               0x01
+#define   PCI_CLASS_DISPLAY_XGA         0x01
+#define   PCI_CLASS_DISPLAY_3D          0x02
+#define   PCI_CLASS_DISPLAY_OTHER       0x80
+
+#define PCI_CLASS_MEDIA               0x04
+#define   PCI_CLASS_MEDIA_VIDEO         0x00
+#define   PCI_CLASS_MEDIA_AUDIO         0x01
+#define   PCI_CLASS_MEDIA_TELEPHONE     0x02
+#define   PCI_CLASS_MEDIA_OTHER         0x80
+
+#define PCI_CLASS_MEMORY_CONTROLLER   0x05
+#define   PCI_CLASS_MEMORY_RAM          0x00
+#define   PCI_CLASS_MEMORY_FLASH        0x01
+#define   PCI_CLASS_MEMORY_OTHER        0x80
+
+#define PCI_CLASS_BRIDGE              0x06
+#define   PCI_CLASS_BRIDGE_HOST         0x00
+#define   PCI_CLASS_BRIDGE_ISA          0x01
+#define   PCI_CLASS_BRIDGE_EISA         0x02
+#define   PCI_CLASS_BRIDGE_MCA          0x03
+#define   PCI_CLASS_BRIDGE_P2P          0x04
+#define     PCI_IF_BRIDGE_P2P             0x00
+#define     PCI_IF_BRIDGE_P2P_SUBTRACTIVE 0x01
+#define   PCI_CLASS_BRIDGE_PCMCIA       0x05
+#define   PCI_CLASS_BRIDGE_NUBUS        0x06
+#define   PCI_CLASS_BRIDGE_CARDBUS      0x07
+#define   PCI_CLASS_BRIDGE_RACEWAY      0x08
+#define   PCI_CLASS_BRIDGE_OTHER        0x80
+#define   PCI_CLASS_BRIDGE_ISA_PDECODE  0x80
+
+#define PCI_CLASS_SCC                 0x07  ///< Simple communications controllers
+#define   PCI_SUBCLASS_SERIAL           0x00
+#define     PCI_IF_GENERIC_XT             0x00
+#define     PCI_IF_16450                  0x01
+#define     PCI_IF_16550                  0x02
+#define     PCI_IF_16650                  0x03
+#define     PCI_IF_16750                  0x04
+#define     PCI_IF_16850                  0x05
+#define     PCI_IF_16950                  0x06
+#define   PCI_SUBCLASS_PARALLEL         0x01
+#define     PCI_IF_PARALLEL_PORT          0x00
+#define     PCI_IF_BI_DIR_PARALLEL_PORT   0x01
+#define     PCI_IF_ECP_PARALLEL_PORT      0x02
+#define     PCI_IF_1284_CONTROLLER        0x03
+#define     PCI_IF_1284_DEVICE            0xFE
+#define   PCI_SUBCLASS_MULTIPORT_SERIAL 0x02
+#define   PCI_SUBCLASS_MODEM            0x03
+#define     PCI_IF_GENERIC_MODEM          0x00
+#define     PCI_IF_16450_MODEM            0x01
+#define     PCI_IF_16550_MODEM            0x02
+#define     PCI_IF_16650_MODEM            0x03
+#define     PCI_IF_16750_MODEM            0x04
+#define   PCI_SUBCLASS_SCC_OTHER        0x80
+
+#define PCI_CLASS_SYSTEM_PERIPHERAL   0x08
+#define   PCI_SUBCLASS_PIC              0x00
+#define     PCI_IF_8259_PIC               0x00
+#define     PCI_IF_ISA_PIC                0x01
+#define     PCI_IF_EISA_PIC               0x02
+#define     PCI_IF_APIC_CONTROLLER        0x10  ///< I/O APIC interrupt controller , 32 byte none-prefetchable memory.
+#define     PCI_IF_APIC_CONTROLLER2       0x20
+#define   PCI_SUBCLASS_DMA              0x01
+#define     PCI_IF_8237_DMA               0x00
+#define     PCI_IF_ISA_DMA                0x01
+#define     PCI_IF_EISA_DMA               0x02
+#define   PCI_SUBCLASS_TIMER            0x02
+#define     PCI_IF_8254_TIMER             0x00
+#define     PCI_IF_ISA_TIMER              0x01
+#define     PCI_IF_EISA_TIMER             0x02
+#define   PCI_SUBCLASS_RTC              0x03
+#define     PCI_IF_GENERIC_RTC            0x00
+#define     PCI_IF_ISA_RTC                0x01
+#define   PCI_SUBCLASS_PNP_CONTROLLER   0x04    ///< HotPlug Controller
+#define   PCI_SUBCLASS_PERIPHERAL_OTHER 0x80
+
+#define PCI_CLASS_INPUT_DEVICE        0x09
+#define   PCI_SUBCLASS_KEYBOARD         0x00
+#define   PCI_SUBCLASS_PEN              0x01
+#define   PCI_SUBCLASS_MOUSE_CONTROLLER 0x02
+#define   PCI_SUBCLASS_SCAN_CONTROLLER  0x03
+#define   PCI_SUBCLASS_GAMEPORT         0x04
+#define     PCI_IF_GAMEPORT               0x00
+#define     PCI_IF_GAMEPORT1              0x10
+#define   PCI_SUBCLASS_INPUT_OTHER      0x80
+
+#define PCI_CLASS_DOCKING_STATION     0x0A
+#define   PCI_SUBCLASS_DOCKING_GENERIC  0x00
+#define   PCI_SUBCLASS_DOCKING_OTHER    0x80
+
+#define PCI_CLASS_PROCESSOR           0x0B
+#define   PCI_SUBCLASS_PROC_386         0x00
+#define   PCI_SUBCLASS_PROC_486         0x01
+#define   PCI_SUBCLASS_PROC_PENTIUM     0x02
+#define   PCI_SUBCLASS_PROC_ALPHA       0x10
+#define   PCI_SUBCLASS_PROC_POWERPC     0x20
+#define   PCI_SUBCLASS_PROC_MIPS        0x30
+#define   PCI_SUBCLASS_PROC_CO_PORC     0x40 ///< Co-Processor
+
+#define PCI_CLASS_SERIAL              0x0C
+#define   PCI_CLASS_SERIAL_FIREWIRE     0x00
+#define     PCI_IF_1394                   0x00
+#define     PCI_IF_1394_OPEN_HCI          0x10
+#define   PCI_CLASS_SERIAL_ACCESS_BUS   0x01
+#define   PCI_CLASS_SERIAL_SSA          0x02
+#define   PCI_CLASS_SERIAL_USB          0x03
+#define     PCI_IF_UHCI                   0x00
+#define     PCI_IF_OHCI                   0x10
+#define     PCI_IF_USB_OTHER              0x80
+#define     PCI_IF_USB_DEVICE             0xFE
+#define   PCI_CLASS_SERIAL_FIBRECHANNEL 0x04
+#define   PCI_CLASS_SERIAL_SMB          0x05
+
+#define PCI_CLASS_WIRELESS            0x0D
+#define   PCI_SUBCLASS_IRDA             0x00
+#define   PCI_SUBCLASS_IR               0x01
+#define   PCI_SUBCLASS_RF               0x10
+#define   PCI_SUBCLASS_WIRELESS_OTHER   0x80
+
+#define PCI_CLASS_INTELLIGENT_IO      0x0E
+
+#define PCI_CLASS_SATELLITE           0x0F
+#define   PCI_SUBCLASS_TV               0x01
+#define   PCI_SUBCLASS_AUDIO            0x02
+#define   PCI_SUBCLASS_VOICE            0x03
+#define   PCI_SUBCLASS_DATA             0x04
+
+#define PCI_SECURITY_CONTROLLER       0x10   ///< Encryption and decryption controller
+#define   PCI_SUBCLASS_NET_COMPUT       0x00
+#define   PCI_SUBCLASS_ENTERTAINMENT    0x10
+#define   PCI_SUBCLASS_SECURITY_OTHER   0x80
+
+#define PCI_CLASS_DPIO                0x11
+#define   PCI_SUBCLASS_DPIO             0x00
+#define   PCI_SUBCLASS_DPIO_OTHER       0x80
+
+/**
+  Macro that checks whether the Base Class code of device matched.
+
+  @param  _p      Specified device.
+  @param  c       Base Class code needs matching.
+
+  @retval TRUE    Base Class code matches the specified device.
+  @retval FALSE   Base Class code doesn't match the specified device.
+
+**/
+#define IS_CLASS1(_p, c)              ((_p)->Hdr.ClassCode[2] == (c))
+/**
+  Macro that checks whether the Base Class code and Sub-Class code of device matched.
+
+  @param  _p      Specified device.
+  @param  c       Base Class code needs matching.
+  @param  s       Sub-Class code needs matching.
+
+  @retval TRUE    Base Class code and Sub-Class code match the specified device.
+  @retval FALSE   Base Class code and Sub-Class code don't match the specified device.
+
+**/
+#define IS_CLASS2(_p, c, s)           (IS_CLASS1 (_p, c) && ((_p)->Hdr.ClassCode[1] == (s)))
+/**
+  Macro that checks whether the Base Class code, Sub-Class code and Interface code of device matched.
+
+  @param  _p      Specified device.
+  @param  c       Base Class code needs matching.
+  @param  s       Sub-Class code needs matching.
+  @param  p       Interface code needs matching.
+
+  @retval TRUE    Base Class code, Sub-Class code and Interface code match the specified device.
+  @retval FALSE   Base Class code, Sub-Class code and Interface code don't match the specified device.
+
+**/
+#define IS_CLASS3(_p, c, s, p)        (IS_CLASS2 (_p, c, s) && ((_p)->Hdr.ClassCode[0] == (p)))
+
+/**
+  Macro that checks whether device is a display controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a display controller.
+  @retval FALSE   Device is not a display controller.
+
+**/
+#define IS_PCI_DISPLAY(_p)            IS_CLASS1 (_p, PCI_CLASS_DISPLAY)
+/**
+  Macro that checks whether device is a VGA-compatible controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a VGA-compatible controller.
+  @retval FALSE   Device is not a VGA-compatible controller.
+
+**/
+#define IS_PCI_VGA(_p)                IS_CLASS3 (_p, PCI_CLASS_DISPLAY, PCI_CLASS_DISPLAY_VGA, PCI_IF_VGA_VGA)
+/**
+  Macro that checks whether device is an 8514-compatible controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is an 8514-compatible controller.
+  @retval FALSE   Device is not an 8514-compatible controller.
+
+**/
+#define IS_PCI_8514(_p)               IS_CLASS3 (_p, PCI_CLASS_DISPLAY, PCI_CLASS_DISPLAY_VGA, PCI_IF_VGA_8514)
+/**
+  Macro that checks whether device is built before the Class Code field was defined.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is an old device.
+  @retval FALSE   Device is not an old device.
+
+**/
+#define IS_PCI_OLD(_p)                IS_CLASS1 (_p, PCI_CLASS_OLD)
+/**
+  Macro that checks whether device is a VGA-compatible device built before the Class Code field was defined.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is an old VGA-compatible device.
+  @retval FALSE   Device is not an old VGA-compatible device.
+
+**/
+#define IS_PCI_OLD_VGA(_p)            IS_CLASS2 (_p, PCI_CLASS_OLD, PCI_CLASS_OLD_VGA)
+/**
+  Macro that checks whether device is an IDE controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is an IDE controller.
+  @retval FALSE   Device is not an IDE controller.
+
+**/
+#define IS_PCI_IDE(_p)                IS_CLASS2 (_p, PCI_CLASS_MASS_STORAGE, PCI_CLASS_MASS_STORAGE_IDE)
+/**
+  Macro that checks whether device is a SCSI bus controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a SCSI bus controller.
+  @retval FALSE   Device is not a SCSI bus controller.
+
+**/
+#define IS_PCI_SCSI(_p)               IS_CLASS2 (_p, PCI_CLASS_MASS_STORAGE, PCI_CLASS_MASS_STORAGE_SCSI)
+/**
+  Macro that checks whether device is a RAID controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a RAID controller.
+  @retval FALSE   Device is not a RAID controller.
+
+**/
+#define IS_PCI_RAID(_p)               IS_CLASS2 (_p, PCI_CLASS_MASS_STORAGE, PCI_CLASS_MASS_STORAGE_RAID)
+/**
+  Macro that checks whether device is an ISA bridge.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is an ISA bridge.
+  @retval FALSE   Device is not an ISA bridge.
+
+**/
+#define IS_PCI_LPC(_p)                IS_CLASS2 (_p, PCI_CLASS_BRIDGE, PCI_CLASS_BRIDGE_ISA)
+/**
+  Macro that checks whether device is a PCI-to-PCI bridge.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a PCI-to-PCI bridge.
+  @retval FALSE   Device is not a PCI-to-PCI bridge.
+
+**/
+#define IS_PCI_P2P(_p)                IS_CLASS3 (_p, PCI_CLASS_BRIDGE, PCI_CLASS_BRIDGE_P2P, PCI_IF_BRIDGE_P2P)
+/**
+  Macro that checks whether device is a Subtractive Decode PCI-to-PCI bridge.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a Subtractive Decode PCI-to-PCI bridge.
+  @retval FALSE   Device is not a Subtractive Decode PCI-to-PCI bridge.
+
+**/
+#define IS_PCI_P2P_SUB(_p)            IS_CLASS3 (_p, PCI_CLASS_BRIDGE, PCI_CLASS_BRIDGE_P2P, PCI_IF_BRIDGE_P2P_SUBTRACTIVE)
+/**
+  Macro that checks whether device is a 16550-compatible serial controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a 16550-compatible serial controller.
+  @retval FALSE   Device is not a 16550-compatible serial controller.
+
+**/
+#define IS_PCI_16550_SERIAL(_p)       IS_CLASS3 (_p, PCI_CLASS_SCC, PCI_SUBCLASS_SERIAL, PCI_IF_16550)
+/**
+  Macro that checks whether device is a Universal Serial Bus controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a Universal Serial Bus controller.
+  @retval FALSE   Device is not a Universal Serial Bus controller.
+
+**/
+#define IS_PCI_USB(_p)                IS_CLASS2 (_p, PCI_CLASS_SERIAL, PCI_CLASS_SERIAL_USB)
+
+//
+// the definition of Header Type
+//
+#define HEADER_TYPE_DEVICE            0x00
+#define HEADER_TYPE_PCI_TO_PCI_BRIDGE 0x01
+#define HEADER_TYPE_CARDBUS_BRIDGE    0x02
+#define HEADER_TYPE_MULTI_FUNCTION    0x80
+//
+// Mask of Header type
+//
+#define HEADER_LAYOUT_CODE            0x7f
+/**
+  Macro that checks whether device is a PCI-PCI bridge.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a PCI-PCI bridge.
+  @retval FALSE   Device is not a PCI-PCI bridge.
+
+**/
+#define IS_PCI_BRIDGE(_p)             (((_p)->Hdr.HeaderType & HEADER_LAYOUT_CODE) == (HEADER_TYPE_PCI_TO_PCI_BRIDGE))
+/**
+  Macro that checks whether device is a CardBus bridge.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a CardBus bridge.
+  @retval FALSE   Device is not a CardBus bridge.
+
+**/
+#define IS_CARDBUS_BRIDGE(_p)         (((_p)->Hdr.HeaderType & HEADER_LAYOUT_CODE) == (HEADER_TYPE_CARDBUS_BRIDGE))
+/**
+  Macro that checks whether device is a multiple functions device.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a multiple functions device.
+  @retval FALSE   Device is not a multiple functions device.
+
+**/
+#define IS_PCI_MULTI_FUNC(_p)         ((_p)->Hdr.HeaderType & HEADER_TYPE_MULTI_FUNCTION)
+
+///
+/// Rom Base Address in Bridge, defined in PCI-to-PCI Bridge Architecture Specification,
+///
+#define PCI_BRIDGE_ROMBAR             0x38
+
+#define PCI_MAX_BAR                   0x0006
+#define PCI_MAX_CONFIG_OFFSET         0x0100
+
+#define PCI_VENDOR_ID_OFFSET                        0x00
+#define PCI_DEVICE_ID_OFFSET                        0x02
+#define PCI_COMMAND_OFFSET                          0x04
+#define PCI_PRIMARY_STATUS_OFFSET                   0x06
+#define PCI_REVISION_ID_OFFSET                      0x08
+#define PCI_CLASSCODE_OFFSET                        0x09
+#define PCI_CACHELINE_SIZE_OFFSET                   0x0C
+#define PCI_LATENCY_TIMER_OFFSET                    0x0D
+#define PCI_HEADER_TYPE_OFFSET                      0x0E
+#define PCI_BIST_OFFSET                             0x0F
+#define PCI_BASE_ADDRESSREG_OFFSET                  0x10
+#define PCI_CARDBUS_CIS_OFFSET                      0x28
+#define PCI_SVID_OFFSET                             0x2C ///< SubSystem Vendor id
+#define PCI_SUBSYSTEM_VENDOR_ID_OFFSET              0x2C
+#define PCI_SID_OFFSET                              0x2E ///< SubSystem ID
+#define PCI_SUBSYSTEM_ID_OFFSET                     0x2E
+#define PCI_EXPANSION_ROM_BASE                      0x30
+#define PCI_CAPBILITY_POINTER_OFFSET                0x34
+#define PCI_INT_LINE_OFFSET                         0x3C ///< Interrupt Line Register
+#define PCI_INT_PIN_OFFSET                          0x3D ///< Interrupt Pin Register
+#define PCI_MAXGNT_OFFSET                           0x3E ///< Max Grant Register
+#define PCI_MAXLAT_OFFSET                           0x3F ///< Max Latency Register
+
+//
+// defined in PCI-to-PCI Bridge Architecture Specification
+//
+#define PCI_BRIDGE_PRIMARY_BUS_REGISTER_OFFSET      0x18
+#define PCI_BRIDGE_SECONDARY_BUS_REGISTER_OFFSET    0x19
+#define PCI_BRIDGE_SUBORDINATE_BUS_REGISTER_OFFSET  0x1a
+#define PCI_BRIDGE_SECONDARY_LATENCY_TIMER_OFFSET   0x1b
+#define PCI_BRIDGE_STATUS_REGISTER_OFFSET           0x1E
+#define PCI_BRIDGE_CONTROL_REGISTER_OFFSET          0x3E
+
+///
+/// Interrupt Line "Unknown" or "No connection" value defined for x86 based system
+///
+#define PCI_INT_LINE_UNKNOWN                        0xFF
+
+///
+/// PCI Access Data Format
+///
+typedef union {
+  struct {
+    UINT32  Reg : 8;
+    UINT32  Func : 3;
+    UINT32  Dev : 5;
+    UINT32  Bus : 8;
+    UINT32  Reserved : 7;
+    UINT32  Enable : 1;
+  } Bits;
+  UINT32  Uint32;
+} PCI_CONFIG_ACCESS_CF8;
+
+#pragma pack()
+
+#define EFI_PCI_COMMAND_IO_SPACE                        BIT0   ///< 0x0001
+#define EFI_PCI_COMMAND_MEMORY_SPACE                    BIT1   ///< 0x0002
+#define EFI_PCI_COMMAND_BUS_MASTER                      BIT2   ///< 0x0004
+#define EFI_PCI_COMMAND_SPECIAL_CYCLE                   BIT3   ///< 0x0008
+#define EFI_PCI_COMMAND_MEMORY_WRITE_AND_INVALIDATE     BIT4   ///< 0x0010
+#define EFI_PCI_COMMAND_VGA_PALETTE_SNOOP               BIT5   ///< 0x0020
+#define EFI_PCI_COMMAND_PARITY_ERROR_RESPOND            BIT6   ///< 0x0040
+#define EFI_PCI_COMMAND_STEPPING_CONTROL                BIT7   ///< 0x0080
+#define EFI_PCI_COMMAND_SERR                            BIT8   ///< 0x0100
+#define EFI_PCI_COMMAND_FAST_BACK_TO_BACK               BIT9   ///< 0x0200
+
+//
+// defined in PCI-to-PCI Bridge Architecture Specification
+//
+#define EFI_PCI_BRIDGE_CONTROL_PARITY_ERROR_RESPONSE    BIT0   ///< 0x0001
+#define EFI_PCI_BRIDGE_CONTROL_SERR                     BIT1   ///< 0x0002
+#define EFI_PCI_BRIDGE_CONTROL_ISA                      BIT2   ///< 0x0004
+#define EFI_PCI_BRIDGE_CONTROL_VGA                      BIT3   ///< 0x0008
+#define EFI_PCI_BRIDGE_CONTROL_VGA_16                   BIT4   ///< 0x0010
+#define EFI_PCI_BRIDGE_CONTROL_MASTER_ABORT             BIT5   ///< 0x0020
+#define EFI_PCI_BRIDGE_CONTROL_RESET_SECONDARY_BUS      BIT6   ///< 0x0040
+#define EFI_PCI_BRIDGE_CONTROL_FAST_BACK_TO_BACK        BIT7   ///< 0x0080
+#define EFI_PCI_BRIDGE_CONTROL_PRIMARY_DISCARD_TIMER    BIT8   ///< 0x0100
+#define EFI_PCI_BRIDGE_CONTROL_SECONDARY_DISCARD_TIMER  BIT9   ///< 0x0200
+#define EFI_PCI_BRIDGE_CONTROL_TIMER_STATUS             BIT10  ///< 0x0400
+#define EFI_PCI_BRIDGE_CONTROL_DISCARD_TIMER_SERR       BIT11  ///< 0x0800
+
+//
+// Following are the PCI-CARDBUS bridge control bit, defined in PC Card Standard
+//
+#define EFI_PCI_BRIDGE_CONTROL_IREQINT_ENABLE           BIT7   ///< 0x0080
+#define EFI_PCI_BRIDGE_CONTROL_RANGE0_MEMORY_TYPE       BIT8   ///< 0x0100
+#define EFI_PCI_BRIDGE_CONTROL_RANGE1_MEMORY_TYPE       BIT9   ///< 0x0200
+#define EFI_PCI_BRIDGE_CONTROL_WRITE_POSTING_ENABLE     BIT10  ///< 0x0400
+
+//
+// Following are the PCI status control bit
+//
+#define EFI_PCI_STATUS_CAPABILITY                       BIT4   ///< 0x0010
+#define EFI_PCI_STATUS_66MZ_CAPABLE                     BIT5   ///< 0x0020
+#define EFI_PCI_FAST_BACK_TO_BACK_CAPABLE               BIT7   ///< 0x0080
+#define EFI_PCI_MASTER_DATA_PARITY_ERROR                BIT8   ///< 0x0100
+
+///
+/// defined in PC Card Standard
+///
+#define EFI_PCI_CARDBUS_BRIDGE_CAPABILITY_PTR 0x14
+
+#pragma pack(1)
+//
+// PCI Capability List IDs and records
+//
+#define EFI_PCI_CAPABILITY_ID_PMI     0x01
+#define EFI_PCI_CAPABILITY_ID_AGP     0x02
+#define EFI_PCI_CAPABILITY_ID_VPD     0x03
+#define EFI_PCI_CAPABILITY_ID_SLOTID  0x04
+#define EFI_PCI_CAPABILITY_ID_MSI     0x05
+#define EFI_PCI_CAPABILITY_ID_HOTPLUG 0x06
+#define EFI_PCI_CAPABILITY_ID_SHPC    0x0C
+
+///
+/// Capabilities List Header
+/// Section 6.7, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  UINT8 CapabilityID;
+  UINT8 NextItemPtr;
+} EFI_PCI_CAPABILITY_HDR;
+
+///
+/// PMC - Power Management Capabilities
+/// Section 3.2.3, PCI Power Management Interface Specification, Revision 1.2
+///
+typedef union {
+  struct {
+    UINT16 Version : 3;
+    UINT16 PmeClock : 1;
+    UINT16 Reserved : 1;
+    UINT16 DeviceSpecificInitialization : 1;
+    UINT16 AuxCurrent : 3;
+    UINT16 D1Support : 1;
+    UINT16 D2Support : 1;
+    UINT16 PmeSupport : 5;
+  } Bits;
+  UINT16 Data;
+} EFI_PCI_PMC;
+
+#define EFI_PCI_PMC_D3_COLD_MASK    (BIT15)
+
+///
+/// PMCSR - Power Management Control/Status
+/// Section 3.2.4, PCI Power Management Interface Specification, Revision 1.2
+///
+typedef union {
+  struct {
+    UINT16 PowerState : 2;
+    UINT16 ReservedForPciExpress : 1;
+    UINT16 NoSoftReset : 1;
+    UINT16 Reserved : 4;
+    UINT16 PmeEnable : 1;
+    UINT16 DataSelect : 4;
+    UINT16 DataScale : 2;
+    UINT16 PmeStatus : 1;
+  } Bits;
+  UINT16 Data;
+} EFI_PCI_PMCSR;
+
+#define PCI_POWER_STATE_D0     0
+#define PCI_POWER_STATE_D1     1
+#define PCI_POWER_STATE_D2     2
+#define PCI_POWER_STATE_D3_HOT 3
+
+///
+/// PMCSR_BSE - PMCSR PCI-to-PCI Bridge Support Extensions
+/// Section 3.2.5, PCI Power Management Interface Specification, Revision 1.2
+///
+typedef union {
+  struct {
+    UINT8 Reserved : 6;
+    UINT8 B2B3 : 1;
+    UINT8 BusPowerClockControl : 1;
+  } Bits;
+  UINT8   Uint8;
+} EFI_PCI_PMCSR_BSE;
+
+///
+/// Power Management Register Block Definition
+/// Section 3.2, PCI Power Management Interface Specification, Revision 1.2
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  EFI_PCI_PMC             PMC;
+  EFI_PCI_PMCSR           PMCSR;
+  EFI_PCI_PMCSR_BSE       BridgeExtention;
+  UINT8                   Data;
+} EFI_PCI_CAPABILITY_PMI;
+
+///
+/// A.G.P Capability
+/// Section 6.1.4, Accelerated Graphics Port Interface Specification, Revision 1.0
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT8                   Rev;
+  UINT8                   Reserved;
+  UINT32                  Status;
+  UINT32                  Command;
+} EFI_PCI_CAPABILITY_AGP;
+
+///
+/// VPD Capability Structure
+/// Appendix I, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT16                  AddrReg;
+  UINT32                  DataReg;
+} EFI_PCI_CAPABILITY_VPD;
+
+///
+/// Slot Numbering Capabilities Register
+/// Section 3.2.6, PCI-to-PCI Bridge Architecture Specification, Revision 1.2
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT8                   ExpnsSlotReg;
+  UINT8                   ChassisNo;
+} EFI_PCI_CAPABILITY_SLOTID;
+
+///
+/// Message Capability Structure for 32-bit Message Address
+/// Section 6.8.1, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT16                  MsgCtrlReg;
+  UINT32                  MsgAddrReg;
+  UINT16                  MsgDataReg;
+} EFI_PCI_CAPABILITY_MSI32;
+
+///
+/// Message Capability Structure for 64-bit Message Address
+/// Section 6.8.1, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT16                  MsgCtrlReg;
+  UINT32                  MsgAddrRegLsdw;
+  UINT32                  MsgAddrRegMsdw;
+  UINT16                  MsgDataReg;
+} EFI_PCI_CAPABILITY_MSI64;
+
+///
+/// Capability EFI_PCI_CAPABILITY_ID_HOTPLUG,
+/// CompactPCI Hot Swap Specification PICMG 2.1, R1.0
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  ///
+  /// not finished - fields need to go here
+  ///
+} EFI_PCI_CAPABILITY_HOTPLUG;
+
+#define PCI_BAR_IDX0        0x00
+#define PCI_BAR_IDX1        0x01
+#define PCI_BAR_IDX2        0x02
+#define PCI_BAR_IDX3        0x03
+#define PCI_BAR_IDX4        0x04
+#define PCI_BAR_IDX5        0x05
+
+///
+/// EFI PCI Option ROM definitions
+///
+#define EFI_ROOT_BRIDGE_LIST                            'eprb'
+#define EFI_PCI_EXPANSION_ROM_HEADER_EFISIGNATURE       0x0EF1  ///< defined in UEFI Spec.
+
+#define PCI_EXPANSION_ROM_HEADER_SIGNATURE              0xaa55
+#define PCI_DATA_STRUCTURE_SIGNATURE                    SIGNATURE_32 ('P', 'C', 'I', 'R')
+#define PCI_CODE_TYPE_PCAT_IMAGE                        0x00
+#define EFI_PCI_EXPANSION_ROM_HEADER_COMPRESSED         0x0001  ///< defined in UEFI spec.
+
+///
+/// Standard PCI Expansion ROM Header
+/// Section 13.4.2, Unified Extensible Firmware Interface Specification, Version 2.1
+///
+typedef struct {
+  UINT16  Signature;    ///< 0xaa55
+  UINT8   Reserved[0x16];
+  UINT16  PcirOffset;
+} PCI_EXPANSION_ROM_HEADER;
+
+///
+/// Legacy ROM Header Extensions
+/// Section 6.3.3.1, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  UINT16  Signature;    ///< 0xaa55
+  UINT8   Size512;
+  UINT8   InitEntryPoint[3];
+  UINT8   Reserved[0x12];
+  UINT16  PcirOffset;
+} EFI_LEGACY_EXPANSION_ROM_HEADER;
+
+///
+/// PCI Data Structure Format
+/// Section 6.3.1.2, PCI Local Bus Specification, 2.2
+///
+typedef struct {
+  UINT32  Signature;    ///< "PCIR"
+  UINT16  VendorId;
+  UINT16  DeviceId;
+  UINT16  Reserved0;
+  UINT16  Length;
+  UINT8   Revision;
+  UINT8   ClassCode[3];
+  UINT16  ImageLength;
+  UINT16  CodeRevision;
+  UINT8   CodeType;
+  UINT8   Indicator;
+  UINT16  Reserved1;
+} PCI_DATA_STRUCTURE;
+
+///
+/// EFI PCI Expansion ROM Header
+/// Section 13.4.2, Unified Extensible Firmware Interface Specification, Version 2.1
+///
+typedef struct {
+  UINT16  Signature;    ///< 0xaa55
+  UINT16  InitializationSize;
+  UINT32  EfiSignature; ///< 0x0EF1
+  UINT16  EfiSubsystem;
+  UINT16  EfiMachineType;
+  UINT16  CompressionType;
+  UINT8   Reserved[8];
+  UINT16  EfiImageHeaderOffset;
+  UINT16  PcirOffset;
+} EFI_PCI_EXPANSION_ROM_HEADER;
+
+typedef union {
+  UINT8                           *Raw;
+  PCI_EXPANSION_ROM_HEADER        *Generic;
+  EFI_PCI_EXPANSION_ROM_HEADER    *Efi;
+  EFI_LEGACY_EXPANSION_ROM_HEADER *PcAt;
+} EFI_PCI_ROM_HEADER;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Pci23.h b/libedk2_tpm/include/IndustryStandard/Pci23.h
new file mode 100644
index 0000000..0ce38eb
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Pci23.h
@@ -0,0 +1,127 @@
+/** @file
+  Support for PCI 2.3 standard.
+
+  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCI23_H_
+#define _PCI23_H_
+
+#include <IndustryStandard/Pci22.h>
+
+///
+/// PCI_CLASS_MASS_STORAGE, Base Class 01h.
+///
+///@{
+#define PCI_CLASS_MASS_STORAGE_ATA       0x05
+#define   PCI_IF_MASS_STORAGE_SINGLE_DMA   0x20
+#define   PCI_IF_MASS_STORAGE_CHAINED_DMA  0x30
+///@}
+
+///
+/// PCI_CLASS_NETWORK, Base Class 02h.
+///
+///@{
+#define PCI_CLASS_NETWORK_WORLDFIP              0x05
+#define PCI_CLASS_NETWORK_PICMG_MULTI_COMPUTING 0x06
+///@}
+
+///
+/// PCI_CLASS_BRIDGE, Base Class 06h.
+///
+///@{
+#define PCI_CLASS_BRIDGE_SEMI_TRANSPARENT_P2P        0x09
+#define   PCI_IF_BRIDGE_SEMI_TRANSPARENT_P2P_PRIMARY   0x40
+#define   PCI_IF_BRIDGE_SEMI_TRANSPARENT_P2P_SECONDARY 0x80
+#define PCI_CLASS_BRIDGE_INFINIBAND_TO_PCI           0x0A
+///@}
+
+///
+/// PCI_CLASS_SCC, Base Class 07h.
+///
+///@{
+#define PCI_SUBCLASS_GPIB          0x04
+#define PCI_SUBCLASS_SMART_CARD    0x05
+///@}
+
+///
+/// PCI_CLASS_SERIAL, Base Class 0Ch.
+///
+///@{
+#define   PCI_IF_EHCI                      0x20
+#define PCI_CLASS_SERIAL_IB              0x06
+#define PCI_CLASS_SERIAL_IPMI            0x07
+#define   PCI_IF_IPMI_SMIC                 0x00
+#define   PCI_IF_IPMI_KCS                  0x01 ///< Keyboard Controller Style
+#define   PCI_IF_IPMI_BT                   0x02 ///< Block Transfer
+#define PCI_CLASS_SERIAL_SERCOS          0x08
+#define PCI_CLASS_SERIAL_CANBUS          0x09
+///@}
+
+///
+/// PCI_CLASS_WIRELESS, Base Class 0Dh.
+///
+///@{
+#define PCI_SUBCLASS_BLUETOOTH    0x11
+#define PCI_SUBCLASS_BROADBAND    0x12
+///@}
+
+///
+/// PCI_CLASS_DPIO, Base Class 11h.
+///
+///@{
+#define PCI_SUBCLASS_PERFORMANCE_COUNTERS          0x01
+#define PCI_SUBCLASS_COMMUNICATION_SYNCHRONIZATION 0x10
+#define PCI_SUBCLASS_MANAGEMENT_CARD               0x20
+///@}
+
+///
+/// defined in PCI Express Spec.
+///
+#define PCI_EXP_MAX_CONFIG_OFFSET     0x1000
+
+///
+/// PCI Capability List IDs and records.
+///
+#define EFI_PCI_CAPABILITY_ID_PCIX    0x07
+#define EFI_PCI_CAPABILITY_ID_VENDOR  0x09
+
+#pragma pack(1)
+///
+/// PCI-X Capabilities List,
+/// Section 7.2, PCI-X Addendum to the PCI Local Bus Specification, Revision 1.0b.
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT16                  CommandReg;
+  UINT32                  StatusReg;
+} EFI_PCI_CAPABILITY_PCIX;
+
+///
+/// PCI-X Bridge Capabilities List,
+/// Section 8.6.2, PCI-X Addendum to the PCI Local Bus Specification, Revision 1.0b.
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT16                  SecStatusReg;
+  UINT32                  StatusReg;
+  UINT32                  SplitTransCtrlRegUp;
+  UINT32                  SplitTransCtrlRegDn;
+} EFI_PCI_CAPABILITY_PCIX_BRDG;
+
+///
+/// Vendor Specific Capability Header
+/// Table H-1: Capability IDs, PCI Local Bus Specification, 2.3
+///
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR  Hdr;
+  UINT8                   Length;
+} EFI_PCI_CAPABILITY_VENDOR_HDR;
+
+#pragma pack()
+
+#define PCI_CODE_TYPE_EFI_IMAGE       0x03
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Pci30.h b/libedk2_tpm/include/IndustryStandard/Pci30.h
new file mode 100644
index 0000000..beefb1a
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Pci30.h
@@ -0,0 +1,73 @@
+/** @file
+  Support for PCI 3.0 standard.
+
+  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __PCI30_H__
+#define __PCI30_H__
+
+
+#include <IndustryStandard/Pci23.h>
+
+///
+/// PCI_CLASS_MASS_STORAGE, Base Class 01h.
+///
+///@{
+#define PCI_CLASS_MASS_STORAGE_SATADPA   0x06
+#define   PCI_IF_MASS_STORAGE_SATA         0x00
+#define   PCI_IF_MASS_STORAGE_AHCI         0x01
+///@}
+
+///
+/// PCI_CLASS_WIRELESS, Base Class 0Dh.
+///
+///@{
+#define PCI_SUBCLASS_ETHERNET_80211A    0x20
+#define PCI_SUBCLASS_ETHERNET_80211B    0x21
+///@}
+
+/**
+  Macro that checks whether device is a SATA controller.
+
+  @param  _p      Specified device.
+
+  @retval TRUE    Device is a SATA controller.
+  @retval FALSE   Device is not a SATA controller.
+
+**/
+#define IS_PCI_SATADPA(_p) IS_CLASS2 (_p, PCI_CLASS_MASS_STORAGE, PCI_CLASS_MASS_STORAGE_SATADPA)
+
+///
+/// PCI Capability List IDs and records
+///
+#define EFI_PCI_CAPABILITY_ID_PCIEXP  0x10
+
+#pragma pack(1)
+
+///
+/// PCI Data Structure Format
+/// Section 5.1.2, PCI Firmware Specification, Revision 3.0
+///
+typedef struct {
+  UINT32  Signature;    ///< "PCIR"
+  UINT16  VendorId;
+  UINT16  DeviceId;
+  UINT16  DeviceListOffset;
+  UINT16  Length;
+  UINT8   Revision;
+  UINT8   ClassCode[3];
+  UINT16  ImageLength;
+  UINT16  CodeRevision;
+  UINT8   CodeType;
+  UINT8   Indicator;
+  UINT16  MaxRuntimeImageLength;
+  UINT16  ConfigUtilityCodeHeaderOffset;
+  UINT16  DMTFCLPEntryPointOffset;
+} PCI_3_0_DATA_STRUCTURE;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/PciCodeId.h b/libedk2_tpm/include/IndustryStandard/PciCodeId.h
new file mode 100644
index 0000000..e5b63c3
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/PciCodeId.h
@@ -0,0 +1,94 @@
+/** @file
+  The file lists the PCI class codes only defined in PCI code and ID assignment specification
+  revision 1.3.
+
+  Copyright (c) 2012 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __PCI_CODE_ID_H__
+#define __PCI_CODE_ID_H__
+
+
+///
+/// PCI_CLASS_MASS_STORAGE, Base Class 01h.
+///
+///@{
+#define   PCI_IF_MASS_STORAGE_SCSI_VENDOR_SPECIFIC          0x00
+#define   PCI_IF_MASS_STORAGE_SCSI_DEVICE_PQI               0x11
+#define   PCI_IF_MASS_STORAGE_SCSI_CONTROLLER_PQI           0x12
+#define   PCI_IF_MASS_STORAGE_SCSI_DEVICE_CONTROLLER_PQI    0x13
+#define   PCI_IF_MASS_STORAGE_SCSI_DEVICE_NVM_EXPRESS       0x21
+#define   PCI_IF_MASS_STORAGE_SATA_SERIAL_BUS               0x02
+#define PCI_CLASS_MASS_STORAGE_SAS                        0x07
+#define   PCI_IF_MASS_STORAGE_SAS                           0x00
+#define   PCI_IF_MASS_STORAGE_SAS_SERIAL_BUS                0x01
+#define PCI_CLASS_MASS_STORAGE_SOLID_STATE                0x08
+#define   PCI_IF_MASS_STORAGE_SOLID_STATE                   0x00
+#define   PCI_IF_MASS_STORAGE_SOLID_STATE_NVMHCI            0x01
+#define   PCI_IF_MASS_STORAGE_SOLID_STATE_ENTERPRISE_NVMHCI 0x02
+///@}
+
+///
+/// PCI_CLASS_NETWORK, Base Class 02h.
+///
+///@{
+#define PCI_CLASS_NETWORK_INFINIBAND   0x07
+///@}
+
+///
+/// PCI_CLASS_MEDIA, Base Class 04h.
+///
+///@{
+#define PCI_CLASS_MEDIA_MIXED_MODE   0x03
+///@}
+
+///
+/// PCI_CLASS_BRIDGE, Base Class 06h.
+///
+///@{
+#define PCI_CLASS_BRIDGE_ADVANCED_SWITCHING_TO_PCI      0x0B
+#define   PCI_IF_BRIDGE_ADVANCED_SWITCHING_TO_PCI_CUSTOM  0x00
+#define   PCI_IF_BRIDGE_ADVANCED_SWITCHING_TO_PCI_ASI_SIG 0x01
+///@}
+
+///
+/// PCI_CLASS_SYSTEM_PERIPHERAL, Base Class 08h.
+///
+///@{
+#define   PCI_IF_HPET                 0x03
+#define PCI_SUBCLASS_SD_HOST_CONTROLLER 0x05
+#define PCI_SUBCLASS_IOMMU              0x06
+///@}
+
+///
+/// PCI_CLASS_PROCESSOR, Base Class 0Bh.
+///
+///@{
+#define PCI_SUBCLASS_PROC_OTHER 0x80
+///@}
+
+///
+/// PCI_CLASS_SERIAL, Base Class 0Ch.
+///
+///@{
+#define   PCI_IF_XHCI             0x30
+#define PCI_CLASS_SERIAL_OTHER  0x80
+///@}
+
+///
+/// PCI_CLASS_SATELLITE, Base Class 0Fh.
+///
+///@{
+#define PCI_SUBCLASS_SATELLITE_OTHER 0x80
+///@}
+
+///
+/// PCI_CLASS_PROCESSING_ACCELERATOR, Base Class 12h.
+///
+///@{
+#define PCI_CLASS_PROCESSING_ACCELERATOR  0x12
+///@}
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/PciExpress21.h b/libedk2_tpm/include/IndustryStandard/PciExpress21.h
new file mode 100644
index 0000000..dbe6349
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/PciExpress21.h
@@ -0,0 +1,715 @@
+/** @file
+  Support for the latest PCI standard.
+
+  Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
+  (C) Copyright 2016 Hewlett Packard Enterprise Development LP<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCIEXPRESS21_H_
+#define _PCIEXPRESS21_H_
+
+#include <IndustryStandard/Pci30.h>
+
+/**
+  Macro that converts PCI Bus, PCI Device, PCI Function and PCI Register to an
+  ECAM (Enhanced Configuration Access Mechanism) address. The unused upper bits
+  of Bus, Device, Function and Register are stripped prior to the generation of
+  the address.
+
+  @param  Bus       PCI Bus number. Range 0..255.
+  @param  Device    PCI Device number. Range 0..31.
+  @param  Function  PCI Function number. Range 0..7.
+  @param  Register  PCI Register number. Range 0..4095.
+
+  @return The encode ECAM address.
+
+**/
+#define PCI_ECAM_ADDRESS(Bus,Device,Function,Offset) \
+  (((Offset) & 0xfff) | (((Function) & 0x07) << 12) | (((Device) & 0x1f) << 15) | (((Bus) & 0xff) << 20))
+
+#pragma pack(1)
+///
+/// PCI Express Capability Structure
+///
+typedef union {
+  struct {
+    UINT16 Version : 4;
+    UINT16 DevicePortType : 4;
+    UINT16 SlotImplemented : 1;
+    UINT16 InterruptMessageNumber : 5;
+    UINT16 Undefined : 1;
+    UINT16 Reserved : 1;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_CAPABILITY;
+
+#define PCIE_DEVICE_PORT_TYPE_PCIE_ENDPOINT                    0
+#define PCIE_DEVICE_PORT_TYPE_LEGACY_PCIE_ENDPOINT             1
+#define PCIE_DEVICE_PORT_TYPE_ROOT_PORT                        4
+#define PCIE_DEVICE_PORT_TYPE_UPSTREAM_PORT                    5
+#define PCIE_DEVICE_PORT_TYPE_DOWNSTREAM_PORT                  6
+#define PCIE_DEVICE_PORT_TYPE_PCIE_TO_PCI_BRIDGE               7
+#define PCIE_DEVICE_PORT_TYPE_PCI_TO_PCIE_BRIDGE               8
+#define PCIE_DEVICE_PORT_TYPE_ROOT_COMPLEX_INTEGRATED_ENDPOINT 9
+#define PCIE_DEVICE_PORT_TYPE_ROOT_COMPLEX_EVENT_COLLECTOR     10
+
+typedef union {
+  struct {
+    UINT32 MaxPayloadSize : 3;
+    UINT32 PhantomFunctions : 2;
+    UINT32 ExtendedTagField : 1;
+    UINT32 EndpointL0sAcceptableLatency : 3;
+    UINT32 EndpointL1AcceptableLatency : 3;
+    UINT32 Undefined : 3;
+    UINT32 RoleBasedErrorReporting : 1;
+    UINT32 Reserved : 2;
+    UINT32 CapturedSlotPowerLimitValue : 8;
+    UINT32 CapturedSlotPowerLimitScale : 2;
+    UINT32 FunctionLevelReset : 1;
+    UINT32 Reserved2 : 3;
+  } Bits;
+  UINT32   Uint32;
+} PCI_REG_PCIE_DEVICE_CAPABILITY;
+
+typedef union {
+  struct {
+    UINT16 CorrectableError : 1;
+    UINT16 NonFatalError : 1;
+    UINT16 FatalError : 1;
+    UINT16 UnsupportedRequest : 1;
+    UINT16 RelaxedOrdering : 1;
+    UINT16 MaxPayloadSize : 3;
+    UINT16 ExtendedTagField : 1;
+    UINT16 PhantomFunctions : 1;
+    UINT16 AuxPower : 1;
+    UINT16 NoSnoop : 1;
+    UINT16 MaxReadRequestSize : 3;
+    UINT16 BridgeConfigurationRetryOrFunctionLevelReset : 1;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_DEVICE_CONTROL;
+
+#define PCIE_MAX_PAYLOAD_SIZE_128B   0
+#define PCIE_MAX_PAYLOAD_SIZE_256B   1
+#define PCIE_MAX_PAYLOAD_SIZE_512B   2
+#define PCIE_MAX_PAYLOAD_SIZE_1024B  3
+#define PCIE_MAX_PAYLOAD_SIZE_2048B  4
+#define PCIE_MAX_PAYLOAD_SIZE_4096B  5
+#define PCIE_MAX_PAYLOAD_SIZE_RVSD1  6
+#define PCIE_MAX_PAYLOAD_SIZE_RVSD2  7
+
+#define PCIE_MAX_READ_REQ_SIZE_128B    0
+#define PCIE_MAX_READ_REQ_SIZE_256B    1
+#define PCIE_MAX_READ_REQ_SIZE_512B    2
+#define PCIE_MAX_READ_REQ_SIZE_1024B   3
+#define PCIE_MAX_READ_REQ_SIZE_2048B   4
+#define PCIE_MAX_READ_REQ_SIZE_4096B   5
+#define PCIE_MAX_READ_REQ_SIZE_RVSD1   6
+#define PCIE_MAX_READ_REQ_SIZE_RVSD2   7
+
+typedef union {
+  struct {
+    UINT16 CorrectableError : 1;
+    UINT16 NonFatalError : 1;
+    UINT16 FatalError : 1;
+    UINT16 UnsupportedRequest : 1;
+    UINT16 AuxPower : 1;
+    UINT16 TransactionsPending : 1;
+    UINT16 Reserved : 10;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_DEVICE_STATUS;
+
+typedef union {
+  struct {
+    UINT32 MaxLinkSpeed : 4;
+    UINT32 MaxLinkWidth : 6;
+    UINT32 Aspm : 2;
+    UINT32 L0sExitLatency : 3;
+    UINT32 L1ExitLatency : 3;
+    UINT32 ClockPowerManagement : 1;
+    UINT32 SurpriseDownError : 1;
+    UINT32 DataLinkLayerLinkActive : 1;
+    UINT32 LinkBandwidthNotification : 1;
+    UINT32 AspmOptionalityCompliance : 1;
+    UINT32 Reserved : 1;
+    UINT32 PortNumber : 8;
+  } Bits;
+  UINT32   Uint32;
+} PCI_REG_PCIE_LINK_CAPABILITY;
+
+#define PCIE_LINK_ASPM_L0S BIT0
+#define PCIE_LINK_ASPM_L1  BIT1
+
+typedef union {
+  struct {
+    UINT16 AspmControl : 2;
+    UINT16 Reserved : 1;
+    UINT16 ReadCompletionBoundary : 1;
+    UINT16 LinkDisable : 1;
+    UINT16 RetrainLink : 1;
+    UINT16 CommonClockConfiguration : 1;
+    UINT16 ExtendedSynch : 1;
+    UINT16 ClockPowerManagement : 1;
+    UINT16 HardwareAutonomousWidthDisable : 1;
+    UINT16 LinkBandwidthManagementInterrupt : 1;
+    UINT16 LinkAutonomousBandwidthInterrupt : 1;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_LINK_CONTROL;
+
+typedef union {
+  struct {
+    UINT16 CurrentLinkSpeed : 4;
+    UINT16 NegotiatedLinkWidth : 6;
+    UINT16 Undefined : 1;
+    UINT16 LinkTraining : 1;
+    UINT16 SlotClockConfiguration : 1;
+    UINT16 DataLinkLayerLinkActive : 1;
+    UINT16 LinkBandwidthManagement : 1;
+    UINT16 LinkAutonomousBandwidth : 1;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_LINK_STATUS;
+
+typedef union {
+  struct {
+    UINT32 AttentionButton : 1;
+    UINT32 PowerController : 1;
+    UINT32 MrlSensor : 1;
+    UINT32 AttentionIndicator : 1;
+    UINT32 PowerIndicator : 1;
+    UINT32 HotPlugSurprise : 1;
+    UINT32 HotPlugCapable : 1;
+    UINT32 SlotPowerLimitValue : 8;
+    UINT32 SlotPowerLimitScale : 2;
+    UINT32 ElectromechanicalInterlock : 1;
+    UINT32 NoCommandCompleted : 1;
+    UINT32 PhysicalSlotNumber : 13;
+  } Bits;
+  UINT32   Uint32;
+} PCI_REG_PCIE_SLOT_CAPABILITY;
+
+typedef union {
+  struct {
+    UINT16 AttentionButtonPressed : 1;
+    UINT16 PowerFaultDetected : 1;
+    UINT16 MrlSensorChanged : 1;
+    UINT16 PresenceDetectChanged : 1;
+    UINT16 CommandCompletedInterrupt : 1;
+    UINT16 HotPlugInterrupt : 1;
+    UINT16 AttentionIndicator : 2;
+    UINT16 PowerIndicator : 2;
+    UINT16 PowerController : 1;
+    UINT16 ElectromechanicalInterlock : 1;
+    UINT16 DataLinkLayerStateChanged : 1;
+    UINT16 Reserved : 3;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_SLOT_CONTROL;
+
+typedef union {
+  struct {
+    UINT16 AttentionButtonPressed : 1;
+    UINT16 PowerFaultDetected : 1;
+    UINT16 MrlSensorChanged : 1;
+    UINT16 PresenceDetectChanged : 1;
+    UINT16 CommandCompleted : 1;
+    UINT16 MrlSensor : 1;
+    UINT16 PresenceDetect : 1;
+    UINT16 ElectromechanicalInterlock : 1;
+    UINT16 DataLinkLayerStateChanged : 1;
+    UINT16 Reserved : 7;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_SLOT_STATUS;
+
+typedef union {
+  struct {
+    UINT16 SystemErrorOnCorrectableError : 1;
+    UINT16 SystemErrorOnNonFatalError : 1;
+    UINT16 SystemErrorOnFatalError : 1;
+    UINT16 PmeInterrupt : 1;
+    UINT16 CrsSoftwareVisibility : 1;
+    UINT16 Reserved : 11;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_ROOT_CONTROL;
+
+typedef union {
+  struct {
+    UINT16 CrsSoftwareVisibility : 1;
+    UINT16 Reserved : 15;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_ROOT_CAPABILITY;
+
+typedef union {
+  struct {
+    UINT32 PmeRequesterId : 16;
+    UINT32 PmeStatus : 1;
+    UINT32 PmePending : 1;
+    UINT32 Reserved : 14;
+  } Bits;
+  UINT32   Uint32;
+} PCI_REG_PCIE_ROOT_STATUS;
+
+typedef union {
+  struct {
+    UINT32 CompletionTimeoutRanges : 4;
+    UINT32 CompletionTimeoutDisable : 1;
+    UINT32 AriForwarding : 1;
+    UINT32 AtomicOpRouting : 1;
+    UINT32 AtomicOp32Completer : 1;
+    UINT32 AtomicOp64Completer : 1;
+    UINT32 Cas128Completer : 1;
+    UINT32 NoRoEnabledPrPrPassing : 1;
+    UINT32 LtrMechanism : 1;
+    UINT32 TphCompleter : 2;
+    UINT32 LnSystemCLS : 2;
+    UINT32 TenBitTagCompleterSupported : 1;
+    UINT32 TenBitTagRequesterSupported : 1;
+    UINT32 Obff : 2;
+    UINT32 ExtendedFmtField : 1;
+    UINT32 EndEndTlpPrefix : 1;
+    UINT32 MaxEndEndTlpPrefixes : 2;
+    UINT32 EmergencyPowerReductionSupported : 2;
+    UINT32 EmergencyPowerReductionInitializationRequired : 1;
+    UINT32 Reserved3 : 4;
+    UINT32 FrsSupported : 1;
+  } Bits;
+  UINT32   Uint32;
+} PCI_REG_PCIE_DEVICE_CAPABILITY2;
+
+#define PCIE_COMPLETION_TIMEOUT_NOT_SUPPORTED           0
+#define PCIE_COMPLETION_TIMEOUT_RANGE_A_SUPPORTED       1
+#define PCIE_COMPLETION_TIMEOUT_RANGE_B_SUPPORTED       2
+#define PCIE_COMPLETION_TIMEOUT_RANGE_A_B_SUPPORTED     3
+#define PCIE_COMPLETION_TIMEOUT_RANGE_B_C_SUPPORTED     6
+#define PCIE_COMPLETION_TIMEOUT_RANGE_A_B_C_SUPPORTED   7
+#define PCIE_COMPLETION_TIMEOUT_RANGE_B_C_D_SUPPORTED   14
+#define PCIE_COMPLETION_TIMEOUT_RANGE_A_B_C_D_SUPPORTED 15
+
+#define PCIE_DEVICE_CAPABILITY_OBFF_MESSAGE BIT0
+#define PCIE_DEVICE_CAPABILITY_OBFF_WAKE    BIT1
+
+typedef union {
+  struct {
+    UINT16 CompletionTimeoutValue : 4;
+    UINT16 CompletionTimeoutDisable : 1;
+    UINT16 AriForwarding : 1;
+    UINT16 AtomicOpRequester : 1;
+    UINT16 AtomicOpEgressBlocking : 1;
+    UINT16 IdoRequest : 1;
+    UINT16 IdoCompletion : 1;
+    UINT16 LtrMechanism : 1;
+    UINT16 EmergencyPowerReductionRequest : 1;
+    UINT16 TenBitTagRequesterEnable : 1;
+    UINT16 Obff : 2;
+    UINT16 EndEndTlpPrefixBlocking : 1;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_DEVICE_CONTROL2;
+
+#define PCIE_COMPLETION_TIMEOUT_50US_50MS   0
+#define PCIE_COMPLETION_TIMEOUT_50US_100US  1
+#define PCIE_COMPLETION_TIMEOUT_1MS_10MS    2
+#define PCIE_COMPLETION_TIMEOUT_16MS_55MS   5
+#define PCIE_COMPLETION_TIMEOUT_65MS_210MS  6
+#define PCIE_COMPLETION_TIMEOUT_260MS_900MS 9
+#define PCIE_COMPLETION_TIMEOUT_1S_3_5S     10
+#define PCIE_COMPLETION_TIMEOUT_4S_13S      13
+#define PCIE_COMPLETION_TIMEOUT_17S_64S     14
+
+#define PCIE_DEVICE_CONTROL_OBFF_DISABLED  0
+#define PCIE_DEVICE_CONTROL_OBFF_MESSAGE_A 1
+#define PCIE_DEVICE_CONTROL_OBFF_MESSAGE_B 2
+#define PCIE_DEVICE_CONTROL_OBFF_WAKE      3
+
+typedef union {
+  struct {
+    UINT32 Reserved : 1;
+    UINT32 LinkSpeedsVector : 7;
+    UINT32 Crosslink : 1;
+    UINT32 Reserved2 : 23;
+  } Bits;
+  UINT32   Uint32;
+} PCI_REG_PCIE_LINK_CAPABILITY2;
+
+typedef union {
+  struct {
+    UINT16 TargetLinkSpeed : 4;
+    UINT16 EnterCompliance : 1;
+    UINT16 HardwareAutonomousSpeedDisable : 1;
+    UINT16 SelectableDeemphasis : 1;
+    UINT16 TransmitMargin : 3;
+    UINT16 EnterModifiedCompliance : 1;
+    UINT16 ComplianceSos : 1;
+    UINT16 CompliancePresetDeemphasis : 4;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_LINK_CONTROL2;
+
+typedef union {
+  struct {
+    UINT16 CurrentDeemphasisLevel : 1;
+    UINT16 EqualizationComplete : 1;
+    UINT16 EqualizationPhase1Successful : 1;
+    UINT16 EqualizationPhase2Successful : 1;
+    UINT16 EqualizationPhase3Successful : 1;
+    UINT16 LinkEqualizationRequest : 1;
+    UINT16 Reserved : 10;
+  } Bits;
+  UINT16   Uint16;
+} PCI_REG_PCIE_LINK_STATUS2;
+
+typedef struct {
+  EFI_PCI_CAPABILITY_HDR          Hdr;
+  PCI_REG_PCIE_CAPABILITY         Capability;
+  PCI_REG_PCIE_DEVICE_CAPABILITY  DeviceCapability;
+  PCI_REG_PCIE_DEVICE_CONTROL     DeviceControl;
+  PCI_REG_PCIE_DEVICE_STATUS      DeviceStatus;
+  PCI_REG_PCIE_LINK_CAPABILITY    LinkCapability;
+  PCI_REG_PCIE_LINK_CONTROL       LinkControl;
+  PCI_REG_PCIE_LINK_STATUS        LinkStatus;
+  PCI_REG_PCIE_SLOT_CAPABILITY    SlotCapability;
+  PCI_REG_PCIE_SLOT_CONTROL       SlotControl;
+  PCI_REG_PCIE_SLOT_STATUS        SlotStatus;
+  PCI_REG_PCIE_ROOT_CONTROL       RootControl;
+  PCI_REG_PCIE_ROOT_CAPABILITY    RootCapability;
+  PCI_REG_PCIE_ROOT_STATUS        RootStatus;
+  PCI_REG_PCIE_DEVICE_CAPABILITY2 DeviceCapability2;
+  PCI_REG_PCIE_DEVICE_CONTROL2    DeviceControl2;
+  UINT16                          DeviceStatus2;
+  PCI_REG_PCIE_LINK_CAPABILITY2   LinkCapability2;
+  PCI_REG_PCIE_LINK_CONTROL2      LinkControl2;
+  PCI_REG_PCIE_LINK_STATUS2       LinkStatus2;
+  UINT32                          SlotCapability2;
+  UINT16                          SlotControl2;
+  UINT16                          SlotStatus2;
+} PCI_CAPABILITY_PCIEXP;
+
+#define EFI_PCIE_CAPABILITY_BASE_OFFSET                             0x100
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_CONTROL_ARI_HIERARCHY          0x10
+#define EFI_PCIE_CAPABILITY_DEVICE_CAPABILITIES_2_OFFSET            0x24
+#define EFI_PCIE_CAPABILITY_DEVICE_CAPABILITIES_2_ARI_FORWARDING    0x20
+#define EFI_PCIE_CAPABILITY_DEVICE_CONTROL_2_OFFSET                 0x28
+#define EFI_PCIE_CAPABILITY_DEVICE_CONTROL_2_ARI_FORWARDING         0x20
+
+//
+// for SR-IOV
+//
+#define EFI_PCIE_CAPABILITY_ID_ARI        0x0E
+#define EFI_PCIE_CAPABILITY_ID_ATS        0x0F
+#define EFI_PCIE_CAPABILITY_ID_SRIOV      0x10
+#define EFI_PCIE_CAPABILITY_ID_MRIOV      0x11
+
+typedef struct {
+  UINT32  CapabilityHeader;
+  UINT32  Capability;
+  UINT16  Control;
+  UINT16  Status;
+  UINT16  InitialVFs;
+  UINT16  TotalVFs;
+  UINT16  NumVFs;
+  UINT8   FunctionDependencyLink;
+  UINT8   Reserved0;
+  UINT16  FirstVFOffset;
+  UINT16  VFStride;
+  UINT16  Reserved1;
+  UINT16  VFDeviceID;
+  UINT32  SupportedPageSize;
+  UINT32  SystemPageSize;
+  UINT32  VFBar[6];
+  UINT32  VFMigrationStateArrayOffset;
+} SR_IOV_CAPABILITY_REGISTER;
+
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_CAPABILITIES               0x04
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_CONTROL                    0x08
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_STATUS                     0x0A
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_INITIALVFS                 0x0C
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_TOTALVFS                   0x0E
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_NUMVFS                     0x10
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_FUNCTION_DEPENDENCY_LINK   0x12
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_FIRSTVF                    0x14
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_VFSTRIDE                   0x16
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_VFDEVICEID                 0x1A
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_SUPPORTED_PAGE_SIZE        0x1C
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_SYSTEM_PAGE_SIZE           0x20
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_BAR0                       0x24
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_BAR1                       0x28
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_BAR2                       0x2C
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_BAR3                       0x30
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_BAR4                       0x34
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_BAR5                       0x38
+#define EFI_PCIE_CAPABILITY_ID_SRIOV_VF_MIGRATION_STATE         0x3C
+
+typedef struct {
+  UINT32 CapabilityId:16;
+  UINT32 CapabilityVersion:4;
+  UINT32 NextCapabilityOffset:12;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER;
+
+#define PCI_EXP_EXT_HDR PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ADVANCED_ERROR_REPORTING_ID   0x0001
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ADVANCED_ERROR_REPORTING_VER1 0x1
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ADVANCED_ERROR_REPORTING_VER2 0x2
+
+typedef union {
+  struct {
+    UINT32 Undefined : 1;
+    UINT32 Reserved : 3;
+    UINT32 DataLinkProtocolError : 1;
+    UINT32 SurpriseDownError : 1;
+    UINT32 Reserved2 : 6;
+    UINT32 PoisonedTlp : 1;
+    UINT32 FlowControlProtocolError : 1;
+    UINT32 CompletionTimeout : 1;
+    UINT32 CompleterAbort : 1;
+    UINT32 UnexpectedCompletion : 1;
+    UINT32 ReceiverOverflow : 1;
+    UINT32 MalformedTlp : 1;
+    UINT32 EcrcError : 1;
+    UINT32 UnsupportedRequestError : 1;
+    UINT32 AcsVoilation : 1;
+    UINT32 UncorrectableInternalError : 1;
+    UINT32 McBlockedTlp : 1;
+    UINT32 AtomicOpEgressBlocked : 1;
+    UINT32 TlpPrefixBlockedError : 1;
+    UINT32 Reserved3 : 6;
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_UNCORRECTABLE_ERROR;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  PCI_EXPRESS_REG_UNCORRECTABLE_ERROR       UncorrectableErrorStatus;
+  PCI_EXPRESS_REG_UNCORRECTABLE_ERROR       UncorrectableErrorMask;
+  PCI_EXPRESS_REG_UNCORRECTABLE_ERROR       UncorrectableErrorSeverity;
+  UINT32                                    CorrectableErrorStatus;
+  UINT32                                    CorrectableErrorMask;
+  UINT32                                    AdvancedErrorCapabilitiesAndControl;
+  UINT32                                    HeaderLog[4];
+  UINT32                                    RootErrorCommand;
+  UINT32                                    RootErrorStatus;
+  UINT16                                    ErrorSourceIdentification;
+  UINT16                                    CorrectableErrorSourceIdentification;
+  UINT32                                    TlpPrefixLog[4];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_ADVANCED_ERROR_REPORTING;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_VIRTUAL_CHANNEL_ID    0x0002
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_VIRTUAL_CHANNEL_MFVC  0x0009
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_VIRTUAL_CHANNEL_VER1  0x1
+
+typedef struct {
+  UINT32                                    VcResourceCapability:24;
+  UINT32                                    PortArbTableOffset:8;
+  UINT32                                    VcResourceControl;
+  UINT16                                    Reserved1;
+  UINT16                                    VcResourceStatus;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_VIRTUAL_CHANNEL_VC;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER              Header;
+  UINT32                                                ExtendedVcCount:3;
+  UINT32                                                PortVcCapability1:29;
+  UINT32                                                PortVcCapability2:24;
+  UINT32                                                VcArbTableOffset:8;
+  UINT16                                                PortVcControl;
+  UINT16                                                PortVcStatus;
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_VIRTUAL_CHANNEL_VC  Capability[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_VIRTUAL_CHANNEL_CAPABILITY;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_SERIAL_NUMBER_ID    0x0003
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_SERIAL_NUMBER_VER1  0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT64                                    SerialNumber;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_SERIAL_NUMBER;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_LINK_DECLARATION_ID   0x0005
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_LINK_DECLARATION_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT32                                    ElementSelfDescription;
+  UINT32                                    Reserved;
+  UINT32                                    LinkEntry[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_LINK_DECLARATION;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_LINK_DECLARATION_GET_LINK_COUNT(LINK_DECLARATION) (UINT8)(((LINK_DECLARATION->ElementSelfDescription)&0x0000ff00)>>8)
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_LINK_CONTROL_ID   0x0006
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_LINK_CONTROL_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT32                                    RootComplexLinkCapabilities;
+  UINT16                                    RootComplexLinkControl;
+  UINT16                                    RootComplexLinkStatus;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_INTERNAL_LINK_CONTROL;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_POWER_BUDGETING_ID   0x0004
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_POWER_BUDGETING_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT32                                    DataSelect:8;
+  UINT32                                    Reserved:24;
+  UINT32                                    Data;
+  UINT32                                    PowerBudgetCapability:1;
+  UINT32                                    Reserved2:7;
+  UINT32                                    Reserved3:24;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_POWER_BUDGETING;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ACS_EXTENDED_ID   0x000D
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ACS_EXTENDED_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT16                                    AcsCapability;
+  UINT16                                    AcsControl;
+  UINT8                                     EgressControlVectorArray[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_ACS_EXTENDED;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ACS_EXTENDED_GET_EGRES_CONTROL(ACS_EXTENDED) (UINT8)(((ACS_EXTENDED->AcsCapability)&0x00000020))
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ACS_EXTENDED_GET_EGRES_VECTOR_SIZE(ACS_EXTENDED) (UINT8)(((ACS_EXTENDED->AcsCapability)&0x0000FF00))
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_ID   0x0007
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT32                                    AssociationBitmap;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_EVENT_COLLECTOR_ENDPOINT_ASSOCIATION;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_MULTI_FUNCTION_VIRTUAL_CHANNEL_ID    0x0008
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_MULTI_FUNCTION_VIRTUAL_CHANNEL_VER1  0x1
+
+typedef PCI_EXPRESS_EXTENDED_CAPABILITIES_VIRTUAL_CHANNEL_CAPABILITY PCI_EXPRESS_EXTENDED_CAPABILITIES_MULTI_FUNCTION_VIRTUAL_CHANNEL_CAPABILITY;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_VENDOR_SPECIFIC_ID   0x000B
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_VENDOR_SPECIFIC_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT32                                    VendorSpecificHeader;
+  UINT8                                     VendorSpecific[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_VENDOR_SPECIFIC;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_VENDOR_SPECIFIC_GET_SIZE(VENDOR) (UINT16)(((VENDOR->VendorSpecificHeader)&0xFFF00000)>>20)
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_RCRB_HEADER_ID   0x000A
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_RCRB_HEADER_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT16                                    VendorId;
+  UINT16                                    DeviceId;
+  UINT32                                    RcrbCapabilities;
+  UINT32                                    RcrbControl;
+  UINT32                                    Reserved;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_RCRB_HEADER;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_MULTICAST_ID   0x0012
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_MULTICAST_VER1 0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER  Header;
+  UINT16                                    MultiCastCapability;
+  UINT16                                    MulticastControl;
+  UINT64                                    McBaseAddress;
+  UINT64                                    McReceiveAddress;
+  UINT64                                    McBlockAll;
+  UINT64                                    McBlockUntranslated;
+  UINT64                                    McOverlayBar;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_MULTICAST;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_RESIZABLE_BAR_ID    0x0015
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_RESIZABLE_BAR_VER1  0x1
+
+typedef union {
+  struct {
+    UINT32 Reserved:4;
+    UINT32 BarSizeCapability:28;
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_RESIZABLE_BAR_CAPABILITY;
+
+
+typedef union {
+  struct {
+    UINT32 BarIndex:3;
+    UINT32 Reserved:2;
+    UINT32 ResizableBarNumber:3;
+    UINT32 BarSize:6;
+    UINT32 Reserved2:2;
+    UINT32 BarSizeCapability:16;
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_RESIZABLE_BAR_CONTROL;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_RESIZABLE_BAR_CAPABILITY ResizableBarCapability;
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_RESIZABLE_BAR_CONTROL    ResizableBarControl;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_RESIZABLE_BAR_ENTRY;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER               Header;
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_RESIZABLE_BAR_ENTRY  Capability[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_RESIZABLE_BAR;
+
+#define GET_NUMBER_RESIZABLE_BARS(x) (x->Capability[0].ResizableBarControl.Bits.ResizableBarNumber)
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ARI_CAPABILITY_ID    0x000E
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_ARI_CAPABILITY_VER1  0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                Header;
+  UINT16                                                  AriCapability;
+  UINT16                                                  AriControl;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_ARI_CAPABILITY;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_DYNAMIC_POWER_ALLOCATION_ID    0x0016
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_DYNAMIC_POWER_ALLOCATION_VER1  0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                Header;
+  UINT32                                                  DpaCapability;
+  UINT32                                                  DpaLatencyIndicator;
+  UINT16                                                  DpaStatus;
+  UINT16                                                  DpaControl;
+  UINT8                                                   DpaPowerAllocationArray[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_DYNAMIC_POWER_ALLOCATION;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_DYNAMIC_POWER_ALLOCATION_GET_SUBSTATE_MAX(POWER) (UINT16)(((POWER->DpaCapability)&0x0000000F))
+
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_LATENCE_TOLERANCE_REPORTING_ID    0x0018
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_LATENCE_TOLERANCE_REPORTING_VER1  0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                Header;
+  UINT16                                                  MaxSnoopLatency;
+  UINT16                                                  MaxNoSnoopLatency;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_LATENCE_TOLERANCE_REPORTING;
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_TPH_ID    0x0017
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_TPH_VER1  0x1
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                Header;
+  UINT32                                                  TphRequesterCapability;
+  UINT32                                                  TphRequesterControl;
+  UINT16                                                  TphStTable[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_TPH;
+
+#define GET_TPH_TABLE_SIZE(x) ((x->TphRequesterCapability & 0x7FF0000)>>16) * sizeof(UINT16)
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/PciExpress30.h b/libedk2_tpm/include/IndustryStandard/PciExpress30.h
new file mode 100644
index 0000000..2e52e07
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/PciExpress30.h
@@ -0,0 +1,51 @@
+/** @file
+  Support for the PCI Express 3.0 standard.
+
+  This header file may not define all structures.  Please extend as required.
+
+  Copyright (c) 2014 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCIEXPRESS30_H_
+#define _PCIEXPRESS30_H_
+
+#include <IndustryStandard/PciExpress21.h>
+
+#pragma pack(1)
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_SECONDARY_PCIE_ID    0x0019
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_SECONDARY_PCIE_VER1  0x1
+
+typedef union {
+  struct {
+    UINT32 PerformEqualization : 1;
+    UINT32 LinkEqualizationRequestInterruptEnable : 1;
+    UINT32 Reserved : 30;
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_LINK_CONTROL3;
+
+typedef union {
+  struct {
+    UINT16 DownstreamPortTransmitterPreset : 4;
+    UINT16 DownstreamPortReceiverPresetHint : 3;
+    UINT16 Reserved : 1;
+    UINT16 UpstreamPortTransmitterPreset : 4;
+    UINT16 UpstreamPortReceiverPresetHint : 3;
+    UINT16 Reserved2 : 1;
+  } Bits;
+  UINT16   Uint16;
+} PCI_EXPRESS_REG_LANE_EQUALIZATION_CONTROL;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                Header;
+  PCI_EXPRESS_REG_LINK_CONTROL3                           LinkControl3;
+  UINT32                                                  LaneErrorStatus;
+  PCI_EXPRESS_REG_LANE_EQUALIZATION_CONTROL               EqualizationControl[2];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_SECONDARY_PCIE;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/PciExpress31.h b/libedk2_tpm/include/IndustryStandard/PciExpress31.h
new file mode 100644
index 0000000..2e5e097
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/PciExpress31.h
@@ -0,0 +1,72 @@
+/** @file
+Support for the PCI Express 3.1 standard.
+
+This header file may not define all structures.  Please extend as required.
+
+Copyright (c) 2016, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCIEXPRESS31_H_
+#define _PCIEXPRESS31_H_
+
+#include <IndustryStandard/PciExpress30.h>
+
+#pragma pack(1)
+
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_L1_PM_SUBSTATES_ID    0x001E
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_L1_PM_SUBSTATES_VER1  0x1
+
+typedef union {
+  struct {
+    UINT32 PciPmL12 : 1;
+    UINT32 PciPmL11 : 1;
+    UINT32 AspmL12 : 1;
+    UINT32 AspmL11 : 1;
+    UINT32 L1PmSubstates : 1;
+    UINT32 Reserved : 3;
+    UINT32 CommonModeRestoreTime : 8;
+    UINT32 TPowerOnScale : 2;
+    UINT32 Reserved2 : 1;
+    UINT32 TPowerOnValue : 5;
+    UINT32 Reserved3 : 8;
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_L1_PM_SUBSTATES_CAPABILITY;
+
+typedef union {
+  struct {
+    UINT32 PciPmL12 : 1;
+    UINT32 PciPmL11 : 1;
+    UINT32 AspmL12 : 1;
+    UINT32 AspmL11 : 1;
+    UINT32 Reserved : 4;
+    UINT32 CommonModeRestoreTime : 8;
+    UINT32 LtrL12ThresholdValue : 10;
+    UINT32 Reserved2 : 3;
+    UINT32 LtrL12ThresholdScale : 3;
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_L1_PM_SUBSTATES_CONTROL1;
+
+typedef union {
+  struct {
+    UINT32 TPowerOnScale : 2;
+    UINT32 Reserved : 1;
+    UINT32 TPowerOnValue : 5;
+    UINT32 Reserved2 : 24;
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_L1_PM_SUBSTATES_CONTROL2;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER   Header;
+  PCI_EXPRESS_REG_L1_PM_SUBSTATES_CAPABILITY Capability;
+  PCI_EXPRESS_REG_L1_PM_SUBSTATES_CONTROL1   Control1;
+  PCI_EXPRESS_REG_L1_PM_SUBSTATES_CONTROL2   Control2;
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_L1_PM_SUBSTATES;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/PciExpress40.h b/libedk2_tpm/include/IndustryStandard/PciExpress40.h
new file mode 100644
index 0000000..a76f1bd
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/PciExpress40.h
@@ -0,0 +1,111 @@
+/** @file
+Support for the PCI Express 4.0 standard.
+
+This header file may not define all structures.  Please extend as required.
+
+Copyright (c) 2018, American Megatrends, Inc. All rights reserved.<BR>
+Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCIEXPRESS40_H_
+#define _PCIEXPRESS40_H_
+
+#include <IndustryStandard/PciExpress31.h>
+
+#pragma pack(1)
+
+/// The Physical Layer PCI Express Extended Capability definitions.
+///
+/// Based on section 7.7.5 of PCI Express Base Specification 4.0.
+///@{
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_PHYSICAL_LAYER_16_0_ID    0x0026
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_PHYSICAL_LAYER_16_0_VER1  0x1
+
+// Register offsets from Physical Layer PCI-E Ext Cap Header
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_CAPABILITIES_OFFSET                         0x04
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_CONTROL_OFFSET                              0x08
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_STATUS_OFFSET                               0x0C
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_LOCAL_DATA_PARITY_STATUS_OFFSET             0x10
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_FIRST_RETIMER_DATA_PARITY_STATUS_OFFSET     0x14
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_SECOND_RETIMER_DATA_PARITY_STATUS_OFFSET    0x18
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_LANE_EQUALIZATION_CONTROL_OFFSET            0x20
+
+typedef union {
+  struct {
+    UINT32 Reserved                  : 32; // Reserved bit 0:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_CAPABILITIES;
+
+typedef union {
+  struct {
+    UINT32 Reserved                  : 32; // Reserved bit 0:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_CONTROL;
+
+typedef union {
+  struct {
+    UINT32 EqualizationComplete      : 1; // bit 0
+    UINT32 EqualizationPhase1Success : 1; // bit 1
+    UINT32 EqualizationPhase2Success : 1; // bit 2
+    UINT32 EqualizationPhase3Success : 1; // bit 3
+    UINT32 LinkEqualizationRequest   : 1; // bit 4
+    UINT32 Reserved                  : 27; // Reserved bit 5:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_STATUS;
+
+typedef union {
+  struct {
+    UINT8 DownstreamPortTransmitterPreset : 4; //bit 0..3
+    UINT8 UpstreamPortTransmitterPreset   : 4; //bit 4..7
+  } Bits;
+  UINT8   Uint8;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_LANE_EQUALIZATION_CONTROL;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                      Header;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_CAPABILITIES              Capablities;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_CONTROL                   Control;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_STATUS                    Status;
+  UINT32                                                        LocalDataParityMismatchStatus;
+  UINT32                                                        FirstRetimerDataParityMismatchStatus;
+  UINT32                                                        SecondRetimerDataParityMismatchStatus;
+  UINT32                                                        Reserved;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_16_0_LANE_EQUALIZATION_CONTROL LaneEqualizationControl[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_PHYSICAL_LAYER_16_0;
+///@}
+
+/// The Designated Vendor Specific Capability definitions
+/// Based on section 7.9.6 of PCI Express Base Specification 4.0.
+///@{
+typedef union {
+  struct {
+    UINT32 DvsecVendorId                                        : 16; //bit 0..15
+    UINT32 DvsecRevision                                        : 4;  //bit 16..19
+    UINT32 DvsecLength                                          : 12; //bit 20..31
+  }Bits;
+  UINT32                                                        Uint32;
+}PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1;
+
+typedef union {
+  struct {
+    UINT16 DvsecId                                              : 16; //bit 0..15
+  }Bits;
+  UINT16                                                        Uint16;
+}PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                      Header;
+  PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_1               DesignatedVendorSpecificHeader1;
+  PCI_EXPRESS_DESIGNATED_VENDOR_SPECIFIC_HEADER_2               DesignatedVendorSpecificHeader2;
+  UINT8                                                         DesignatedVendorSpecific[1];
+}PCI_EXPRESS_EXTENDED_CAPABILITIES_DESIGNATED_VENDOR_SPECIFIC;
+///@}
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/PciExpress50.h b/libedk2_tpm/include/IndustryStandard/PciExpress50.h
new file mode 100644
index 0000000..3765875
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/PciExpress50.h
@@ -0,0 +1,136 @@
+/** @file
+Support for the PCI Express 5.0 standard.
+
+This header file may not define all structures.  Please extend as required.
+
+Copyright (c) 2020, American Megatrends International LLC. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _PCIEXPRESS50_H_
+#define _PCIEXPRESS50_H_
+
+#include <IndustryStandard/PciExpress40.h>
+
+#pragma pack(1)
+
+/// The Physical Layer PCI Express Extended Capability definitions.
+///
+/// Based on section 7.7.6 of PCI Express Base Specification 5.0.
+///@{
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_PHYSICAL_LAYER_32_0_ID    0x002A
+#define PCI_EXPRESS_EXTENDED_CAPABILITY_PHYSICAL_LAYER_32_0_VER1  0x1
+
+// Register offsets from Physical Layer PCI-E Ext Cap Header
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_CAPABILITIES_OFFSET                         0x04
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_CONTROL_OFFSET                              0x08
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_STATUS_OFFSET                               0x0C
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_RCVD_MODIFIED_TS_DATA1_OFFSET               0x10
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_RCVD_MODIFIED_TS_DATA2_OFFSET               0x14
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_TRANS_MODIFIED_TS_DATA1_OFFSET              0x18
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_TRANS_MODIFIED_TS_DATA2_OFFSET              0x1C
+#define PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_LANE_EQUALIZATION_CONTROL_OFFSET            0x20
+
+typedef union {
+  struct {
+    UINT32 EqualizationByPassToHighestRateSupport                  : 1; // bit 0
+    UINT32 NoEqualizationNeededSupport                             : 1; // bit 1
+    UINT32 Reserved1                                               : 6; // Reserved bit 2:7
+    UINT32 ModifiedTSUsageMode0Support                             : 1; // bit 8
+    UINT32 ModifiedTSUsageMode1Support                             : 1; // bit 9
+    UINT32 ModifiedTSUsageMode2Support                             : 1; // bit 10
+    UINT32 ModifiedTSReservedUsageModes                            : 5; // bit 11:15
+    UINT32 Reserved2                                               : 16; // Reserved bit 16:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_CAPABILITIES;
+
+typedef union {
+  struct {
+    UINT32 EqualizationByPassToHighestRateDisable                  : 1; // bit 0
+    UINT32 NoEqualizationNeededDisable                             : 1; // bit 1
+    UINT32 Reserved1                                               : 6; // Reserved bit 2:7
+    UINT32 ModifiedTSUsageModeSelected                             : 3; // bit 8:10
+    UINT32 Reserved2                                               : 21; // Reserved bit 11:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_CONTROL;
+
+typedef union {
+  struct {
+    UINT32 EqualizationComplete      : 1; // bit 0
+    UINT32 EqualizationPhase1Success : 1; // bit 1
+    UINT32 EqualizationPhase2Success : 1; // bit 2
+    UINT32 EqualizationPhase3Success : 1; // bit 3
+    UINT32 LinkEqualizationRequest   : 1; // bit 4
+    UINT32 ModifiedTSRcvd            : 1; // bit 5
+    UINT32 RcvdEnhancedLinkControl   : 2; // bit 6:7
+    UINT32 TransmitterPrecodingOn    : 1; // bit 8
+    UINT32 TransmitterPrecodeRequest : 1; // bit 9
+    UINT32 NoEqualizationNeededRcvd  : 1; // bit 10
+    UINT32 Reserved                  : 21; // Reserved bit 11:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_STATUS;
+
+typedef union {
+  struct {
+    UINT32 RcvdModifiedTSUsageMode   : 3; // bit 0:2
+    UINT32 RcvdModifiedTSUsageInfo1  : 13; // bit 3:15
+    UINT32 RcvdModifiedTSVendorId    : 16; // bit 16:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_RCVD_MODIFIED_TS_DATA1;
+
+typedef union {
+  struct {
+    UINT32 RcvdModifiedTSUsageInfo2     : 24; // bit 0:23
+    UINT32 AltProtocolNegotiationStatus : 2; // bit 24:25
+    UINT32 Reserved                     : 6; // Reserved bit 26:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_RCVD_MODIFIED_TS_DATA2;
+
+typedef union {
+  struct {
+    UINT32 TransModifiedTSUsageMode   : 3; // bit 0:2
+    UINT32 TransModifiedTSUsageInfo1  : 13; // bit 3:15
+    UINT32 TransModifiedTSVendorId    : 16; // bit 16:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_TRANS_MODIFIED_TS_DATA1;
+
+typedef union {
+  struct {
+    UINT32 TransModifiedTSUsageInfo2    : 24; // bit 0:23
+    UINT32 AltProtocolNegotiationStatus : 2; // bit 24:25
+    UINT32 Reserved                     : 6; // Reserved bit 26:31
+  } Bits;
+  UINT32   Uint32;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_TRANS_MODIFIED_TS_DATA2;
+
+typedef union {
+  struct {
+    UINT8 DownstreamPortTransmitterPreset : 4; //bit 0..3
+    UINT8 UpstreamPortTransmitterPreset   : 4; //bit 4..7
+  } Bits;
+  UINT8   Uint8;
+} PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_LANE_EQUALIZATION_CONTROL;
+
+typedef struct {
+  PCI_EXPRESS_EXTENDED_CAPABILITIES_HEADER                      Header;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_CAPABILITIES              Capablities;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_CONTROL                   Control;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_STATUS                    Status;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_RCVD_MODIFIED_TS_DATA1    RcvdModifiedTs1Data;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_RCVD_MODIFIED_TS_DATA2    RcvdModifiedTs2Data;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_TRANS_MODIFIED_TS_DATA1   TransModifiedTs1Data;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_TRANS_MODIFIED_TS_DATA2   TransModifiedTs2Data;
+  PCI_EXPRESS_REG_PHYSICAL_LAYER_32_0_LANE_EQUALIZATION_CONTROL LaneEqualizationControl[1];
+} PCI_EXPRESS_EXTENDED_CAPABILITIES_PHYSICAL_LAYER_32_0;
+///@}
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/PeImage.h b/libedk2_tpm/include/IndustryStandard/PeImage.h
new file mode 100644
index 0000000..15a713e
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/PeImage.h
@@ -0,0 +1,762 @@
+/** @file
+  EFI image format for PE32, PE32+ and TE. Please note some data structures are
+  different for PE32 and PE32+. EFI_IMAGE_NT_HEADERS32 is for PE32 and
+  EFI_IMAGE_NT_HEADERS64 is for PE32+.
+
+  This file is coded to the Visual Studio, Microsoft Portable Executable and
+  Common Object File Format Specification, Revision 8.3 - February 6, 2013.
+  This file also includes some definitions in PI Specification, Revision 1.0.
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+Portions copyright (c) 2008 - 2009, Apple Inc. All rights reserved.<BR>
+Portions Copyright (c) 2016 - 2020, Hewlett Packard Enterprise Development LP. All rights reserved.<BR>
+
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __PE_IMAGE_H__
+#define __PE_IMAGE_H__
+
+//
+// PE32+ Subsystem type for EFI images
+//
+#define EFI_IMAGE_SUBSYSTEM_EFI_APPLICATION         10
+#define EFI_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11
+#define EFI_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER      12
+#define EFI_IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER      13 ///< defined PI Specification, 1.0
+
+
+//
+// PE32+ Machine type for EFI images
+//
+#define IMAGE_FILE_MACHINE_I386            0x014c
+#define IMAGE_FILE_MACHINE_IA64            0x0200
+#define IMAGE_FILE_MACHINE_EBC             0x0EBC
+#define IMAGE_FILE_MACHINE_X64             0x8664
+#define IMAGE_FILE_MACHINE_ARMTHUMB_MIXED  0x01c2
+#define IMAGE_FILE_MACHINE_ARM64           0xAA64
+#define IMAGE_FILE_MACHINE_RISCV32         0x5032
+#define IMAGE_FILE_MACHINE_RISCV64         0x5064
+#define IMAGE_FILE_MACHINE_RISCV128        0x5128
+
+//
+// EXE file formats
+//
+#define EFI_IMAGE_DOS_SIGNATURE     SIGNATURE_16('M', 'Z')
+#define EFI_IMAGE_OS2_SIGNATURE     SIGNATURE_16('N', 'E')
+#define EFI_IMAGE_OS2_SIGNATURE_LE  SIGNATURE_16('L', 'E')
+#define EFI_IMAGE_NT_SIGNATURE      SIGNATURE_32('P', 'E', '\0', '\0')
+
+///
+/// PE images can start with an optional DOS header, so if an image is run
+/// under DOS it can print an error message.
+///
+typedef struct {
+  UINT16  e_magic;    ///< Magic number.
+  UINT16  e_cblp;     ///< Bytes on last page of file.
+  UINT16  e_cp;       ///< Pages in file.
+  UINT16  e_crlc;     ///< Relocations.
+  UINT16  e_cparhdr;  ///< Size of header in paragraphs.
+  UINT16  e_minalloc; ///< Minimum extra paragraphs needed.
+  UINT16  e_maxalloc; ///< Maximum extra paragraphs needed.
+  UINT16  e_ss;       ///< Initial (relative) SS value.
+  UINT16  e_sp;       ///< Initial SP value.
+  UINT16  e_csum;     ///< Checksum.
+  UINT16  e_ip;       ///< Initial IP value.
+  UINT16  e_cs;       ///< Initial (relative) CS value.
+  UINT16  e_lfarlc;   ///< File address of relocation table.
+  UINT16  e_ovno;     ///< Overlay number.
+  UINT16  e_res[4];   ///< Reserved words.
+  UINT16  e_oemid;    ///< OEM identifier (for e_oeminfo).
+  UINT16  e_oeminfo;  ///< OEM information; e_oemid specific.
+  UINT16  e_res2[10]; ///< Reserved words.
+  UINT32  e_lfanew;   ///< File address of new exe header.
+} EFI_IMAGE_DOS_HEADER;
+
+///
+/// COFF File Header (Object and Image).
+///
+typedef struct {
+  UINT16  Machine;
+  UINT16  NumberOfSections;
+  UINT32  TimeDateStamp;
+  UINT32  PointerToSymbolTable;
+  UINT32  NumberOfSymbols;
+  UINT16  SizeOfOptionalHeader;
+  UINT16  Characteristics;
+} EFI_IMAGE_FILE_HEADER;
+
+///
+/// Size of EFI_IMAGE_FILE_HEADER.
+///
+#define EFI_IMAGE_SIZEOF_FILE_HEADER        20
+
+//
+// Characteristics
+//
+#define EFI_IMAGE_FILE_RELOCS_STRIPPED      BIT0     ///< 0x0001  Relocation info stripped from file.
+#define EFI_IMAGE_FILE_EXECUTABLE_IMAGE     BIT1     ///< 0x0002  File is executable  (i.e. no unresolved externel references).
+#define EFI_IMAGE_FILE_LINE_NUMS_STRIPPED   BIT2     ///< 0x0004  Line numbers stripped from file.
+#define EFI_IMAGE_FILE_LOCAL_SYMS_STRIPPED  BIT3     ///< 0x0008  Local symbols stripped from file.
+#define EFI_IMAGE_FILE_BYTES_REVERSED_LO    BIT7     ///< 0x0080  Bytes of machine word are reversed.
+#define EFI_IMAGE_FILE_32BIT_MACHINE        BIT8     ///< 0x0100  32 bit word machine.
+#define EFI_IMAGE_FILE_DEBUG_STRIPPED       BIT9     ///< 0x0200  Debugging info stripped from file in .DBG file.
+#define EFI_IMAGE_FILE_SYSTEM               BIT12    ///< 0x1000  System File.
+#define EFI_IMAGE_FILE_DLL                  BIT13    ///< 0x2000  File is a DLL.
+#define EFI_IMAGE_FILE_BYTES_REVERSED_HI    BIT15    ///< 0x8000  Bytes of machine word are reversed.
+
+///
+/// Header Data Directories.
+///
+typedef struct {
+  UINT32  VirtualAddress;
+  UINT32  Size;
+} EFI_IMAGE_DATA_DIRECTORY;
+
+//
+// Directory Entries
+//
+#define EFI_IMAGE_DIRECTORY_ENTRY_EXPORT      0
+#define EFI_IMAGE_DIRECTORY_ENTRY_IMPORT      1
+#define EFI_IMAGE_DIRECTORY_ENTRY_RESOURCE    2
+#define EFI_IMAGE_DIRECTORY_ENTRY_EXCEPTION   3
+#define EFI_IMAGE_DIRECTORY_ENTRY_SECURITY    4
+#define EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC   5
+#define EFI_IMAGE_DIRECTORY_ENTRY_DEBUG       6
+#define EFI_IMAGE_DIRECTORY_ENTRY_COPYRIGHT   7
+#define EFI_IMAGE_DIRECTORY_ENTRY_GLOBALPTR   8
+#define EFI_IMAGE_DIRECTORY_ENTRY_TLS         9
+#define EFI_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10
+
+#define EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES 16
+
+///
+/// @attention
+/// EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC means PE32 and
+/// EFI_IMAGE_OPTIONAL_HEADER32 must be used. The data structures only vary
+/// after NT additional fields.
+///
+#define EFI_IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b
+
+///
+/// Optional Header Standard Fields for PE32.
+///
+typedef struct {
+  ///
+  /// Standard fields.
+  ///
+  UINT16                    Magic;
+  UINT8                     MajorLinkerVersion;
+  UINT8                     MinorLinkerVersion;
+  UINT32                    SizeOfCode;
+  UINT32                    SizeOfInitializedData;
+  UINT32                    SizeOfUninitializedData;
+  UINT32                    AddressOfEntryPoint;
+  UINT32                    BaseOfCode;
+  UINT32                    BaseOfData;  ///< PE32 contains this additional field, which is absent in PE32+.
+  ///
+  /// Optional Header Windows-Specific Fields.
+  ///
+  UINT32                    ImageBase;
+  UINT32                    SectionAlignment;
+  UINT32                    FileAlignment;
+  UINT16                    MajorOperatingSystemVersion;
+  UINT16                    MinorOperatingSystemVersion;
+  UINT16                    MajorImageVersion;
+  UINT16                    MinorImageVersion;
+  UINT16                    MajorSubsystemVersion;
+  UINT16                    MinorSubsystemVersion;
+  UINT32                    Win32VersionValue;
+  UINT32                    SizeOfImage;
+  UINT32                    SizeOfHeaders;
+  UINT32                    CheckSum;
+  UINT16                    Subsystem;
+  UINT16                    DllCharacteristics;
+  UINT32                    SizeOfStackReserve;
+  UINT32                    SizeOfStackCommit;
+  UINT32                    SizeOfHeapReserve;
+  UINT32                    SizeOfHeapCommit;
+  UINT32                    LoaderFlags;
+  UINT32                    NumberOfRvaAndSizes;
+  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
+} EFI_IMAGE_OPTIONAL_HEADER32;
+
+///
+/// @attention
+/// EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC means PE32+ and
+/// EFI_IMAGE_OPTIONAL_HEADER64 must be used. The data structures only vary
+/// after NT additional fields.
+///
+#define EFI_IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
+
+///
+/// Optional Header Standard Fields for PE32+.
+///
+typedef struct {
+  ///
+  /// Standard fields.
+  ///
+  UINT16                    Magic;
+  UINT8                     MajorLinkerVersion;
+  UINT8                     MinorLinkerVersion;
+  UINT32                    SizeOfCode;
+  UINT32                    SizeOfInitializedData;
+  UINT32                    SizeOfUninitializedData;
+  UINT32                    AddressOfEntryPoint;
+  UINT32                    BaseOfCode;
+  ///
+  /// Optional Header Windows-Specific Fields.
+  ///
+  UINT64                    ImageBase;
+  UINT32                    SectionAlignment;
+  UINT32                    FileAlignment;
+  UINT16                    MajorOperatingSystemVersion;
+  UINT16                    MinorOperatingSystemVersion;
+  UINT16                    MajorImageVersion;
+  UINT16                    MinorImageVersion;
+  UINT16                    MajorSubsystemVersion;
+  UINT16                    MinorSubsystemVersion;
+  UINT32                    Win32VersionValue;
+  UINT32                    SizeOfImage;
+  UINT32                    SizeOfHeaders;
+  UINT32                    CheckSum;
+  UINT16                    Subsystem;
+  UINT16                    DllCharacteristics;
+  UINT64                    SizeOfStackReserve;
+  UINT64                    SizeOfStackCommit;
+  UINT64                    SizeOfHeapReserve;
+  UINT64                    SizeOfHeapCommit;
+  UINT32                    LoaderFlags;
+  UINT32                    NumberOfRvaAndSizes;
+  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[EFI_IMAGE_NUMBER_OF_DIRECTORY_ENTRIES];
+} EFI_IMAGE_OPTIONAL_HEADER64;
+
+
+///
+/// @attention
+/// EFI_IMAGE_NT_HEADERS32 is for use ONLY by tools.
+///
+typedef struct {
+  UINT32                      Signature;
+  EFI_IMAGE_FILE_HEADER       FileHeader;
+  EFI_IMAGE_OPTIONAL_HEADER32 OptionalHeader;
+} EFI_IMAGE_NT_HEADERS32;
+
+#define EFI_IMAGE_SIZEOF_NT_OPTIONAL32_HEADER sizeof (EFI_IMAGE_NT_HEADERS32)
+
+///
+/// @attention
+/// EFI_IMAGE_HEADERS64 is for use ONLY by tools.
+///
+typedef struct {
+  UINT32                      Signature;
+  EFI_IMAGE_FILE_HEADER       FileHeader;
+  EFI_IMAGE_OPTIONAL_HEADER64 OptionalHeader;
+} EFI_IMAGE_NT_HEADERS64;
+
+#define EFI_IMAGE_SIZEOF_NT_OPTIONAL64_HEADER sizeof (EFI_IMAGE_NT_HEADERS64)
+
+//
+// Other Windows Subsystem Values
+//
+#define EFI_IMAGE_SUBSYSTEM_UNKNOWN     0
+#define EFI_IMAGE_SUBSYSTEM_NATIVE      1
+#define EFI_IMAGE_SUBSYSTEM_WINDOWS_GUI 2
+#define EFI_IMAGE_SUBSYSTEM_WINDOWS_CUI 3
+#define EFI_IMAGE_SUBSYSTEM_OS2_CUI     5
+#define EFI_IMAGE_SUBSYSTEM_POSIX_CUI   7
+
+///
+/// Length of ShortName.
+///
+#define EFI_IMAGE_SIZEOF_SHORT_NAME 8
+
+///
+/// Section Table. This table immediately follows the optional header.
+///
+typedef struct {
+  UINT8 Name[EFI_IMAGE_SIZEOF_SHORT_NAME];
+  union {
+    UINT32  PhysicalAddress;
+    UINT32  VirtualSize;
+  } Misc;
+  UINT32  VirtualAddress;
+  UINT32  SizeOfRawData;
+  UINT32  PointerToRawData;
+  UINT32  PointerToRelocations;
+  UINT32  PointerToLinenumbers;
+  UINT16  NumberOfRelocations;
+  UINT16  NumberOfLinenumbers;
+  UINT32  Characteristics;
+} EFI_IMAGE_SECTION_HEADER;
+
+///
+/// Size of EFI_IMAGE_SECTION_HEADER.
+///
+#define EFI_IMAGE_SIZEOF_SECTION_HEADER       40
+
+//
+// Section Flags Values
+//
+#define EFI_IMAGE_SCN_TYPE_NO_PAD                  BIT3   ///< 0x00000008  ///< Reserved.
+#define EFI_IMAGE_SCN_CNT_CODE                     BIT5   ///< 0x00000020
+#define EFI_IMAGE_SCN_CNT_INITIALIZED_DATA         BIT6   ///< 0x00000040
+#define EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA       BIT7   ///< 0x00000080
+
+#define EFI_IMAGE_SCN_LNK_OTHER                    BIT8   ///< 0x00000100  ///< Reserved.
+#define EFI_IMAGE_SCN_LNK_INFO                     BIT9   ///< 0x00000200  ///< Section contains comments or some other type of information.
+#define EFI_IMAGE_SCN_LNK_REMOVE                   BIT11  ///< 0x00000800  ///< Section contents will not become part of image.
+#define EFI_IMAGE_SCN_LNK_COMDAT                   BIT12  ///< 0x00001000
+
+#define EFI_IMAGE_SCN_ALIGN_1BYTES                 BIT20  ///< 0x00100000
+#define EFI_IMAGE_SCN_ALIGN_2BYTES                 BIT21  ///< 0x00200000
+#define EFI_IMAGE_SCN_ALIGN_4BYTES          (BIT20|BIT21) ///< 0x00300000
+#define EFI_IMAGE_SCN_ALIGN_8BYTES                 BIT22  ///< 0x00400000
+#define EFI_IMAGE_SCN_ALIGN_16BYTES         (BIT20|BIT22) ///< 0x00500000
+#define EFI_IMAGE_SCN_ALIGN_32BYTES         (BIT21|BIT22) ///< 0x00600000
+#define EFI_IMAGE_SCN_ALIGN_64BYTES   (BIT20|BIT21|BIT22) ///< 0x00700000
+
+#define EFI_IMAGE_SCN_MEM_DISCARDABLE              BIT25  ///< 0x02000000
+#define EFI_IMAGE_SCN_MEM_NOT_CACHED               BIT26  ///< 0x04000000
+#define EFI_IMAGE_SCN_MEM_NOT_PAGED                BIT27  ///< 0x08000000
+#define EFI_IMAGE_SCN_MEM_SHARED                   BIT28  ///< 0x10000000
+#define EFI_IMAGE_SCN_MEM_EXECUTE                  BIT29  ///< 0x20000000
+#define EFI_IMAGE_SCN_MEM_READ                     BIT30  ///< 0x40000000
+#define EFI_IMAGE_SCN_MEM_WRITE                    BIT31  ///< 0x80000000
+
+///
+/// Size of a Symbol Table Record.
+///
+#define EFI_IMAGE_SIZEOF_SYMBOL 18
+
+//
+// Symbols have a section number of the section in which they are
+// defined. Otherwise, section numbers have the following meanings:
+//
+#define EFI_IMAGE_SYM_UNDEFINED (UINT16) 0  ///< Symbol is undefined or is common.
+#define EFI_IMAGE_SYM_ABSOLUTE  (UINT16) -1 ///< Symbol is an absolute value.
+#define EFI_IMAGE_SYM_DEBUG     (UINT16) -2 ///< Symbol is a special debug item.
+
+//
+// Symbol Type (fundamental) values.
+//
+#define EFI_IMAGE_SYM_TYPE_NULL   0   ///< no type.
+#define EFI_IMAGE_SYM_TYPE_VOID   1   ///< no valid type.
+#define EFI_IMAGE_SYM_TYPE_CHAR   2   ///< type character.
+#define EFI_IMAGE_SYM_TYPE_SHORT  3   ///< type short integer.
+#define EFI_IMAGE_SYM_TYPE_INT    4
+#define EFI_IMAGE_SYM_TYPE_LONG   5
+#define EFI_IMAGE_SYM_TYPE_FLOAT  6
+#define EFI_IMAGE_SYM_TYPE_DOUBLE 7
+#define EFI_IMAGE_SYM_TYPE_STRUCT 8
+#define EFI_IMAGE_SYM_TYPE_UNION  9
+#define EFI_IMAGE_SYM_TYPE_ENUM   10  ///< enumeration.
+#define EFI_IMAGE_SYM_TYPE_MOE    11  ///< member of enumeration.
+#define EFI_IMAGE_SYM_TYPE_BYTE   12
+#define EFI_IMAGE_SYM_TYPE_WORD   13
+#define EFI_IMAGE_SYM_TYPE_UINT   14
+#define EFI_IMAGE_SYM_TYPE_DWORD  15
+
+//
+// Symbol Type (derived) values.
+//
+#define EFI_IMAGE_SYM_DTYPE_NULL      0 ///< no derived type.
+#define EFI_IMAGE_SYM_DTYPE_POINTER   1
+#define EFI_IMAGE_SYM_DTYPE_FUNCTION  2
+#define EFI_IMAGE_SYM_DTYPE_ARRAY     3
+
+//
+// Storage classes.
+//
+#define EFI_IMAGE_SYM_CLASS_END_OF_FUNCTION   ((UINT8) -1)
+#define EFI_IMAGE_SYM_CLASS_NULL              0
+#define EFI_IMAGE_SYM_CLASS_AUTOMATIC         1
+#define EFI_IMAGE_SYM_CLASS_EXTERNAL          2
+#define EFI_IMAGE_SYM_CLASS_STATIC            3
+#define EFI_IMAGE_SYM_CLASS_REGISTER          4
+#define EFI_IMAGE_SYM_CLASS_EXTERNAL_DEF      5
+#define EFI_IMAGE_SYM_CLASS_LABEL             6
+#define EFI_IMAGE_SYM_CLASS_UNDEFINED_LABEL   7
+#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_STRUCT  8
+#define EFI_IMAGE_SYM_CLASS_ARGUMENT          9
+#define EFI_IMAGE_SYM_CLASS_STRUCT_TAG        10
+#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_UNION   11
+#define EFI_IMAGE_SYM_CLASS_UNION_TAG         12
+#define EFI_IMAGE_SYM_CLASS_TYPE_DEFINITION   13
+#define EFI_IMAGE_SYM_CLASS_UNDEFINED_STATIC  14
+#define EFI_IMAGE_SYM_CLASS_ENUM_TAG          15
+#define EFI_IMAGE_SYM_CLASS_MEMBER_OF_ENUM    16
+#define EFI_IMAGE_SYM_CLASS_REGISTER_PARAM    17
+#define EFI_IMAGE_SYM_CLASS_BIT_FIELD         18
+#define EFI_IMAGE_SYM_CLASS_BLOCK             100
+#define EFI_IMAGE_SYM_CLASS_FUNCTION          101
+#define EFI_IMAGE_SYM_CLASS_END_OF_STRUCT     102
+#define EFI_IMAGE_SYM_CLASS_FILE              103
+#define EFI_IMAGE_SYM_CLASS_SECTION           104
+#define EFI_IMAGE_SYM_CLASS_WEAK_EXTERNAL     105
+
+//
+// type packing constants
+//
+#define EFI_IMAGE_N_BTMASK  017
+#define EFI_IMAGE_N_TMASK   060
+#define EFI_IMAGE_N_TMASK1  0300
+#define EFI_IMAGE_N_TMASK2  0360
+#define EFI_IMAGE_N_BTSHFT  4
+#define EFI_IMAGE_N_TSHIFT  2
+
+//
+// Communal selection types.
+//
+#define EFI_IMAGE_COMDAT_SELECT_NODUPLICATES    1
+#define EFI_IMAGE_COMDAT_SELECT_ANY             2
+#define EFI_IMAGE_COMDAT_SELECT_SAME_SIZE       3
+#define EFI_IMAGE_COMDAT_SELECT_EXACT_MATCH     4
+#define EFI_IMAGE_COMDAT_SELECT_ASSOCIATIVE     5
+
+//
+// the following values only be referred in PeCoff, not defined in PECOFF.
+//
+#define EFI_IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  1
+#define EFI_IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    2
+#define EFI_IMAGE_WEAK_EXTERN_SEARCH_ALIAS      3
+
+///
+/// Relocation format.
+///
+typedef struct {
+  UINT32  VirtualAddress;
+  UINT32  SymbolTableIndex;
+  UINT16  Type;
+} EFI_IMAGE_RELOCATION;
+
+///
+/// Size of EFI_IMAGE_RELOCATION
+///
+#define EFI_IMAGE_SIZEOF_RELOCATION 10
+
+//
+// I386 relocation types.
+//
+#define EFI_IMAGE_REL_I386_ABSOLUTE 0x0000  ///< Reference is absolute, no relocation is necessary.
+#define EFI_IMAGE_REL_I386_DIR16    0x0001  ///< Direct 16-bit reference to the symbols virtual address.
+#define EFI_IMAGE_REL_I386_REL16    0x0002  ///< PC-relative 16-bit reference to the symbols virtual address.
+#define EFI_IMAGE_REL_I386_DIR32    0x0006  ///< Direct 32-bit reference to the symbols virtual address.
+#define EFI_IMAGE_REL_I386_DIR32NB  0x0007  ///< Direct 32-bit reference to the symbols virtual address, base not included.
+#define EFI_IMAGE_REL_I386_SEG12    0x0009  ///< Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address.
+#define EFI_IMAGE_REL_I386_SECTION  0x000A
+#define EFI_IMAGE_REL_I386_SECREL   0x000B
+#define EFI_IMAGE_REL_I386_REL32    0x0014  ///< PC-relative 32-bit reference to the symbols virtual address.
+
+//
+// x64 processor relocation types.
+//
+#define IMAGE_REL_AMD64_ABSOLUTE  0x0000
+#define IMAGE_REL_AMD64_ADDR64    0x0001
+#define IMAGE_REL_AMD64_ADDR32    0x0002
+#define IMAGE_REL_AMD64_ADDR32NB  0x0003
+#define IMAGE_REL_AMD64_REL32     0x0004
+#define IMAGE_REL_AMD64_REL32_1   0x0005
+#define IMAGE_REL_AMD64_REL32_2   0x0006
+#define IMAGE_REL_AMD64_REL32_3   0x0007
+#define IMAGE_REL_AMD64_REL32_4   0x0008
+#define IMAGE_REL_AMD64_REL32_5   0x0009
+#define IMAGE_REL_AMD64_SECTION   0x000A
+#define IMAGE_REL_AMD64_SECREL    0x000B
+#define IMAGE_REL_AMD64_SECREL7   0x000C
+#define IMAGE_REL_AMD64_TOKEN     0x000D
+#define IMAGE_REL_AMD64_SREL32    0x000E
+#define IMAGE_REL_AMD64_PAIR      0x000F
+#define IMAGE_REL_AMD64_SSPAN32   0x0010
+
+///
+/// Based relocation format.
+///
+typedef struct {
+  UINT32  VirtualAddress;
+  UINT32  SizeOfBlock;
+} EFI_IMAGE_BASE_RELOCATION;
+
+///
+/// Size of EFI_IMAGE_BASE_RELOCATION.
+///
+#define EFI_IMAGE_SIZEOF_BASE_RELOCATION  8
+
+//
+// Based relocation types.
+//
+#define EFI_IMAGE_REL_BASED_ABSOLUTE        0
+#define EFI_IMAGE_REL_BASED_HIGH            1
+#define EFI_IMAGE_REL_BASED_LOW             2
+#define EFI_IMAGE_REL_BASED_HIGHLOW         3
+#define EFI_IMAGE_REL_BASED_HIGHADJ         4
+#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR    5
+#define EFI_IMAGE_REL_BASED_ARM_MOV32A      5
+#define EFI_IMAGE_REL_BASED_ARM_MOV32T      7
+#define EFI_IMAGE_REL_BASED_IA64_IMM64      9
+#define EFI_IMAGE_REL_BASED_MIPS_JMPADDR16  9
+#define EFI_IMAGE_REL_BASED_DIR64           10
+
+///
+/// Relocation types of RISC-V processor.
+///
+#define EFI_IMAGE_REL_BASED_RISCV_HI20      5
+#define EFI_IMAGE_REL_BASED_RISCV_LOW12I    7
+#define EFI_IMAGE_REL_BASED_RISCV_LOW12S    8
+
+///
+/// Line number format.
+///
+typedef struct {
+  union {
+    UINT32  SymbolTableIndex; ///< Symbol table index of function name if Linenumber is 0.
+    UINT32  VirtualAddress;   ///< Virtual address of line number.
+  } Type;
+  UINT16  Linenumber;         ///< Line number.
+} EFI_IMAGE_LINENUMBER;
+
+///
+/// Size of EFI_IMAGE_LINENUMBER.
+///
+#define EFI_IMAGE_SIZEOF_LINENUMBER 6
+
+//
+// Archive format.
+//
+#define EFI_IMAGE_ARCHIVE_START_SIZE        8
+#define EFI_IMAGE_ARCHIVE_START             "!<arch>\n"
+#define EFI_IMAGE_ARCHIVE_END               "`\n"
+#define EFI_IMAGE_ARCHIVE_PAD               "\n"
+#define EFI_IMAGE_ARCHIVE_LINKER_MEMBER     "/               "
+#define EFI_IMAGE_ARCHIVE_LONGNAMES_MEMBER  "//              "
+
+///
+/// Archive Member Headers
+///
+typedef struct {
+  UINT8 Name[16];     ///< File member name - `/' terminated.
+  UINT8 Date[12];     ///< File member date - decimal.
+  UINT8 UserID[6];    ///< File member user id - decimal.
+  UINT8 GroupID[6];   ///< File member group id - decimal.
+  UINT8 Mode[8];      ///< File member mode - octal.
+  UINT8 Size[10];     ///< File member size - decimal.
+  UINT8 EndHeader[2]; ///< String to end header. (0x60 0x0A).
+} EFI_IMAGE_ARCHIVE_MEMBER_HEADER;
+
+///
+/// Size of EFI_IMAGE_ARCHIVE_MEMBER_HEADER.
+///
+#define EFI_IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR 60
+
+
+//
+// DLL Support
+//
+
+///
+/// Export Directory Table.
+///
+typedef struct {
+  UINT32  Characteristics;
+  UINT32  TimeDateStamp;
+  UINT16  MajorVersion;
+  UINT16  MinorVersion;
+  UINT32  Name;
+  UINT32  Base;
+  UINT32  NumberOfFunctions;
+  UINT32  NumberOfNames;
+  UINT32  AddressOfFunctions;
+  UINT32  AddressOfNames;
+  UINT32  AddressOfNameOrdinals;
+} EFI_IMAGE_EXPORT_DIRECTORY;
+
+///
+/// Hint/Name Table.
+///
+typedef struct {
+  UINT16  Hint;
+  UINT8   Name[1];
+} EFI_IMAGE_IMPORT_BY_NAME;
+
+///
+/// Import Address Table RVA (Thunk Table).
+///
+typedef struct {
+  union {
+    UINT32                    Function;
+    UINT32                    Ordinal;
+    EFI_IMAGE_IMPORT_BY_NAME  *AddressOfData;
+  } u1;
+} EFI_IMAGE_THUNK_DATA;
+
+#define EFI_IMAGE_ORDINAL_FLAG              BIT31    ///< Flag for PE32.
+#define EFI_IMAGE_SNAP_BY_ORDINAL(Ordinal)  ((Ordinal & EFI_IMAGE_ORDINAL_FLAG) != 0)
+#define EFI_IMAGE_ORDINAL(Ordinal)          (Ordinal & 0xffff)
+
+///
+/// Import Directory Table
+///
+typedef struct {
+  UINT32                Characteristics;
+  UINT32                TimeDateStamp;
+  UINT32                ForwarderChain;
+  UINT32                Name;
+  EFI_IMAGE_THUNK_DATA  *FirstThunk;
+} EFI_IMAGE_IMPORT_DESCRIPTOR;
+
+
+///
+/// Debug Directory Format.
+///
+typedef struct {
+  UINT32  Characteristics;
+  UINT32  TimeDateStamp;
+  UINT16  MajorVersion;
+  UINT16  MinorVersion;
+  UINT32  Type;
+  UINT32  SizeOfData;
+  UINT32  RVA;           ///< The address of the debug data when loaded, relative to the image base.
+  UINT32  FileOffset;    ///< The file pointer to the debug data.
+} EFI_IMAGE_DEBUG_DIRECTORY_ENTRY;
+
+#define EFI_IMAGE_DEBUG_TYPE_CODEVIEW 2     ///< The Visual C++ debug information.
+
+///
+/// Debug Data Structure defined in Microsoft C++.
+///
+#define CODEVIEW_SIGNATURE_NB10  SIGNATURE_32('N', 'B', '1', '0')
+typedef struct {
+  UINT32  Signature;                        ///< "NB10"
+  UINT32  Unknown;
+  UINT32  Unknown2;
+  UINT32  Unknown3;
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_NB10_ENTRY;
+
+///
+/// Debug Data Structure defined in Microsoft C++.
+///
+#define CODEVIEW_SIGNATURE_RSDS  SIGNATURE_32('R', 'S', 'D', 'S')
+typedef struct {
+  UINT32  Signature;                        ///< "RSDS".
+  UINT32  Unknown;
+  UINT32  Unknown2;
+  UINT32  Unknown3;
+  UINT32  Unknown4;
+  UINT32  Unknown5;
+  //
+  // Filename of .PDB goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_RSDS_ENTRY;
+
+
+///
+/// Debug Data Structure defined by Apple Mach-O to Coff utility.
+///
+#define CODEVIEW_SIGNATURE_MTOC  SIGNATURE_32('M', 'T', 'O', 'C')
+typedef struct {
+  UINT32    Signature;                       ///< "MTOC".
+  GUID      MachOUuid;
+  //
+  //  Filename of .DLL (Mach-O with debug info) goes here
+  //
+} EFI_IMAGE_DEBUG_CODEVIEW_MTOC_ENTRY;
+
+///
+/// Resource format.
+///
+typedef struct {
+  UINT32  Characteristics;
+  UINT32  TimeDateStamp;
+  UINT16  MajorVersion;
+  UINT16  MinorVersion;
+  UINT16  NumberOfNamedEntries;
+  UINT16  NumberOfIdEntries;
+  //
+  // Array of EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY entries goes here.
+  //
+} EFI_IMAGE_RESOURCE_DIRECTORY;
+
+///
+/// Resource directory entry format.
+///
+typedef struct {
+  union {
+    struct {
+      UINT32  NameOffset:31;
+      UINT32  NameIsString:1;
+    } s;
+    UINT32  Id;
+  } u1;
+  union {
+    UINT32  OffsetToData;
+    struct {
+      UINT32  OffsetToDirectory:31;
+      UINT32  DataIsDirectory:1;
+    } s;
+  } u2;
+} EFI_IMAGE_RESOURCE_DIRECTORY_ENTRY;
+
+///
+/// Resource directory entry for string.
+///
+typedef struct {
+  UINT16  Length;
+  CHAR16  String[1];
+} EFI_IMAGE_RESOURCE_DIRECTORY_STRING;
+
+///
+/// Resource directory entry for data array.
+///
+typedef struct {
+  UINT32  OffsetToData;
+  UINT32  Size;
+  UINT32  CodePage;
+  UINT32  Reserved;
+} EFI_IMAGE_RESOURCE_DATA_ENTRY;
+
+///
+/// Header format for TE images, defined in the PI Specification, 1.0.
+///
+typedef struct {
+  UINT16                    Signature;            ///< The signature for TE format = "VZ".
+  UINT16                    Machine;              ///< From the original file header.
+  UINT8                     NumberOfSections;     ///< From the original file header.
+  UINT8                     Subsystem;            ///< From original optional header.
+  UINT16                    StrippedSize;         ///< Number of bytes we removed from the header.
+  UINT32                    AddressOfEntryPoint;  ///< Offset to entry point -- from original optional header.
+  UINT32                    BaseOfCode;           ///< From original image -- required for ITP debug.
+  UINT64                    ImageBase;            ///< From original file header.
+  EFI_IMAGE_DATA_DIRECTORY  DataDirectory[2];     ///< Only base relocation and debug directory.
+} EFI_TE_IMAGE_HEADER;
+
+
+#define EFI_TE_IMAGE_HEADER_SIGNATURE  SIGNATURE_16('V', 'Z')
+
+//
+// Data directory indexes in our TE image header
+//
+#define EFI_TE_IMAGE_DIRECTORY_ENTRY_BASERELOC  0
+#define EFI_TE_IMAGE_DIRECTORY_ENTRY_DEBUG      1
+
+
+///
+/// Union of PE32, PE32+, and TE headers.
+///
+typedef union {
+  EFI_IMAGE_NT_HEADERS32   Pe32;
+  EFI_IMAGE_NT_HEADERS64   Pe32Plus;
+  EFI_TE_IMAGE_HEADER      Te;
+} EFI_IMAGE_OPTIONAL_HEADER_UNION;
+
+typedef union {
+  EFI_IMAGE_NT_HEADERS32            *Pe32;
+  EFI_IMAGE_NT_HEADERS64            *Pe32Plus;
+  EFI_TE_IMAGE_HEADER               *Te;
+  EFI_IMAGE_OPTIONAL_HEADER_UNION   *Union;
+} EFI_IMAGE_OPTIONAL_HEADER_PTR_UNION;
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Scsi.h b/libedk2_tpm/include/IndustryStandard/Scsi.h
new file mode 100644
index 0000000..f49c55b
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Scsi.h
@@ -0,0 +1,426 @@
+/** @file
+  Support for SCSI-2 standard
+
+  Copyright (c) 2006 - 2020, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __SCSI_H__
+#define __SCSI_H__
+
+//
+// SCSI command OP Code
+//
+//
+// Commands for all device types
+//
+#define EFI_SCSI_OP_CHANGE_DEFINITION 0x40
+#define EFI_SCSI_OP_COMPARE           0x39
+#define EFI_SCSI_OP_COPY              0x18
+#define EFI_SCSI_OP_COPY_VERIFY       0x3a
+#define EFI_SCSI_OP_INQUIRY           0x12
+#define EFI_SCSI_OP_LOG_SELECT        0x4c
+#define EFI_SCSI_OP_LOG_SENSE         0x4d
+#define EFI_SCSI_OP_MODE_SEL6         0x15
+#define EFI_SCSI_OP_MODE_SEL10        0x55
+#define EFI_SCSI_OP_MODE_SEN6         0x1a
+#define EFI_SCSI_OP_MODE_SEN10        0x5a
+#define EFI_SCSI_OP_READ_BUFFER       0x3c
+#define EFI_SCSI_OP_RECEIVE_DIAG      0x1c
+#define EFI_SCSI_OP_REQUEST_SENSE     0x03
+#define EFI_SCSI_OP_SEND_DIAG         0x1d
+#define EFI_SCSI_OP_TEST_UNIT_READY   0x00
+#define EFI_SCSI_OP_WRITE_BUFF        0x3b
+
+//
+// Additional commands for Direct Access Devices
+//
+#define EFI_SCSI_OP_FORMAT          0x04
+#define EFI_SCSI_OP_LOCK_UN_CACHE   0x36
+#define EFI_SCSI_OP_PREFETCH        0x34
+#define EFI_SCSI_OP_MEDIA_REMOVAL   0x1e
+#define EFI_SCSI_OP_READ6           0x08
+#define EFI_SCSI_OP_READ10          0x28
+#define EFI_SCSI_OP_READ16          0x88
+#define EFI_SCSI_OP_READ_CAPACITY   0x25
+#define EFI_SCSI_OP_READ_CAPACITY16 0x9e
+#define EFI_SCSI_OP_READ_DEFECT     0x37
+#define EFI_SCSI_OP_READ_LONG       0x3e
+#define EFI_SCSI_OP_REASSIGN_BLK    0x07
+#define EFI_SCSI_OP_RELEASE         0x17
+#define EFI_SCSI_OP_REZERO          0x01
+#define EFI_SCSI_OP_SEARCH_DATA_E   0x31
+#define EFI_SCSI_OP_SEARCH_DATA_H   0x30
+#define EFI_SCSI_OP_SEARCH_DATA_L   0x32
+#define EFI_SCSI_OP_SEEK6           0x0b
+#define EFI_SCSI_OP_SEEK10          0x2b
+#define EFI_SCSI_OP_SEND_DIAG       0x1d
+#define EFI_SCSI_OP_SET_LIMIT       0x33
+#define EFI_SCSI_OP_START_STOP_UNIT 0x1b
+#define EFI_SCSI_OP_SYNC_CACHE      0x35
+#define EFI_SCSI_OP_VERIFY          0x2f
+#define EFI_SCSI_OP_WRITE6          0x0a
+#define EFI_SCSI_OP_WRITE10         0x2a
+#define EFI_SCSI_OP_WRITE16         0x8a
+#define EFI_SCSI_OP_WRITE_VERIFY    0x2e
+#define EFI_SCSI_OP_WRITE_LONG      0x3f
+#define EFI_SCSI_OP_WRITE_SAME      0x41
+#define EFI_SCSI_OP_UNMAP           0x42
+
+//
+// Additional commands for Sequential Access Devices
+//
+#define EFI_SCSI_OP_ERASE             0x19
+#define EFI_SCSI_OP_LOAD_UNLOAD       0x1b
+#define EFI_SCSI_OP_LOCATE            0x2b
+#define EFI_SCSI_OP_READ_BLOCK_LIMIT  0x05
+#define EFI_SCSI_OP_READ_POS          0x34
+#define EFI_SCSI_OP_READ_REVERSE      0x0f
+#define EFI_SCSI_OP_RECOVER_BUF_DATA  0x14
+#define EFI_SCSI_OP_RESERVE_UNIT      0x16
+#define EFI_SCSI_OP_REWIND            0x01
+#define EFI_SCSI_OP_SPACE             0x11
+#define EFI_SCSI_OP_VERIFY_TAPE       0x13
+#define EFI_SCSI_OP_WRITE_FILEMARK    0x10
+
+//
+// Additional commands for Printer Devices
+//
+#define EFI_SCSI_OP_PRINT       0x0a
+#define EFI_SCSI_OP_SLEW_PRINT  0x0b
+#define EFI_SCSI_OP_STOP_PRINT  0x1b
+#define EFI_SCSI_OP_SYNC_BUFF   0x10
+
+//
+// Additional commands for Processor Devices
+//
+#define EFI_SCSI_OP_RECEIVE 0x08
+#define EFI_SCSI_OP_SEND    0x0a
+
+//
+// Additional commands for Write-Once Devices
+//
+#define EFI_SCSI_OP_MEDIUM_SCAN     0x38
+#define EFI_SCSI_OP_SEARCH_DAT_E10  0x31
+#define EFI_SCSI_OP_SEARCH_DAT_E12  0xb1
+#define EFI_SCSI_OP_SEARCH_DAT_H10  0x30
+#define EFI_SCSI_OP_SEARCH_DAT_H12  0xb0
+#define EFI_SCSI_OP_SEARCH_DAT_L10  0x32
+#define EFI_SCSI_OP_SEARCH_DAT_L12  0xb2
+#define EFI_SCSI_OP_SET_LIMIT10     0x33
+#define EFI_SCSI_OP_SET_LIMIT12     0xb3
+#define EFI_SCSI_OP_VERIFY10        0x2f
+#define EFI_SCSI_OP_VERIFY12        0xaf
+#define EFI_SCSI_OP_WRITE12         0xaa
+#define EFI_SCSI_OP_WRITE_VERIFY10  0x2e
+#define EFI_SCSI_OP_WRITE_VERIFY12  0xae
+
+//
+// Additional commands for CD-ROM Devices
+//
+#define EFI_SCSI_OP_PLAY_AUD_10       0x45
+#define EFI_SCSI_OP_PLAY_AUD_12       0xa5
+#define EFI_SCSI_OP_PLAY_AUD_MSF      0x47
+#define EFI_SCSI_OP_PLAY_AUD_TKIN     0x48
+#define EFI_SCSI_OP_PLAY_TK_REL10     0x49
+#define EFI_SCSI_OP_PLAY_TK_REL12     0xa9
+#define EFI_SCSI_OP_READ_CD_CAPACITY  0x25
+#define EFI_SCSI_OP_READ_HEADER       0x44
+#define EFI_SCSI_OP_READ_SUB_CHANNEL  0x42
+#define EFI_SCSI_OP_READ_TOC          0x43
+
+//
+// Additional commands for Scanner Devices
+//
+#define EFI_SCSI_OP_GET_DATABUFF_STAT 0x34
+#define EFI_SCSI_OP_GET_WINDOW        0x25
+#define EFI_SCSI_OP_OBJECT_POS        0x31
+#define EFI_SCSI_OP_SCAN              0x1b
+#define EFI_SCSI_OP_SET_WINDOW        0x24
+
+//
+// Additional commands for Optical Memory Devices
+//
+#define EFI_SCSI_OP_UPDATE_BLOCK  0x3d
+
+//
+// Additional commands for Medium Changer Devices
+//
+#define EFI_SCSI_OP_EXCHANGE_MEDIUM   0xa6
+#define EFI_SCSI_OP_INIT_ELEMENT_STAT 0x07
+#define EFI_SCSI_OP_POS_TO_ELEMENT    0x2b
+#define EFI_SCSI_OP_REQUEST_VE_ADDR   0xb5
+#define EFI_SCSI_OP_SEND_VOL_TAG      0xb6
+
+//
+// Additional commands for Communication Devices
+//
+#define EFI_SCSI_OP_GET_MESSAGE6    0x08
+#define EFI_SCSI_OP_GET_MESSAGE10   0x28
+#define EFI_SCSI_OP_GET_MESSAGE12   0xa8
+#define EFI_SCSI_OP_SEND_MESSAGE6   0x0a
+#define EFI_SCSI_OP_SEND_MESSAGE10  0x2a
+#define EFI_SCSI_OP_SEND_MESSAGE12  0xaa
+
+//
+// Additional commands for Secure Transactions
+//
+#define EFI_SCSI_OP_SECURITY_PROTOCOL_IN  0xa2
+#define EFI_SCSI_OP_SECURITY_PROTOCOL_OUT 0xb5
+
+//
+// SCSI Data Transfer Direction
+//
+#define EFI_SCSI_DATA_IN  0
+#define EFI_SCSI_DATA_OUT 1
+
+//
+// SCSI Block Command Cache Control Parameters
+//
+#define EFI_SCSI_BLOCK_FUA  BIT3  ///< Force Unit Access
+#define EFI_SCSI_BLOCK_DPO  BIT4  ///< Disable Page Out
+
+//
+// Peripheral Device Type Definitions
+//
+#define EFI_SCSI_TYPE_DISK            0x00  ///< Direct-access device (e.g. magnetic disk)
+#define EFI_SCSI_TYPE_TAPE            0x01  ///< Sequential-access device (e.g. magnetic tape)
+#define EFI_SCSI_TYPE_PRINTER         0x02  ///< Printer device
+#define EFI_SCSI_TYPE_PROCESSOR       0x03  ///< Processor device
+#define EFI_SCSI_TYPE_WORM            0x04  ///< Write-once device (e.g. some optical disks)
+#define EFI_SCSI_TYPE_CDROM           0x05  ///< CD/DVD device
+#define EFI_SCSI_TYPE_SCANNER         0x06  ///< Scanner device (obsolete)
+#define EFI_SCSI_TYPE_OPTICAL         0x07  ///< Optical memory device (e.g. some optical disks)
+#define EFI_SCSI_TYPE_MEDIUMCHANGER   0x08  ///< Medium changer device (e.g. jukeboxes)
+#define EFI_SCSI_TYPE_COMMUNICATION   0x09  ///< Communications device (obsolete)
+#define EFI_SCSI_TYPE_ASCIT8_1        0x0A  ///< Defined by ASC IT8 (Graphic arts pre-press devices)
+#define EFI_SCSI_TYPE_ASCIT8_2        0x0B  ///< Defined by ASC IT8 (Graphic arts pre-press devices)
+#define EFI_SCSI_TYPE_RAID            0x0C  ///< Storage array controller device (e.g., RAID)
+#define EFI_SCSI_TYPE_SES             0x0D  ///< Enclosure services device
+#define EFI_SCSI_TYPE_RBC             0x0E  ///< Simplified direct-access device (e.g., magnetic disk)
+#define EFI_SCSI_TYPE_OCRW            0x0F  ///< Optical card reader/writer device
+#define EFI_SCSI_TYPE_BRIDGE          0x10  ///< Bridge Controller Commands
+#define EFI_SCSI_TYPE_OSD             0x11  ///< Object-based Storage Device
+#define EFI_SCSI_TYPE_AUTOMATION      0x12  ///< Automation/Drive Interface
+#define EFI_SCSI_TYPE_SECURITYMANAGER 0x13  ///< Security manager device
+#define EFI_SCSI_TYPE_RESERVED_LOW    0x14  ///< Reserved (low)
+#define EFI_SCSI_TYPE_RESERVED_HIGH   0x1D  ///< Reserved (high)
+#define EFI_SCSI_TYPE_WLUN            0x1E  ///< Well known logical unit
+#define EFI_SCSI_TYPE_UNKNOWN         0x1F  ///< Unknown or no device type
+
+//
+// Page Codes for INQUIRY command
+//
+#define EFI_SCSI_PAGE_CODE_SUPPORTED_VPD    0x00
+#define EFI_SCSI_PAGE_CODE_BLOCK_LIMITS_VPD 0xB0
+
+#pragma pack(1)
+///
+/// Standard INQUIRY data format
+///
+typedef struct {
+  UINT8 Peripheral_Type : 5;
+  UINT8 Peripheral_Qualifier : 3;
+  UINT8 DeviceType_Modifier : 7;
+  UINT8 Rmb : 1;
+  UINT8 Version;
+  UINT8 Response_Data_Format;
+  UINT8 Addnl_Length;
+  UINT8 Reserved_5_95[95 - 5 + 1];
+} EFI_SCSI_INQUIRY_DATA;
+
+///
+/// Supported VPD Pages VPD page
+///
+typedef struct {
+  UINT8 Peripheral_Type : 5;
+  UINT8 Peripheral_Qualifier : 3;
+  UINT8 PageCode;
+  UINT8 PageLength2;
+  UINT8 PageLength1;
+  UINT8 SupportedVpdPageList[0x100];
+} EFI_SCSI_SUPPORTED_VPD_PAGES_VPD_PAGE;
+
+///
+/// Block Limits VPD page
+///
+typedef struct {
+  UINT8 Peripheral_Type : 5;
+  UINT8 Peripheral_Qualifier : 3;
+  UINT8 PageCode;
+  UINT8 PageLength2;
+  UINT8 PageLength1;
+  UINT8 WriteSameNonZero : 1;
+  UINT8 Reserved_4 : 7;
+  UINT8 MaximumCompareAndWriteLength;
+  UINT8 OptimalTransferLengthGranularity2;
+  UINT8 OptimalTransferLengthGranularity1;
+  UINT8 MaximumTransferLength4;
+  UINT8 MaximumTransferLength3;
+  UINT8 MaximumTransferLength2;
+  UINT8 MaximumTransferLength1;
+  UINT8 OptimalTransferLength4;
+  UINT8 OptimalTransferLength3;
+  UINT8 OptimalTransferLength2;
+  UINT8 OptimalTransferLength1;
+  UINT8 MaximumPrefetchXdreadXdwriteTransferLength4;
+  UINT8 MaximumPrefetchXdreadXdwriteTransferLength3;
+  UINT8 MaximumPrefetchXdreadXdwriteTransferLength2;
+  UINT8 MaximumPrefetchXdreadXdwriteTransferLength1;
+  UINT8 MaximumUnmapLbaCount4;
+  UINT8 MaximumUnmapLbaCount3;
+  UINT8 MaximumUnmapLbaCount2;
+  UINT8 MaximumUnmapLbaCount1;
+  UINT8 MaximumUnmapBlockDescriptorCount4;
+  UINT8 MaximumUnmapBlockDescriptorCount3;
+  UINT8 MaximumUnmapBlockDescriptorCount2;
+  UINT8 MaximumUnmapBlockDescriptorCount1;
+  UINT8 OptimalUnmapGranularity4;
+  UINT8 OptimalUnmapGranularity3;
+  UINT8 OptimalUnmapGranularity2;
+  UINT8 OptimalUnmapGranularity1;
+  UINT8 UnmapGranularityAlignment4 : 7;
+  UINT8 UnmapGranularityAlignmentValid : 1;
+  UINT8 UnmapGranularityAlignment3;
+  UINT8 UnmapGranularityAlignment2;
+  UINT8 UnmapGranularityAlignment1;
+  UINT8 MaximumWriteSameLength4;
+  UINT8 MaximumWriteSameLength3;
+  UINT8 MaximumWriteSameLength2;
+  UINT8 MaximumWriteSameLength1;
+  UINT8 MaximumAtomicTransferLength4;
+  UINT8 MaximumAtomicTransferLength3;
+  UINT8 MaximumAtomicTransferLength2;
+  UINT8 MaximumAtomicTransferLength1;
+  UINT8 AtomicAlignment4;
+  UINT8 AtomicAlignment3;
+  UINT8 AtomicAlignment2;
+  UINT8 AtomicAlignment1;
+  UINT8 AtomicTransferLengthGranularity4;
+  UINT8 AtomicTransferLengthGranularity3;
+  UINT8 AtomicTransferLengthGranularity2;
+  UINT8 AtomicTransferLengthGranularity1;
+  UINT8 MaximumAtomicTransferLengthWithAtomicBoundary4;
+  UINT8 MaximumAtomicTransferLengthWithAtomicBoundary3;
+  UINT8 MaximumAtomicTransferLengthWithAtomicBoundary2;
+  UINT8 MaximumAtomicTransferLengthWithAtomicBoundary1;
+  UINT8 MaximumAtomicBoundarySize4;
+  UINT8 MaximumAtomicBoundarySize3;
+  UINT8 MaximumAtomicBoundarySize2;
+  UINT8 MaximumAtomicBoundarySize1;
+} EFI_SCSI_BLOCK_LIMITS_VPD_PAGE;
+
+///
+/// Error codes 70h and 71h sense data format
+///
+typedef struct {
+  UINT8 Error_Code : 7;
+  UINT8 Valid : 1;
+  UINT8 Segment_Number;
+  UINT8 Sense_Key : 4;
+  UINT8 Reserved_21 : 1;
+  UINT8 Ili : 1;
+  UINT8 Reserved_22 : 2;
+  UINT8 Information_3_6[4];
+  UINT8 Addnl_Sense_Length;           ///< Additional sense length (n-7)
+  UINT8 Vendor_Specific_8_11[4];
+  UINT8 Addnl_Sense_Code;             ///< Additional sense code
+  UINT8 Addnl_Sense_Code_Qualifier;   ///< Additional sense code qualifier
+  UINT8 Field_Replaceable_Unit_Code;  ///< Field replaceable unit code
+  UINT8 Reserved_15_17[3];
+} EFI_SCSI_SENSE_DATA;
+
+///
+/// SCSI Disk READ CAPACITY Data
+///
+typedef struct {
+  UINT8 LastLba3;
+  UINT8 LastLba2;
+  UINT8 LastLba1;
+  UINT8 LastLba0;
+  UINT8 BlockSize3;
+  UINT8 BlockSize2;
+  UINT8 BlockSize1;
+  UINT8 BlockSize0;
+} EFI_SCSI_DISK_CAPACITY_DATA;
+
+typedef struct {
+  UINT8 LastLba7;
+  UINT8 LastLba6;
+  UINT8 LastLba5;
+  UINT8 LastLba4;
+  UINT8 LastLba3;
+  UINT8 LastLba2;
+  UINT8 LastLba1;
+  UINT8 LastLba0;
+  UINT8 BlockSize3;
+  UINT8 BlockSize2;
+  UINT8 BlockSize1;
+  UINT8 BlockSize0;
+  UINT8 Protection;
+  UINT8 LogicPerPhysical;
+  UINT8 LowestAlignLogic2;
+  UINT8 LowestAlignLogic1;
+  UINT8 Reserved[16];
+} EFI_SCSI_DISK_CAPACITY_DATA16;
+
+typedef struct {
+  UINT16 DataLen;
+  UINT16 BlkDespDataLen;
+  UINT8  Reserved[4];
+} EFI_SCSI_DISK_UNMAP_PARAM_LIST_HEADER;
+
+typedef struct {
+  UINT64 Lba;
+  UINT32 BlockNum;
+  UINT8  Reserved[4];
+} EFI_SCSI_DISK_UNMAP_BLOCK_DESP;
+
+
+#pragma pack()
+
+//
+// Sense Key
+//
+#define EFI_SCSI_SK_NO_SENSE          (0x0)
+#define EFI_SCSI_SK_RECOVERY_ERROR    (0x1)
+#define EFI_SCSI_SK_NOT_READY         (0x2)
+#define EFI_SCSI_SK_MEDIUM_ERROR      (0x3)
+#define EFI_SCSI_SK_HARDWARE_ERROR    (0x4)
+#define EFI_SCSI_SK_ILLEGAL_REQUEST   (0x5)
+#define EFI_SCSI_SK_UNIT_ATTENTION    (0x6)
+#define EFI_SCSI_SK_DATA_PROTECT      (0x7)
+#define EFI_SCSI_SK_BLANK_CHECK       (0x8)
+#define EFI_SCSI_SK_VENDOR_SPECIFIC   (0x9)
+#define EFI_SCSI_SK_RESERVED_A        (0xA)
+#define EFI_SCSI_SK_ABORT             (0xB)
+#define EFI_SCSI_SK_RESERVED_C        (0xC)
+#define EFI_SCSI_SK_OVERFLOW          (0xD)
+#define EFI_SCSI_SK_MISCOMPARE        (0xE)
+#define EFI_SCSI_SK_RESERVED_F        (0xF)
+
+//
+// Additional Sense Codes and Sense Code Qualifiers.
+// Only some frequently used additional sense codes and qualifiers are
+// defined here. Please refer to SCSI standard for full value definition.
+//
+#define EFI_SCSI_ASC_NOT_READY                    (0x04)
+#define EFI_SCSI_ASCQ_IN_PROGRESS                 (0x01)
+
+#define EFI_SCSI_ASC_MEDIA_ERR1                   (0x10)
+#define EFI_SCSI_ASC_MEDIA_ERR2                   (0x11)
+#define EFI_SCSI_ASC_MEDIA_ERR3                   (0x14)
+#define EFI_SCSI_ASC_MEDIA_ERR4                   (0x30)
+#define EFI_SCSI_ASC_MEDIA_UPSIDE_DOWN            (0x06)
+#define EFI_SCSI_ASC_INVALID_CMD                  (0x20)
+#define EFI_SCSI_ASC_LBA_OUT_OF_RANGE             (0x21)
+#define EFI_SCSI_ASC_INVALID_FIELD                (0x24)
+#define EFI_SCSI_ASC_WRITE_PROTECTED              (0x27)
+#define EFI_SCSI_ASC_MEDIA_CHANGE                 (0x28)
+#define EFI_SCSI_ASC_RESET                        (0x29)   ///< Power On Reset or Bus Reset occurred
+#define EFI_SCSI_ASC_ILLEGAL_FIELD                (0x26)
+#define EFI_SCSI_ASC_NO_MEDIA                     (0x3A)
+#define EFI_SCSI_ASC_ILLEGAL_MODE_FOR_THIS_TRACK  (0x64)
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Sd.h b/libedk2_tpm/include/IndustryStandard/Sd.h
new file mode 100644
index 0000000..415aaf8
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Sd.h
@@ -0,0 +1,175 @@
+/** @file
+  Header file for SD memory card support.
+
+  This header file contains some definitions defined in SD Physical Layer Simplified
+  Specification Version 4.10 spec.
+
+  Copyright (c) 2015, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __SD_H__
+#define __SD_H__
+
+//
+// SD command index
+//
+#define  SD_GO_IDLE_STATE           0
+#define  SD_ALL_SEND_CID            2
+#define  SD_SET_RELATIVE_ADDR       3
+#define  SD_SET_DSR                 4
+#define  SDIO_SEND_OP_COND          5
+#define  SD_SWITCH_FUNC             6
+#define  SD_SELECT_DESELECT_CARD    7
+#define  SD_SEND_IF_COND            8
+#define  SD_SEND_CSD                9
+#define  SD_SEND_CID                10
+#define  SD_VOLTAGE_SWITCH          11
+#define  SD_STOP_TRANSMISSION       12
+#define  SD_SEND_STATUS             13
+#define  SD_GO_INACTIVE_STATE       15
+#define  SD_SET_BLOCKLEN            16
+#define  SD_READ_SINGLE_BLOCK       17
+#define  SD_READ_MULTIPLE_BLOCK     18
+#define  SD_SEND_TUNING_BLOCK       19
+#define  SD_SPEED_CLASS_CONTROL     20
+#define  SD_SET_BLOCK_COUNT         23
+#define  SD_WRITE_SINGLE_BLOCK      24
+#define  SD_WRITE_MULTIPLE_BLOCK    25
+#define  SD_PROGRAM_CSD             27
+#define  SD_SET_WRITE_PROT          28
+#define  SD_CLR_WRITE_PROT          29
+#define  SD_SEND_WRITE_PROT         30
+#define  SD_ERASE_WR_BLK_START      32
+#define  SD_ERASE_WR_BLK_END        33
+#define  SD_ERASE                   38
+#define  SD_LOCK_UNLOCK             42
+#define  SD_READ_EXTR_SINGLE        48
+#define  SD_WRITE_EXTR_SINGLE       49
+#define  SDIO_RW_DIRECT             52
+#define  SDIO_RW_EXTENDED           53
+#define  SD_APP_CMD                 55
+#define  SD_GEN_CMD                 56
+#define  SD_READ_EXTR_MULTI         58
+#define  SD_WRITE_EXTR_MULTI        59
+
+#define  SD_SET_BUS_WIDTH           6           // ACMD6
+#define  SD_STATUS                  13          // ACMD13
+#define  SD_SEND_NUM_WR_BLOCKS      22          // ACMD22
+#define  SD_SET_WR_BLK_ERASE_COUNT  23          // ACMD23
+#define  SD_SEND_OP_COND            41          // ACMD41
+#define  SD_SET_CLR_CARD_DETECT     42          // ACMD42
+#define  SD_SEND_SCR                51          // ACMD51
+
+#pragma pack(1)
+typedef struct {
+  UINT8   NotUsed:1;                            // Not used [0:0]
+  UINT8   Crc:7;                                // CRC [7:1]
+  UINT16  ManufacturingDate:12;                 // Manufacturing date [19:8]
+  UINT16  Reserved:4;                           // Reserved [23:20]
+  UINT8   ProductSerialNumber[4];               // Product serial number [55:24]
+  UINT8   ProductRevision;                      // Product revision [63:56]
+  UINT8   ProductName[5];                       // Product name [103:64]
+  UINT8   OemId[2];                             // OEM/Application ID [119:104]
+  UINT8   ManufacturerId;                       // Manufacturer ID [127:120]
+} SD_CID;
+
+typedef struct {
+  UINT32  NotUsed:1;                            // Not used [0:0]
+  UINT32  Crc:7;                                // CRC [7:1]
+  UINT32  Reserved:2;                           // Reserved [9:8]
+  UINT32  FileFormat:2;                         // File format [11:10]
+  UINT32  TmpWriteProtect:1;                    // Temporary write protection [12:12]
+  UINT32  PermWriteProtect:1;                   // Permanent write protection [13:13]
+  UINT32  Copy:1;                               // Copy flag (OTP) [14:14]
+  UINT32  FileFormatGrp:1;                      // File format group [15:15]
+  UINT32  Reserved1:5;                          // Reserved [20:16]
+  UINT32  WriteBlPartial:1;                     // Partial blocks for write allowed [21:21]
+  UINT32  WriteBlLen:4;                         // Max. write data block length [25:22]
+  UINT32  R2WFactor:3;                          // Write speed factor [28:26]
+  UINT32  Reserved2:2;                          // Manufacturer default ECC [30:29]
+  UINT32  WpGrpEnable:1;                        // Write protect group enable [31:31]
+
+  UINT32  WpGrpSize:7;                          // Write protect group size [38:32]
+  UINT32  SectorSize:7;                         // Erase sector size [45:39]
+  UINT32  EraseBlkEn:1;                         // Erase single block enable [46:46]
+  UINT32  CSizeMul:3;                           // device size multiplier [49:47]
+  UINT32  VddWCurrMax:3;                        // max. write current @VDD max [52:50]
+  UINT32  VddWCurrMin:3;                        // max. write current @VDD min [55:53]
+  UINT32  VddRCurrMax:3;                        // max. read current @VDD max [58:56]
+  UINT32  VddRCurrMin:3;                        // max. read current @VDD min [61:59]
+  UINT32  CSizeLow:2;                           // Device size low 2 bits [63:62]
+
+  UINT32  CSizeHigh:10;                         // Device size high 10 bits [73:64]
+  UINT32  Reserved4:2;                          // Reserved [75:74]
+  UINT32  DsrImp:1;                             // DSR implemented [76:76]
+  UINT32  ReadBlkMisalign:1;                    // Read block misalignment [77:77]
+  UINT32  WriteBlkMisalign:1;                   // Write block misalignment [78:78]
+  UINT32  ReadBlPartial:1;                      // Partial blocks for read allowed [79:79]
+  UINT32  ReadBlLen:4;                          // Max. read data block length [83:80]
+  UINT32  Ccc:12;                               // Card command classes [95:84]
+
+  UINT32  TranSpeed:8;                          // Max. data transfer rate [103:96]
+  UINT32  Nsac:8;                               // Data read access-time in CLK cycles (NSAC*100) [111:104]
+  UINT32  Taac:8;                               // Data read access-time [119:112]
+  UINT32  Reserved5:6;                          // Reserved [125:120]
+  UINT32  CsdStructure:2;                       // CSD structure [127:126]
+} SD_CSD;
+
+typedef struct {
+  UINT32  NotUsed:1;                            // Not used [0:0]
+  UINT32  Crc:7;                                // CRC [7:1]
+  UINT32  Reserved:2;                           // Reserved [9:8]
+  UINT32  FileFormat:2;                         // File format [11:10]
+  UINT32  TmpWriteProtect:1;                    // Temporary write protection [12:12]
+  UINT32  PermWriteProtect:1;                   // Permanent write protection [13:13]
+  UINT32  Copy:1;                               // Copy flag (OTP) [14:14]
+  UINT32  FileFormatGrp:1;                      // File format group [15:15]
+  UINT32  Reserved1:5;                          // Reserved [20:16]
+  UINT32  WriteBlPartial:1;                     // Partial blocks for write allowed [21:21]
+  UINT32  WriteBlLen:4;                         // Max. write data block length [25:22]
+  UINT32  R2WFactor:3;                          // Write speed factor [28:26]
+  UINT32  Reserved2:2;                          // Manufacturer default ECC [30:29]
+  UINT32  WpGrpEnable:1;                        // Write protect group enable [31:31]
+
+  UINT32  WpGrpSize:7;                          // Write protect group size [38:32]
+  UINT32  SectorSize:7;                         // Erase sector size [45:39]
+  UINT32  EraseBlkEn:1;                         // Erase single block enable [46:46]
+  UINT32  Reserved3:1;                          // Reserved [47:47]
+  UINT32  CSizeLow:16;                          // Device size low 16 bits [63:48]
+
+  UINT32  CSizeHigh:6;                          // Device size high 6 bits [69:64]
+  UINT32  Reserved4:6;                          // Reserved [75:70]
+  UINT32  DsrImp:1;                             // DSR implemented [76:76]
+  UINT32  ReadBlkMisalign:1;                    // Read block misalignment [77:77]
+  UINT32  WriteBlkMisalign:1;                   // Write block misalignment [78:78]
+  UINT32  ReadBlPartial:1;                      // Partial blocks for read allowed [79:79]
+  UINT32  ReadBlLen:4;                          // Max. read data block length [83:80]
+  UINT32  Ccc:12;                               // Card command classes [95:84]
+
+  UINT32  TranSpeed:8;                          // Max. data transfer rate [103:96]
+  UINT32  Nsac:8;                               // Data read access-time in CLK cycles (NSAC*100) [111:104]
+  UINT32  Taac:8;                               // Data read access-time [119:112]
+  UINT32  Reserved5:6;                          // Reserved [125:120]
+  UINT32  CsdStructure:2;                       // CSD structure [127:126]
+} SD_CSD2;
+
+typedef struct {
+  UINT32  Reserved;                             // Reserved [31:0]
+
+  UINT32  CmdSupport:4;                         // Command Support bits [35:32]
+  UINT32  Reserved1:6;                          // Reserved [41:36]
+  UINT32  SdSpec4:1;                            // Spec. Version 4.00 or higher [42:42]
+  UINT32  ExSecurity:4;                         // Extended Security Support [46:43]
+  UINT32  SdSpec3:1;                            // Spec. Version 3.00 or higher [47:47]
+  UINT32  SdBusWidths:4;                        // DAT Bus widths supported [51:48]
+  UINT32  SdSecurity:3;                         // CPRM security support [54:52]
+  UINT32  DataStatAfterErase:1;                 // Data status after erases [55]
+  UINT32  SdSpec:4;                             // SD Memory Card Spec. Version [59:56]
+  UINT32  ScrStructure:4;                       // SCR Structure [63:60]
+} SD_SCR;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/SmBios.h b/libedk2_tpm/include/IndustryStandard/SmBios.h
new file mode 100644
index 0000000..486e984
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/SmBios.h
@@ -0,0 +1,2724 @@
+/** @file
+  Industry Standard Definitions of SMBIOS Table Specification v3.3.0.
+
+Copyright (c) 2006 - 2021, Intel Corporation. All rights reserved.<BR>
+(C) Copyright 2015-2017 Hewlett Packard Enterprise Development LP<BR>
+(C) Copyright 2015 - 2019 Hewlett Packard Enterprise Development LP<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __SMBIOS_STANDARD_H__
+#define __SMBIOS_STANDARD_H__
+
+///
+/// Reference SMBIOS 2.6, chapter 3.1.2.
+/// For v2.1 and later, handle values in the range 0FF00h to 0FFFFh are reserved for
+/// use by this specification.
+///
+#define SMBIOS_HANDLE_RESERVED_BEGIN 0xFF00
+
+///
+/// Reference SMBIOS 2.7, chapter 6.1.2.
+/// The UEFI Platform Initialization Specification reserves handle number FFFEh for its
+/// EFI_SMBIOS_PROTOCOL.Add() function to mean "assign an unused handle number automatically."
+/// This number is not used for any other purpose by the SMBIOS specification.
+///
+#define SMBIOS_HANDLE_PI_RESERVED 0xFFFE
+
+///
+/// Reference SMBIOS 2.6, chapter 3.1.3.
+/// Each text string is limited to 64 significant characters due to system MIF limitations.
+/// Reference SMBIOS 2.7, chapter 6.1.3.
+/// It will have no limit on the length of each individual text string.
+///
+#define SMBIOS_STRING_MAX_LENGTH     64
+
+//
+// The length of the entire structure table (including all strings) must be reported
+// in the Structure Table Length field of the SMBIOS Structure Table Entry Point,
+// which is a WORD field limited to 65,535 bytes.
+//
+#define SMBIOS_TABLE_MAX_LENGTH 0xFFFF
+
+//
+// For SMBIOS 3.0, Structure table maximum size in Entry Point structure is DWORD field limited to 0xFFFFFFFF bytes.
+//
+#define SMBIOS_3_0_TABLE_MAX_LENGTH 0xFFFFFFFF
+
+//
+// SMBIOS type macros which is according to SMBIOS 3.3.0 specification.
+//
+#define SMBIOS_TYPE_BIOS_INFORMATION                     0
+#define SMBIOS_TYPE_SYSTEM_INFORMATION                   1
+#define SMBIOS_TYPE_BASEBOARD_INFORMATION                2
+#define SMBIOS_TYPE_SYSTEM_ENCLOSURE                     3
+#define SMBIOS_TYPE_PROCESSOR_INFORMATION                4
+#define SMBIOS_TYPE_MEMORY_CONTROLLER_INFORMATION        5
+#define SMBIOS_TYPE_MEMORY_MODULE_INFORMATON             6
+#define SMBIOS_TYPE_CACHE_INFORMATION                    7
+#define SMBIOS_TYPE_PORT_CONNECTOR_INFORMATION           8
+#define SMBIOS_TYPE_SYSTEM_SLOTS                         9
+#define SMBIOS_TYPE_ONBOARD_DEVICE_INFORMATION           10
+#define SMBIOS_TYPE_OEM_STRINGS                          11
+#define SMBIOS_TYPE_SYSTEM_CONFIGURATION_OPTIONS         12
+#define SMBIOS_TYPE_BIOS_LANGUAGE_INFORMATION            13
+#define SMBIOS_TYPE_GROUP_ASSOCIATIONS                   14
+#define SMBIOS_TYPE_SYSTEM_EVENT_LOG                     15
+#define SMBIOS_TYPE_PHYSICAL_MEMORY_ARRAY                16
+#define SMBIOS_TYPE_MEMORY_DEVICE                        17
+#define SMBIOS_TYPE_32BIT_MEMORY_ERROR_INFORMATION       18
+#define SMBIOS_TYPE_MEMORY_ARRAY_MAPPED_ADDRESS          19
+#define SMBIOS_TYPE_MEMORY_DEVICE_MAPPED_ADDRESS         20
+#define SMBIOS_TYPE_BUILT_IN_POINTING_DEVICE             21
+#define SMBIOS_TYPE_PORTABLE_BATTERY                     22
+#define SMBIOS_TYPE_SYSTEM_RESET                         23
+#define SMBIOS_TYPE_HARDWARE_SECURITY                    24
+#define SMBIOS_TYPE_SYSTEM_POWER_CONTROLS                25
+#define SMBIOS_TYPE_VOLTAGE_PROBE                        26
+#define SMBIOS_TYPE_COOLING_DEVICE                       27
+#define SMBIOS_TYPE_TEMPERATURE_PROBE                    28
+#define SMBIOS_TYPE_ELECTRICAL_CURRENT_PROBE             29
+#define SMBIOS_TYPE_OUT_OF_BAND_REMOTE_ACCESS            30
+#define SMBIOS_TYPE_BOOT_INTEGRITY_SERVICE               31
+#define SMBIOS_TYPE_SYSTEM_BOOT_INFORMATION              32
+#define SMBIOS_TYPE_64BIT_MEMORY_ERROR_INFORMATION       33
+#define SMBIOS_TYPE_MANAGEMENT_DEVICE                    34
+#define SMBIOS_TYPE_MANAGEMENT_DEVICE_COMPONENT          35
+#define SMBIOS_TYPE_MANAGEMENT_DEVICE_THRESHOLD_DATA     36
+#define SMBIOS_TYPE_MEMORY_CHANNEL                       37
+#define SMBIOS_TYPE_IPMI_DEVICE_INFORMATION              38
+#define SMBIOS_TYPE_SYSTEM_POWER_SUPPLY                  39
+#define SMBIOS_TYPE_ADDITIONAL_INFORMATION               40
+#define SMBIOS_TYPE_ONBOARD_DEVICES_EXTENDED_INFORMATION 41
+#define SMBIOS_TYPE_MANAGEMENT_CONTROLLER_HOST_INTERFACE 42
+#define SMBIOS_TYPE_TPM_DEVICE                           43
+#define SMBIOS_TYPE_PROCESSOR_ADDITIONAL_INFORMATION     44
+
+///
+/// Inactive type is added from SMBIOS 2.2. Reference SMBIOS 2.6, chapter 3.3.43.
+/// Upper-level software that interprets the SMBIOS structure-table should bypass an
+/// Inactive structure just like a structure type that the software does not recognize.
+///
+#define SMBIOS_TYPE_INACTIVE         0x007E
+
+///
+/// End-of-table type is added from SMBIOS 2.2. Reference SMBIOS 2.6, chapter 3.3.44.
+/// The end-of-table indicator is used in the last physical structure in a table
+///
+#define SMBIOS_TYPE_END_OF_TABLE     0x007F
+
+#define SMBIOS_OEM_BEGIN             128
+#define SMBIOS_OEM_END               255
+
+///
+/// Types 0 through 127 (7Fh) are reserved for and defined by this
+/// specification. Types 128 through 256 (80h to FFh) are available for system- and OEM-specific information.
+///
+typedef UINT8  SMBIOS_TYPE;
+
+///
+/// Specifies the structure's handle, a unique 16-bit number in the range 0 to 0FFFEh (for version
+/// 2.0) or 0 to 0FEFFh (for version 2.1 and later). The handle can be used with the Get SMBIOS
+/// Structure function to retrieve a specific structure; the handle numbers are not required to be
+/// contiguous. For v2.1 and later, handle values in the range 0FF00h to 0FFFFh are reserved for
+/// use by this specification.
+/// If the system configuration changes, a previously assigned handle might no longer exist.
+/// However once a handle has been assigned by the BIOS, the BIOS cannot re-assign that handle
+/// number to another structure.
+///
+typedef UINT16 SMBIOS_HANDLE;
+
+///
+/// Smbios Table Entry Point Structure.
+///
+#pragma pack(1)
+typedef struct {
+  UINT8   AnchorString[4];
+  UINT8   EntryPointStructureChecksum;
+  UINT8   EntryPointLength;
+  UINT8   MajorVersion;
+  UINT8   MinorVersion;
+  UINT16  MaxStructureSize;
+  UINT8   EntryPointRevision;
+  UINT8   FormattedArea[5];
+  UINT8   IntermediateAnchorString[5];
+  UINT8   IntermediateChecksum;
+  UINT16  TableLength;
+  UINT32  TableAddress;
+  UINT16  NumberOfSmbiosStructures;
+  UINT8   SmbiosBcdRevision;
+} SMBIOS_TABLE_ENTRY_POINT;
+
+typedef struct {
+  UINT8   AnchorString[5];
+  UINT8   EntryPointStructureChecksum;
+  UINT8   EntryPointLength;
+  UINT8   MajorVersion;
+  UINT8   MinorVersion;
+  UINT8   DocRev;
+  UINT8   EntryPointRevision;
+  UINT8   Reserved;
+  UINT32  TableMaximumSize;
+  UINT64  TableAddress;
+} SMBIOS_TABLE_3_0_ENTRY_POINT;
+
+///
+/// The Smbios structure header.
+///
+typedef struct {
+  SMBIOS_TYPE    Type;
+  UINT8          Length;
+  SMBIOS_HANDLE  Handle;
+} SMBIOS_STRUCTURE;
+
+///
+/// Text strings associated with a given SMBIOS structure are returned in the dmiStrucBuffer, appended directly after
+/// the formatted portion of the structure. This method of returning string information eliminates the need for
+/// application software to deal with pointers embedded in the SMBIOS structure. Each string is terminated with a null
+/// (00h) BYTE and the set of strings is terminated with an additional null (00h) BYTE. When the formatted portion of
+/// a SMBIOS structure references a string, it does so by specifying a non-zero string number within the structure's
+/// string-set. For example, if a string field contains 02h, it references the second string following the formatted portion
+/// of the SMBIOS structure. If a string field references no string, a null (0) is placed in that string field. If the
+/// formatted portion of the structure contains string-reference fields and all the string fields are set to 0 (no string
+/// references), the formatted section of the structure is followed by two null (00h) BYTES.
+///
+typedef UINT8 SMBIOS_TABLE_STRING;
+
+///
+/// BIOS Characteristics
+/// Defines which functions the BIOS supports. PCI, PCMCIA, Flash, etc.
+///
+typedef struct {
+  UINT32  Reserved                          :2;  ///< Bits 0-1.
+  UINT32  Unknown                           :1;
+  UINT32  BiosCharacteristicsNotSupported   :1;
+  UINT32  IsaIsSupported                    :1;
+  UINT32  McaIsSupported                    :1;
+  UINT32  EisaIsSupported                   :1;
+  UINT32  PciIsSupported                    :1;
+  UINT32  PcmciaIsSupported                 :1;
+  UINT32  PlugAndPlayIsSupported            :1;
+  UINT32  ApmIsSupported                    :1;
+  UINT32  BiosIsUpgradable                  :1;
+  UINT32  BiosShadowingAllowed              :1;
+  UINT32  VlVesaIsSupported                 :1;
+  UINT32  EscdSupportIsAvailable            :1;
+  UINT32  BootFromCdIsSupported             :1;
+  UINT32  SelectableBootIsSupported         :1;
+  UINT32  RomBiosIsSocketed                 :1;
+  UINT32  BootFromPcmciaIsSupported         :1;
+  UINT32  EDDSpecificationIsSupported       :1;
+  UINT32  JapaneseNecFloppyIsSupported      :1;
+  UINT32  JapaneseToshibaFloppyIsSupported  :1;
+  UINT32  Floppy525_360IsSupported          :1;
+  UINT32  Floppy525_12IsSupported           :1;
+  UINT32  Floppy35_720IsSupported           :1;
+  UINT32  Floppy35_288IsSupported           :1;
+  UINT32  PrintScreenIsSupported            :1;
+  UINT32  Keyboard8042IsSupported           :1;
+  UINT32  SerialIsSupported                 :1;
+  UINT32  PrinterIsSupported                :1;
+  UINT32  CgaMonoIsSupported                :1;
+  UINT32  NecPc98                           :1;
+  UINT32  ReservedForVendor                 :32; ///< Bits 32-63. Bits 32-47 reserved for BIOS vendor
+                                                 ///< and bits 48-63 reserved for System Vendor.
+} MISC_BIOS_CHARACTERISTICS;
+
+///
+/// BIOS Characteristics Extension Byte 1.
+/// This information, available for SMBIOS version 2.1 and later, appears at offset 12h
+/// within the BIOS Information structure.
+///
+typedef struct {
+  UINT8  AcpiIsSupported                   :1;
+  UINT8  UsbLegacyIsSupported              :1;
+  UINT8  AgpIsSupported                    :1;
+  UINT8  I2OBootIsSupported                :1;
+  UINT8  Ls120BootIsSupported              :1;
+  UINT8  AtapiZipDriveBootIsSupported      :1;
+  UINT8  Boot1394IsSupported               :1;
+  UINT8  SmartBatteryIsSupported           :1;
+} MBCE_BIOS_RESERVED;
+
+///
+/// BIOS Characteristics Extension Byte 2.
+/// This information, available for SMBIOS version 2.3 and later, appears at offset 13h
+/// within the BIOS Information structure.
+///
+typedef struct {
+  UINT8  BiosBootSpecIsSupported              :1;
+  UINT8  FunctionKeyNetworkBootIsSupported    :1;
+  UINT8  TargetContentDistributionEnabled     :1;
+  UINT8  UefiSpecificationSupported           :1;
+  UINT8  VirtualMachineSupported              :1;
+  UINT8  ExtensionByte2Reserved               :3;
+} MBCE_SYSTEM_RESERVED;
+
+///
+/// BIOS Characteristics Extension Bytes.
+///
+typedef struct {
+  MBCE_BIOS_RESERVED    BiosReserved;
+  MBCE_SYSTEM_RESERVED  SystemReserved;
+} MISC_BIOS_CHARACTERISTICS_EXTENSION;
+
+///
+/// Extended BIOS ROM size.
+///
+typedef struct {
+  UINT16 Size           :14;
+  UINT16 Unit           :2;
+} EXTENDED_BIOS_ROM_SIZE;
+
+///
+/// BIOS Information (Type 0).
+///
+typedef struct {
+  SMBIOS_STRUCTURE          Hdr;
+  SMBIOS_TABLE_STRING       Vendor;
+  SMBIOS_TABLE_STRING       BiosVersion;
+  UINT16                    BiosSegment;
+  SMBIOS_TABLE_STRING       BiosReleaseDate;
+  UINT8                     BiosSize;
+  MISC_BIOS_CHARACTERISTICS BiosCharacteristics;
+  UINT8                     BIOSCharacteristicsExtensionBytes[2];
+  UINT8                     SystemBiosMajorRelease;
+  UINT8                     SystemBiosMinorRelease;
+  UINT8                     EmbeddedControllerFirmwareMajorRelease;
+  UINT8                     EmbeddedControllerFirmwareMinorRelease;
+  //
+  // Add for smbios 3.1.0
+  //
+  EXTENDED_BIOS_ROM_SIZE    ExtendedBiosSize;
+} SMBIOS_TABLE_TYPE0;
+
+///
+///  System Wake-up Type.
+///
+typedef enum {
+  SystemWakeupTypeReserved         = 0x00,
+  SystemWakeupTypeOther            = 0x01,
+  SystemWakeupTypeUnknown          = 0x02,
+  SystemWakeupTypeApmTimer         = 0x03,
+  SystemWakeupTypeModemRing        = 0x04,
+  SystemWakeupTypeLanRemote        = 0x05,
+  SystemWakeupTypePowerSwitch      = 0x06,
+  SystemWakeupTypePciPme           = 0x07,
+  SystemWakeupTypeAcPowerRestored  = 0x08
+} MISC_SYSTEM_WAKEUP_TYPE;
+
+///
+/// System Information (Type 1).
+///
+/// The information in this structure defines attributes of the overall system and is
+/// intended to be associated with the Component ID group of the system's MIF.
+/// An SMBIOS implementation is associated with a single system instance and contains
+/// one and only one System Information (Type 1) structure.
+///
+typedef struct {
+  SMBIOS_STRUCTURE        Hdr;
+  SMBIOS_TABLE_STRING     Manufacturer;
+  SMBIOS_TABLE_STRING     ProductName;
+  SMBIOS_TABLE_STRING     Version;
+  SMBIOS_TABLE_STRING     SerialNumber;
+  GUID                    Uuid;
+  UINT8                   WakeUpType;           ///< The enumeration value from MISC_SYSTEM_WAKEUP_TYPE.
+  SMBIOS_TABLE_STRING     SKUNumber;
+  SMBIOS_TABLE_STRING     Family;
+} SMBIOS_TABLE_TYPE1;
+
+///
+///  Base Board - Feature Flags.
+///
+typedef struct {
+  UINT8  Motherboard           :1;
+  UINT8  RequiresDaughterCard  :1;
+  UINT8  Removable             :1;
+  UINT8  Replaceable           :1;
+  UINT8  HotSwappable          :1;
+  UINT8  Reserved              :3;
+} BASE_BOARD_FEATURE_FLAGS;
+
+///
+///  Base Board - Board Type.
+///
+typedef enum {
+  BaseBoardTypeUnknown                  = 0x1,
+  BaseBoardTypeOther                    = 0x2,
+  BaseBoardTypeServerBlade              = 0x3,
+  BaseBoardTypeConnectivitySwitch       = 0x4,
+  BaseBoardTypeSystemManagementModule   = 0x5,
+  BaseBoardTypeProcessorModule          = 0x6,
+  BaseBoardTypeIOModule                 = 0x7,
+  BaseBoardTypeMemoryModule             = 0x8,
+  BaseBoardTypeDaughterBoard            = 0x9,
+  BaseBoardTypeMotherBoard              = 0xA,
+  BaseBoardTypeProcessorMemoryModule    = 0xB,
+  BaseBoardTypeProcessorIOModule        = 0xC,
+  BaseBoardTypeInterconnectBoard        = 0xD
+} BASE_BOARD_TYPE;
+
+///
+/// Base Board (or Module) Information (Type 2).
+///
+/// The information in this structure defines attributes of a system baseboard -
+/// for example a motherboard, planar, or server blade or other standard system module.
+///
+typedef struct {
+  SMBIOS_STRUCTURE          Hdr;
+  SMBIOS_TABLE_STRING       Manufacturer;
+  SMBIOS_TABLE_STRING       ProductName;
+  SMBIOS_TABLE_STRING       Version;
+  SMBIOS_TABLE_STRING       SerialNumber;
+  SMBIOS_TABLE_STRING       AssetTag;
+  BASE_BOARD_FEATURE_FLAGS  FeatureFlag;
+  SMBIOS_TABLE_STRING       LocationInChassis;
+  UINT16                    ChassisHandle;
+  UINT8                     BoardType;              ///< The enumeration value from BASE_BOARD_TYPE.
+  UINT8                     NumberOfContainedObjectHandles;
+  UINT16                    ContainedObjectHandles[1];
+} SMBIOS_TABLE_TYPE2;
+
+///
+/// System Enclosure or Chassis Types
+///
+typedef enum {
+  MiscChassisTypeOther                = 0x01,
+  MiscChassisTypeUnknown              = 0x02,
+  MiscChassisTypeDeskTop              = 0x03,
+  MiscChassisTypeLowProfileDesktop    = 0x04,
+  MiscChassisTypePizzaBox             = 0x05,
+  MiscChassisTypeMiniTower            = 0x06,
+  MiscChassisTypeTower                = 0x07,
+  MiscChassisTypePortable             = 0x08,
+  MiscChassisTypeLapTop               = 0x09,
+  MiscChassisTypeNotebook             = 0x0A,
+  MiscChassisTypeHandHeld             = 0x0B,
+  MiscChassisTypeDockingStation       = 0x0C,
+  MiscChassisTypeAllInOne             = 0x0D,
+  MiscChassisTypeSubNotebook          = 0x0E,
+  MiscChassisTypeSpaceSaving          = 0x0F,
+  MiscChassisTypeLunchBox             = 0x10,
+  MiscChassisTypeMainServerChassis    = 0x11,
+  MiscChassisTypeExpansionChassis     = 0x12,
+  MiscChassisTypeSubChassis           = 0x13,
+  MiscChassisTypeBusExpansionChassis  = 0x14,
+  MiscChassisTypePeripheralChassis    = 0x15,
+  MiscChassisTypeRaidChassis          = 0x16,
+  MiscChassisTypeRackMountChassis     = 0x17,
+  MiscChassisTypeSealedCasePc         = 0x18,
+  MiscChassisMultiSystemChassis       = 0x19,
+  MiscChassisCompactPCI               = 0x1A,
+  MiscChassisAdvancedTCA              = 0x1B,
+  MiscChassisBlade                    = 0x1C,
+  MiscChassisBladeEnclosure           = 0x1D,
+  MiscChassisTablet                   = 0x1E,
+  MiscChassisConvertible              = 0x1F,
+  MiscChassisDetachable               = 0x20,
+  MiscChassisIoTGateway               = 0x21,
+  MiscChassisEmbeddedPc               = 0x22,
+  MiscChassisMiniPc                   = 0x23,
+  MiscChassisStickPc                  = 0x24
+} MISC_CHASSIS_TYPE;
+
+///
+/// System Enclosure or Chassis States .
+///
+typedef enum {
+  ChassisStateOther           = 0x01,
+  ChassisStateUnknown         = 0x02,
+  ChassisStateSafe            = 0x03,
+  ChassisStateWarning         = 0x04,
+  ChassisStateCritical        = 0x05,
+  ChassisStateNonRecoverable  = 0x06
+} MISC_CHASSIS_STATE;
+
+///
+/// System Enclosure or Chassis Security Status.
+///
+typedef enum {
+  ChassisSecurityStatusOther                          = 0x01,
+  ChassisSecurityStatusUnknown                        = 0x02,
+  ChassisSecurityStatusNone                           = 0x03,
+  ChassisSecurityStatusExternalInterfaceLockedOut     = 0x04,
+  ChassisSecurityStatusExternalInterfaceLockedEnabled = 0x05
+} MISC_CHASSIS_SECURITY_STATE;
+
+///
+/// Contained Element record
+///
+typedef struct {
+  UINT8                 ContainedElementType;
+  UINT8                 ContainedElementMinimum;
+  UINT8                 ContainedElementMaximum;
+} CONTAINED_ELEMENT;
+
+
+///
+/// System Enclosure or Chassis (Type 3).
+///
+/// The information in this structure defines attributes of the system's mechanical enclosure(s).
+/// For example, if a system included a separate enclosure for its peripheral devices,
+/// two structures would be returned: one for the main, system enclosure and the second for
+/// the peripheral device enclosure.  The additions to this structure in v2.1 of this specification
+/// support the population of the CIM_Chassis class.
+///
+typedef struct {
+  SMBIOS_STRUCTURE            Hdr;
+  SMBIOS_TABLE_STRING         Manufacturer;
+  UINT8                       Type;
+  SMBIOS_TABLE_STRING         Version;
+  SMBIOS_TABLE_STRING         SerialNumber;
+  SMBIOS_TABLE_STRING         AssetTag;
+  UINT8                       BootupState;            ///< The enumeration value from MISC_CHASSIS_STATE.
+  UINT8                       PowerSupplyState;       ///< The enumeration value from MISC_CHASSIS_STATE.
+  UINT8                       ThermalState;           ///< The enumeration value from MISC_CHASSIS_STATE.
+  UINT8                       SecurityStatus;         ///< The enumeration value from MISC_CHASSIS_SECURITY_STATE.
+  UINT8                       OemDefined[4];
+  UINT8                       Height;
+  UINT8                       NumberofPowerCords;
+  UINT8                       ContainedElementCount;
+  UINT8                       ContainedElementRecordLength;
+  //
+  // Can have 0 to (ContainedElementCount * ContainedElementRecordLength) contained elements
+  //
+  CONTAINED_ELEMENT           ContainedElements[1];
+  //
+  // Add for smbios 2.7
+  //
+  // Since ContainedElements has a variable number of entries, must not define SKUNumber in
+  // the structure.  Need to reference it by starting at offset 0x15 and adding
+  // (ContainedElementCount * ContainedElementRecordLength) bytes.
+  //
+  // SMBIOS_TABLE_STRING         SKUNumber;
+} SMBIOS_TABLE_TYPE3;
+
+///
+/// Processor Information - Processor Type.
+///
+typedef enum {
+  ProcessorOther   = 0x01,
+  ProcessorUnknown = 0x02,
+  CentralProcessor = 0x03,
+  MathProcessor    = 0x04,
+  DspProcessor     = 0x05,
+  VideoProcessor   = 0x06
+} PROCESSOR_TYPE_DATA;
+
+///
+/// Processor Information - Processor Family.
+///
+typedef enum {
+  ProcessorFamilyOther                  = 0x01,
+  ProcessorFamilyUnknown                = 0x02,
+  ProcessorFamily8086                   = 0x03,
+  ProcessorFamily80286                  = 0x04,
+  ProcessorFamilyIntel386               = 0x05,
+  ProcessorFamilyIntel486               = 0x06,
+  ProcessorFamily8087                   = 0x07,
+  ProcessorFamily80287                  = 0x08,
+  ProcessorFamily80387                  = 0x09,
+  ProcessorFamily80487                  = 0x0A,
+  ProcessorFamilyPentium                = 0x0B,
+  ProcessorFamilyPentiumPro             = 0x0C,
+  ProcessorFamilyPentiumII              = 0x0D,
+  ProcessorFamilyPentiumMMX             = 0x0E,
+  ProcessorFamilyCeleron                = 0x0F,
+  ProcessorFamilyPentiumIIXeon          = 0x10,
+  ProcessorFamilyPentiumIII             = 0x11,
+  ProcessorFamilyM1                     = 0x12,
+  ProcessorFamilyM2                     = 0x13,
+  ProcessorFamilyIntelCeleronM          = 0x14,
+  ProcessorFamilyIntelPentium4Ht        = 0x15,
+  ProcessorFamilyAmdDuron               = 0x18,
+  ProcessorFamilyK5                     = 0x19,
+  ProcessorFamilyK6                     = 0x1A,
+  ProcessorFamilyK6_2                   = 0x1B,
+  ProcessorFamilyK6_3                   = 0x1C,
+  ProcessorFamilyAmdAthlon              = 0x1D,
+  ProcessorFamilyAmd29000               = 0x1E,
+  ProcessorFamilyK6_2Plus               = 0x1F,
+  ProcessorFamilyPowerPC                = 0x20,
+  ProcessorFamilyPowerPC601             = 0x21,
+  ProcessorFamilyPowerPC603             = 0x22,
+  ProcessorFamilyPowerPC603Plus         = 0x23,
+  ProcessorFamilyPowerPC604             = 0x24,
+  ProcessorFamilyPowerPC620             = 0x25,
+  ProcessorFamilyPowerPCx704            = 0x26,
+  ProcessorFamilyPowerPC750             = 0x27,
+  ProcessorFamilyIntelCoreDuo           = 0x28,
+  ProcessorFamilyIntelCoreDuoMobile     = 0x29,
+  ProcessorFamilyIntelCoreSoloMobile    = 0x2A,
+  ProcessorFamilyIntelAtom              = 0x2B,
+  ProcessorFamilyIntelCoreM             = 0x2C,
+  ProcessorFamilyIntelCorem3            = 0x2D,
+  ProcessorFamilyIntelCorem5            = 0x2E,
+  ProcessorFamilyIntelCorem7            = 0x2F,
+  ProcessorFamilyAlpha                  = 0x30,
+  ProcessorFamilyAlpha21064             = 0x31,
+  ProcessorFamilyAlpha21066             = 0x32,
+  ProcessorFamilyAlpha21164             = 0x33,
+  ProcessorFamilyAlpha21164PC           = 0x34,
+  ProcessorFamilyAlpha21164a            = 0x35,
+  ProcessorFamilyAlpha21264             = 0x36,
+  ProcessorFamilyAlpha21364             = 0x37,
+  ProcessorFamilyAmdTurionIIUltraDualCoreMobileM    = 0x38,
+  ProcessorFamilyAmdTurionIIDualCoreMobileM         = 0x39,
+  ProcessorFamilyAmdAthlonIIDualCoreM   = 0x3A,
+  ProcessorFamilyAmdOpteron6100Series   = 0x3B,
+  ProcessorFamilyAmdOpteron4100Series   = 0x3C,
+  ProcessorFamilyAmdOpteron6200Series   = 0x3D,
+  ProcessorFamilyAmdOpteron4200Series   = 0x3E,
+  ProcessorFamilyAmdFxSeries            = 0x3F,
+  ProcessorFamilyMips                   = 0x40,
+  ProcessorFamilyMIPSR4000              = 0x41,
+  ProcessorFamilyMIPSR4200              = 0x42,
+  ProcessorFamilyMIPSR4400              = 0x43,
+  ProcessorFamilyMIPSR4600              = 0x44,
+  ProcessorFamilyMIPSR10000             = 0x45,
+  ProcessorFamilyAmdCSeries             = 0x46,
+  ProcessorFamilyAmdESeries             = 0x47,
+  ProcessorFamilyAmdASeries             = 0x48,    ///< SMBIOS spec 2.8.0 updated the name
+  ProcessorFamilyAmdGSeries             = 0x49,
+  ProcessorFamilyAmdZSeries             = 0x4A,
+  ProcessorFamilyAmdRSeries             = 0x4B,
+  ProcessorFamilyAmdOpteron4300         = 0x4C,
+  ProcessorFamilyAmdOpteron6300         = 0x4D,
+  ProcessorFamilyAmdOpteron3300         = 0x4E,
+  ProcessorFamilyAmdFireProSeries       = 0x4F,
+  ProcessorFamilySparc                  = 0x50,
+  ProcessorFamilySuperSparc             = 0x51,
+  ProcessorFamilymicroSparcII           = 0x52,
+  ProcessorFamilymicroSparcIIep         = 0x53,
+  ProcessorFamilyUltraSparc             = 0x54,
+  ProcessorFamilyUltraSparcII           = 0x55,
+  ProcessorFamilyUltraSparcIii          = 0x56,
+  ProcessorFamilyUltraSparcIII          = 0x57,
+  ProcessorFamilyUltraSparcIIIi         = 0x58,
+  ProcessorFamily68040                  = 0x60,
+  ProcessorFamily68xxx                  = 0x61,
+  ProcessorFamily68000                  = 0x62,
+  ProcessorFamily68010                  = 0x63,
+  ProcessorFamily68020                  = 0x64,
+  ProcessorFamily68030                  = 0x65,
+  ProcessorFamilyAmdAthlonX4QuadCore    = 0x66,
+  ProcessorFamilyAmdOpteronX1000Series  = 0x67,
+  ProcessorFamilyAmdOpteronX2000Series  = 0x68,
+  ProcessorFamilyAmdOpteronASeries      = 0x69,
+  ProcessorFamilyAmdOpteronX3000Series  = 0x6A,
+  ProcessorFamilyAmdZen                 = 0x6B,
+  ProcessorFamilyHobbit                 = 0x70,
+  ProcessorFamilyCrusoeTM5000           = 0x78,
+  ProcessorFamilyCrusoeTM3000           = 0x79,
+  ProcessorFamilyEfficeonTM8000         = 0x7A,
+  ProcessorFamilyWeitek                 = 0x80,
+  ProcessorFamilyItanium                = 0x82,
+  ProcessorFamilyAmdAthlon64            = 0x83,
+  ProcessorFamilyAmdOpteron             = 0x84,
+  ProcessorFamilyAmdSempron             = 0x85,
+  ProcessorFamilyAmdTurion64Mobile      = 0x86,
+  ProcessorFamilyDualCoreAmdOpteron     = 0x87,
+  ProcessorFamilyAmdAthlon64X2DualCore  = 0x88,
+  ProcessorFamilyAmdTurion64X2Mobile    = 0x89,
+  ProcessorFamilyQuadCoreAmdOpteron     = 0x8A,
+  ProcessorFamilyThirdGenerationAmdOpteron = 0x8B,
+  ProcessorFamilyAmdPhenomFxQuadCore    = 0x8C,
+  ProcessorFamilyAmdPhenomX4QuadCore    = 0x8D,
+  ProcessorFamilyAmdPhenomX2DualCore    = 0x8E,
+  ProcessorFamilyAmdAthlonX2DualCore    = 0x8F,
+  ProcessorFamilyPARISC                 = 0x90,
+  ProcessorFamilyPaRisc8500             = 0x91,
+  ProcessorFamilyPaRisc8000             = 0x92,
+  ProcessorFamilyPaRisc7300LC           = 0x93,
+  ProcessorFamilyPaRisc7200             = 0x94,
+  ProcessorFamilyPaRisc7100LC           = 0x95,
+  ProcessorFamilyPaRisc7100             = 0x96,
+  ProcessorFamilyV30                    = 0xA0,
+  ProcessorFamilyQuadCoreIntelXeon3200Series  = 0xA1,
+  ProcessorFamilyDualCoreIntelXeon3000Series  = 0xA2,
+  ProcessorFamilyQuadCoreIntelXeon5300Series  = 0xA3,
+  ProcessorFamilyDualCoreIntelXeon5100Series  = 0xA4,
+  ProcessorFamilyDualCoreIntelXeon5000Series  = 0xA5,
+  ProcessorFamilyDualCoreIntelXeonLV          = 0xA6,
+  ProcessorFamilyDualCoreIntelXeonULV         = 0xA7,
+  ProcessorFamilyDualCoreIntelXeon7100Series  = 0xA8,
+  ProcessorFamilyQuadCoreIntelXeon5400Series  = 0xA9,
+  ProcessorFamilyQuadCoreIntelXeon            = 0xAA,
+  ProcessorFamilyDualCoreIntelXeon5200Series  = 0xAB,
+  ProcessorFamilyDualCoreIntelXeon7200Series  = 0xAC,
+  ProcessorFamilyQuadCoreIntelXeon7300Series  = 0xAD,
+  ProcessorFamilyQuadCoreIntelXeon7400Series  = 0xAE,
+  ProcessorFamilyMultiCoreIntelXeon7400Series = 0xAF,
+  ProcessorFamilyPentiumIIIXeon         = 0xB0,
+  ProcessorFamilyPentiumIIISpeedStep    = 0xB1,
+  ProcessorFamilyPentium4               = 0xB2,
+  ProcessorFamilyIntelXeon              = 0xB3,
+  ProcessorFamilyAS400                  = 0xB4,
+  ProcessorFamilyIntelXeonMP            = 0xB5,
+  ProcessorFamilyAMDAthlonXP            = 0xB6,
+  ProcessorFamilyAMDAthlonMP            = 0xB7,
+  ProcessorFamilyIntelItanium2          = 0xB8,
+  ProcessorFamilyIntelPentiumM          = 0xB9,
+  ProcessorFamilyIntelCeleronD          = 0xBA,
+  ProcessorFamilyIntelPentiumD          = 0xBB,
+  ProcessorFamilyIntelPentiumEx         = 0xBC,
+  ProcessorFamilyIntelCoreSolo          = 0xBD,  ///< SMBIOS spec 2.6 updated this value
+  ProcessorFamilyReserved               = 0xBE,
+  ProcessorFamilyIntelCore2             = 0xBF,
+  ProcessorFamilyIntelCore2Solo         = 0xC0,
+  ProcessorFamilyIntelCore2Extreme      = 0xC1,
+  ProcessorFamilyIntelCore2Quad         = 0xC2,
+  ProcessorFamilyIntelCore2ExtremeMobile = 0xC3,
+  ProcessorFamilyIntelCore2DuoMobile    = 0xC4,
+  ProcessorFamilyIntelCore2SoloMobile   = 0xC5,
+  ProcessorFamilyIntelCoreI7            = 0xC6,
+  ProcessorFamilyDualCoreIntelCeleron   = 0xC7,
+  ProcessorFamilyIBM390                 = 0xC8,
+  ProcessorFamilyG4                     = 0xC9,
+  ProcessorFamilyG5                     = 0xCA,
+  ProcessorFamilyG6                     = 0xCB,
+  ProcessorFamilyzArchitecture          = 0xCC,
+  ProcessorFamilyIntelCoreI5            = 0xCD,
+  ProcessorFamilyIntelCoreI3            = 0xCE,
+  ProcessorFamilyIntelCoreI9            = 0xCF,
+  ProcessorFamilyViaC7M                 = 0xD2,
+  ProcessorFamilyViaC7D                 = 0xD3,
+  ProcessorFamilyViaC7                  = 0xD4,
+  ProcessorFamilyViaEden                = 0xD5,
+  ProcessorFamilyMultiCoreIntelXeon           = 0xD6,
+  ProcessorFamilyDualCoreIntelXeon3Series     = 0xD7,
+  ProcessorFamilyQuadCoreIntelXeon3Series     = 0xD8,
+  ProcessorFamilyViaNano                      = 0xD9,
+  ProcessorFamilyDualCoreIntelXeon5Series     = 0xDA,
+  ProcessorFamilyQuadCoreIntelXeon5Series     = 0xDB,
+  ProcessorFamilyDualCoreIntelXeon7Series     = 0xDD,
+  ProcessorFamilyQuadCoreIntelXeon7Series     = 0xDE,
+  ProcessorFamilyMultiCoreIntelXeon7Series    = 0xDF,
+  ProcessorFamilyMultiCoreIntelXeon3400Series = 0xE0,
+  ProcessorFamilyAmdOpteron3000Series         = 0xE4,
+  ProcessorFamilyAmdSempronII                 = 0xE5,
+  ProcessorFamilyEmbeddedAmdOpteronQuadCore   = 0xE6,
+  ProcessorFamilyAmdPhenomTripleCore          = 0xE7,
+  ProcessorFamilyAmdTurionUltraDualCoreMobile = 0xE8,
+  ProcessorFamilyAmdTurionDualCoreMobile      = 0xE9,
+  ProcessorFamilyAmdAthlonDualCore            = 0xEA,
+  ProcessorFamilyAmdSempronSI                 = 0xEB,
+  ProcessorFamilyAmdPhenomII                  = 0xEC,
+  ProcessorFamilyAmdAthlonII                  = 0xED,
+  ProcessorFamilySixCoreAmdOpteron            = 0xEE,
+  ProcessorFamilyAmdSempronM                  = 0xEF,
+  ProcessorFamilyi860                   = 0xFA,
+  ProcessorFamilyi960                   = 0xFB,
+  ProcessorFamilyIndicatorFamily2       = 0xFE,
+  ProcessorFamilyReserved1              = 0xFF
+} PROCESSOR_FAMILY_DATA;
+
+///
+/// Processor Information2 - Processor Family2.
+///
+typedef enum {
+  ProcessorFamilyARMv7                 = 0x0100,
+  ProcessorFamilyARMv8                 = 0x0101,
+  ProcessorFamilySH3                   = 0x0104,
+  ProcessorFamilySH4                   = 0x0105,
+  ProcessorFamilyARM                   = 0x0118,
+  ProcessorFamilyStrongARM             = 0x0119,
+  ProcessorFamily6x86                  = 0x012C,
+  ProcessorFamilyMediaGX               = 0x012D,
+  ProcessorFamilyMII                   = 0x012E,
+  ProcessorFamilyWinChip               = 0x0140,
+  ProcessorFamilyDSP                   = 0x015E,
+  ProcessorFamilyVideoProcessor        = 0x01F4,
+  ProcessorFamilyRiscvRV32             = 0x0200,
+  ProcessorFamilyRiscVRV64             = 0x0201,
+  ProcessorFamilyRiscVRV128            = 0x0202
+} PROCESSOR_FAMILY2_DATA;
+
+///
+/// Processor Information - Voltage.
+///
+typedef struct {
+  UINT8  ProcessorVoltageCapability5V        :1;
+  UINT8  ProcessorVoltageCapability3_3V      :1;
+  UINT8  ProcessorVoltageCapability2_9V      :1;
+  UINT8  ProcessorVoltageCapabilityReserved  :1; ///< Bit 3, must be zero.
+  UINT8  ProcessorVoltageReserved            :3; ///< Bits 4-6, must be zero.
+  UINT8  ProcessorVoltageIndicateLegacy      :1;
+} PROCESSOR_VOLTAGE;
+
+///
+/// Processor Information - Processor Upgrade.
+///
+typedef enum {
+  ProcessorUpgradeOther         = 0x01,
+  ProcessorUpgradeUnknown       = 0x02,
+  ProcessorUpgradeDaughterBoard = 0x03,
+  ProcessorUpgradeZIFSocket     = 0x04,
+  ProcessorUpgradePiggyBack     = 0x05, ///< Replaceable.
+  ProcessorUpgradeNone          = 0x06,
+  ProcessorUpgradeLIFSocket     = 0x07,
+  ProcessorUpgradeSlot1         = 0x08,
+  ProcessorUpgradeSlot2         = 0x09,
+  ProcessorUpgrade370PinSocket  = 0x0A,
+  ProcessorUpgradeSlotA         = 0x0B,
+  ProcessorUpgradeSlotM         = 0x0C,
+  ProcessorUpgradeSocket423     = 0x0D,
+  ProcessorUpgradeSocketA       = 0x0E, ///< Socket 462.
+  ProcessorUpgradeSocket478     = 0x0F,
+  ProcessorUpgradeSocket754     = 0x10,
+  ProcessorUpgradeSocket940     = 0x11,
+  ProcessorUpgradeSocket939     = 0x12,
+  ProcessorUpgradeSocketmPGA604 = 0x13,
+  ProcessorUpgradeSocketLGA771  = 0x14,
+  ProcessorUpgradeSocketLGA775  = 0x15,
+  ProcessorUpgradeSocketS1      = 0x16,
+  ProcessorUpgradeAM2           = 0x17,
+  ProcessorUpgradeF1207         = 0x18,
+  ProcessorSocketLGA1366        = 0x19,
+  ProcessorUpgradeSocketG34     = 0x1A,
+  ProcessorUpgradeSocketAM3     = 0x1B,
+  ProcessorUpgradeSocketC32     = 0x1C,
+  ProcessorUpgradeSocketLGA1156 = 0x1D,
+  ProcessorUpgradeSocketLGA1567 = 0x1E,
+  ProcessorUpgradeSocketPGA988A = 0x1F,
+  ProcessorUpgradeSocketBGA1288 = 0x20,
+  ProcessorUpgradeSocketrPGA988B = 0x21,
+  ProcessorUpgradeSocketBGA1023 = 0x22,
+  ProcessorUpgradeSocketBGA1224 = 0x23,
+  ProcessorUpgradeSocketLGA1155 = 0x24,  ///< SMBIOS spec 2.8.0 updated the name
+  ProcessorUpgradeSocketLGA1356 = 0x25,
+  ProcessorUpgradeSocketLGA2011 = 0x26,
+  ProcessorUpgradeSocketFS1     = 0x27,
+  ProcessorUpgradeSocketFS2     = 0x28,
+  ProcessorUpgradeSocketFM1     = 0x29,
+  ProcessorUpgradeSocketFM2     = 0x2A,
+  ProcessorUpgradeSocketLGA2011_3 = 0x2B,
+  ProcessorUpgradeSocketLGA1356_3 = 0x2C,
+  ProcessorUpgradeSocketLGA1150   = 0x2D,
+  ProcessorUpgradeSocketBGA1168   = 0x2E,
+  ProcessorUpgradeSocketBGA1234   = 0x2F,
+  ProcessorUpgradeSocketBGA1364   = 0x30,
+  ProcessorUpgradeSocketAM4       = 0x31,
+  ProcessorUpgradeSocketLGA1151   = 0x32,
+  ProcessorUpgradeSocketBGA1356   = 0x33,
+  ProcessorUpgradeSocketBGA1440   = 0x34,
+  ProcessorUpgradeSocketBGA1515   = 0x35,
+  ProcessorUpgradeSocketLGA3647_1 = 0x36,
+  ProcessorUpgradeSocketSP3       = 0x37,
+  ProcessorUpgradeSocketSP3r2     = 0x38,
+  ProcessorUpgradeSocketLGA2066   = 0x39,
+  ProcessorUpgradeSocketBGA1392   = 0x3A,
+  ProcessorUpgradeSocketBGA1510   = 0x3B,
+  ProcessorUpgradeSocketBGA1528   = 0x3C,
+  ProcessorUpgradeSocketLGA4189   = 0x3D,
+  ProcessorUpgradeSocketLGA1200   = 0x3E,
+  ProcessorUpgradeSocketLGA4677   = 0x3F
+} PROCESSOR_UPGRADE;
+
+///
+/// Processor ID Field Description
+///
+typedef struct {
+  UINT32  ProcessorSteppingId:4;
+  UINT32  ProcessorModel:     4;
+  UINT32  ProcessorFamily:    4;
+  UINT32  ProcessorType:      2;
+  UINT32  ProcessorReserved1: 2;
+  UINT32  ProcessorXModel:    4;
+  UINT32  ProcessorXFamily:   8;
+  UINT32  ProcessorReserved2: 4;
+} PROCESSOR_SIGNATURE;
+
+typedef struct {
+  UINT32  ProcessorFpu       :1;
+  UINT32  ProcessorVme       :1;
+  UINT32  ProcessorDe        :1;
+  UINT32  ProcessorPse       :1;
+  UINT32  ProcessorTsc       :1;
+  UINT32  ProcessorMsr       :1;
+  UINT32  ProcessorPae       :1;
+  UINT32  ProcessorMce       :1;
+  UINT32  ProcessorCx8       :1;
+  UINT32  ProcessorApic      :1;
+  UINT32  ProcessorReserved1 :1;
+  UINT32  ProcessorSep       :1;
+  UINT32  ProcessorMtrr      :1;
+  UINT32  ProcessorPge       :1;
+  UINT32  ProcessorMca       :1;
+  UINT32  ProcessorCmov      :1;
+  UINT32  ProcessorPat       :1;
+  UINT32  ProcessorPse36     :1;
+  UINT32  ProcessorPsn       :1;
+  UINT32  ProcessorClfsh     :1;
+  UINT32  ProcessorReserved2 :1;
+  UINT32  ProcessorDs        :1;
+  UINT32  ProcessorAcpi      :1;
+  UINT32  ProcessorMmx       :1;
+  UINT32  ProcessorFxsr      :1;
+  UINT32  ProcessorSse       :1;
+  UINT32  ProcessorSse2      :1;
+  UINT32  ProcessorSs        :1;
+  UINT32  ProcessorReserved3 :1;
+  UINT32  ProcessorTm        :1;
+  UINT32  ProcessorReserved4 :2;
+} PROCESSOR_FEATURE_FLAGS;
+
+typedef struct {
+  UINT16  ProcessorReserved1              :1;
+  UINT16  ProcessorUnknown                :1;
+  UINT16  Processor64BitCapable           :1;
+  UINT16  ProcessorMultiCore              :1;
+  UINT16  ProcessorHardwareThread         :1;
+  UINT16  ProcessorExecuteProtection      :1;
+  UINT16  ProcessorEnhancedVirtualization :1;
+  UINT16  ProcessorPowerPerformanceCtrl   :1;
+  UINT16  Processor128BitCapable          :1;
+  UINT16  ProcessorArm64SocId             :1;
+  UINT16  ProcessorReserved2              :6;
+} PROCESSOR_CHARACTERISTIC_FLAGS;
+
+///
+/// Processor Information - Status
+///
+typedef union {
+  struct {
+    UINT8 CpuStatus       :3; ///< Indicates the status of the processor.
+    UINT8 Reserved1       :3; ///< Reserved for future use. Must be set to zero.
+    UINT8 SocketPopulated :1; ///< Indicates if the processor socket is populated or not.
+    UINT8 Reserved2       :1; ///< Reserved for future use. Must be set to zero.
+  } Bits;
+  UINT8 Data;
+} PROCESSOR_STATUS_DATA;
+
+typedef struct {
+  PROCESSOR_SIGNATURE     Signature;
+  PROCESSOR_FEATURE_FLAGS FeatureFlags;
+} PROCESSOR_ID_DATA;
+
+///
+/// Processor Information (Type 4).
+///
+/// The information in this structure defines the attributes of a single processor;
+/// a separate structure instance is provided for each system processor socket/slot.
+/// For example, a system with an IntelDX2 processor would have a single
+/// structure instance, while a system with an IntelSX2 processor would have a structure
+/// to describe the main CPU, and a second structure to describe the 80487 co-processor.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  SMBIOS_TABLE_STRING   Socket;
+  UINT8                 ProcessorType;          ///< The enumeration value from PROCESSOR_TYPE_DATA.
+  UINT8                 ProcessorFamily;        ///< The enumeration value from PROCESSOR_FAMILY_DATA.
+  SMBIOS_TABLE_STRING   ProcessorManufacturer;
+  PROCESSOR_ID_DATA     ProcessorId;
+  SMBIOS_TABLE_STRING   ProcessorVersion;
+  PROCESSOR_VOLTAGE     Voltage;
+  UINT16                ExternalClock;
+  UINT16                MaxSpeed;
+  UINT16                CurrentSpeed;
+  UINT8                 Status;
+  UINT8                 ProcessorUpgrade;      ///< The enumeration value from PROCESSOR_UPGRADE.
+  UINT16                L1CacheHandle;
+  UINT16                L2CacheHandle;
+  UINT16                L3CacheHandle;
+  SMBIOS_TABLE_STRING   SerialNumber;
+  SMBIOS_TABLE_STRING   AssetTag;
+  SMBIOS_TABLE_STRING   PartNumber;
+  //
+  // Add for smbios 2.5
+  //
+  UINT8                 CoreCount;
+  UINT8                 EnabledCoreCount;
+  UINT8                 ThreadCount;
+  UINT16                ProcessorCharacteristics;
+  //
+  // Add for smbios 2.6
+  //
+  UINT16                ProcessorFamily2;
+  //
+  // Add for smbios 3.0
+  //
+  UINT16                CoreCount2;
+  UINT16                EnabledCoreCount2;
+  UINT16                ThreadCount2;
+} SMBIOS_TABLE_TYPE4;
+
+///
+/// Memory Controller Error Detecting Method.
+///
+typedef enum {
+  ErrorDetectingMethodOther   = 0x01,
+  ErrorDetectingMethodUnknown = 0x02,
+  ErrorDetectingMethodNone    = 0x03,
+  ErrorDetectingMethodParity  = 0x04,
+  ErrorDetectingMethod32Ecc   = 0x05,
+  ErrorDetectingMethod64Ecc   = 0x06,
+  ErrorDetectingMethod128Ecc  = 0x07,
+  ErrorDetectingMethodCrc     = 0x08
+} MEMORY_ERROR_DETECT_METHOD;
+
+///
+/// Memory Controller Error Correcting Capability.
+///
+typedef struct {
+  UINT8  Other                 :1;
+  UINT8  Unknown               :1;
+  UINT8  None                  :1;
+  UINT8  SingleBitErrorCorrect :1;
+  UINT8  DoubleBitErrorCorrect :1;
+  UINT8  ErrorScrubbing        :1;
+  UINT8  Reserved              :2;
+} MEMORY_ERROR_CORRECT_CAPABILITY;
+
+///
+/// Memory Controller Information - Interleave Support.
+///
+typedef enum {
+  MemoryInterleaveOther      = 0x01,
+  MemoryInterleaveUnknown    = 0x02,
+  MemoryInterleaveOneWay     = 0x03,
+  MemoryInterleaveTwoWay     = 0x04,
+  MemoryInterleaveFourWay    = 0x05,
+  MemoryInterleaveEightWay   = 0x06,
+  MemoryInterleaveSixteenWay = 0x07
+} MEMORY_SUPPORT_INTERLEAVE_TYPE;
+
+///
+/// Memory Controller Information - Memory Speeds.
+///
+typedef struct {
+  UINT16     Other    :1;
+  UINT16     Unknown  :1;
+  UINT16     SeventyNs:1;
+  UINT16     SixtyNs  :1;
+  UINT16     FiftyNs  :1;
+  UINT16     Reserved :11;
+} MEMORY_SPEED_TYPE;
+
+///
+/// Memory Controller Information (Type 5, Obsolete).
+///
+/// The information in this structure defines the attributes of the system's memory controller(s)
+/// and the supported attributes of any memory-modules present in the sockets controlled by
+/// this controller.
+/// Note: This structure, and its companion Memory Module Information (Type 6, Obsolete),
+/// are obsolete starting with version 2.1 of this specification. The Physical Memory Array (Type 16)
+/// and Memory Device (Type 17) structures should be used instead.  BIOS providers might
+/// choose to implement both memory description types to allow existing DMI browsers
+/// to properly display the system's memory attributes.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                Hdr;
+  UINT8                           ErrDetectMethod;            ///< The enumeration value from MEMORY_ERROR_DETECT_METHOD.
+  MEMORY_ERROR_CORRECT_CAPABILITY ErrCorrectCapability;
+  UINT8                           SupportInterleave;          ///< The enumeration value from MEMORY_SUPPORT_INTERLEAVE_TYPE.
+  UINT8                           CurrentInterleave;          ///< The enumeration value from MEMORY_SUPPORT_INTERLEAVE_TYPE .
+  UINT8                           MaxMemoryModuleSize;
+  MEMORY_SPEED_TYPE               SupportSpeed;
+  UINT16                          SupportMemoryType;
+  UINT8                           MemoryModuleVoltage;
+  UINT8                           AssociatedMemorySlotNum;
+  UINT16                          MemoryModuleConfigHandles[1];
+} SMBIOS_TABLE_TYPE5;
+
+///
+/// Memory Module Information - Memory Types
+///
+typedef struct {
+  UINT16  Other       :1;
+  UINT16  Unknown     :1;
+  UINT16  Standard    :1;
+  UINT16  FastPageMode:1;
+  UINT16  Edo         :1;
+  UINT16  Parity      :1;
+  UINT16  Ecc         :1;
+  UINT16  Simm        :1;
+  UINT16  Dimm        :1;
+  UINT16  BurstEdo    :1;
+  UINT16  Sdram       :1;
+  UINT16  Reserved    :5;
+} MEMORY_CURRENT_TYPE;
+
+///
+/// Memory Module Information - Memory Size.
+///
+typedef struct {
+  UINT8   InstalledOrEnabledSize  :7; ///< Size (n), where 2**n is the size in MB.
+  UINT8   SingleOrDoubleBank      :1;
+} MEMORY_INSTALLED_ENABLED_SIZE;
+
+///
+/// Memory Module Information (Type 6, Obsolete)
+///
+/// One Memory Module Information structure is included for each memory-module socket
+/// in the system.  The structure describes the speed, type, size, and error status
+/// of each system memory module.  The supported attributes of each module are described
+/// by the "owning" Memory Controller Information structure.
+/// Note:  This structure, and its companion Memory Controller Information (Type 5, Obsolete),
+/// are obsolete starting with version 2.1 of this specification. The Physical Memory Array (Type 16)
+/// and Memory Device (Type 17) structures should be used instead.
+///
+typedef struct {
+  SMBIOS_STRUCTURE              Hdr;
+  SMBIOS_TABLE_STRING           SocketDesignation;
+  UINT8                         BankConnections;
+  UINT8                         CurrentSpeed;
+  MEMORY_CURRENT_TYPE           CurrentMemoryType;
+  MEMORY_INSTALLED_ENABLED_SIZE InstalledSize;
+  MEMORY_INSTALLED_ENABLED_SIZE EnabledSize;
+  UINT8                         ErrorStatus;
+} SMBIOS_TABLE_TYPE6;
+
+///
+/// Cache Information - SRAM Type.
+///
+typedef struct {
+  UINT16  Other         :1;
+  UINT16  Unknown       :1;
+  UINT16  NonBurst      :1;
+  UINT16  Burst         :1;
+  UINT16  PipelineBurst :1;
+  UINT16  Synchronous   :1;
+  UINT16  Asynchronous  :1;
+  UINT16  Reserved      :9;
+} CACHE_SRAM_TYPE_DATA;
+
+///
+/// Cache Information - Error Correction Type.
+///
+typedef enum {
+  CacheErrorOther     = 0x01,
+  CacheErrorUnknown   = 0x02,
+  CacheErrorNone      = 0x03,
+  CacheErrorParity    = 0x04,
+  CacheErrorSingleBit = 0x05, ///< ECC
+  CacheErrorMultiBit  = 0x06  ///< ECC
+} CACHE_ERROR_TYPE_DATA;
+
+///
+/// Cache Information - System Cache Type.
+///
+typedef enum {
+  CacheTypeOther       = 0x01,
+  CacheTypeUnknown     = 0x02,
+  CacheTypeInstruction = 0x03,
+  CacheTypeData        = 0x04,
+  CacheTypeUnified     = 0x05
+} CACHE_TYPE_DATA;
+
+///
+/// Cache Information - Associativity.
+///
+typedef enum {
+  CacheAssociativityOther        = 0x01,
+  CacheAssociativityUnknown      = 0x02,
+  CacheAssociativityDirectMapped = 0x03,
+  CacheAssociativity2Way         = 0x04,
+  CacheAssociativity4Way         = 0x05,
+  CacheAssociativityFully        = 0x06,
+  CacheAssociativity8Way         = 0x07,
+  CacheAssociativity16Way        = 0x08,
+  CacheAssociativity12Way        = 0x09,
+  CacheAssociativity24Way        = 0x0A,
+  CacheAssociativity32Way        = 0x0B,
+  CacheAssociativity48Way        = 0x0C,
+  CacheAssociativity64Way        = 0x0D,
+  CacheAssociativity20Way        = 0x0E
+} CACHE_ASSOCIATIVITY_DATA;
+
+///
+/// Cache Information (Type 7).
+///
+/// The information in this structure defines the attributes of CPU cache device in the system.
+/// One structure is specified for each such device, whether the device is internal to
+/// or external to the CPU module.  Cache modules can be associated with a processor structure
+/// in one or two ways, depending on the SMBIOS version.
+///
+typedef struct {
+  SMBIOS_STRUCTURE          Hdr;
+  SMBIOS_TABLE_STRING       SocketDesignation;
+  UINT16                    CacheConfiguration;
+  UINT16                    MaximumCacheSize;
+  UINT16                    InstalledSize;
+  CACHE_SRAM_TYPE_DATA      SupportedSRAMType;
+  CACHE_SRAM_TYPE_DATA      CurrentSRAMType;
+  UINT8                     CacheSpeed;
+  UINT8                     ErrorCorrectionType;            ///< The enumeration value from CACHE_ERROR_TYPE_DATA.
+  UINT8                     SystemCacheType;                ///< The enumeration value from CACHE_TYPE_DATA.
+  UINT8                     Associativity;                  ///< The enumeration value from CACHE_ASSOCIATIVITY_DATA.
+  //
+  // Add for smbios 3.1.0
+  //
+  UINT32                    MaximumCacheSize2;
+  UINT32                    InstalledSize2;
+} SMBIOS_TABLE_TYPE7;
+
+///
+/// Port Connector Information - Connector Types.
+///
+typedef enum {
+  PortConnectorTypeNone                   = 0x00,
+  PortConnectorTypeCentronics             = 0x01,
+  PortConnectorTypeMiniCentronics         = 0x02,
+  PortConnectorTypeProprietary            = 0x03,
+  PortConnectorTypeDB25Male               = 0x04,
+  PortConnectorTypeDB25Female             = 0x05,
+  PortConnectorTypeDB15Male               = 0x06,
+  PortConnectorTypeDB15Female             = 0x07,
+  PortConnectorTypeDB9Male                = 0x08,
+  PortConnectorTypeDB9Female              = 0x09,
+  PortConnectorTypeRJ11                   = 0x0A,
+  PortConnectorTypeRJ45                   = 0x0B,
+  PortConnectorType50PinMiniScsi          = 0x0C,
+  PortConnectorTypeMiniDin                = 0x0D,
+  PortConnectorTypeMicroDin               = 0x0E,
+  PortConnectorTypePS2                    = 0x0F,
+  PortConnectorTypeInfrared               = 0x10,
+  PortConnectorTypeHpHil                  = 0x11,
+  PortConnectorTypeUsb                    = 0x12,
+  PortConnectorTypeSsaScsi                = 0x13,
+  PortConnectorTypeCircularDin8Male       = 0x14,
+  PortConnectorTypeCircularDin8Female     = 0x15,
+  PortConnectorTypeOnboardIde             = 0x16,
+  PortConnectorTypeOnboardFloppy          = 0x17,
+  PortConnectorType9PinDualInline         = 0x18,
+  PortConnectorType25PinDualInline        = 0x19,
+  PortConnectorType50PinDualInline        = 0x1A,
+  PortConnectorType68PinDualInline        = 0x1B,
+  PortConnectorTypeOnboardSoundInput      = 0x1C,
+  PortConnectorTypeMiniCentronicsType14   = 0x1D,
+  PortConnectorTypeMiniCentronicsType26   = 0x1E,
+  PortConnectorTypeHeadPhoneMiniJack      = 0x1F,
+  PortConnectorTypeBNC                    = 0x20,
+  PortConnectorType1394                   = 0x21,
+  PortConnectorTypeSasSata                = 0x22,
+  PortConnectorTypeUsbTypeC               = 0x23,
+  PortConnectorTypePC98                   = 0xA0,
+  PortConnectorTypePC98Hireso             = 0xA1,
+  PortConnectorTypePCH98                  = 0xA2,
+  PortConnectorTypePC98Note               = 0xA3,
+  PortConnectorTypePC98Full               = 0xA4,
+  PortConnectorTypeOther                  = 0xFF
+} MISC_PORT_CONNECTOR_TYPE;
+
+///
+/// Port Connector Information - Port Types
+///
+typedef enum {
+  PortTypeNone                      = 0x00,
+  PortTypeParallelXtAtCompatible    = 0x01,
+  PortTypeParallelPortPs2           = 0x02,
+  PortTypeParallelPortEcp           = 0x03,
+  PortTypeParallelPortEpp           = 0x04,
+  PortTypeParallelPortEcpEpp        = 0x05,
+  PortTypeSerialXtAtCompatible      = 0x06,
+  PortTypeSerial16450Compatible     = 0x07,
+  PortTypeSerial16550Compatible     = 0x08,
+  PortTypeSerial16550ACompatible    = 0x09,
+  PortTypeScsi                      = 0x0A,
+  PortTypeMidi                      = 0x0B,
+  PortTypeJoyStick                  = 0x0C,
+  PortTypeKeyboard                  = 0x0D,
+  PortTypeMouse                     = 0x0E,
+  PortTypeSsaScsi                   = 0x0F,
+  PortTypeUsb                       = 0x10,
+  PortTypeFireWire                  = 0x11,
+  PortTypePcmciaTypeI               = 0x12,
+  PortTypePcmciaTypeII              = 0x13,
+  PortTypePcmciaTypeIII             = 0x14,
+  PortTypeCardBus                   = 0x15,
+  PortTypeAccessBusPort             = 0x16,
+  PortTypeScsiII                    = 0x17,
+  PortTypeScsiWide                  = 0x18,
+  PortTypePC98                      = 0x19,
+  PortTypePC98Hireso                = 0x1A,
+  PortTypePCH98                     = 0x1B,
+  PortTypeVideoPort                 = 0x1C,
+  PortTypeAudioPort                 = 0x1D,
+  PortTypeModemPort                 = 0x1E,
+  PortTypeNetworkPort               = 0x1F,
+  PortTypeSata                      = 0x20,
+  PortTypeSas                       = 0x21,
+  PortTypeMfdp                      = 0x22, ///< Multi-Function Display Port
+  PortTypeThunderbolt               = 0x23,
+  PortType8251Compatible            = 0xA0,
+  PortType8251FifoCompatible        = 0xA1,
+  PortTypeOther                     = 0xFF
+} MISC_PORT_TYPE;
+
+///
+/// Port Connector Information (Type 8).
+///
+/// The information in this structure defines the attributes of a system port connector,
+/// e.g. parallel, serial, keyboard, or mouse ports.  The port's type and connector information
+/// are provided. One structure is present for each port provided by the system.
+///
+typedef struct {
+  SMBIOS_STRUCTURE          Hdr;
+  SMBIOS_TABLE_STRING       InternalReferenceDesignator;
+  UINT8                     InternalConnectorType;          ///< The enumeration value from MISC_PORT_CONNECTOR_TYPE.
+  SMBIOS_TABLE_STRING       ExternalReferenceDesignator;
+  UINT8                     ExternalConnectorType;          ///< The enumeration value from MISC_PORT_CONNECTOR_TYPE.
+  UINT8                     PortType;                       ///< The enumeration value from MISC_PORT_TYPE.
+} SMBIOS_TABLE_TYPE8;
+
+///
+/// System Slots - Slot Type
+///
+typedef enum {
+  SlotTypeOther                        = 0x01,
+  SlotTypeUnknown                      = 0x02,
+  SlotTypeIsa                          = 0x03,
+  SlotTypeMca                          = 0x04,
+  SlotTypeEisa                         = 0x05,
+  SlotTypePci                          = 0x06,
+  SlotTypePcmcia                       = 0x07,
+  SlotTypeVlVesa                       = 0x08,
+  SlotTypeProprietary                  = 0x09,
+  SlotTypeProcessorCardSlot            = 0x0A,
+  SlotTypeProprietaryMemoryCardSlot    = 0x0B,
+  SlotTypeIORiserCardSlot              = 0x0C,
+  SlotTypeNuBus                        = 0x0D,
+  SlotTypePci66MhzCapable              = 0x0E,
+  SlotTypeAgp                          = 0x0F,
+  SlotTypeApg2X                        = 0x10,
+  SlotTypeAgp4X                        = 0x11,
+  SlotTypePciX                         = 0x12,
+  SlotTypeAgp8X                        = 0x13,
+  SlotTypeM2Socket1_DP                 = 0x14,
+  SlotTypeM2Socket1_SD                 = 0x15,
+  SlotTypeM2Socket2                    = 0x16,
+  SlotTypeM2Socket3                    = 0x17,
+  SlotTypeMxmTypeI                     = 0x18,
+  SlotTypeMxmTypeII                    = 0x19,
+  SlotTypeMxmTypeIIIStandard           = 0x1A,
+  SlotTypeMxmTypeIIIHe                 = 0x1B,
+  SlotTypeMxmTypeIV                    = 0x1C,
+  SlotTypeMxm30TypeA                   = 0x1D,
+  SlotTypeMxm30TypeB                   = 0x1E,
+  SlotTypePciExpressGen2Sff_8639       = 0x1F,
+  SlotTypePciExpressGen3Sff_8639       = 0x20,
+  SlotTypePciExpressMini52pinWithBSKO  = 0x21,      ///< PCI Express Mini 52-pin (CEM spec. 2.0) with bottom-side keep-outs.
+  SlotTypePciExpressMini52pinWithoutBSKO = 0x22,    ///< PCI Express Mini 52-pin (CEM spec. 2.0) without bottom-side keep-outs.
+  SlotTypePciExpressMini76pin          = 0x23,      ///< PCI Express Mini 76-pin (CEM spec. 2.0) Corresponds to Display-Mini card.
+  SlotTypeCXLFlexbus10                 = 0x30,
+  SlotTypePC98C20                      = 0xA0,
+  SlotTypePC98C24                      = 0xA1,
+  SlotTypePC98E                        = 0xA2,
+  SlotTypePC98LocalBus                 = 0xA3,
+  SlotTypePC98Card                     = 0xA4,
+  SlotTypePciExpress                   = 0xA5,
+  SlotTypePciExpressX1                 = 0xA6,
+  SlotTypePciExpressX2                 = 0xA7,
+  SlotTypePciExpressX4                 = 0xA8,
+  SlotTypePciExpressX8                 = 0xA9,
+  SlotTypePciExpressX16                = 0xAA,
+  SlotTypePciExpressGen2               = 0xAB,
+  SlotTypePciExpressGen2X1             = 0xAC,
+  SlotTypePciExpressGen2X2             = 0xAD,
+  SlotTypePciExpressGen2X4             = 0xAE,
+  SlotTypePciExpressGen2X8             = 0xAF,
+  SlotTypePciExpressGen2X16            = 0xB0,
+  SlotTypePciExpressGen3               = 0xB1,
+  SlotTypePciExpressGen3X1             = 0xB2,
+  SlotTypePciExpressGen3X2             = 0xB3,
+  SlotTypePciExpressGen3X4             = 0xB4,
+  SlotTypePciExpressGen3X8             = 0xB5,
+  SlotTypePciExpressGen3X16            = 0xB6,
+  SlotTypePciExpressGen4               = 0xB8,
+  SlotTypePciExpressGen4X1             = 0xB9,
+  SlotTypePciExpressGen4X2             = 0xBA,
+  SlotTypePciExpressGen4X4             = 0xBB,
+  SlotTypePciExpressGen4X8             = 0xBC,
+  SlotTypePciExpressGen4X16            = 0xBD
+} MISC_SLOT_TYPE;
+
+///
+/// System Slots - Slot Data Bus Width.
+///
+typedef enum {
+  SlotDataBusWidthOther      = 0x01,
+  SlotDataBusWidthUnknown    = 0x02,
+  SlotDataBusWidth8Bit       = 0x03,
+  SlotDataBusWidth16Bit      = 0x04,
+  SlotDataBusWidth32Bit      = 0x05,
+  SlotDataBusWidth64Bit      = 0x06,
+  SlotDataBusWidth128Bit     = 0x07,
+  SlotDataBusWidth1X         = 0x08, ///< Or X1
+  SlotDataBusWidth2X         = 0x09, ///< Or X2
+  SlotDataBusWidth4X         = 0x0A, ///< Or X4
+  SlotDataBusWidth8X         = 0x0B, ///< Or X8
+  SlotDataBusWidth12X        = 0x0C, ///< Or X12
+  SlotDataBusWidth16X        = 0x0D, ///< Or X16
+  SlotDataBusWidth32X        = 0x0E  ///< Or X32
+} MISC_SLOT_DATA_BUS_WIDTH;
+
+///
+/// System Slots - Current Usage.
+///
+typedef enum {
+  SlotUsageOther        = 0x01,
+  SlotUsageUnknown      = 0x02,
+  SlotUsageAvailable    = 0x03,
+  SlotUsageInUse        = 0x04,
+  SlotUsageUnavailable  = 0x05
+} MISC_SLOT_USAGE;
+
+///
+/// System Slots - Slot Length.
+///
+typedef enum {
+  SlotLengthOther   = 0x01,
+  SlotLengthUnknown = 0x02,
+  SlotLengthShort   = 0x03,
+  SlotLengthLong    = 0x04
+} MISC_SLOT_LENGTH;
+
+///
+/// System Slots - Slot Characteristics 1.
+///
+typedef struct {
+  UINT8  CharacteristicsUnknown  :1;
+  UINT8  Provides50Volts         :1;
+  UINT8  Provides33Volts         :1;
+  UINT8  SharedSlot              :1;
+  UINT8  PcCard16Supported       :1;
+  UINT8  CardBusSupported        :1;
+  UINT8  ZoomVideoSupported      :1;
+  UINT8  ModemRingResumeSupported:1;
+} MISC_SLOT_CHARACTERISTICS1;
+///
+/// System Slots - Slot Characteristics 2.
+///
+typedef struct {
+  UINT8  PmeSignalSupported      :1;
+  UINT8  HotPlugDevicesSupported :1;
+  UINT8  SmbusSignalSupported    :1;
+  UINT8  BifurcationSupported    :1;
+  UINT8  AsyncSurpriseRemoval    :1;
+  UINT8  FlexbusSlotCxl10Capable :1;
+  UINT8  FlexbusSlotCxl20Capable :1;
+  UINT8  Reserved                :1;  ///< Set to 0.
+} MISC_SLOT_CHARACTERISTICS2;
+
+///
+/// System Slots - Peer Segment/Bus/Device/Function/Width Groups
+///
+typedef struct {
+  UINT16                      SegmentGroupNum;
+  UINT8                       BusNum;
+  UINT8                       DevFuncNum;
+  UINT8                       DataBusWidth;
+} MISC_SLOT_PEER_GROUP;
+
+///
+/// System Slots (Type 9)
+///
+/// The information in this structure defines the attributes of a system slot.
+/// One structure is provided for each slot in the system.
+///
+///
+typedef struct {
+  SMBIOS_STRUCTURE            Hdr;
+  SMBIOS_TABLE_STRING         SlotDesignation;
+  UINT8                       SlotType;                 ///< The enumeration value from MISC_SLOT_TYPE.
+  UINT8                       SlotDataBusWidth;         ///< The enumeration value from MISC_SLOT_DATA_BUS_WIDTH.
+  UINT8                       CurrentUsage;             ///< The enumeration value from MISC_SLOT_USAGE.
+  UINT8                       SlotLength;               ///< The enumeration value from MISC_SLOT_LENGTH.
+  UINT16                      SlotID;
+  MISC_SLOT_CHARACTERISTICS1  SlotCharacteristics1;
+  MISC_SLOT_CHARACTERISTICS2  SlotCharacteristics2;
+  //
+  // Add for smbios 2.6
+  //
+  UINT16                      SegmentGroupNum;
+  UINT8                       BusNum;
+  UINT8                       DevFuncNum;
+  //
+  // Add for smbios 3.2
+  //
+  UINT8                       DataBusWidth;
+  UINT8                       PeerGroupingCount;
+  MISC_SLOT_PEER_GROUP        PeerGroups[1];
+  //
+  // Add for smbios 3.4
+  //
+  UINT8                       SlotInformation;
+  UINT8                       SlotPhysicalWidth;
+  UINT16                      SlotPitch;
+} SMBIOS_TABLE_TYPE9;
+
+///
+/// On Board Devices Information - Device Types.
+///
+typedef enum {
+  OnBoardDeviceTypeOther          = 0x01,
+  OnBoardDeviceTypeUnknown        = 0x02,
+  OnBoardDeviceTypeVideo          = 0x03,
+  OnBoardDeviceTypeScsiController = 0x04,
+  OnBoardDeviceTypeEthernet       = 0x05,
+  OnBoardDeviceTypeTokenRing      = 0x06,
+  OnBoardDeviceTypeSound          = 0x07,
+  OnBoardDeviceTypePATAController = 0x08,
+  OnBoardDeviceTypeSATAController = 0x09,
+  OnBoardDeviceTypeSASController  = 0x0A
+} MISC_ONBOARD_DEVICE_TYPE;
+
+///
+/// Device Item Entry
+///
+typedef struct {
+  UINT8                     DeviceType;             ///< Bit [6:0] - enumeration type of device from MISC_ONBOARD_DEVICE_TYPE.
+                                                    ///< Bit 7     - 1 : device enabled, 0 : device disabled.
+  SMBIOS_TABLE_STRING       DescriptionString;
+} DEVICE_STRUCT;
+
+///
+/// On Board Devices Information (Type 10, obsolete).
+///
+/// Note: This structure is obsolete starting with version 2.6 specification; the Onboard Devices Extended
+/// Information (Type 41) structure should be used instead . BIOS providers can choose to implement both
+/// types to allow existing SMBIOS browsers to properly display the system's onboard devices information.
+/// The information in this structure defines the attributes of devices that are onboard (soldered onto)
+/// a system element, usually the baseboard.  In general, an entry in this table implies that the BIOS
+/// has some level of control over the enabling of the associated device for use by the system.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  DEVICE_STRUCT         Device[1];
+} SMBIOS_TABLE_TYPE10;
+
+///
+/// OEM Strings (Type 11).
+/// This structure contains free form strings defined by the OEM. Examples of this are:
+/// Part Numbers for Reference Documents for the system, contact information for the manufacturer, etc.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 StringCount;
+} SMBIOS_TABLE_TYPE11;
+
+///
+/// System Configuration Options (Type 12).
+///
+/// This structure contains information required to configure the base board's Jumpers and Switches.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 StringCount;
+} SMBIOS_TABLE_TYPE12;
+
+
+///
+/// BIOS Language Information (Type 13).
+///
+/// The information in this structure defines the installable language attributes of the BIOS.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 InstallableLanguages;
+  UINT8                 Flags;
+  UINT8                 Reserved[15];
+  SMBIOS_TABLE_STRING   CurrentLanguages;
+} SMBIOS_TABLE_TYPE13;
+
+///
+/// Group Item Entry
+///
+typedef struct {
+  UINT8                 ItemType;
+  UINT16                ItemHandle;
+} GROUP_STRUCT;
+
+///
+/// Group Associations (Type 14).
+///
+/// The Group Associations structure is provided for OEMs who want to specify
+/// the arrangement or hierarchy of certain components (including other Group Associations)
+/// within the system.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  SMBIOS_TABLE_STRING   GroupName;
+  GROUP_STRUCT          Group[1];
+} SMBIOS_TABLE_TYPE14;
+
+///
+/// System Event Log - Event Log Types.
+///
+typedef enum {
+  EventLogTypeReserved         = 0x00,
+  EventLogTypeSingleBitECC     = 0x01,
+  EventLogTypeMultiBitECC      = 0x02,
+  EventLogTypeParityMemErr     = 0x03,
+  EventLogTypeBusTimeOut       = 0x04,
+  EventLogTypeIOChannelCheck   = 0x05,
+  EventLogTypeSoftwareNMI      = 0x06,
+  EventLogTypePOSTMemResize    = 0x07,
+  EventLogTypePOSTErr          = 0x08,
+  EventLogTypePCIParityErr     = 0x09,
+  EventLogTypePCISystemErr     = 0x0A,
+  EventLogTypeCPUFailure       = 0x0B,
+  EventLogTypeEISATimeOut      = 0x0C,
+  EventLogTypeMemLogDisabled   = 0x0D,
+  EventLogTypeLoggingDisabled  = 0x0E,
+  EventLogTypeSysLimitExce     = 0x10,
+  EventLogTypeAsyncHWTimer     = 0x11,
+  EventLogTypeSysConfigInfo    = 0x12,
+  EventLogTypeHDInfo           = 0x13,
+  EventLogTypeSysReconfig      = 0x14,
+  EventLogTypeUncorrectCPUErr  = 0x15,
+  EventLogTypeAreaResetAndClr  = 0x16,
+  EventLogTypeSystemBoot       = 0x17,
+  EventLogTypeUnused           = 0x18, ///< 0x18 - 0x7F
+  EventLogTypeAvailForSys      = 0x80, ///< 0x80 - 0xFE
+  EventLogTypeEndOfLog         = 0xFF
+} EVENT_LOG_TYPE_DATA;
+
+///
+/// System Event Log - Variable Data Format Types.
+///
+typedef enum {
+  EventLogVariableNone                        = 0x00,
+  EventLogVariableHandle                      = 0x01,
+  EventLogVariableMutilEvent                  = 0x02,
+  EventLogVariableMutilEventHandle            = 0x03,
+  EventLogVariablePOSTResultBitmap            = 0x04,
+  EventLogVariableSysManagementType           = 0x05,
+  EventLogVariableMutliEventSysManagmentType  = 0x06,
+  EventLogVariableUnused                      = 0x07,
+  EventLogVariableOEMAssigned                 = 0x80
+} EVENT_LOG_VARIABLE_DATA;
+
+///
+/// Event Log Type Descriptors
+///
+typedef struct {
+  UINT8                 LogType;                    ///< The enumeration value from EVENT_LOG_TYPE_DATA.
+  UINT8                 DataFormatType;
+} EVENT_LOG_TYPE;
+
+///
+/// System Event Log (Type 15).
+///
+/// The presence of this structure within the SMBIOS data returned for a system indicates
+/// that the system supports an event log.  An event log is a fixed-length area within a
+/// non-volatile storage element, starting with a fixed-length (and vendor-specific) header
+/// record, followed by one or more variable-length log records.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT16                LogAreaLength;
+  UINT16                LogHeaderStartOffset;
+  UINT16                LogDataStartOffset;
+  UINT8                 AccessMethod;
+  UINT8                 LogStatus;
+  UINT32                LogChangeToken;
+  UINT32                AccessMethodAddress;
+  UINT8                 LogHeaderFormat;
+  UINT8                 NumberOfSupportedLogTypeDescriptors;
+  UINT8                 LengthOfLogTypeDescriptor;
+  EVENT_LOG_TYPE        EventLogTypeDescriptors[1];
+} SMBIOS_TABLE_TYPE15;
+
+///
+/// Physical Memory Array - Location.
+///
+typedef enum {
+  MemoryArrayLocationOther                 = 0x01,
+  MemoryArrayLocationUnknown               = 0x02,
+  MemoryArrayLocationSystemBoard           = 0x03,
+  MemoryArrayLocationIsaAddonCard          = 0x04,
+  MemoryArrayLocationEisaAddonCard         = 0x05,
+  MemoryArrayLocationPciAddonCard          = 0x06,
+  MemoryArrayLocationMcaAddonCard          = 0x07,
+  MemoryArrayLocationPcmciaAddonCard       = 0x08,
+  MemoryArrayLocationProprietaryAddonCard  = 0x09,
+  MemoryArrayLocationNuBus                 = 0x0A,
+  MemoryArrayLocationPc98C20AddonCard      = 0xA0,
+  MemoryArrayLocationPc98C24AddonCard      = 0xA1,
+  MemoryArrayLocationPc98EAddonCard        = 0xA2,
+  MemoryArrayLocationPc98LocalBusAddonCard = 0xA3,
+  MemoryArrayLocationCXLAddonCard          = 0xA4
+} MEMORY_ARRAY_LOCATION;
+
+///
+/// Physical Memory Array - Use.
+///
+typedef enum {
+  MemoryArrayUseOther                      = 0x01,
+  MemoryArrayUseUnknown                    = 0x02,
+  MemoryArrayUseSystemMemory               = 0x03,
+  MemoryArrayUseVideoMemory                = 0x04,
+  MemoryArrayUseFlashMemory                = 0x05,
+  MemoryArrayUseNonVolatileRam             = 0x06,
+  MemoryArrayUseCacheMemory                = 0x07
+} MEMORY_ARRAY_USE;
+
+///
+/// Physical Memory Array - Error Correction Types.
+///
+typedef enum {
+  MemoryErrorCorrectionOther               = 0x01,
+  MemoryErrorCorrectionUnknown             = 0x02,
+  MemoryErrorCorrectionNone                = 0x03,
+  MemoryErrorCorrectionParity              = 0x04,
+  MemoryErrorCorrectionSingleBitEcc        = 0x05,
+  MemoryErrorCorrectionMultiBitEcc         = 0x06,
+  MemoryErrorCorrectionCrc                 = 0x07
+} MEMORY_ERROR_CORRECTION;
+
+///
+/// Physical Memory Array (Type 16).
+///
+/// This structure describes a collection of memory devices that operate
+/// together to form a memory address space.
+///
+typedef struct {
+  SMBIOS_STRUCTURE          Hdr;
+  UINT8                     Location;                       ///< The enumeration value from MEMORY_ARRAY_LOCATION.
+  UINT8                     Use;                            ///< The enumeration value from MEMORY_ARRAY_USE.
+  UINT8                     MemoryErrorCorrection;          ///< The enumeration value from MEMORY_ERROR_CORRECTION.
+  UINT32                    MaximumCapacity;
+  UINT16                    MemoryErrorInformationHandle;
+  UINT16                    NumberOfMemoryDevices;
+  //
+  // Add for smbios 2.7
+  //
+  UINT64                    ExtendedMaximumCapacity;
+} SMBIOS_TABLE_TYPE16;
+
+///
+/// Memory Device - Form Factor.
+///
+typedef enum {
+  MemoryFormFactorOther                    = 0x01,
+  MemoryFormFactorUnknown                  = 0x02,
+  MemoryFormFactorSimm                     = 0x03,
+  MemoryFormFactorSip                      = 0x04,
+  MemoryFormFactorChip                     = 0x05,
+  MemoryFormFactorDip                      = 0x06,
+  MemoryFormFactorZip                      = 0x07,
+  MemoryFormFactorProprietaryCard          = 0x08,
+  MemoryFormFactorDimm                     = 0x09,
+  MemoryFormFactorTsop                     = 0x0A,
+  MemoryFormFactorRowOfChips               = 0x0B,
+  MemoryFormFactorRimm                     = 0x0C,
+  MemoryFormFactorSodimm                   = 0x0D,
+  MemoryFormFactorSrimm                    = 0x0E,
+  MemoryFormFactorFbDimm                   = 0x0F,
+  MemoryFormFactorDie                      = 0x10
+} MEMORY_FORM_FACTOR;
+
+///
+/// Memory Device - Type
+///
+typedef enum {
+  MemoryTypeOther                          = 0x01,
+  MemoryTypeUnknown                        = 0x02,
+  MemoryTypeDram                           = 0x03,
+  MemoryTypeEdram                          = 0x04,
+  MemoryTypeVram                           = 0x05,
+  MemoryTypeSram                           = 0x06,
+  MemoryTypeRam                            = 0x07,
+  MemoryTypeRom                            = 0x08,
+  MemoryTypeFlash                          = 0x09,
+  MemoryTypeEeprom                         = 0x0A,
+  MemoryTypeFeprom                         = 0x0B,
+  MemoryTypeEprom                          = 0x0C,
+  MemoryTypeCdram                          = 0x0D,
+  MemoryType3Dram                          = 0x0E,
+  MemoryTypeSdram                          = 0x0F,
+  MemoryTypeSgram                          = 0x10,
+  MemoryTypeRdram                          = 0x11,
+  MemoryTypeDdr                            = 0x12,
+  MemoryTypeDdr2                           = 0x13,
+  MemoryTypeDdr2FbDimm                     = 0x14,
+  MemoryTypeDdr3                           = 0x18,
+  MemoryTypeFbd2                           = 0x19,
+  MemoryTypeDdr4                           = 0x1A,
+  MemoryTypeLpddr                          = 0x1B,
+  MemoryTypeLpddr2                         = 0x1C,
+  MemoryTypeLpddr3                         = 0x1D,
+  MemoryTypeLpddr4                         = 0x1E,
+  MemoryTypeLogicalNonVolatileDevice       = 0x1F,
+  MemoryTypeHBM                            = 0x20,
+  MemoryTypeHBM2                           = 0x21,
+  MemoryTypeDdr5                           = 0x22,
+  MemoryTypeLpddr5                         = 0x23
+} MEMORY_DEVICE_TYPE;
+
+///
+/// Memory Device - Type Detail
+///
+typedef struct {
+  UINT16    Reserved        :1;
+  UINT16    Other           :1;
+  UINT16    Unknown         :1;
+  UINT16    FastPaged       :1;
+  UINT16    StaticColumn    :1;
+  UINT16    PseudoStatic    :1;
+  UINT16    Rambus          :1;
+  UINT16    Synchronous     :1;
+  UINT16    Cmos            :1;
+  UINT16    Edo             :1;
+  UINT16    WindowDram      :1;
+  UINT16    CacheDram       :1;
+  UINT16    Nonvolatile     :1;
+  UINT16    Registered      :1;
+  UINT16    Unbuffered      :1;
+  UINT16    LrDimm          :1;
+} MEMORY_DEVICE_TYPE_DETAIL;
+
+///
+/// Memory Device - Memory Technology
+///
+typedef enum {
+  MemoryTechnologyOther                          = 0x01,
+  MemoryTechnologyUnknown                        = 0x02,
+  MemoryTechnologyDram                           = 0x03,
+  MemoryTechnologyNvdimmN                        = 0x04,
+  MemoryTechnologyNvdimmF                        = 0x05,
+  MemoryTechnologyNvdimmP                        = 0x06,
+  //
+  // This definition is updated to represent Intel
+  // Optane DC Persistent Memory in SMBIOS spec 3.4.0
+  //
+  MemoryTechnologyIntelOptanePersistentMemory    = 0x07
+
+} MEMORY_DEVICE_TECHNOLOGY;
+
+///
+/// Memory Device - Memory Operating Mode Capability
+///
+typedef union {
+  ///
+  /// Individual bit fields
+  ///
+  struct {
+    UINT16 Reserved                         :1;   ///< Set to 0.
+    UINT16 Other                            :1;
+    UINT16 Unknown                          :1;
+    UINT16 VolatileMemory                   :1;
+    UINT16 ByteAccessiblePersistentMemory   :1;
+    UINT16 BlockAccessiblePersistentMemory  :1;
+    UINT16 Reserved2                        :10;  ///< Set to 0.
+  } Bits;
+  ///
+  /// All bit fields as a 16-bit value
+  ///
+  UINT16 Uint16;
+} MEMORY_DEVICE_OPERATING_MODE_CAPABILITY;
+
+///
+/// Memory Device (Type 17).
+///
+/// This structure describes a single memory device that is part of
+/// a larger Physical Memory Array (Type 16).
+/// Note:  If a system includes memory-device sockets, the SMBIOS implementation
+/// includes a Memory Device structure instance for each slot, whether or not the
+/// socket is currently populated.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                          Hdr;
+  UINT16                                    MemoryArrayHandle;
+  UINT16                                    MemoryErrorInformationHandle;
+  UINT16                                    TotalWidth;
+  UINT16                                    DataWidth;
+  UINT16                                    Size;
+  UINT8                                     FormFactor;         ///< The enumeration value from MEMORY_FORM_FACTOR.
+  UINT8                                     DeviceSet;
+  SMBIOS_TABLE_STRING                       DeviceLocator;
+  SMBIOS_TABLE_STRING                       BankLocator;
+  UINT8                                     MemoryType;         ///< The enumeration value from MEMORY_DEVICE_TYPE.
+  MEMORY_DEVICE_TYPE_DETAIL                 TypeDetail;
+  UINT16                                    Speed;
+  SMBIOS_TABLE_STRING                       Manufacturer;
+  SMBIOS_TABLE_STRING                       SerialNumber;
+  SMBIOS_TABLE_STRING                       AssetTag;
+  SMBIOS_TABLE_STRING                       PartNumber;
+  //
+  // Add for smbios 2.6
+  //
+  UINT8                                     Attributes;
+  //
+  // Add for smbios 2.7
+  //
+  UINT32                                    ExtendedSize;
+  //
+  // Keep using name "ConfiguredMemoryClockSpeed" for compatibility
+  // although this field is renamed from "Configured Memory Clock Speed"
+  // to "Configured Memory Speed" in smbios 3.2.0.
+  //
+  UINT16                                    ConfiguredMemoryClockSpeed;
+  //
+  // Add for smbios 2.8.0
+  //
+  UINT16                                    MinimumVoltage;
+  UINT16                                    MaximumVoltage;
+  UINT16                                    ConfiguredVoltage;
+  //
+  // Add for smbios 3.2.0
+  //
+  UINT8                                     MemoryTechnology;   ///< The enumeration value from MEMORY_DEVICE_TECHNOLOGY
+  MEMORY_DEVICE_OPERATING_MODE_CAPABILITY   MemoryOperatingModeCapability;
+  SMBIOS_TABLE_STRING                       FirmwareVersion;
+  UINT16                                    ModuleManufacturerID;
+  UINT16                                    ModuleProductID;
+  UINT16                                    MemorySubsystemControllerManufacturerID;
+  UINT16                                    MemorySubsystemControllerProductID;
+  UINT64                                    NonVolatileSize;
+  UINT64                                    VolatileSize;
+  UINT64                                    CacheSize;
+  UINT64                                    LogicalSize;
+  //
+  // Add for smbios 3.3.0
+  //
+  UINT32                                    ExtendedSpeed;
+  UINT32                                    ExtendedConfiguredMemorySpeed;
+} SMBIOS_TABLE_TYPE17;
+
+///
+/// 32-bit Memory Error Information - Error Type.
+///
+typedef enum {
+  MemoryErrorOther             = 0x01,
+  MemoryErrorUnknown           = 0x02,
+  MemoryErrorOk                = 0x03,
+  MemoryErrorBadRead           = 0x04,
+  MemoryErrorParity            = 0x05,
+  MemoryErrorSigleBit          = 0x06,
+  MemoryErrorDoubleBit         = 0x07,
+  MemoryErrorMultiBit          = 0x08,
+  MemoryErrorNibble            = 0x09,
+  MemoryErrorChecksum          = 0x0A,
+  MemoryErrorCrc               = 0x0B,
+  MemoryErrorCorrectSingleBit  = 0x0C,
+  MemoryErrorCorrected         = 0x0D,
+  MemoryErrorUnCorrectable     = 0x0E
+} MEMORY_ERROR_TYPE;
+
+///
+/// 32-bit Memory Error Information - Error Granularity.
+///
+typedef enum {
+  MemoryGranularityOther               = 0x01,
+  MemoryGranularityOtherUnknown        = 0x02,
+  MemoryGranularityDeviceLevel         = 0x03,
+  MemoryGranularityMemPartitionLevel   = 0x04
+} MEMORY_ERROR_GRANULARITY;
+
+///
+/// 32-bit Memory Error Information - Error Operation.
+///
+typedef enum {
+  MemoryErrorOperationOther            = 0x01,
+  MemoryErrorOperationUnknown          = 0x02,
+  MemoryErrorOperationRead             = 0x03,
+  MemoryErrorOperationWrite            = 0x04,
+  MemoryErrorOperationPartialWrite     = 0x05
+} MEMORY_ERROR_OPERATION;
+
+///
+/// 32-bit Memory Error Information (Type 18).
+///
+/// This structure identifies the specifics of an error that might be detected
+/// within a Physical Memory Array.
+///
+typedef struct {
+  SMBIOS_STRUCTURE          Hdr;
+  UINT8                     ErrorType;                  ///< The enumeration value from MEMORY_ERROR_TYPE.
+  UINT8                     ErrorGranularity;           ///< The enumeration value from MEMORY_ERROR_GRANULARITY.
+  UINT8                     ErrorOperation;             ///< The enumeration value from MEMORY_ERROR_OPERATION.
+  UINT32                    VendorSyndrome;
+  UINT32                    MemoryArrayErrorAddress;
+  UINT32                    DeviceErrorAddress;
+  UINT32                    ErrorResolution;
+} SMBIOS_TABLE_TYPE18;
+
+///
+/// Memory Array Mapped Address (Type 19).
+///
+/// This structure provides the address mapping for a Physical Memory Array.
+/// One structure is present for each contiguous address range described.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT32                StartingAddress;
+  UINT32                EndingAddress;
+  UINT16                MemoryArrayHandle;
+  UINT8                 PartitionWidth;
+  //
+  // Add for smbios 2.7
+  //
+  UINT64                ExtendedStartingAddress;
+  UINT64                ExtendedEndingAddress;
+} SMBIOS_TABLE_TYPE19;
+
+///
+/// Memory Device Mapped Address (Type 20).
+///
+/// This structure maps memory address space usually to a device-level granularity.
+/// One structure is present for each contiguous address range described.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT32                StartingAddress;
+  UINT32                EndingAddress;
+  UINT16                MemoryDeviceHandle;
+  UINT16                MemoryArrayMappedAddressHandle;
+  UINT8                 PartitionRowPosition;
+  UINT8                 InterleavePosition;
+  UINT8                 InterleavedDataDepth;
+  //
+  // Add for smbios 2.7
+  //
+  UINT64                ExtendedStartingAddress;
+  UINT64                ExtendedEndingAddress;
+} SMBIOS_TABLE_TYPE20;
+
+///
+/// Built-in Pointing Device - Type
+///
+typedef enum {
+  PointingDeviceTypeOther         = 0x01,
+  PointingDeviceTypeUnknown       = 0x02,
+  PointingDeviceTypeMouse         = 0x03,
+  PointingDeviceTypeTrackBall     = 0x04,
+  PointingDeviceTypeTrackPoint    = 0x05,
+  PointingDeviceTypeGlidePoint    = 0x06,
+  PointingDeviceTouchPad          = 0x07,
+  PointingDeviceTouchScreen       = 0x08,
+  PointingDeviceOpticalSensor     = 0x09
+} BUILTIN_POINTING_DEVICE_TYPE;
+
+///
+/// Built-in Pointing Device - Interface.
+///
+typedef enum {
+  PointingDeviceInterfaceOther              = 0x01,
+  PointingDeviceInterfaceUnknown            = 0x02,
+  PointingDeviceInterfaceSerial             = 0x03,
+  PointingDeviceInterfacePs2                = 0x04,
+  PointingDeviceInterfaceInfrared           = 0x05,
+  PointingDeviceInterfaceHpHil              = 0x06,
+  PointingDeviceInterfaceBusMouse           = 0x07,
+  PointingDeviceInterfaceADB                = 0x08,
+  PointingDeviceInterfaceBusMouseDB9        = 0xA0,
+  PointingDeviceInterfaceBusMouseMicroDin   = 0xA1,
+  PointingDeviceInterfaceUsb                = 0xA2
+} BUILTIN_POINTING_DEVICE_INTERFACE;
+
+///
+/// Built-in Pointing Device (Type 21).
+///
+/// This structure describes the attributes of the built-in pointing device for the
+/// system. The presence of this structure does not imply that the built-in
+/// pointing device is active for the system's use!
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  UINT8                             Type;                   ///< The enumeration value from BUILTIN_POINTING_DEVICE_TYPE.
+  UINT8                             Interface;              ///< The enumeration value from BUILTIN_POINTING_DEVICE_INTERFACE.
+  UINT8                             NumberOfButtons;
+} SMBIOS_TABLE_TYPE21;
+
+///
+/// Portable Battery - Device Chemistry
+///
+typedef enum {
+  PortableBatteryDeviceChemistryOther               = 0x01,
+  PortableBatteryDeviceChemistryUnknown             = 0x02,
+  PortableBatteryDeviceChemistryLeadAcid            = 0x03,
+  PortableBatteryDeviceChemistryNickelCadmium       = 0x04,
+  PortableBatteryDeviceChemistryNickelMetalHydride  = 0x05,
+  PortableBatteryDeviceChemistryLithiumIon          = 0x06,
+  PortableBatteryDeviceChemistryZincAir             = 0x07,
+  PortableBatteryDeviceChemistryLithiumPolymer      = 0x08
+} PORTABLE_BATTERY_DEVICE_CHEMISTRY;
+
+///
+/// Portable Battery (Type 22).
+///
+/// This structure describes the attributes of the portable battery(s) for the system.
+/// The structure contains the static attributes for the group.  Each structure describes
+/// a single battery pack's attributes.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  SMBIOS_TABLE_STRING               Location;
+  SMBIOS_TABLE_STRING               Manufacturer;
+  SMBIOS_TABLE_STRING               ManufactureDate;
+  SMBIOS_TABLE_STRING               SerialNumber;
+  SMBIOS_TABLE_STRING               DeviceName;
+  UINT8                             DeviceChemistry;              ///< The enumeration value from PORTABLE_BATTERY_DEVICE_CHEMISTRY.
+  UINT16                            DeviceCapacity;
+  UINT16                            DesignVoltage;
+  SMBIOS_TABLE_STRING               SBDSVersionNumber;
+  UINT8                             MaximumErrorInBatteryData;
+  UINT16                            SBDSSerialNumber;
+  UINT16                            SBDSManufactureDate;
+  SMBIOS_TABLE_STRING               SBDSDeviceChemistry;
+  UINT8                             DesignCapacityMultiplier;
+  UINT32                            OEMSpecific;
+} SMBIOS_TABLE_TYPE22;
+
+///
+/// System Reset (Type 23)
+///
+/// This structure describes whether Automatic System Reset functions enabled (Status).
+/// If the system has a watchdog Timer and the timer is not reset (Timer Reset)
+/// before the Interval elapses, an automatic system reset will occur. The system will re-boot
+/// according to the Boot Option. This function may repeat until the Limit is reached, at which time
+/// the system will re-boot according to the Boot Option at Limit.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 Capabilities;
+  UINT16                ResetCount;
+  UINT16                ResetLimit;
+  UINT16                TimerInterval;
+  UINT16                Timeout;
+} SMBIOS_TABLE_TYPE23;
+
+///
+/// Hardware Security (Type 24).
+///
+/// This structure describes the system-wide hardware security settings.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 HardwareSecuritySettings;
+} SMBIOS_TABLE_TYPE24;
+
+///
+/// System Power Controls (Type 25).
+///
+/// This structure describes the attributes for controlling the main power supply to the system.
+/// Software that interprets this structure uses the month, day, hour, minute, and second values
+/// to determine the number of seconds until the next power-on of the system.  The presence of
+/// this structure implies that a timed power-on facility is available for the system.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 NextScheduledPowerOnMonth;
+  UINT8                 NextScheduledPowerOnDayOfMonth;
+  UINT8                 NextScheduledPowerOnHour;
+  UINT8                 NextScheduledPowerOnMinute;
+  UINT8                 NextScheduledPowerOnSecond;
+} SMBIOS_TABLE_TYPE25;
+
+///
+/// Voltage Probe - Location and Status.
+///
+typedef struct {
+  UINT8 VoltageProbeSite      :5;
+  UINT8  VoltageProbeStatus   :3;
+} MISC_VOLTAGE_PROBE_LOCATION;
+
+///
+/// Voltage Probe (Type 26)
+///
+/// This describes the attributes for a voltage probe in the system.
+/// Each structure describes a single voltage probe.
+///
+typedef struct {
+  SMBIOS_STRUCTURE              Hdr;
+  SMBIOS_TABLE_STRING           Description;
+  MISC_VOLTAGE_PROBE_LOCATION   LocationAndStatus;
+  UINT16                        MaximumValue;
+  UINT16                        MinimumValue;
+  UINT16                        Resolution;
+  UINT16                        Tolerance;
+  UINT16                        Accuracy;
+  UINT32                        OEMDefined;
+  UINT16                        NominalValue;
+} SMBIOS_TABLE_TYPE26;
+
+///
+/// Cooling Device - Device Type and Status.
+///
+typedef struct {
+  UINT8 CoolingDevice       :5;
+  UINT8 CoolingDeviceStatus :3;
+} MISC_COOLING_DEVICE_TYPE;
+
+///
+/// Cooling Device (Type 27)
+///
+/// This structure describes the attributes for a cooling device in the system.
+/// Each structure describes a single cooling device.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  UINT16                            TemperatureProbeHandle;
+  MISC_COOLING_DEVICE_TYPE          DeviceTypeAndStatus;
+  UINT8                             CoolingUnitGroup;
+  UINT32                            OEMDefined;
+  UINT16                            NominalSpeed;
+  //
+  // Add for smbios 2.7
+  //
+  SMBIOS_TABLE_STRING               Description;
+} SMBIOS_TABLE_TYPE27;
+
+///
+/// Temperature Probe - Location and Status.
+///
+typedef struct {
+  UINT8 TemperatureProbeSite   :5;
+  UINT8 TemperatureProbeStatus :3;
+} MISC_TEMPERATURE_PROBE_LOCATION;
+
+///
+/// Temperature Probe (Type 28).
+///
+/// This structure describes the attributes for a temperature probe in the system.
+/// Each structure describes a single temperature probe.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  SMBIOS_TABLE_STRING               Description;
+  MISC_TEMPERATURE_PROBE_LOCATION   LocationAndStatus;
+  UINT16                            MaximumValue;
+  UINT16                            MinimumValue;
+  UINT16                            Resolution;
+  UINT16                            Tolerance;
+  UINT16                            Accuracy;
+  UINT32                            OEMDefined;
+  UINT16                            NominalValue;
+} SMBIOS_TABLE_TYPE28;
+
+///
+/// Electrical Current Probe - Location and Status.
+///
+typedef struct {
+  UINT8 ElectricalCurrentProbeSite   :5;
+  UINT8 ElectricalCurrentProbeStatus :3;
+} MISC_ELECTRICAL_CURRENT_PROBE_LOCATION;
+
+///
+/// Electrical Current Probe (Type 29).
+///
+/// This structure describes the attributes for an electrical current probe in the system.
+/// Each structure describes a single electrical current probe.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                        Hdr;
+  SMBIOS_TABLE_STRING                     Description;
+  MISC_ELECTRICAL_CURRENT_PROBE_LOCATION  LocationAndStatus;
+  UINT16                                  MaximumValue;
+  UINT16                                  MinimumValue;
+  UINT16                                  Resolution;
+  UINT16                                  Tolerance;
+  UINT16                                  Accuracy;
+  UINT32                                  OEMDefined;
+  UINT16                                  NominalValue;
+} SMBIOS_TABLE_TYPE29;
+
+///
+/// Out-of-Band Remote Access (Type 30).
+///
+/// This structure describes the attributes and policy settings of a hardware facility
+/// that may be used to gain remote access to a hardware system when the operating system
+/// is not available due to power-down status, hardware failures, or boot failures.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  SMBIOS_TABLE_STRING   ManufacturerName;
+  UINT8                 Connections;
+} SMBIOS_TABLE_TYPE30;
+
+///
+/// Boot Integrity Services (BIS) Entry Point (Type 31).
+///
+/// Structure type 31 (decimal) is reserved for use by the Boot Integrity Services (BIS).
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 Checksum;
+  UINT8                 Reserved1;
+  UINT16                Reserved2;
+  UINT32                BisEntry16;
+  UINT32                BisEntry32;
+  UINT64                Reserved3;
+  UINT32                Reserved4;
+} SMBIOS_TABLE_TYPE31;
+
+///
+/// System Boot Information - System Boot Status.
+///
+typedef enum {
+  BootInformationStatusNoError                  = 0x00,
+  BootInformationStatusNoBootableMedia          = 0x01,
+  BootInformationStatusNormalOSFailedLoading    = 0x02,
+  BootInformationStatusFirmwareDetectedFailure  = 0x03,
+  BootInformationStatusOSDetectedFailure        = 0x04,
+  BootInformationStatusUserRequestedBoot        = 0x05,
+  BootInformationStatusSystemSecurityViolation  = 0x06,
+  BootInformationStatusPreviousRequestedImage   = 0x07,
+  BootInformationStatusWatchdogTimerExpired     = 0x08,
+  BootInformationStatusStartReserved            = 0x09,
+  BootInformationStatusStartOemSpecific         = 0x80,
+  BootInformationStatusStartProductSpecific     = 0xC0
+} MISC_BOOT_INFORMATION_STATUS_DATA_TYPE;
+
+///
+/// System Boot Information (Type 32).
+///
+/// The client system firmware, e.g. BIOS, communicates the System Boot Status to the
+/// client's Pre-boot Execution Environment (PXE) boot image or OS-present management
+/// application via this structure. When used in the PXE environment, for example,
+/// this code identifies the reason the PXE was initiated and can be used by boot-image
+/// software to further automate an enterprise's PXE sessions.  For example, an enterprise
+/// could choose to automatically download a hardware-diagnostic image to a client whose
+/// reason code indicated either a firmware- or operating system-detected hardware failure.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                        Hdr;
+  UINT8                                   Reserved[6];
+  UINT8                                   BootStatus;     ///< The enumeration value from MISC_BOOT_INFORMATION_STATUS_DATA_TYPE.
+} SMBIOS_TABLE_TYPE32;
+
+///
+/// 64-bit Memory Error Information (Type 33).
+///
+/// This structure describes an error within a Physical Memory Array,
+/// when the error address is above 4G (0xFFFFFFFF).
+///
+typedef struct {
+  SMBIOS_STRUCTURE          Hdr;
+  UINT8                     ErrorType;                    ///< The enumeration value from MEMORY_ERROR_TYPE.
+  UINT8                     ErrorGranularity;             ///< The enumeration value from MEMORY_ERROR_GRANULARITY.
+  UINT8                     ErrorOperation;               ///< The enumeration value from MEMORY_ERROR_OPERATION.
+  UINT32                    VendorSyndrome;
+  UINT64                    MemoryArrayErrorAddress;
+  UINT64                    DeviceErrorAddress;
+  UINT32                    ErrorResolution;
+} SMBIOS_TABLE_TYPE33;
+
+///
+/// Management Device -  Type.
+///
+typedef enum {
+  ManagementDeviceTypeOther      = 0x01,
+  ManagementDeviceTypeUnknown    = 0x02,
+  ManagementDeviceTypeLm75       = 0x03,
+  ManagementDeviceTypeLm78       = 0x04,
+  ManagementDeviceTypeLm79       = 0x05,
+  ManagementDeviceTypeLm80       = 0x06,
+  ManagementDeviceTypeLm81       = 0x07,
+  ManagementDeviceTypeAdm9240    = 0x08,
+  ManagementDeviceTypeDs1780     = 0x09,
+  ManagementDeviceTypeMaxim1617  = 0x0A,
+  ManagementDeviceTypeGl518Sm    = 0x0B,
+  ManagementDeviceTypeW83781D    = 0x0C,
+  ManagementDeviceTypeHt82H791   = 0x0D
+} MISC_MANAGEMENT_DEVICE_TYPE;
+
+///
+/// Management Device -  Address Type.
+///
+typedef enum {
+  ManagementDeviceAddressTypeOther   = 0x01,
+  ManagementDeviceAddressTypeUnknown = 0x02,
+  ManagementDeviceAddressTypeIOPort  = 0x03,
+  ManagementDeviceAddressTypeMemory  = 0x04,
+  ManagementDeviceAddressTypeSmbus   = 0x05
+} MISC_MANAGEMENT_DEVICE_ADDRESS_TYPE;
+
+///
+/// Management Device (Type 34).
+///
+/// The information in this structure defines the attributes of a Management Device.
+/// A Management Device might control one or more fans or voltage, current, or temperature
+/// probes as defined by one or more Management Device Component structures.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                      Hdr;
+  SMBIOS_TABLE_STRING                   Description;
+  UINT8                                 Type;                     ///< The enumeration value from MISC_MANAGEMENT_DEVICE_TYPE.
+  UINT32                                Address;
+  UINT8                                 AddressType;              ///< The enumeration value from MISC_MANAGEMENT_DEVICE_ADDRESS_TYPE.
+} SMBIOS_TABLE_TYPE34;
+
+///
+/// Management Device Component (Type 35)
+///
+/// This structure associates a cooling device or environmental probe with structures
+/// that define the controlling hardware device and (optionally) the component's thresholds.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  SMBIOS_TABLE_STRING   Description;
+  UINT16                ManagementDeviceHandle;
+  UINT16                ComponentHandle;
+  UINT16                ThresholdHandle;
+} SMBIOS_TABLE_TYPE35;
+
+///
+/// Management Device Threshold Data (Type 36).
+///
+/// The information in this structure defines threshold information for
+/// a component (probe or cooling-unit) contained within a Management Device.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT16                LowerThresholdNonCritical;
+  UINT16                UpperThresholdNonCritical;
+  UINT16                LowerThresholdCritical;
+  UINT16                UpperThresholdCritical;
+  UINT16                LowerThresholdNonRecoverable;
+  UINT16                UpperThresholdNonRecoverable;
+} SMBIOS_TABLE_TYPE36;
+
+///
+/// Memory Channel Entry.
+///
+typedef struct {
+  UINT8                 DeviceLoad;
+  UINT16                DeviceHandle;
+} MEMORY_DEVICE;
+
+///
+/// Memory Channel - Channel Type.
+///
+typedef enum {
+  MemoryChannelTypeOther       = 0x01,
+  MemoryChannelTypeUnknown     = 0x02,
+  MemoryChannelTypeRambus      = 0x03,
+  MemoryChannelTypeSyncLink    = 0x04
+} MEMORY_CHANNEL_TYPE;
+
+///
+/// Memory Channel (Type 37)
+///
+/// The information in this structure provides the correlation between a Memory Channel
+/// and its associated Memory Devices.  Each device presents one or more loads to the channel.
+/// The sum of all device loads cannot exceed the channel's defined maximum.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 ChannelType;
+  UINT8                 MaximumChannelLoad;
+  UINT8                 MemoryDeviceCount;
+  MEMORY_DEVICE         MemoryDevice[1];
+} SMBIOS_TABLE_TYPE37;
+
+///
+/// IPMI Device Information - BMC Interface Type
+///
+typedef enum {
+  IPMIDeviceInfoInterfaceTypeUnknown       = 0x00,
+  IPMIDeviceInfoInterfaceTypeKCS           = 0x01, ///< The Keyboard Controller Style.
+  IPMIDeviceInfoInterfaceTypeSMIC          = 0x02, ///< The Server Management Interface Chip.
+  IPMIDeviceInfoInterfaceTypeBT            = 0x03, ///< The Block Transfer
+  IPMIDeviceInfoInterfaceTypeSSIF          = 0x04  ///< SMBus System Interface
+} BMC_INTERFACE_TYPE;
+
+///
+/// IPMI Device Information (Type 38).
+///
+/// The information in this structure defines the attributes of an
+/// Intelligent Platform Management Interface (IPMI) Baseboard Management Controller (BMC).
+///
+/// The Type 42 structure can also be used to describe a physical management controller
+/// host interface and one or more protocols that share that interface. If IPMI is not
+/// shared with other protocols, either the Type 38 or Type 42 structures can be used.
+/// Providing Type 38 is recommended for backward compatibility.
+///
+typedef struct {
+  SMBIOS_STRUCTURE      Hdr;
+  UINT8                 InterfaceType;              ///< The enumeration value from BMC_INTERFACE_TYPE.
+  UINT8                 IPMISpecificationRevision;
+  UINT8                 I2CSlaveAddress;
+  UINT8                 NVStorageDeviceAddress;
+  UINT64                BaseAddress;
+  UINT8                 BaseAddressModifier_InterruptInfo;
+  UINT8                 InterruptNumber;
+} SMBIOS_TABLE_TYPE38;
+
+///
+/// System Power Supply - Power Supply Characteristics.
+///
+typedef struct {
+  UINT16                        PowerSupplyHotReplaceable:1;
+  UINT16                        PowerSupplyPresent       :1;
+  UINT16                        PowerSupplyUnplugged     :1;
+  UINT16                        InputVoltageRangeSwitch  :4;
+  UINT16                        PowerSupplyStatus        :3;
+  UINT16                        PowerSupplyType          :4;
+  UINT16                        Reserved                 :2;
+} SYS_POWER_SUPPLY_CHARACTERISTICS;
+
+///
+/// System Power Supply (Type 39).
+///
+/// This structure identifies attributes of a system power supply. One instance
+/// of this record is present for each possible power supply in a system.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  UINT8                             PowerUnitGroup;
+  SMBIOS_TABLE_STRING               Location;
+  SMBIOS_TABLE_STRING               DeviceName;
+  SMBIOS_TABLE_STRING               Manufacturer;
+  SMBIOS_TABLE_STRING               SerialNumber;
+  SMBIOS_TABLE_STRING               AssetTagNumber;
+  SMBIOS_TABLE_STRING               ModelPartNumber;
+  SMBIOS_TABLE_STRING               RevisionLevel;
+  UINT16                            MaxPowerCapacity;
+  SYS_POWER_SUPPLY_CHARACTERISTICS  PowerSupplyCharacteristics;
+  UINT16                            InputVoltageProbeHandle;
+  UINT16                            CoolingDeviceHandle;
+  UINT16                            InputCurrentProbeHandle;
+} SMBIOS_TABLE_TYPE39;
+
+///
+/// Additional Information Entry Format.
+///
+typedef struct {
+  UINT8                   EntryLength;
+  UINT16                  ReferencedHandle;
+  UINT8                   ReferencedOffset;
+  SMBIOS_TABLE_STRING     EntryString;
+  UINT8                   Value[1];
+} ADDITIONAL_INFORMATION_ENTRY;
+
+///
+/// Additional Information (Type 40).
+///
+/// This structure is intended to provide additional information for handling unspecified
+/// enumerated values and interim field updates in another structure.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                      Hdr;
+  UINT8                                 NumberOfAdditionalInformationEntries;
+  ADDITIONAL_INFORMATION_ENTRY          AdditionalInfoEntries[1];
+} SMBIOS_TABLE_TYPE40;
+
+///
+/// Onboard Devices Extended Information - Onboard Device Types.
+///
+typedef enum{
+  OnBoardDeviceExtendedTypeOther          = 0x01,
+  OnBoardDeviceExtendedTypeUnknown        = 0x02,
+  OnBoardDeviceExtendedTypeVideo          = 0x03,
+  OnBoardDeviceExtendedTypeScsiController = 0x04,
+  OnBoardDeviceExtendedTypeEthernet       = 0x05,
+  OnBoardDeviceExtendedTypeTokenRing      = 0x06,
+  OnBoardDeviceExtendedTypeSound          = 0x07,
+  OnBoardDeviceExtendedTypePATAController = 0x08,
+  OnBoardDeviceExtendedTypeSATAController = 0x09,
+  OnBoardDeviceExtendedTypeSASController  = 0x0A
+} ONBOARD_DEVICE_EXTENDED_INFO_TYPE;
+
+///
+/// Onboard Devices Extended Information (Type 41).
+///
+/// The information in this structure defines the attributes of devices that
+/// are onboard (soldered onto) a system element, usually the baseboard.
+/// In general, an entry in this table implies that the BIOS has some level of
+/// control over the enabling of the associated device for use by the system.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  SMBIOS_TABLE_STRING               ReferenceDesignation;
+  UINT8                             DeviceType;             ///< The enumeration value from ONBOARD_DEVICE_EXTENDED_INFO_TYPE
+  UINT8                             DeviceTypeInstance;
+  UINT16                            SegmentGroupNum;
+  UINT8                             BusNum;
+  UINT8                             DevFuncNum;
+} SMBIOS_TABLE_TYPE41;
+
+///
+///  Management Controller Host Interface - Protocol Record Data Format.
+///
+typedef struct {
+  UINT8                        ProtocolType;
+  UINT8                        ProtocolTypeDataLen;
+  UINT8                        ProtocolTypeData[1];
+} MC_HOST_INTERFACE_PROTOCOL_RECORD;
+
+///
+/// Management Controller Host Interface - Interface Types.
+/// 00h - 3Fh: MCTP Host Interfaces
+///
+typedef enum{
+  MCHostInterfaceTypeNetworkHostInterface       = 0x40,
+  MCHostInterfaceTypeOemDefined                 = 0xF0
+} MC_HOST_INTERFACE_TYPE;
+
+///
+/// Management Controller Host Interface - Protocol Types.
+///
+typedef enum{
+  MCHostInterfaceProtocolTypeIPMI               = 0x02,
+  MCHostInterfaceProtocolTypeMCTP               = 0x03,
+  MCHostInterfaceProtocolTypeRedfishOverIP      = 0x04,
+  MCHostInterfaceProtocolTypeOemDefined         = 0xF0
+} MC_HOST_INTERFACE_PROTOCOL_TYPE;
+
+///
+/// Management Controller Host Interface (Type 42).
+///
+/// The information in this structure defines the attributes of a Management
+/// Controller Host Interface that is not discoverable by "Plug and Play" mechanisms.
+///
+/// Type 42 should be used for management controller host interfaces that use protocols
+/// other than IPMI or that use multiple protocols on a single host interface type.
+///
+/// This structure should also be provided if IPMI is shared with other protocols
+/// over the same interface hardware. If IPMI is not shared with other protocols,
+/// either the Type 38 or Type 42 structures can be used. Providing Type 38 is
+/// recommended for backward compatibility. The structures are not required to
+/// be mutually exclusive. Type 38 and Type 42 structures may be implemented
+/// simultaneously to provide backward compatibility with IPMI applications or drivers
+/// that do not yet recognize the Type 42 structure.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  UINT8                             InterfaceType;                  ///< The enumeration value from MC_HOST_INTERFACE_TYPE
+  UINT8                             InterfaceTypeSpecificDataLength;
+  UINT8                             InterfaceTypeSpecificData[4];   ///< This field has a minimum of four bytes
+} SMBIOS_TABLE_TYPE42;
+
+
+///
+/// Processor Specific Block - Processor Architecture Type
+///
+typedef enum{
+  ProcessorSpecificBlockArchTypeReserved   = 0x00,
+  ProcessorSpecificBlockArchTypeIa32       = 0x01,
+  ProcessorSpecificBlockArchTypeX64        = 0x02,
+  ProcessorSpecificBlockArchTypeItanium    = 0x03,
+  ProcessorSpecificBlockArchTypeAarch32    = 0x04,
+  ProcessorSpecificBlockArchTypeAarch64    = 0x05,
+  ProcessorSpecificBlockArchTypeRiscVRV32  = 0x06,
+  ProcessorSpecificBlockArchTypeRiscVRV64  = 0x07,
+  ProcessorSpecificBlockArchTypeRiscVRV128 = 0x08
+} PROCESSOR_SPECIFIC_BLOCK_ARCH_TYPE;
+
+///
+/// Processor Specific Block is the standard container of processor-specific data.
+///
+typedef struct {
+  UINT8                              Length;
+  UINT8                              ProcessorArchType;
+  ///
+  /// Below followed by Processor-specific data
+  ///
+  ///
+} PROCESSOR_SPECIFIC_BLOCK;
+
+///
+/// Processor Additional Information(Type 44).
+///
+/// The information in this structure defines the processor additional information in case
+/// SMBIOS type 4 is not sufficient to describe processor characteristics.
+/// The SMBIOS type 44 structure has a reference handle field to link back to the related
+/// SMBIOS type 4 structure. There may be multiple SMBIOS type 44 structures linked to the
+/// same SMBIOS type 4 structure. For example, when cores are not identical in a processor,
+/// SMBIOS type 44 structures describe different core-specific information.
+///
+/// SMBIOS type 44 defines the standard header for the processor-specific block, while the
+/// contents of processor-specific data are maintained by processor
+/// architecture workgroups or vendors in separate documents.
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  SMBIOS_HANDLE                     RefHandle;                 ///< This field refer to associated SMBIOS type 4
+  ///
+  /// Below followed by Processor-specific block
+  ///
+  PROCESSOR_SPECIFIC_BLOCK          ProcessorSpecificBlock;
+} SMBIOS_TABLE_TYPE44;
+
+///
+/// TPM Device (Type 43).
+///
+typedef struct {
+  SMBIOS_STRUCTURE                  Hdr;
+  UINT8                             VendorID[4];
+  UINT8                             MajorSpecVersion;
+  UINT8                             MinorSpecVersion;
+  UINT32                            FirmwareVersion1;
+  UINT32                            FirmwareVersion2;
+  SMBIOS_TABLE_STRING               Description;
+  UINT64                            Characteristics;
+  UINT32                            OemDefined;
+} SMBIOS_TABLE_TYPE43;
+
+///
+/// Inactive (Type 126)
+///
+typedef struct {
+  SMBIOS_STRUCTURE   Hdr;
+} SMBIOS_TABLE_TYPE126;
+
+///
+/// End-of-Table (Type 127)
+///
+typedef struct {
+  SMBIOS_STRUCTURE   Hdr;
+} SMBIOS_TABLE_TYPE127;
+
+///
+/// Union of all the possible SMBIOS record types.
+///
+typedef union {
+  SMBIOS_STRUCTURE      *Hdr;
+  SMBIOS_TABLE_TYPE0    *Type0;
+  SMBIOS_TABLE_TYPE1    *Type1;
+  SMBIOS_TABLE_TYPE2    *Type2;
+  SMBIOS_TABLE_TYPE3    *Type3;
+  SMBIOS_TABLE_TYPE4    *Type4;
+  SMBIOS_TABLE_TYPE5    *Type5;
+  SMBIOS_TABLE_TYPE6    *Type6;
+  SMBIOS_TABLE_TYPE7    *Type7;
+  SMBIOS_TABLE_TYPE8    *Type8;
+  SMBIOS_TABLE_TYPE9    *Type9;
+  SMBIOS_TABLE_TYPE10   *Type10;
+  SMBIOS_TABLE_TYPE11   *Type11;
+  SMBIOS_TABLE_TYPE12   *Type12;
+  SMBIOS_TABLE_TYPE13   *Type13;
+  SMBIOS_TABLE_TYPE14   *Type14;
+  SMBIOS_TABLE_TYPE15   *Type15;
+  SMBIOS_TABLE_TYPE16   *Type16;
+  SMBIOS_TABLE_TYPE17   *Type17;
+  SMBIOS_TABLE_TYPE18   *Type18;
+  SMBIOS_TABLE_TYPE19   *Type19;
+  SMBIOS_TABLE_TYPE20   *Type20;
+  SMBIOS_TABLE_TYPE21   *Type21;
+  SMBIOS_TABLE_TYPE22   *Type22;
+  SMBIOS_TABLE_TYPE23   *Type23;
+  SMBIOS_TABLE_TYPE24   *Type24;
+  SMBIOS_TABLE_TYPE25   *Type25;
+  SMBIOS_TABLE_TYPE26   *Type26;
+  SMBIOS_TABLE_TYPE27   *Type27;
+  SMBIOS_TABLE_TYPE28   *Type28;
+  SMBIOS_TABLE_TYPE29   *Type29;
+  SMBIOS_TABLE_TYPE30   *Type30;
+  SMBIOS_TABLE_TYPE31   *Type31;
+  SMBIOS_TABLE_TYPE32   *Type32;
+  SMBIOS_TABLE_TYPE33   *Type33;
+  SMBIOS_TABLE_TYPE34   *Type34;
+  SMBIOS_TABLE_TYPE35   *Type35;
+  SMBIOS_TABLE_TYPE36   *Type36;
+  SMBIOS_TABLE_TYPE37   *Type37;
+  SMBIOS_TABLE_TYPE38   *Type38;
+  SMBIOS_TABLE_TYPE39   *Type39;
+  SMBIOS_TABLE_TYPE40   *Type40;
+  SMBIOS_TABLE_TYPE41   *Type41;
+  SMBIOS_TABLE_TYPE42   *Type42;
+  SMBIOS_TABLE_TYPE43   *Type43;
+  SMBIOS_TABLE_TYPE44   *Type44;
+  SMBIOS_TABLE_TYPE126  *Type126;
+  SMBIOS_TABLE_TYPE127  *Type127;
+  UINT8                 *Raw;
+} SMBIOS_STRUCTURE_POINTER;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/SmBus.h b/libedk2_tpm/include/IndustryStandard/SmBus.h
new file mode 100644
index 0000000..960d77e
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/SmBus.h
@@ -0,0 +1,74 @@
+/** @file
+  This file declares the SMBus definitions defined in SmBus Specification V2.0
+  and defined in PI1.0 specification volume 5.
+
+  Copyright (c) 2007 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _SMBUS_H_
+#define _SMBUS_H_
+
+
+///
+/// UDID of SMBUS device.
+///
+typedef struct {
+  UINT32  VendorSpecificId;
+  UINT16  SubsystemDeviceId;
+  UINT16  SubsystemVendorId;
+  UINT16  Interface;
+  UINT16  DeviceId;
+  UINT16  VendorId;
+  UINT8   VendorRevision;
+  UINT8   DeviceCapabilities;
+} EFI_SMBUS_UDID;
+
+///
+/// Smbus Device Address
+///
+typedef struct {
+  ///
+  /// The SMBUS hardware address to which the SMBUS device is preassigned or allocated.
+  ///
+  UINTN SmbusDeviceAddress : 7;
+} EFI_SMBUS_DEVICE_ADDRESS;
+
+typedef struct {
+  ///
+  /// The SMBUS hardware address to which the SMBUS device is preassigned or
+  /// allocated. Type EFI_SMBUS_DEVICE_ADDRESS is defined in EFI_PEI_SMBUS2_PPI.Execute().
+  ///
+  EFI_SMBUS_DEVICE_ADDRESS  SmbusDeviceAddress;
+  ///
+  /// The SMBUS Unique Device Identifier (UDID) as defined in EFI_SMBUS_UDID.
+  /// Type EFI_SMBUS_UDID is defined in EFI_PEI_SMBUS2_PPI.ArpDevice().
+  ///
+  EFI_SMBUS_UDID            SmbusDeviceUdid;
+} EFI_SMBUS_DEVICE_MAP;
+
+///
+/// Smbus Operations
+///
+typedef enum _EFI_SMBUS_OPERATION {
+  EfiSmbusQuickRead,
+  EfiSmbusQuickWrite,
+  EfiSmbusReceiveByte,
+  EfiSmbusSendByte,
+  EfiSmbusReadByte,
+  EfiSmbusWriteByte,
+  EfiSmbusReadWord,
+  EfiSmbusWriteWord,
+  EfiSmbusReadBlock,
+  EfiSmbusWriteBlock,
+  EfiSmbusProcessCall,
+  EfiSmbusBWBRProcessCall
+} EFI_SMBUS_OPERATION;
+
+///
+/// EFI_SMBUS_DEVICE_COMMAND
+///
+typedef UINTN   EFI_SMBUS_DEVICE_COMMAND;
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Tpm12.h b/libedk2_tpm/include/IndustryStandard/Tpm12.h
new file mode 100644
index 0000000..4ac86c4
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Tpm12.h
@@ -0,0 +1,2167 @@
+/** @file
+  TPM Specification data structures (TCG TPM Specification Version 1.2 Revision 103)
+  See http://trustedcomputinggroup.org for latest specification updates
+
+  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+**/
+
+
+#ifndef _TPM12_H_
+#define _TPM12_H_
+
+///
+/// The start of TPM return codes
+///
+#define TPM_BASE                    0
+
+//
+// All structures MUST be packed on a byte boundary.
+//
+
+#pragma pack (1)
+
+//
+// Part 2, section 2.2.3: Helper redefinitions
+//
+///
+/// Indicates the conditions where it is required that authorization be presented
+///
+typedef UINT8                       TPM_AUTH_DATA_USAGE;
+///
+/// The information as to what the payload is in an encrypted structure
+///
+typedef UINT8                       TPM_PAYLOAD_TYPE;
+///
+/// The version info breakdown
+///
+typedef UINT8                       TPM_VERSION_BYTE;
+///
+/// The state of the dictionary attack mitigation logic
+///
+typedef UINT8                       TPM_DA_STATE;
+///
+/// The request or response authorization type
+///
+typedef UINT16                      TPM_TAG;
+///
+/// The protocol in use
+///
+typedef UINT16                      TPM_PROTOCOL_ID;
+///
+/// Indicates the start state
+///
+typedef UINT16                      TPM_STARTUP_TYPE;
+///
+/// The definition of the encryption scheme
+///
+typedef UINT16                      TPM_ENC_SCHEME;
+///
+/// The definition of the signature scheme
+///
+typedef UINT16                      TPM_SIG_SCHEME;
+///
+/// The definition of the migration scheme
+///
+typedef UINT16                      TPM_MIGRATE_SCHEME;
+///
+/// Sets the state of the physical presence mechanism
+///
+typedef UINT16                      TPM_PHYSICAL_PRESENCE;
+///
+/// Indicates the types of entity that are supported by the TPM
+///
+typedef UINT16                      TPM_ENTITY_TYPE;
+///
+/// Indicates the permitted usage of the key
+///
+typedef UINT16                      TPM_KEY_USAGE;
+///
+/// The type of asymmetric encrypted structure in use by the endorsement key
+///
+typedef UINT16                      TPM_EK_TYPE;
+///
+/// The tag for the structure
+///
+typedef UINT16                      TPM_STRUCTURE_TAG;
+///
+/// The platform specific spec to which the information relates to
+///
+typedef UINT16                      TPM_PLATFORM_SPECIFIC;
+///
+/// The command ordinal
+///
+typedef UINT32                      TPM_COMMAND_CODE;
+///
+/// Identifies a TPM capability area
+///
+typedef UINT32                      TPM_CAPABILITY_AREA;
+///
+/// Indicates information regarding a key
+///
+typedef UINT32                      TPM_KEY_FLAGS;
+///
+/// Indicates the type of algorithm
+///
+typedef UINT32                      TPM_ALGORITHM_ID;
+///
+/// The locality modifier
+///
+typedef UINT32                      TPM_MODIFIER_INDICATOR;
+///
+/// The actual number of a counter
+///
+typedef UINT32                      TPM_ACTUAL_COUNT;
+///
+/// Attributes that define what options are in use for a transport session
+///
+typedef UINT32                      TPM_TRANSPORT_ATTRIBUTES;
+///
+/// Handle to an authorization session
+///
+typedef UINT32                      TPM_AUTHHANDLE;
+///
+/// Index to a DIR register
+///
+typedef UINT32                      TPM_DIRINDEX;
+///
+/// The area where a key is held assigned by the TPM
+///
+typedef UINT32                      TPM_KEY_HANDLE;
+///
+/// Index to a PCR register
+///
+typedef UINT32                      TPM_PCRINDEX;
+///
+/// The return code from a function
+///
+typedef UINT32                      TPM_RESULT;
+///
+/// The types of resources that a TPM may have using internal resources
+///
+typedef UINT32                      TPM_RESOURCE_TYPE;
+///
+/// Allows for controlling of the key when loaded and how to handle TPM_Startup issues
+///
+typedef UINT32                      TPM_KEY_CONTROL;
+///
+/// The index into the NV storage area
+///
+typedef UINT32                      TPM_NV_INDEX;
+///
+/// The family ID. Family IDs are automatically assigned a sequence number by the TPM.
+/// A trusted process can set the FamilyID value in an individual row to NULL, which
+/// invalidates that row. The family ID resets to NULL on each change of TPM Owner.
+///
+typedef UINT32                      TPM_FAMILY_ID;
+///
+/// IA value used as a label for the most recent verification of this family. Set to zero when not in use.
+///
+typedef UINT32                      TPM_FAMILY_VERIFICATION;
+///
+/// How the TPM handles var
+///
+typedef UINT32                      TPM_STARTUP_EFFECTS;
+///
+/// The mode of a symmetric encryption
+///
+typedef UINT32                      TPM_SYM_MODE;
+///
+/// The family flags
+///
+typedef UINT32                      TPM_FAMILY_FLAGS;
+///
+/// The index value for the delegate NV table
+///
+typedef UINT32                      TPM_DELEGATE_INDEX;
+///
+/// The restrictions placed on delegation of CMK commands
+///
+typedef UINT32                      TPM_CMK_DELEGATE;
+///
+/// The ID value of a monotonic counter
+///
+typedef UINT32                      TPM_COUNT_ID;
+///
+/// A command to execute
+///
+typedef UINT32                      TPM_REDIT_COMMAND;
+///
+/// A transport session handle
+///
+typedef UINT32                      TPM_TRANSHANDLE;
+///
+/// A generic handle could be key, transport etc
+///
+typedef UINT32                      TPM_HANDLE;
+///
+/// What operation is happening
+///
+typedef UINT32                      TPM_FAMILY_OPERATION;
+
+//
+// Part 2, section 2.2.4: Vendor specific
+// The following defines allow for the quick specification of a
+// vendor specific item.
+//
+#define TPM_Vendor_Specific32       ((UINT32) 0x00000400)
+#define TPM_Vendor_Specific8        ((UINT8) 0x80)
+
+//
+// Part 2, section 3.1: TPM_STRUCTURE_TAG
+//
+#define TPM_TAG_CONTEXTBLOB         ((TPM_STRUCTURE_TAG) 0x0001)
+#define TPM_TAG_CONTEXT_SENSITIVE   ((TPM_STRUCTURE_TAG) 0x0002)
+#define TPM_TAG_CONTEXTPOINTER      ((TPM_STRUCTURE_TAG) 0x0003)
+#define TPM_TAG_CONTEXTLIST         ((TPM_STRUCTURE_TAG) 0x0004)
+#define TPM_TAG_SIGNINFO            ((TPM_STRUCTURE_TAG) 0x0005)
+#define TPM_TAG_PCR_INFO_LONG       ((TPM_STRUCTURE_TAG) 0x0006)
+#define TPM_TAG_PERSISTENT_FLAGS    ((TPM_STRUCTURE_TAG) 0x0007)
+#define TPM_TAG_VOLATILE_FLAGS      ((TPM_STRUCTURE_TAG) 0x0008)
+#define TPM_TAG_PERSISTENT_DATA     ((TPM_STRUCTURE_TAG) 0x0009)
+#define TPM_TAG_VOLATILE_DATA       ((TPM_STRUCTURE_TAG) 0x000A)
+#define TPM_TAG_SV_DATA             ((TPM_STRUCTURE_TAG) 0x000B)
+#define TPM_TAG_EK_BLOB             ((TPM_STRUCTURE_TAG) 0x000C)
+#define TPM_TAG_EK_BLOB_AUTH        ((TPM_STRUCTURE_TAG) 0x000D)
+#define TPM_TAG_COUNTER_VALUE       ((TPM_STRUCTURE_TAG) 0x000E)
+#define TPM_TAG_TRANSPORT_INTERNAL  ((TPM_STRUCTURE_TAG) 0x000F)
+#define TPM_TAG_TRANSPORT_LOG_IN    ((TPM_STRUCTURE_TAG) 0x0010)
+#define TPM_TAG_TRANSPORT_LOG_OUT   ((TPM_STRUCTURE_TAG) 0x0011)
+#define TPM_TAG_AUDIT_EVENT_IN      ((TPM_STRUCTURE_TAG) 0x0012)
+#define TPM_TAG_AUDIT_EVENT_OUT     ((TPM_STRUCTURE_TAG) 0x0013)
+#define TPM_TAG_CURRENT_TICKS       ((TPM_STRUCTURE_TAG) 0x0014)
+#define TPM_TAG_KEY                 ((TPM_STRUCTURE_TAG) 0x0015)
+#define TPM_TAG_STORED_DATA12       ((TPM_STRUCTURE_TAG) 0x0016)
+#define TPM_TAG_NV_ATTRIBUTES       ((TPM_STRUCTURE_TAG) 0x0017)
+#define TPM_TAG_NV_DATA_PUBLIC      ((TPM_STRUCTURE_TAG) 0x0018)
+#define TPM_TAG_NV_DATA_SENSITIVE   ((TPM_STRUCTURE_TAG) 0x0019)
+#define TPM_TAG_DELEGATIONS         ((TPM_STRUCTURE_TAG) 0x001A)
+#define TPM_TAG_DELEGATE_PUBLIC     ((TPM_STRUCTURE_TAG) 0x001B)
+#define TPM_TAG_DELEGATE_TABLE_ROW  ((TPM_STRUCTURE_TAG) 0x001C)
+#define TPM_TAG_TRANSPORT_AUTH      ((TPM_STRUCTURE_TAG) 0x001D)
+#define TPM_TAG_TRANSPORT_PUBLIC    ((TPM_STRUCTURE_TAG) 0x001E)
+#define TPM_TAG_PERMANENT_FLAGS     ((TPM_STRUCTURE_TAG) 0x001F)
+#define TPM_TAG_STCLEAR_FLAGS       ((TPM_STRUCTURE_TAG) 0x0020)
+#define TPM_TAG_STANY_FLAGS         ((TPM_STRUCTURE_TAG) 0x0021)
+#define TPM_TAG_PERMANENT_DATA      ((TPM_STRUCTURE_TAG) 0x0022)
+#define TPM_TAG_STCLEAR_DATA        ((TPM_STRUCTURE_TAG) 0x0023)
+#define TPM_TAG_STANY_DATA          ((TPM_STRUCTURE_TAG) 0x0024)
+#define TPM_TAG_FAMILY_TABLE_ENTRY  ((TPM_STRUCTURE_TAG) 0x0025)
+#define TPM_TAG_DELEGATE_SENSITIVE  ((TPM_STRUCTURE_TAG) 0x0026)
+#define TPM_TAG_DELG_KEY_BLOB       ((TPM_STRUCTURE_TAG) 0x0027)
+#define TPM_TAG_KEY12               ((TPM_STRUCTURE_TAG) 0x0028)
+#define TPM_TAG_CERTIFY_INFO2       ((TPM_STRUCTURE_TAG) 0x0029)
+#define TPM_TAG_DELEGATE_OWNER_BLOB ((TPM_STRUCTURE_TAG) 0x002A)
+#define TPM_TAG_EK_BLOB_ACTIVATE    ((TPM_STRUCTURE_TAG) 0x002B)
+#define TPM_TAG_DAA_BLOB            ((TPM_STRUCTURE_TAG) 0x002C)
+#define TPM_TAG_DAA_CONTEXT         ((TPM_STRUCTURE_TAG) 0x002D)
+#define TPM_TAG_DAA_ENFORCE         ((TPM_STRUCTURE_TAG) 0x002E)
+#define TPM_TAG_DAA_ISSUER          ((TPM_STRUCTURE_TAG) 0x002F)
+#define TPM_TAG_CAP_VERSION_INFO    ((TPM_STRUCTURE_TAG) 0x0030)
+#define TPM_TAG_DAA_SENSITIVE       ((TPM_STRUCTURE_TAG) 0x0031)
+#define TPM_TAG_DAA_TPM             ((TPM_STRUCTURE_TAG) 0x0032)
+#define TPM_TAG_CMK_MIGAUTH         ((TPM_STRUCTURE_TAG) 0x0033)
+#define TPM_TAG_CMK_SIGTICKET       ((TPM_STRUCTURE_TAG) 0x0034)
+#define TPM_TAG_CMK_MA_APPROVAL     ((TPM_STRUCTURE_TAG) 0x0035)
+#define TPM_TAG_QUOTE_INFO2         ((TPM_STRUCTURE_TAG) 0x0036)
+#define TPM_TAG_DA_INFO             ((TPM_STRUCTURE_TAG) 0x0037)
+#define TPM_TAG_DA_LIMITED          ((TPM_STRUCTURE_TAG) 0x0038)
+#define TPM_TAG_DA_ACTION_TYPE      ((TPM_STRUCTURE_TAG) 0x0039)
+
+//
+// Part 2, section 4: TPM Types
+//
+
+//
+// Part 2, section 4.1: TPM_RESOURCE_TYPE
+//
+#define TPM_RT_KEY                  ((TPM_RESOURCE_TYPE) 0x00000001) ///< The handle is a key handle and is the result of a LoadKey type operation
+#define TPM_RT_AUTH                 ((TPM_RESOURCE_TYPE) 0x00000002) ///< The handle is an authorization handle. Auth handles come from TPM_OIAP, TPM_OSAP and TPM_DSAP
+#define TPM_RT_HASH                 ((TPM_RESOURCE_TYPE) 0x00000003) ///< Reserved for hashes
+#define TPM_RT_TRANS                ((TPM_RESOURCE_TYPE) 0x00000004) ///< The handle is for a transport session. Transport handles come from TPM_EstablishTransport
+#define TPM_RT_CONTEXT              ((TPM_RESOURCE_TYPE) 0x00000005) ///< Resource wrapped and held outside the TPM using the context save/restore commands
+#define TPM_RT_COUNTER              ((TPM_RESOURCE_TYPE) 0x00000006) ///< Reserved for counters
+#define TPM_RT_DELEGATE             ((TPM_RESOURCE_TYPE) 0x00000007) ///< The handle is for a delegate row. These are the internal rows held in NV storage by the TPM
+#define TPM_RT_DAA_TPM              ((TPM_RESOURCE_TYPE) 0x00000008) ///< The value is a DAA TPM specific blob
+#define TPM_RT_DAA_V0               ((TPM_RESOURCE_TYPE) 0x00000009) ///< The value is a DAA V0 parameter
+#define TPM_RT_DAA_V1               ((TPM_RESOURCE_TYPE) 0x0000000A) ///< The value is a DAA V1 parameter
+
+//
+// Part 2, section 4.2: TPM_PAYLOAD_TYPE
+//
+#define TPM_PT_ASYM                 ((TPM_PAYLOAD_TYPE) 0x01) ///< The entity is an asymmetric key
+#define TPM_PT_BIND                 ((TPM_PAYLOAD_TYPE) 0x02) ///< The entity is bound data
+#define TPM_PT_MIGRATE              ((TPM_PAYLOAD_TYPE) 0x03) ///< The entity is a migration blob
+#define TPM_PT_MAINT                ((TPM_PAYLOAD_TYPE) 0x04) ///< The entity is a maintenance blob
+#define TPM_PT_SEAL                 ((TPM_PAYLOAD_TYPE) 0x05) ///< The entity is sealed data
+#define TPM_PT_MIGRATE_RESTRICTED   ((TPM_PAYLOAD_TYPE) 0x06) ///< The entity is a restricted-migration asymmetric key
+#define TPM_PT_MIGRATE_EXTERNAL     ((TPM_PAYLOAD_TYPE) 0x07) ///< The entity is a external migratable key
+#define TPM_PT_CMK_MIGRATE          ((TPM_PAYLOAD_TYPE) 0x08) ///< The entity is a CMK migratable blob
+#define TPM_PT_VENDOR_SPECIFIC      ((TPM_PAYLOAD_TYPE) 0x80) ///< 0x80 - 0xFF Vendor specific payloads
+
+//
+// Part 2, section 4.3: TPM_ENTITY_TYPE
+//
+#define TPM_ET_KEYHANDLE            ((UINT16) 0x0001) ///< The entity is a keyHandle or key
+#define TPM_ET_OWNER                ((UINT16) 0x0002) ///< The entity is the TPM Owner
+#define TPM_ET_DATA                 ((UINT16) 0x0003) ///< The entity is some data
+#define TPM_ET_SRK                  ((UINT16) 0x0004) ///< The entity is the SRK
+#define TPM_ET_KEY                  ((UINT16) 0x0005) ///< The entity is a key or keyHandle
+#define TPM_ET_REVOKE               ((UINT16) 0x0006) ///< The entity is the RevokeTrust value
+#define TPM_ET_DEL_OWNER_BLOB       ((UINT16) 0x0007) ///< The entity is a delegate owner blob
+#define TPM_ET_DEL_ROW              ((UINT16) 0x0008) ///< The entity is a delegate row
+#define TPM_ET_DEL_KEY_BLOB         ((UINT16) 0x0009) ///< The entity is a delegate key blob
+#define TPM_ET_COUNTER              ((UINT16) 0x000A) ///< The entity is a counter
+#define TPM_ET_NV                   ((UINT16) 0x000B) ///< The entity is a NV index
+#define TPM_ET_OPERATOR             ((UINT16) 0x000C) ///< The entity is the operator
+#define TPM_ET_RESERVED_HANDLE      ((UINT16) 0x0040) ///< Reserved. This value avoids collisions with the handle MSB setting.
+//
+// TPM_ENTITY_TYPE MSB Values: The MSB is used to indicate the ADIP encryption sheme when applicable
+//
+#define TPM_ET_XOR                  ((UINT16) 0x0000) ///< ADIP encryption scheme: XOR
+#define TPM_ET_AES128               ((UINT16) 0x0006) ///< ADIP encryption scheme: AES 128 bits
+
+//
+// Part 2, section 4.4.1: Reserved Key Handles
+//
+#define TPM_KH_SRK                  ((TPM_KEY_HANDLE) 0x40000000) ///< The handle points to the SRK
+#define TPM_KH_OWNER                ((TPM_KEY_HANDLE) 0x40000001) ///< The handle points to the TPM Owner
+#define TPM_KH_REVOKE               ((TPM_KEY_HANDLE) 0x40000002) ///< The handle points to the RevokeTrust value
+#define TPM_KH_TRANSPORT            ((TPM_KEY_HANDLE) 0x40000003) ///< The handle points to the EstablishTransport static authorization
+#define TPM_KH_OPERATOR             ((TPM_KEY_HANDLE) 0x40000004) ///< The handle points to the Operator auth
+#define TPM_KH_ADMIN                ((TPM_KEY_HANDLE) 0x40000005) ///< The handle points to the delegation administration auth
+#define TPM_KH_EK                   ((TPM_KEY_HANDLE) 0x40000006) ///< The handle points to the PUBEK, only usable with TPM_OwnerReadInternalPub
+
+//
+// Part 2, section 4.5: TPM_STARTUP_TYPE
+//
+#define TPM_ST_CLEAR                ((TPM_STARTUP_TYPE) 0x0001) ///< The TPM is starting up from a clean state
+#define TPM_ST_STATE                ((TPM_STARTUP_TYPE) 0x0002) ///< The TPM is starting up from a saved state
+#define TPM_ST_DEACTIVATED          ((TPM_STARTUP_TYPE) 0x0003) ///< The TPM is to startup and set the deactivated flag to TRUE
+
+//
+// Part 2, section 4.6: TPM_STATUP_EFFECTS
+// The table makeup is still an open issue.
+//
+
+//
+// Part 2, section 4.7: TPM_PROTOCOL_ID
+//
+#define TPM_PID_OIAP                ((TPM_PROTOCOL_ID) 0x0001) ///< The OIAP protocol.
+#define TPM_PID_OSAP                ((TPM_PROTOCOL_ID) 0x0002) ///< The OSAP protocol.
+#define TPM_PID_ADIP                ((TPM_PROTOCOL_ID) 0x0003) ///< The ADIP protocol.
+#define TPM_PID_ADCP                ((TPM_PROTOCOL_ID) 0x0004) ///< The ADCP protocol.
+#define TPM_PID_OWNER               ((TPM_PROTOCOL_ID) 0x0005) ///< The protocol for taking ownership of a TPM.
+#define TPM_PID_DSAP                ((TPM_PROTOCOL_ID) 0x0006) ///< The DSAP protocol
+#define TPM_PID_TRANSPORT           ((TPM_PROTOCOL_ID) 0x0007) ///< The transport protocol
+
+//
+// Part 2, section 4.8: TPM_ALGORITHM_ID
+//   The TPM MUST support the algorithms TPM_ALG_RSA, TPM_ALG_SHA, TPM_ALG_HMAC,
+//   TPM_ALG_MGF1
+//
+#define TPM_ALG_RSA                 ((TPM_ALGORITHM_ID) 0x00000001) ///< The RSA algorithm.
+#define TPM_ALG_DES                 ((TPM_ALGORITHM_ID) 0x00000002) ///< The DES algorithm
+#define TPM_ALG_3DES                ((TPM_ALGORITHM_ID) 0x00000003) ///< The 3DES algorithm in EDE mode
+#define TPM_ALG_SHA                 ((TPM_ALGORITHM_ID) 0x00000004) ///< The SHA1 algorithm
+#define TPM_ALG_HMAC                ((TPM_ALGORITHM_ID) 0x00000005) ///< The RFC 2104 HMAC algorithm
+#define TPM_ALG_AES128              ((TPM_ALGORITHM_ID) 0x00000006) ///< The AES algorithm, key size 128
+#define TPM_ALG_MGF1                ((TPM_ALGORITHM_ID) 0x00000007) ///< The XOR algorithm using MGF1 to create a string the size of the encrypted block
+#define TPM_ALG_AES192              ((TPM_ALGORITHM_ID) 0x00000008) ///< AES, key size 192
+#define TPM_ALG_AES256              ((TPM_ALGORITHM_ID) 0x00000009) ///< AES, key size 256
+#define TPM_ALG_XOR                 ((TPM_ALGORITHM_ID) 0x0000000A) ///< XOR using the rolling nonces
+
+//
+// Part 2, section 4.9: TPM_PHYSICAL_PRESENCE
+//
+#define TPM_PHYSICAL_PRESENCE_HW_DISABLE    ((TPM_PHYSICAL_PRESENCE) 0x0200) ///< Sets the physicalPresenceHWEnable to FALSE
+#define TPM_PHYSICAL_PRESENCE_CMD_DISABLE   ((TPM_PHYSICAL_PRESENCE) 0x0100) ///< Sets the physicalPresenceCMDEnable to FALSE
+#define TPM_PHYSICAL_PRESENCE_LIFETIME_LOCK ((TPM_PHYSICAL_PRESENCE) 0x0080) ///< Sets the physicalPresenceLifetimeLock to TRUE
+#define TPM_PHYSICAL_PRESENCE_HW_ENABLE     ((TPM_PHYSICAL_PRESENCE) 0x0040) ///< Sets the physicalPresenceHWEnable to TRUE
+#define TPM_PHYSICAL_PRESENCE_CMD_ENABLE    ((TPM_PHYSICAL_PRESENCE) 0x0020) ///< Sets the physicalPresenceCMDEnable to TRUE
+#define TPM_PHYSICAL_PRESENCE_NOTPRESENT    ((TPM_PHYSICAL_PRESENCE) 0x0010) ///< Sets PhysicalPresence = FALSE
+#define TPM_PHYSICAL_PRESENCE_PRESENT       ((TPM_PHYSICAL_PRESENCE) 0x0008) ///< Sets PhysicalPresence = TRUE
+#define TPM_PHYSICAL_PRESENCE_LOCK          ((TPM_PHYSICAL_PRESENCE) 0x0004) ///< Sets PhysicalPresenceLock = TRUE
+
+//
+// Part 2, section 4.10: TPM_MIGRATE_SCHEME
+//
+#define TPM_MS_MIGRATE                      ((TPM_MIGRATE_SCHEME) 0x0001) ///< A public key that can be used with all TPM migration commands other than 'ReWrap' mode.
+#define TPM_MS_REWRAP                       ((TPM_MIGRATE_SCHEME) 0x0002) ///< A public key that can be used for the ReWrap mode of TPM_CreateMigrationBlob.
+#define TPM_MS_MAINT                        ((TPM_MIGRATE_SCHEME) 0x0003) ///< A public key that can be used for the Maintenance commands
+#define TPM_MS_RESTRICT_MIGRATE             ((TPM_MIGRATE_SCHEME) 0x0004) ///< The key is to be migrated to a Migration Authority.
+#define TPM_MS_RESTRICT_APPROVE_DOUBLE      ((TPM_MIGRATE_SCHEME) 0x0005) ///< The key is to be migrated to an entity approved by a Migration Authority using double wrapping
+
+//
+// Part 2, section 4.11: TPM_EK_TYPE
+//
+#define TPM_EK_TYPE_ACTIVATE        ((TPM_EK_TYPE) 0x0001) ///< The blob MUST be TPM_EK_BLOB_ACTIVATE
+#define TPM_EK_TYPE_AUTH            ((TPM_EK_TYPE) 0x0002) ///< The blob MUST be TPM_EK_BLOB_AUTH
+
+//
+// Part 2, section 4.12: TPM_PLATFORM_SPECIFIC
+//
+#define TPM_PS_PC_11                ((TPM_PLATFORM_SPECIFIC) 0x0001) ///< PC Specific version 1.1
+#define TPM_PS_PC_12                ((TPM_PLATFORM_SPECIFIC) 0x0002) ///< PC Specific version 1.2
+#define TPM_PS_PDA_12               ((TPM_PLATFORM_SPECIFIC) 0x0003) ///< PDA Specific version 1.2
+#define TPM_PS_Server_12            ((TPM_PLATFORM_SPECIFIC) 0x0004) ///< Server Specific version 1.2
+#define TPM_PS_Mobile_12            ((TPM_PLATFORM_SPECIFIC) 0x0005) ///< Mobil Specific version 1.2
+
+//
+// Part 2, section 5: Basic Structures
+//
+
+///
+/// Part 2, section 5.1: TPM_STRUCT_VER
+///
+typedef struct tdTPM_STRUCT_VER {
+  UINT8                             major;
+  UINT8                             minor;
+  UINT8                             revMajor;
+  UINT8                             revMinor;
+} TPM_STRUCT_VER;
+
+///
+/// Part 2, section 5.3: TPM_VERSION
+///
+typedef struct tdTPM_VERSION {
+  TPM_VERSION_BYTE                  major;
+  TPM_VERSION_BYTE                  minor;
+  UINT8                             revMajor;
+  UINT8                             revMinor;
+} TPM_VERSION;
+
+
+#define TPM_SHA1_160_HASH_LEN       0x14
+#define TPM_SHA1BASED_NONCE_LEN     TPM_SHA1_160_HASH_LEN
+
+///
+/// Part 2, section 5.4: TPM_DIGEST
+///
+typedef struct tdTPM_DIGEST{
+  UINT8                             digest[TPM_SHA1_160_HASH_LEN];
+} TPM_DIGEST;
+
+///
+/// This SHALL be the digest of the chosen identityLabel and privacyCA for a new TPM identity
+///
+typedef TPM_DIGEST                  TPM_CHOSENID_HASH;
+///
+/// This SHALL be the hash of a list of PCR indexes and PCR values that a key or data is bound to
+///
+typedef TPM_DIGEST                  TPM_COMPOSITE_HASH;
+///
+/// This SHALL be the value of a DIR register
+///
+typedef TPM_DIGEST                  TPM_DIRVALUE;
+
+typedef TPM_DIGEST                  TPM_HMAC;
+///
+/// The value inside of the PCR
+///
+typedef TPM_DIGEST                  TPM_PCRVALUE;
+///
+/// This SHALL be the value of the current internal audit state
+///
+typedef TPM_DIGEST                  TPM_AUDITDIGEST;
+
+///
+/// Part 2, section 5.5: TPM_NONCE
+///
+typedef struct tdTPM_NONCE{
+  UINT8                             nonce[20];
+} TPM_NONCE;
+
+///
+/// This SHALL be a random value generated by a TPM immediately after the EK is installed
+/// in that TPM, whenever an EK is installed in that TPM
+///
+typedef TPM_NONCE                  TPM_DAA_TPM_SEED;
+///
+/// This SHALL be a random value
+///
+typedef TPM_NONCE                  TPM_DAA_CONTEXT_SEED;
+
+//
+// Part 2, section 5.6: TPM_AUTHDATA
+//
+///
+/// The AuthData data is the information that is saved or passed to provide proof of ownership
+/// 296 of an entity
+///
+typedef UINT8                       tdTPM_AUTHDATA[20];
+
+typedef tdTPM_AUTHDATA              TPM_AUTHDATA;
+///
+/// A secret plaintext value used in the authorization process
+///
+typedef TPM_AUTHDATA                TPM_SECRET;
+///
+/// A ciphertext (encrypted) version of AuthData data. The encryption mechanism depends on the context
+///
+typedef TPM_AUTHDATA                TPM_ENCAUTH;
+
+///
+/// Part 2, section 5.7: TPM_KEY_HANDLE_LIST
+/// Size of handle is loaded * sizeof(TPM_KEY_HANDLE)
+///
+typedef struct tdTPM_KEY_HANDLE_LIST {
+  UINT16                            loaded;
+  TPM_KEY_HANDLE                    handle[1];
+} TPM_KEY_HANDLE_LIST;
+
+//
+// Part 2, section 5.8: TPM_KEY_USAGE values
+//
+///
+/// TPM_KEY_SIGNING SHALL indicate a signing key. The [private] key SHALL be
+/// used for signing operations, only. This means that it MUST be a leaf of the
+/// Protected Storage key hierarchy.
+///
+#define TPM_KEY_SIGNING             ((UINT16) 0x0010)
+///
+/// TPM_KEY_STORAGE SHALL indicate a storage key. The key SHALL be used to wrap
+/// and unwrap other keys in the Protected Storage hierarchy
+///
+#define TPM_KEY_STORAGE             ((UINT16) 0x0011)
+///
+/// TPM_KEY_IDENTITY SHALL indicate an identity key. The key SHALL be used for
+/// operations that require a TPM identity, only.
+///
+#define TPM_KEY_IDENTITY            ((UINT16) 0x0012)
+///
+/// TPM_KEY_AUTHCHANGE SHALL indicate an ephemeral key that is in use during
+/// the ChangeAuthAsym process, only.
+///
+#define TPM_KEY_AUTHCHANGE          ((UINT16) 0x0013)
+///
+/// TPM_KEY_BIND SHALL indicate a key that can be used for TPM_Bind and
+/// TPM_Unbind operations only.
+///
+#define TPM_KEY_BIND                ((UINT16) 0x0014)
+///
+/// TPM_KEY_LEGACY SHALL indicate a key that can perform signing and binding
+/// operations. The key MAY be used for both signing and binding operations.
+/// The TPM_KEY_LEGACY key type is to allow for use by applications where both
+/// signing and encryption operations occur with the same key. The use of this
+/// key type is not recommended TPM_KEY_MIGRATE 0x0016 This SHALL indicate a
+/// key in use for TPM_MigrateKey
+///
+#define TPM_KEY_LEGACY              ((UINT16) 0x0015)
+///
+/// TPM_KEY_MIGRAGE SHALL indicate a key in use for TPM_MigrateKey
+///
+#define TPM_KEY_MIGRATE             ((UINT16) 0x0016)
+
+//
+// Part 2, section 5.8.1: Mandatory Key Usage Schemes
+//
+
+#define TPM_ES_NONE                 ((TPM_ENC_SCHEME) 0x0001)
+#define TPM_ES_RSAESPKCSv15         ((TPM_ENC_SCHEME) 0x0002)
+#define TPM_ES_RSAESOAEP_SHA1_MGF1  ((TPM_ENC_SCHEME) 0x0003)
+#define TPM_ES_SYM_CNT              ((TPM_ENC_SCHEME) 0x0004)  ///< rev94 defined
+#define TPM_ES_SYM_CTR              ((TPM_ENC_SCHEME) 0x0004)
+#define TPM_ES_SYM_OFB              ((TPM_ENC_SCHEME) 0x0005)
+
+#define TPM_SS_NONE                 ((TPM_SIG_SCHEME) 0x0001)
+#define TPM_SS_RSASSAPKCS1v15_SHA1  ((TPM_SIG_SCHEME) 0x0002)
+#define TPM_SS_RSASSAPKCS1v15_DER   ((TPM_SIG_SCHEME) 0x0003)
+#define TPM_SS_RSASSAPKCS1v15_INFO  ((TPM_SIG_SCHEME) 0x0004)
+
+//
+// Part 2, section 5.9: TPM_AUTH_DATA_USAGE values
+//
+#define TPM_AUTH_NEVER              ((TPM_AUTH_DATA_USAGE) 0x00)
+#define TPM_AUTH_ALWAYS             ((TPM_AUTH_DATA_USAGE) 0x01)
+#define TPM_AUTH_PRIV_USE_ONLY      ((TPM_AUTH_DATA_USAGE) 0x03)
+
+///
+/// Part 2, section 5.10: TPM_KEY_FLAGS
+///
+typedef enum tdTPM_KEY_FLAGS {
+  redirection                       = 0x00000001,
+  migratable                        = 0x00000002,
+  isVolatile                        = 0x00000004,
+  pcrIgnoredOnRead                  = 0x00000008,
+  migrateAuthority                  = 0x00000010
+} TPM_KEY_FLAGS_BITS;
+
+///
+/// Part 2, section 5.11: TPM_CHANGEAUTH_VALIDATE
+///
+typedef struct tdTPM_CHANGEAUTH_VALIDATE {
+  TPM_SECRET                        newAuthSecret;
+  TPM_NONCE                         n1;
+} TPM_CHANGEAUTH_VALIDATE;
+
+///
+/// Part 2, section 5.12: TPM_MIGRATIONKEYAUTH
+///   declared after section 10 to catch declaration of TPM_PUBKEY
+///
+/// Part 2 section 10.1: TPM_KEY_PARMS
+///   [size_is(parmSize)] BYTE* parms;
+///
+typedef struct tdTPM_KEY_PARMS {
+  TPM_ALGORITHM_ID                  algorithmID;
+  TPM_ENC_SCHEME                    encScheme;
+  TPM_SIG_SCHEME                    sigScheme;
+  UINT32                            parmSize;
+  UINT8                             *parms;
+} TPM_KEY_PARMS;
+
+///
+/// Part 2, section 10.4: TPM_STORE_PUBKEY
+///
+typedef struct tdTPM_STORE_PUBKEY {
+  UINT32                            keyLength;
+  UINT8                             key[1];
+} TPM_STORE_PUBKEY;
+
+///
+/// Part 2, section 10.5: TPM_PUBKEY
+///
+typedef struct tdTPM_PUBKEY{
+  TPM_KEY_PARMS                     algorithmParms;
+  TPM_STORE_PUBKEY                  pubKey;
+} TPM_PUBKEY;
+
+///
+/// Part 2, section 5.12: TPM_MIGRATIONKEYAUTH
+///
+typedef struct tdTPM_MIGRATIONKEYAUTH{
+  TPM_PUBKEY                        migrationKey;
+  TPM_MIGRATE_SCHEME                migrationScheme;
+  TPM_DIGEST                        digest;
+} TPM_MIGRATIONKEYAUTH;
+
+///
+/// Part 2, section 5.13: TPM_COUNTER_VALUE
+///
+typedef struct tdTPM_COUNTER_VALUE{
+  TPM_STRUCTURE_TAG                 tag;
+  UINT8                             label[4];
+  TPM_ACTUAL_COUNT                  counter;
+} TPM_COUNTER_VALUE;
+
+///
+/// Part 2, section 5.14: TPM_SIGN_INFO
+///   Size of data indicated by dataLen
+///
+typedef struct tdTPM_SIGN_INFO {
+  TPM_STRUCTURE_TAG                 tag;
+  UINT8                             fixed[4];
+  TPM_NONCE                         replay;
+  UINT32                            dataLen;
+  UINT8                             *data;
+} TPM_SIGN_INFO;
+
+///
+/// Part 2, section 5.15: TPM_MSA_COMPOSITE
+///   Number of migAuthDigest indicated by MSAlist
+///
+typedef struct tdTPM_MSA_COMPOSITE {
+  UINT32                            MSAlist;
+  TPM_DIGEST                        migAuthDigest[1];
+} TPM_MSA_COMPOSITE;
+
+///
+/// Part 2, section 5.16: TPM_CMK_AUTH
+///
+typedef struct tdTPM_CMK_AUTH{
+  TPM_DIGEST                        migrationAuthorityDigest;
+  TPM_DIGEST                        destinationKeyDigest;
+  TPM_DIGEST                        sourceKeyDigest;
+} TPM_CMK_AUTH;
+
+//
+// Part 2, section 5.17: TPM_CMK_DELEGATE
+//
+#define TPM_CMK_DELEGATE_SIGNING    ((TPM_CMK_DELEGATE) BIT31)
+#define TPM_CMK_DELEGATE_STORAGE    ((TPM_CMK_DELEGATE) BIT30)
+#define TPM_CMK_DELEGATE_BIND       ((TPM_CMK_DELEGATE) BIT29)
+#define TPM_CMK_DELEGATE_LEGACY     ((TPM_CMK_DELEGATE) BIT28)
+#define TPM_CMK_DELEGATE_MIGRATE    ((TPM_CMK_DELEGATE) BIT27)
+
+///
+/// Part 2, section 5.18: TPM_SELECT_SIZE
+///
+typedef struct tdTPM_SELECT_SIZE {
+  UINT8                             major;
+  UINT8                             minor;
+  UINT16                            reqSize;
+} TPM_SELECT_SIZE;
+
+///
+/// Part 2, section 5,19: TPM_CMK_MIGAUTH
+///
+typedef struct tdTPM_CMK_MIGAUTH{
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_DIGEST                        msaDigest;
+  TPM_DIGEST                        pubKeyDigest;
+} TPM_CMK_MIGAUTH;
+
+///
+/// Part 2, section 5.20: TPM_CMK_SIGTICKET
+///
+typedef struct tdTPM_CMK_SIGTICKET{
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_DIGEST                        verKeyDigest;
+  TPM_DIGEST                        signedData;
+} TPM_CMK_SIGTICKET;
+
+///
+/// Part 2, section 5.21: TPM_CMK_MA_APPROVAL
+///
+typedef struct tdTPM_CMK_MA_APPROVAL{
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_DIGEST                        migrationAuthorityDigest;
+} TPM_CMK_MA_APPROVAL;
+
+//
+// Part 2, section 6: Command Tags
+//
+#define TPM_TAG_RQU_COMMAND         ((TPM_STRUCTURE_TAG) 0x00C1)
+#define TPM_TAG_RQU_AUTH1_COMMAND   ((TPM_STRUCTURE_TAG) 0x00C2)
+#define TPM_TAG_RQU_AUTH2_COMMAND   ((TPM_STRUCTURE_TAG) 0x00C3)
+#define TPM_TAG_RSP_COMMAND         ((TPM_STRUCTURE_TAG) 0x00C4)
+#define TPM_TAG_RSP_AUTH1_COMMAND   ((TPM_STRUCTURE_TAG) 0x00C5)
+#define TPM_TAG_RSP_AUTH2_COMMAND   ((TPM_STRUCTURE_TAG) 0x00C6)
+
+///
+/// Part 2, section 7.1: TPM_PERMANENT_FLAGS
+///
+typedef struct tdTPM_PERMANENT_FLAGS{
+  TPM_STRUCTURE_TAG                 tag;
+  BOOLEAN                           disable;
+  BOOLEAN                           ownership;
+  BOOLEAN                           deactivated;
+  BOOLEAN                           readPubek;
+  BOOLEAN                           disableOwnerClear;
+  BOOLEAN                           allowMaintenance;
+  BOOLEAN                           physicalPresenceLifetimeLock;
+  BOOLEAN                           physicalPresenceHWEnable;
+  BOOLEAN                           physicalPresenceCMDEnable;
+  BOOLEAN                           CEKPUsed;
+  BOOLEAN                           TPMpost;
+  BOOLEAN                           TPMpostLock;
+  BOOLEAN                           FIPS;
+  BOOLEAN                           operator;
+  BOOLEAN                           enableRevokeEK;
+  BOOLEAN                           nvLocked;
+  BOOLEAN                           readSRKPub;
+  BOOLEAN                           tpmEstablished;
+  BOOLEAN                           maintenanceDone;
+  BOOLEAN                           disableFullDALogicInfo;
+} TPM_PERMANENT_FLAGS;
+
+//
+// Part 2, section 7.1.1: Flag Restrictions (of TPM_PERMANENT_FLAGS)
+//
+#define TPM_PF_DISABLE                      ((TPM_CAPABILITY_AREA) 1)
+#define TPM_PF_OWNERSHIP                    ((TPM_CAPABILITY_AREA) 2)
+#define TPM_PF_DEACTIVATED                  ((TPM_CAPABILITY_AREA) 3)
+#define TPM_PF_READPUBEK                    ((TPM_CAPABILITY_AREA) 4)
+#define TPM_PF_DISABLEOWNERCLEAR            ((TPM_CAPABILITY_AREA) 5)
+#define TPM_PF_ALLOWMAINTENANCE             ((TPM_CAPABILITY_AREA) 6)
+#define TPM_PF_PHYSICALPRESENCELIFETIMELOCK ((TPM_CAPABILITY_AREA) 7)
+#define TPM_PF_PHYSICALPRESENCEHWENABLE     ((TPM_CAPABILITY_AREA) 8)
+#define TPM_PF_PHYSICALPRESENCECMDENABLE    ((TPM_CAPABILITY_AREA) 9)
+#define TPM_PF_CEKPUSED                     ((TPM_CAPABILITY_AREA) 10)
+#define TPM_PF_TPMPOST                      ((TPM_CAPABILITY_AREA) 11)
+#define TPM_PF_TPMPOSTLOCK                  ((TPM_CAPABILITY_AREA) 12)
+#define TPM_PF_FIPS                         ((TPM_CAPABILITY_AREA) 13)
+#define TPM_PF_OPERATOR                     ((TPM_CAPABILITY_AREA) 14)
+#define TPM_PF_ENABLEREVOKEEK               ((TPM_CAPABILITY_AREA) 15)
+#define TPM_PF_NV_LOCKED                    ((TPM_CAPABILITY_AREA) 16)
+#define TPM_PF_READSRKPUB                   ((TPM_CAPABILITY_AREA) 17)
+#define TPM_PF_TPMESTABLISHED               ((TPM_CAPABILITY_AREA) 18)
+#define TPM_PF_MAINTENANCEDONE              ((TPM_CAPABILITY_AREA) 19)
+#define TPM_PF_DISABLEFULLDALOGICINFO       ((TPM_CAPABILITY_AREA) 20)
+
+///
+/// Part 2, section 7.2: TPM_STCLEAR_FLAGS
+///
+typedef struct tdTPM_STCLEAR_FLAGS{
+  TPM_STRUCTURE_TAG                 tag;
+  BOOLEAN                           deactivated;
+  BOOLEAN                           disableForceClear;
+  BOOLEAN                           physicalPresence;
+  BOOLEAN                           physicalPresenceLock;
+  BOOLEAN                           bGlobalLock;
+} TPM_STCLEAR_FLAGS;
+
+//
+// Part 2, section 7.2.1: Flag Restrictions (of TPM_STCLEAR_FLAGS)
+//
+#define TPM_SF_DEACTIVATED          ((TPM_CAPABILITY_AREA) 1)
+#define TPM_SF_DISABLEFORCECLEAR    ((TPM_CAPABILITY_AREA) 2)
+#define TPM_SF_PHYSICALPRESENCE     ((TPM_CAPABILITY_AREA) 3)
+#define TPM_SF_PHYSICALPRESENCELOCK ((TPM_CAPABILITY_AREA) 4)
+#define TPM_SF_BGLOBALLOCK          ((TPM_CAPABILITY_AREA) 5)
+
+///
+/// Part 2, section 7.3: TPM_STANY_FLAGS
+///
+typedef struct tdTPM_STANY_FLAGS{
+  TPM_STRUCTURE_TAG                 tag;
+  BOOLEAN                           postInitialise;
+  TPM_MODIFIER_INDICATOR            localityModifier;
+  BOOLEAN                           transportExclusive;
+  BOOLEAN                           TOSPresent;
+} TPM_STANY_FLAGS;
+
+//
+// Part 2, section 7.3.1: Flag Restrictions (of TPM_STANY_FLAGS)
+//
+#define TPM_AF_POSTINITIALISE       ((TPM_CAPABILITY_AREA) 1)
+#define TPM_AF_LOCALITYMODIFIER     ((TPM_CAPABILITY_AREA) 2)
+#define TPM_AF_TRANSPORTEXCLUSIVE   ((TPM_CAPABILITY_AREA) 3)
+#define TPM_AF_TOSPRESENT           ((TPM_CAPABILITY_AREA) 4)
+
+//
+// All those structures defined in section 7.4, 7.5, 7.6 are not normative and
+// thus no definitions here
+//
+// Part 2, section 7.4: TPM_PERMANENT_DATA
+//
+#define TPM_MIN_COUNTERS            4   ///< the minimum number of counters is 4
+#define TPM_DELEGATE_KEY            TPM_KEY
+#define TPM_NUM_PCR                 16
+#define TPM_MAX_NV_WRITE_NOOWNER    64
+
+//
+// Part 2, section 7.4.1: PERMANENT_DATA Subcap for SetCapability
+//
+#define TPM_PD_REVMAJOR               ((TPM_CAPABILITY_AREA) 1)
+#define TPM_PD_REVMINOR               ((TPM_CAPABILITY_AREA) 2)
+#define TPM_PD_TPMPROOF               ((TPM_CAPABILITY_AREA) 3)
+#define TPM_PD_OWNERAUTH              ((TPM_CAPABILITY_AREA) 4)
+#define TPM_PD_OPERATORAUTH           ((TPM_CAPABILITY_AREA) 5)
+#define TPM_PD_MANUMAINTPUB           ((TPM_CAPABILITY_AREA) 6)
+#define TPM_PD_ENDORSEMENTKEY         ((TPM_CAPABILITY_AREA) 7)
+#define TPM_PD_SRK                    ((TPM_CAPABILITY_AREA) 8)
+#define TPM_PD_DELEGATEKEY            ((TPM_CAPABILITY_AREA) 9)
+#define TPM_PD_CONTEXTKEY             ((TPM_CAPABILITY_AREA) 10)
+#define TPM_PD_AUDITMONOTONICCOUNTER  ((TPM_CAPABILITY_AREA) 11)
+#define TPM_PD_MONOTONICCOUNTER       ((TPM_CAPABILITY_AREA) 12)
+#define TPM_PD_PCRATTRIB              ((TPM_CAPABILITY_AREA) 13)
+#define TPM_PD_ORDINALAUDITSTATUS     ((TPM_CAPABILITY_AREA) 14)
+#define TPM_PD_AUTHDIR                ((TPM_CAPABILITY_AREA) 15)
+#define TPM_PD_RNGSTATE               ((TPM_CAPABILITY_AREA) 16)
+#define TPM_PD_FAMILYTABLE            ((TPM_CAPABILITY_AREA) 17)
+#define TPM_DELEGATETABLE             ((TPM_CAPABILITY_AREA) 18)
+#define TPM_PD_EKRESET                ((TPM_CAPABILITY_AREA) 19)
+#define TPM_PD_MAXNVBUFSIZE           ((TPM_CAPABILITY_AREA) 20)
+#define TPM_PD_LASTFAMILYID           ((TPM_CAPABILITY_AREA) 21)
+#define TPM_PD_NOOWNERNVWRITE         ((TPM_CAPABILITY_AREA) 22)
+#define TPM_PD_RESTRICTDELEGATE       ((TPM_CAPABILITY_AREA) 23)
+#define TPM_PD_TPMDAASEED             ((TPM_CAPABILITY_AREA) 24)
+#define TPM_PD_DAAPROOF               ((TPM_CAPABILITY_AREA) 25)
+
+///
+/// Part 2, section 7.5: TPM_STCLEAR_DATA
+///   available inside TPM only
+///
+ typedef struct tdTPM_STCLEAR_DATA{
+   TPM_STRUCTURE_TAG                  tag;
+   TPM_NONCE                          contextNonceKey;
+   TPM_COUNT_ID                       countID;
+   UINT32                             ownerReference;
+   BOOLEAN                            disableResetLock;
+   TPM_PCRVALUE                       PCR[TPM_NUM_PCR];
+   UINT32                             deferredPhysicalPresence;
+ }TPM_STCLEAR_DATA;
+
+//
+// Part 2, section 7.5.1: STCLEAR_DATA Subcap for SetCapability
+//
+#define TPM_SD_CONTEXTNONCEKEY            ((TPM_CAPABILITY_AREA)0x00000001)
+#define TPM_SD_COUNTID                    ((TPM_CAPABILITY_AREA)0x00000002)
+#define TPM_SD_OWNERREFERENCE             ((TPM_CAPABILITY_AREA)0x00000003)
+#define TPM_SD_DISABLERESETLOCK           ((TPM_CAPABILITY_AREA)0x00000004)
+#define TPM_SD_PCR                        ((TPM_CAPABILITY_AREA)0x00000005)
+#define TPM_SD_DEFERREDPHYSICALPRESENCE   ((TPM_CAPABILITY_AREA)0x00000006)
+
+//
+// Part 2, section 7.6.1: STANY_DATA Subcap for SetCapability
+//
+#define TPM_AD_CONTEXTNONCESESSION        ((TPM_CAPABILITY_AREA) 1)
+#define TPM_AD_AUDITDIGEST                ((TPM_CAPABILITY_AREA) 2)
+#define TPM_AD_CURRENTTICKS               ((TPM_CAPABILITY_AREA) 3)
+#define TPM_AD_CONTEXTCOUNT               ((TPM_CAPABILITY_AREA) 4)
+#define TPM_AD_CONTEXTLIST                ((TPM_CAPABILITY_AREA) 5)
+#define TPM_AD_SESSIONS                   ((TPM_CAPABILITY_AREA) 6)
+
+//
+// Part 2, section 8: PCR Structures
+//
+
+///
+/// Part 2, section 8.1: TPM_PCR_SELECTION
+///   Size of pcrSelect[] indicated by sizeOfSelect
+///
+typedef struct tdTPM_PCR_SELECTION {
+  UINT16                            sizeOfSelect;
+  UINT8                             pcrSelect[1];
+} TPM_PCR_SELECTION;
+
+///
+/// Part 2, section 8.2: TPM_PCR_COMPOSITE
+///   Size of pcrValue[] indicated by valueSize
+///
+typedef struct tdTPM_PCR_COMPOSITE {
+  TPM_PCR_SELECTION                 select;
+  UINT32                            valueSize;
+  TPM_PCRVALUE                      pcrValue[1];
+} TPM_PCR_COMPOSITE;
+
+///
+/// Part 2, section 8.3: TPM_PCR_INFO
+///
+typedef struct tdTPM_PCR_INFO {
+  TPM_PCR_SELECTION                 pcrSelection;
+  TPM_COMPOSITE_HASH                digestAtRelease;
+  TPM_COMPOSITE_HASH                digestAtCreation;
+} TPM_PCR_INFO;
+
+///
+/// Part 2, section 8.6: TPM_LOCALITY_SELECTION
+///
+typedef UINT8                       TPM_LOCALITY_SELECTION;
+
+#define TPM_LOC_FOUR                ((UINT8) 0x10)
+#define TPM_LOC_THREE               ((UINT8) 0x08)
+#define TPM_LOC_TWO                 ((UINT8) 0x04)
+#define TPM_LOC_ONE                 ((UINT8) 0x02)
+#define TPM_LOC_ZERO                ((UINT8) 0x01)
+
+///
+/// Part 2, section 8.4: TPM_PCR_INFO_LONG
+///
+typedef struct tdTPM_PCR_INFO_LONG {
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_LOCALITY_SELECTION            localityAtCreation;
+  TPM_LOCALITY_SELECTION            localityAtRelease;
+  TPM_PCR_SELECTION                 creationPCRSelection;
+  TPM_PCR_SELECTION                 releasePCRSelection;
+  TPM_COMPOSITE_HASH                digestAtCreation;
+  TPM_COMPOSITE_HASH                digestAtRelease;
+} TPM_PCR_INFO_LONG;
+
+///
+/// Part 2, section 8.5: TPM_PCR_INFO_SHORT
+///
+typedef struct tdTPM_PCR_INFO_SHORT{
+  TPM_PCR_SELECTION                 pcrSelection;
+  TPM_LOCALITY_SELECTION            localityAtRelease;
+  TPM_COMPOSITE_HASH                digestAtRelease;
+} TPM_PCR_INFO_SHORT;
+
+///
+/// Part 2, section 8.8: TPM_PCR_ATTRIBUTES
+///
+typedef struct tdTPM_PCR_ATTRIBUTES{
+  BOOLEAN                           pcrReset;
+  TPM_LOCALITY_SELECTION            pcrExtendLocal;
+  TPM_LOCALITY_SELECTION            pcrResetLocal;
+} TPM_PCR_ATTRIBUTES;
+
+//
+// Part 2, section 9: Storage Structures
+//
+
+///
+/// Part 2, section 9.1: TPM_STORED_DATA
+///   [size_is(sealInfoSize)] BYTE* sealInfo;
+///   [size_is(encDataSize)] BYTE* encData;
+///
+typedef struct tdTPM_STORED_DATA {
+  TPM_STRUCT_VER                    ver;
+  UINT32                            sealInfoSize;
+  UINT8                             *sealInfo;
+  UINT32                            encDataSize;
+  UINT8                             *encData;
+} TPM_STORED_DATA;
+
+///
+/// Part 2, section 9.2: TPM_STORED_DATA12
+///   [size_is(sealInfoSize)] BYTE* sealInfo;
+///   [size_is(encDataSize)] BYTE* encData;
+///
+typedef struct tdTPM_STORED_DATA12 {
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_ENTITY_TYPE                   et;
+  UINT32                            sealInfoSize;
+  UINT8                             *sealInfo;
+  UINT32                            encDataSize;
+  UINT8                             *encData;
+} TPM_STORED_DATA12;
+
+///
+/// Part 2, section 9.3: TPM_SEALED_DATA
+///   [size_is(dataSize)] BYTE* data;
+///
+typedef struct tdTPM_SEALED_DATA {
+  TPM_PAYLOAD_TYPE                  payload;
+  TPM_SECRET                        authData;
+  TPM_NONCE                         tpmProof;
+  TPM_DIGEST                        storedDigest;
+  UINT32                            dataSize;
+  UINT8                             *data;
+} TPM_SEALED_DATA;
+
+///
+/// Part 2, section 9.4: TPM_SYMMETRIC_KEY
+///   [size_is(size)] BYTE* data;
+///
+typedef struct tdTPM_SYMMETRIC_KEY {
+  TPM_ALGORITHM_ID                  algId;
+  TPM_ENC_SCHEME                    encScheme;
+  UINT16                            dataSize;
+  UINT8                             *data;
+} TPM_SYMMETRIC_KEY;
+
+///
+/// Part 2, section 9.5: TPM_BOUND_DATA
+///
+typedef struct tdTPM_BOUND_DATA {
+  TPM_STRUCT_VER                    ver;
+  TPM_PAYLOAD_TYPE                  payload;
+  UINT8                             payloadData[1];
+} TPM_BOUND_DATA;
+
+//
+// Part 2 section 10: TPM_KEY complex
+//
+
+//
+// Section 10.1, 10.4, and 10.5 have been defined previously
+//
+
+///
+/// Part 2, section 10.2: TPM_KEY
+///   [size_is(encDataSize)] BYTE* encData;
+///
+typedef struct tdTPM_KEY{
+  TPM_STRUCT_VER                    ver;
+  TPM_KEY_USAGE                     keyUsage;
+  TPM_KEY_FLAGS                     keyFlags;
+  TPM_AUTH_DATA_USAGE               authDataUsage;
+  TPM_KEY_PARMS                     algorithmParms;
+  UINT32                            PCRInfoSize;
+  UINT8                             *PCRInfo;
+  TPM_STORE_PUBKEY                  pubKey;
+  UINT32                            encDataSize;
+  UINT8                             *encData;
+} TPM_KEY;
+
+///
+/// Part 2, section 10.3: TPM_KEY12
+///   [size_is(encDataSize)] BYTE* encData;
+///
+typedef struct tdTPM_KEY12{
+  TPM_STRUCTURE_TAG                 tag;
+  UINT16                            fill;
+  TPM_KEY_USAGE                     keyUsage;
+  TPM_KEY_FLAGS                     keyFlags;
+  TPM_AUTH_DATA_USAGE               authDataUsage;
+  TPM_KEY_PARMS                     algorithmParms;
+  UINT32                            PCRInfoSize;
+  UINT8                             *PCRInfo;
+  TPM_STORE_PUBKEY                  pubKey;
+  UINT32                            encDataSize;
+  UINT8                             *encData;
+} TPM_KEY12;
+
+///
+/// Part 2, section 10.7: TPM_STORE_PRIVKEY
+///   [size_is(keyLength)] BYTE* key;
+///
+typedef struct tdTPM_STORE_PRIVKEY {
+  UINT32                            keyLength;
+  UINT8                             *key;
+} TPM_STORE_PRIVKEY;
+
+///
+/// Part 2, section 10.6: TPM_STORE_ASYMKEY
+///
+typedef struct tdTPM_STORE_ASYMKEY {                // pos len total
+  TPM_PAYLOAD_TYPE                  payload;        // 0    1   1
+  TPM_SECRET                        usageAuth;      // 1    20  21
+  TPM_SECRET                        migrationAuth;  // 21   20  41
+  TPM_DIGEST                        pubDataDigest;  // 41   20  61
+  TPM_STORE_PRIVKEY                 privKey;        // 61 132-151 193-214
+} TPM_STORE_ASYMKEY;
+
+///
+/// Part 2, section 10.8: TPM_MIGRATE_ASYMKEY
+///   [size_is(partPrivKeyLen)] BYTE* partPrivKey;
+///
+typedef struct tdTPM_MIGRATE_ASYMKEY {              // pos  len  total
+  TPM_PAYLOAD_TYPE                  payload;        //   0    1       1
+  TPM_SECRET                        usageAuth;      //   1   20      21
+  TPM_DIGEST                        pubDataDigest;  //  21   20      41
+  UINT32                            partPrivKeyLen; //  41    4      45
+  UINT8                             *partPrivKey;   //  45 112-127 157-172
+} TPM_MIGRATE_ASYMKEY;
+
+///
+/// Part 2, section 10.9: TPM_KEY_CONTROL
+///
+#define TPM_KEY_CONTROL_OWNER_EVICT ((UINT32) 0x00000001)
+
+//
+// Part 2, section 11: Signed Structures
+//
+
+///
+/// Part 2, section 11.1: TPM_CERTIFY_INFO Structure
+///
+typedef struct tdTPM_CERTIFY_INFO {
+  TPM_STRUCT_VER                  version;
+  TPM_KEY_USAGE                   keyUsage;
+  TPM_KEY_FLAGS                   keyFlags;
+  TPM_AUTH_DATA_USAGE             authDataUsage;
+  TPM_KEY_PARMS                   algorithmParms;
+  TPM_DIGEST                      pubkeyDigest;
+  TPM_NONCE                       data;
+  BOOLEAN                         parentPCRStatus;
+  UINT32                          PCRInfoSize;
+  UINT8                           *PCRInfo;
+} TPM_CERTIFY_INFO;
+
+///
+/// Part 2, section 11.2: TPM_CERTIFY_INFO2 Structure
+///
+typedef struct tdTPM_CERTIFY_INFO2 {
+  TPM_STRUCTURE_TAG               tag;
+  UINT8                           fill;
+  TPM_PAYLOAD_TYPE                payloadType;
+  TPM_KEY_USAGE                   keyUsage;
+  TPM_KEY_FLAGS                   keyFlags;
+  TPM_AUTH_DATA_USAGE             authDataUsage;
+  TPM_KEY_PARMS                   algorithmParms;
+  TPM_DIGEST                      pubkeyDigest;
+  TPM_NONCE                       data;
+  BOOLEAN                         parentPCRStatus;
+  UINT32                          PCRInfoSize;
+  UINT8                           *PCRInfo;
+  UINT32                          migrationAuthoritySize;
+  UINT8                           *migrationAuthority;
+} TPM_CERTIFY_INFO2;
+
+///
+/// Part 2, section 11.3 TPM_QUOTE_INFO Structure
+///
+typedef struct tdTPM_QUOTE_INFO {
+  TPM_STRUCT_VER                  version;
+  UINT8                           fixed[4];
+  TPM_COMPOSITE_HASH              digestValue;
+  TPM_NONCE                       externalData;
+} TPM_QUOTE_INFO;
+
+///
+/// Part 2, section 11.4 TPM_QUOTE_INFO2 Structure
+///
+typedef struct tdTPM_QUOTE_INFO2 {
+  TPM_STRUCTURE_TAG               tag;
+  UINT8                           fixed[4];
+  TPM_NONCE                       externalData;
+  TPM_PCR_INFO_SHORT              infoShort;
+} TPM_QUOTE_INFO2;
+
+//
+// Part 2, section 12: Identity Structures
+//
+
+///
+/// Part 2, section 12.1 TPM_EK_BLOB
+///
+typedef struct tdTPM_EK_BLOB {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_EK_TYPE                     ekType;
+  UINT32                          blobSize;
+  UINT8                           *blob;
+} TPM_EK_BLOB;
+
+///
+/// Part 2, section 12.2 TPM_EK_BLOB_ACTIVATE
+///
+typedef struct tdTPM_EK_BLOB_ACTIVATE {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_SYMMETRIC_KEY               sessionKey;
+  TPM_DIGEST                      idDigest;
+  TPM_PCR_INFO_SHORT              pcrInfo;
+} TPM_EK_BLOB_ACTIVATE;
+
+///
+/// Part 2, section 12.3 TPM_EK_BLOB_AUTH
+///
+typedef struct tdTPM_EK_BLOB_AUTH {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_SECRET                      authValue;
+} TPM_EK_BLOB_AUTH;
+
+
+///
+/// Part 2, section 12.5 TPM_IDENTITY_CONTENTS
+///
+typedef struct tdTPM_IDENTITY_CONTENTS {
+  TPM_STRUCT_VER                  ver;
+  UINT32                          ordinal;
+  TPM_CHOSENID_HASH               labelPrivCADigest;
+  TPM_PUBKEY                      identityPubKey;
+} TPM_IDENTITY_CONTENTS;
+
+///
+/// Part 2, section 12.6 TPM_IDENTITY_REQ
+///
+typedef struct tdTPM_IDENTITY_REQ {
+  UINT32                          asymSize;
+  UINT32                          symSize;
+  TPM_KEY_PARMS                   asymAlgorithm;
+  TPM_KEY_PARMS                   symAlgorithm;
+  UINT8                           *asymBlob;
+  UINT8                           *symBlob;
+} TPM_IDENTITY_REQ;
+
+///
+/// Part 2, section 12.7 TPM_IDENTITY_PROOF
+///
+typedef struct tdTPM_IDENTITY_PROOF {
+  TPM_STRUCT_VER                  ver;
+  UINT32                          labelSize;
+  UINT32                          identityBindingSize;
+  UINT32                          endorsementSize;
+  UINT32                          platformSize;
+  UINT32                          conformanceSize;
+  TPM_PUBKEY                      identityKey;
+  UINT8                           *labelArea;
+  UINT8                           *identityBinding;
+  UINT8                           *endorsementCredential;
+  UINT8                           *platformCredential;
+  UINT8                           *conformanceCredential;
+} TPM_IDENTITY_PROOF;
+
+///
+/// Part 2, section 12.8 TPM_ASYM_CA_CONTENTS
+///
+typedef struct tdTPM_ASYM_CA_CONTENTS {
+  TPM_SYMMETRIC_KEY               sessionKey;
+  TPM_DIGEST                      idDigest;
+} TPM_ASYM_CA_CONTENTS;
+
+///
+/// Part 2, section 12.9 TPM_SYM_CA_ATTESTATION
+///
+typedef struct tdTPM_SYM_CA_ATTESTATION {
+  UINT32                          credSize;
+  TPM_KEY_PARMS                   algorithm;
+  UINT8                           *credential;
+} TPM_SYM_CA_ATTESTATION;
+
+///
+/// Part 2, section 15: Tick Structures
+///   Placed here out of order because definitions are used in section 13.
+///
+typedef struct tdTPM_CURRENT_TICKS {
+  TPM_STRUCTURE_TAG                 tag;
+  UINT64                            currentTicks;
+  UINT16                            tickRate;
+  TPM_NONCE                         tickNonce;
+} TPM_CURRENT_TICKS;
+
+///
+/// Part 2, section 13: Transport structures
+///
+
+///
+/// Part 2, section 13.1: TPM _TRANSPORT_PUBLIC
+///
+typedef struct tdTPM_TRANSPORT_PUBLIC {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_TRANSPORT_ATTRIBUTES        transAttributes;
+  TPM_ALGORITHM_ID                algId;
+  TPM_ENC_SCHEME                  encScheme;
+} TPM_TRANSPORT_PUBLIC;
+
+//
+// Part 2, section 13.1.1 TPM_TRANSPORT_ATTRIBUTES Definitions
+//
+#define TPM_TRANSPORT_ENCRYPT       ((UINT32)BIT0)
+#define TPM_TRANSPORT_LOG           ((UINT32)BIT1)
+#define TPM_TRANSPORT_EXCLUSIVE     ((UINT32)BIT2)
+
+///
+/// Part 2, section 13.2 TPM_TRANSPORT_INTERNAL
+///
+typedef struct tdTPM_TRANSPORT_INTERNAL {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_AUTHDATA                    authData;
+  TPM_TRANSPORT_PUBLIC            transPublic;
+  TPM_TRANSHANDLE                 transHandle;
+  TPM_NONCE                       transNonceEven;
+  TPM_DIGEST                      transDigest;
+} TPM_TRANSPORT_INTERNAL;
+
+///
+/// Part 2, section 13.3 TPM_TRANSPORT_LOG_IN structure
+///
+typedef struct tdTPM_TRANSPORT_LOG_IN {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DIGEST                      parameters;
+  TPM_DIGEST                      pubKeyHash;
+} TPM_TRANSPORT_LOG_IN;
+
+///
+/// Part 2, section 13.4 TPM_TRANSPORT_LOG_OUT structure
+///
+typedef struct tdTPM_TRANSPORT_LOG_OUT {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_CURRENT_TICKS               currentTicks;
+  TPM_DIGEST                      parameters;
+  TPM_MODIFIER_INDICATOR          locality;
+} TPM_TRANSPORT_LOG_OUT;
+
+///
+/// Part 2, section 13.5 TPM_TRANSPORT_AUTH structure
+///
+typedef struct tdTPM_TRANSPORT_AUTH {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_AUTHDATA                    authData;
+} TPM_TRANSPORT_AUTH;
+
+//
+// Part 2, section 14: Audit Structures
+//
+
+///
+/// Part 2, section 14.1 TPM_AUDIT_EVENT_IN structure
+///
+typedef struct tdTPM_AUDIT_EVENT_IN {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DIGEST                      inputParms;
+  TPM_COUNTER_VALUE               auditCount;
+} TPM_AUDIT_EVENT_IN;
+
+///
+/// Part 2, section 14.2 TPM_AUDIT_EVENT_OUT structure
+///
+typedef struct tdTPM_AUDIT_EVENT_OUT {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_COMMAND_CODE                ordinal;
+  TPM_DIGEST                      outputParms;
+  TPM_COUNTER_VALUE               auditCount;
+  TPM_RESULT                      returnCode;
+} TPM_AUDIT_EVENT_OUT;
+
+//
+// Part 2, section 16: Return Codes
+//
+
+#define TPM_VENDOR_ERROR            TPM_Vendor_Specific32
+#define TPM_NON_FATAL               0x00000800
+
+#define TPM_SUCCESS                 ((TPM_RESULT) TPM_BASE)
+#define TPM_AUTHFAIL                ((TPM_RESULT) (TPM_BASE + 1))
+#define TPM_BADINDEX                ((TPM_RESULT) (TPM_BASE + 2))
+#define TPM_BAD_PARAMETER           ((TPM_RESULT) (TPM_BASE + 3))
+#define TPM_AUDITFAILURE            ((TPM_RESULT) (TPM_BASE + 4))
+#define TPM_CLEAR_DISABLED          ((TPM_RESULT) (TPM_BASE + 5))
+#define TPM_DEACTIVATED             ((TPM_RESULT) (TPM_BASE + 6))
+#define TPM_DISABLED                ((TPM_RESULT) (TPM_BASE + 7))
+#define TPM_DISABLED_CMD            ((TPM_RESULT) (TPM_BASE + 8))
+#define TPM_FAIL                    ((TPM_RESULT) (TPM_BASE + 9))
+#define TPM_BAD_ORDINAL             ((TPM_RESULT) (TPM_BASE + 10))
+#define TPM_INSTALL_DISABLED        ((TPM_RESULT) (TPM_BASE + 11))
+#define TPM_INVALID_KEYHANDLE       ((TPM_RESULT) (TPM_BASE + 12))
+#define TPM_KEYNOTFOUND             ((TPM_RESULT) (TPM_BASE + 13))
+#define TPM_INAPPROPRIATE_ENC       ((TPM_RESULT) (TPM_BASE + 14))
+#define TPM_MIGRATEFAIL             ((TPM_RESULT) (TPM_BASE + 15))
+#define TPM_INVALID_PCR_INFO        ((TPM_RESULT) (TPM_BASE + 16))
+#define TPM_NOSPACE                 ((TPM_RESULT) (TPM_BASE + 17))
+#define TPM_NOSRK                   ((TPM_RESULT) (TPM_BASE + 18))
+#define TPM_NOTSEALED_BLOB          ((TPM_RESULT) (TPM_BASE + 19))
+#define TPM_OWNER_SET               ((TPM_RESULT) (TPM_BASE + 20))
+#define TPM_RESOURCES               ((TPM_RESULT) (TPM_BASE + 21))
+#define TPM_SHORTRANDOM             ((TPM_RESULT) (TPM_BASE + 22))
+#define TPM_SIZE                    ((TPM_RESULT) (TPM_BASE + 23))
+#define TPM_WRONGPCRVAL             ((TPM_RESULT) (TPM_BASE + 24))
+#define TPM_BAD_PARAM_SIZE          ((TPM_RESULT) (TPM_BASE + 25))
+#define TPM_SHA_THREAD              ((TPM_RESULT) (TPM_BASE + 26))
+#define TPM_SHA_ERROR               ((TPM_RESULT) (TPM_BASE + 27))
+#define TPM_FAILEDSELFTEST          ((TPM_RESULT) (TPM_BASE + 28))
+#define TPM_AUTH2FAIL               ((TPM_RESULT) (TPM_BASE + 29))
+#define TPM_BADTAG                  ((TPM_RESULT) (TPM_BASE + 30))
+#define TPM_IOERROR                 ((TPM_RESULT) (TPM_BASE + 31))
+#define TPM_ENCRYPT_ERROR           ((TPM_RESULT) (TPM_BASE + 32))
+#define TPM_DECRYPT_ERROR           ((TPM_RESULT) (TPM_BASE + 33))
+#define TPM_INVALID_AUTHHANDLE      ((TPM_RESULT) (TPM_BASE + 34))
+#define TPM_NO_ENDORSEMENT          ((TPM_RESULT) (TPM_BASE + 35))
+#define TPM_INVALID_KEYUSAGE        ((TPM_RESULT) (TPM_BASE + 36))
+#define TPM_WRONG_ENTITYTYPE        ((TPM_RESULT) (TPM_BASE + 37))
+#define TPM_INVALID_POSTINIT        ((TPM_RESULT) (TPM_BASE + 38))
+#define TPM_INAPPROPRIATE_SIG       ((TPM_RESULT) (TPM_BASE + 39))
+#define TPM_BAD_KEY_PROPERTY        ((TPM_RESULT) (TPM_BASE + 40))
+#define TPM_BAD_MIGRATION           ((TPM_RESULT) (TPM_BASE + 41))
+#define TPM_BAD_SCHEME              ((TPM_RESULT) (TPM_BASE + 42))
+#define TPM_BAD_DATASIZE            ((TPM_RESULT) (TPM_BASE + 43))
+#define TPM_BAD_MODE                ((TPM_RESULT) (TPM_BASE + 44))
+#define TPM_BAD_PRESENCE            ((TPM_RESULT) (TPM_BASE + 45))
+#define TPM_BAD_VERSION             ((TPM_RESULT) (TPM_BASE + 46))
+#define TPM_NO_WRAP_TRANSPORT       ((TPM_RESULT) (TPM_BASE + 47))
+#define TPM_AUDITFAIL_UNSUCCESSFUL  ((TPM_RESULT) (TPM_BASE + 48))
+#define TPM_AUDITFAIL_SUCCESSFUL    ((TPM_RESULT) (TPM_BASE + 49))
+#define TPM_NOTRESETABLE            ((TPM_RESULT) (TPM_BASE + 50))
+#define TPM_NOTLOCAL                ((TPM_RESULT) (TPM_BASE + 51))
+#define TPM_BAD_TYPE                ((TPM_RESULT) (TPM_BASE + 52))
+#define TPM_INVALID_RESOURCE        ((TPM_RESULT) (TPM_BASE + 53))
+#define TPM_NOTFIPS                 ((TPM_RESULT) (TPM_BASE + 54))
+#define TPM_INVALID_FAMILY          ((TPM_RESULT) (TPM_BASE + 55))
+#define TPM_NO_NV_PERMISSION        ((TPM_RESULT) (TPM_BASE + 56))
+#define TPM_REQUIRES_SIGN           ((TPM_RESULT) (TPM_BASE + 57))
+#define TPM_KEY_NOTSUPPORTED        ((TPM_RESULT) (TPM_BASE + 58))
+#define TPM_AUTH_CONFLICT           ((TPM_RESULT) (TPM_BASE + 59))
+#define TPM_AREA_LOCKED             ((TPM_RESULT) (TPM_BASE + 60))
+#define TPM_BAD_LOCALITY            ((TPM_RESULT) (TPM_BASE + 61))
+#define TPM_READ_ONLY               ((TPM_RESULT) (TPM_BASE + 62))
+#define TPM_PER_NOWRITE             ((TPM_RESULT) (TPM_BASE + 63))
+#define TPM_FAMILYCOUNT             ((TPM_RESULT) (TPM_BASE + 64))
+#define TPM_WRITE_LOCKED            ((TPM_RESULT) (TPM_BASE + 65))
+#define TPM_BAD_ATTRIBUTES          ((TPM_RESULT) (TPM_BASE + 66))
+#define TPM_INVALID_STRUCTURE       ((TPM_RESULT) (TPM_BASE + 67))
+#define TPM_KEY_OWNER_CONTROL       ((TPM_RESULT) (TPM_BASE + 68))
+#define TPM_BAD_COUNTER             ((TPM_RESULT) (TPM_BASE + 69))
+#define TPM_NOT_FULLWRITE           ((TPM_RESULT) (TPM_BASE + 70))
+#define TPM_CONTEXT_GAP             ((TPM_RESULT) (TPM_BASE + 71))
+#define TPM_MAXNVWRITES             ((TPM_RESULT) (TPM_BASE + 72))
+#define TPM_NOOPERATOR              ((TPM_RESULT) (TPM_BASE + 73))
+#define TPM_RESOURCEMISSING         ((TPM_RESULT) (TPM_BASE + 74))
+#define TPM_DELEGATE_LOCK           ((TPM_RESULT) (TPM_BASE + 75))
+#define TPM_DELEGATE_FAMILY         ((TPM_RESULT) (TPM_BASE + 76))
+#define TPM_DELEGATE_ADMIN          ((TPM_RESULT) (TPM_BASE + 77))
+#define TPM_TRANSPORT_NOTEXCLUSIVE  ((TPM_RESULT) (TPM_BASE + 78))
+#define TPM_OWNER_CONTROL           ((TPM_RESULT) (TPM_BASE + 79))
+#define TPM_DAA_RESOURCES           ((TPM_RESULT) (TPM_BASE + 80))
+#define TPM_DAA_INPUT_DATA0         ((TPM_RESULT) (TPM_BASE + 81))
+#define TPM_DAA_INPUT_DATA1         ((TPM_RESULT) (TPM_BASE + 82))
+#define TPM_DAA_ISSUER_SETTINGS     ((TPM_RESULT) (TPM_BASE + 83))
+#define TPM_DAA_TPM_SETTINGS        ((TPM_RESULT) (TPM_BASE + 84))
+#define TPM_DAA_STAGE               ((TPM_RESULT) (TPM_BASE + 85))
+#define TPM_DAA_ISSUER_VALIDITY     ((TPM_RESULT) (TPM_BASE + 86))
+#define TPM_DAA_WRONG_W             ((TPM_RESULT) (TPM_BASE + 87))
+#define TPM_BAD_HANDLE              ((TPM_RESULT) (TPM_BASE + 88))
+#define TPM_BAD_DELEGATE            ((TPM_RESULT) (TPM_BASE + 89))
+#define TPM_BADCONTEXT              ((TPM_RESULT) (TPM_BASE + 90))
+#define TPM_TOOMANYCONTEXTS         ((TPM_RESULT) (TPM_BASE + 91))
+#define TPM_MA_TICKET_SIGNATURE     ((TPM_RESULT) (TPM_BASE + 92))
+#define TPM_MA_DESTINATION          ((TPM_RESULT) (TPM_BASE + 93))
+#define TPM_MA_SOURCE               ((TPM_RESULT) (TPM_BASE + 94))
+#define TPM_MA_AUTHORITY            ((TPM_RESULT) (TPM_BASE + 95))
+#define TPM_PERMANENTEK             ((TPM_RESULT) (TPM_BASE + 97))
+#define TPM_BAD_SIGNATURE           ((TPM_RESULT) (TPM_BASE + 98))
+#define TPM_NOCONTEXTSPACE          ((TPM_RESULT) (TPM_BASE + 99))
+
+#define TPM_RETRY                   ((TPM_RESULT) (TPM_BASE + TPM_NON_FATAL))
+#define TPM_NEEDS_SELFTEST          ((TPM_RESULT) (TPM_BASE + TPM_NON_FATAL + 1))
+#define TPM_DOING_SELFTEST          ((TPM_RESULT) (TPM_BASE + TPM_NON_FATAL + 2))
+#define TPM_DEFEND_LOCK_RUNNING     ((TPM_RESULT) (TPM_BASE + TPM_NON_FATAL + 3))
+
+//
+// Part 2, section 17: Ordinals
+//
+// Ordinals are 32 bit values. The upper byte contains values that serve as
+// flag indicators, the next byte contains values indicating what committee
+// designated the ordinal, and the final two bytes contain the Command
+// Ordinal Index.
+//      3                   2                   1
+//    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
+//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+//   |P|C|V| Reserved| Purview |     Command Ordinal Index           |
+//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+//
+//  Where:
+//
+//    * P is Protected/Unprotected command. When 0 the command is a Protected
+//      command, when 1 the command is an Unprotected command.
+//
+//    * C is Non-Connection/Connection related command. When 0 this command
+//      passes through to either the protected (TPM) or unprotected (TSS)
+//      components.
+//
+//    * V is TPM/Vendor command. When 0 the command is TPM defined, when 1 the
+//      command is vendor defined.
+//
+//    * All reserved area bits are set to 0.
+//
+
+#define TPM_ORD_ActivateIdentity                  ((TPM_COMMAND_CODE) 0x0000007A)
+#define TPM_ORD_AuthorizeMigrationKey             ((TPM_COMMAND_CODE) 0x0000002B)
+#define TPM_ORD_CertifyKey                        ((TPM_COMMAND_CODE) 0x00000032)
+#define TPM_ORD_CertifyKey2                       ((TPM_COMMAND_CODE) 0x00000033)
+#define TPM_ORD_CertifySelfTest                   ((TPM_COMMAND_CODE) 0x00000052)
+#define TPM_ORD_ChangeAuth                        ((TPM_COMMAND_CODE) 0x0000000C)
+#define TPM_ORD_ChangeAuthAsymFinish              ((TPM_COMMAND_CODE) 0x0000000F)
+#define TPM_ORD_ChangeAuthAsymStart               ((TPM_COMMAND_CODE) 0x0000000E)
+#define TPM_ORD_ChangeAuthOwner                   ((TPM_COMMAND_CODE) 0x00000010)
+#define TPM_ORD_CMK_ApproveMA                     ((TPM_COMMAND_CODE) 0x0000001D)
+#define TPM_ORD_CMK_ConvertMigration              ((TPM_COMMAND_CODE) 0x00000024)
+#define TPM_ORD_CMK_CreateBlob                    ((TPM_COMMAND_CODE) 0x0000001B)
+#define TPM_ORD_CMK_CreateKey                     ((TPM_COMMAND_CODE) 0x00000013)
+#define TPM_ORD_CMK_CreateTicket                  ((TPM_COMMAND_CODE) 0x00000012)
+#define TPM_ORD_CMK_SetRestrictions               ((TPM_COMMAND_CODE) 0x0000001C)
+#define TPM_ORD_ContinueSelfTest                  ((TPM_COMMAND_CODE) 0x00000053)
+#define TPM_ORD_ConvertMigrationBlob              ((TPM_COMMAND_CODE) 0x0000002A)
+#define TPM_ORD_CreateCounter                     ((TPM_COMMAND_CODE) 0x000000DC)
+#define TPM_ORD_CreateEndorsementKeyPair          ((TPM_COMMAND_CODE) 0x00000078)
+#define TPM_ORD_CreateMaintenanceArchive          ((TPM_COMMAND_CODE) 0x0000002C)
+#define TPM_ORD_CreateMigrationBlob               ((TPM_COMMAND_CODE) 0x00000028)
+#define TPM_ORD_CreateRevocableEK                 ((TPM_COMMAND_CODE) 0x0000007F)
+#define TPM_ORD_CreateWrapKey                     ((TPM_COMMAND_CODE) 0x0000001F)
+#define TPM_ORD_DAA_JOIN                          ((TPM_COMMAND_CODE) 0x00000029)
+#define TPM_ORD_DAA_SIGN                          ((TPM_COMMAND_CODE) 0x00000031)
+#define TPM_ORD_Delegate_CreateKeyDelegation      ((TPM_COMMAND_CODE) 0x000000D4)
+#define TPM_ORD_Delegate_CreateOwnerDelegation    ((TPM_COMMAND_CODE) 0x000000D5)
+#define TPM_ORD_Delegate_LoadOwnerDelegation      ((TPM_COMMAND_CODE) 0x000000D8)
+#define TPM_ORD_Delegate_Manage                   ((TPM_COMMAND_CODE) 0x000000D2)
+#define TPM_ORD_Delegate_ReadTable                ((TPM_COMMAND_CODE) 0x000000DB)
+#define TPM_ORD_Delegate_UpdateVerification       ((TPM_COMMAND_CODE) 0x000000D1)
+#define TPM_ORD_Delegate_VerifyDelegation         ((TPM_COMMAND_CODE) 0x000000D6)
+#define TPM_ORD_DirRead                           ((TPM_COMMAND_CODE) 0x0000001A)
+#define TPM_ORD_DirWriteAuth                      ((TPM_COMMAND_CODE) 0x00000019)
+#define TPM_ORD_DisableForceClear                 ((TPM_COMMAND_CODE) 0x0000005E)
+#define TPM_ORD_DisableOwnerClear                 ((TPM_COMMAND_CODE) 0x0000005C)
+#define TPM_ORD_DisablePubekRead                  ((TPM_COMMAND_CODE) 0x0000007E)
+#define TPM_ORD_DSAP                              ((TPM_COMMAND_CODE) 0x00000011)
+#define TPM_ORD_EstablishTransport                ((TPM_COMMAND_CODE) 0x000000E6)
+#define TPM_ORD_EvictKey                          ((TPM_COMMAND_CODE) 0x00000022)
+#define TPM_ORD_ExecuteTransport                  ((TPM_COMMAND_CODE) 0x000000E7)
+#define TPM_ORD_Extend                            ((TPM_COMMAND_CODE) 0x00000014)
+#define TPM_ORD_FieldUpgrade                      ((TPM_COMMAND_CODE) 0x000000AA)
+#define TPM_ORD_FlushSpecific                     ((TPM_COMMAND_CODE) 0x000000BA)
+#define TPM_ORD_ForceClear                        ((TPM_COMMAND_CODE) 0x0000005D)
+#define TPM_ORD_GetAuditDigest                    ((TPM_COMMAND_CODE) 0x00000085)
+#define TPM_ORD_GetAuditDigestSigned              ((TPM_COMMAND_CODE) 0x00000086)
+#define TPM_ORD_GetAuditEvent                     ((TPM_COMMAND_CODE) 0x00000082)
+#define TPM_ORD_GetAuditEventSigned               ((TPM_COMMAND_CODE) 0x00000083)
+#define TPM_ORD_GetCapability                     ((TPM_COMMAND_CODE) 0x00000065)
+#define TPM_ORD_GetCapabilityOwner                ((TPM_COMMAND_CODE) 0x00000066)
+#define TPM_ORD_GetCapabilitySigned               ((TPM_COMMAND_CODE) 0x00000064)
+#define TPM_ORD_GetOrdinalAuditStatus             ((TPM_COMMAND_CODE) 0x0000008C)
+#define TPM_ORD_GetPubKey                         ((TPM_COMMAND_CODE) 0x00000021)
+#define TPM_ORD_GetRandom                         ((TPM_COMMAND_CODE) 0x00000046)
+#define TPM_ORD_GetTestResult                     ((TPM_COMMAND_CODE) 0x00000054)
+#define TPM_ORD_GetTicks                          ((TPM_COMMAND_CODE) 0x000000F1)
+#define TPM_ORD_IncrementCounter                  ((TPM_COMMAND_CODE) 0x000000DD)
+#define TPM_ORD_Init                              ((TPM_COMMAND_CODE) 0x00000097)
+#define TPM_ORD_KeyControlOwner                   ((TPM_COMMAND_CODE) 0x00000023)
+#define TPM_ORD_KillMaintenanceFeature            ((TPM_COMMAND_CODE) 0x0000002E)
+#define TPM_ORD_LoadAuthContext                   ((TPM_COMMAND_CODE) 0x000000B7)
+#define TPM_ORD_LoadContext                       ((TPM_COMMAND_CODE) 0x000000B9)
+#define TPM_ORD_LoadKey                           ((TPM_COMMAND_CODE) 0x00000020)
+#define TPM_ORD_LoadKey2                          ((TPM_COMMAND_CODE) 0x00000041)
+#define TPM_ORD_LoadKeyContext                    ((TPM_COMMAND_CODE) 0x000000B5)
+#define TPM_ORD_LoadMaintenanceArchive            ((TPM_COMMAND_CODE) 0x0000002D)
+#define TPM_ORD_LoadManuMaintPub                  ((TPM_COMMAND_CODE) 0x0000002F)
+#define TPM_ORD_MakeIdentity                      ((TPM_COMMAND_CODE) 0x00000079)
+#define TPM_ORD_MigrateKey                        ((TPM_COMMAND_CODE) 0x00000025)
+#define TPM_ORD_NV_DefineSpace                    ((TPM_COMMAND_CODE) 0x000000CC)
+#define TPM_ORD_NV_ReadValue                      ((TPM_COMMAND_CODE) 0x000000CF)
+#define TPM_ORD_NV_ReadValueAuth                  ((TPM_COMMAND_CODE) 0x000000D0)
+#define TPM_ORD_NV_WriteValue                     ((TPM_COMMAND_CODE) 0x000000CD)
+#define TPM_ORD_NV_WriteValueAuth                 ((TPM_COMMAND_CODE) 0x000000CE)
+#define TPM_ORD_OIAP                              ((TPM_COMMAND_CODE) 0x0000000A)
+#define TPM_ORD_OSAP                              ((TPM_COMMAND_CODE) 0x0000000B)
+#define TPM_ORD_OwnerClear                        ((TPM_COMMAND_CODE) 0x0000005B)
+#define TPM_ORD_OwnerReadInternalPub              ((TPM_COMMAND_CODE) 0x00000081)
+#define TPM_ORD_OwnerReadPubek                    ((TPM_COMMAND_CODE) 0x0000007D)
+#define TPM_ORD_OwnerSetDisable                   ((TPM_COMMAND_CODE) 0x0000006E)
+#define TPM_ORD_PCR_Reset                         ((TPM_COMMAND_CODE) 0x000000C8)
+#define TPM_ORD_PcrRead                           ((TPM_COMMAND_CODE) 0x00000015)
+#define TPM_ORD_PhysicalDisable                   ((TPM_COMMAND_CODE) 0x00000070)
+#define TPM_ORD_PhysicalEnable                    ((TPM_COMMAND_CODE) 0x0000006F)
+#define TPM_ORD_PhysicalSetDeactivated            ((TPM_COMMAND_CODE) 0x00000072)
+#define TPM_ORD_Quote                             ((TPM_COMMAND_CODE) 0x00000016)
+#define TPM_ORD_Quote2                            ((TPM_COMMAND_CODE) 0x0000003E)
+#define TPM_ORD_ReadCounter                       ((TPM_COMMAND_CODE) 0x000000DE)
+#define TPM_ORD_ReadManuMaintPub                  ((TPM_COMMAND_CODE) 0x00000030)
+#define TPM_ORD_ReadPubek                         ((TPM_COMMAND_CODE) 0x0000007C)
+#define TPM_ORD_ReleaseCounter                    ((TPM_COMMAND_CODE) 0x000000DF)
+#define TPM_ORD_ReleaseCounterOwner               ((TPM_COMMAND_CODE) 0x000000E0)
+#define TPM_ORD_ReleaseTransportSigned            ((TPM_COMMAND_CODE) 0x000000E8)
+#define TPM_ORD_Reset                             ((TPM_COMMAND_CODE) 0x0000005A)
+#define TPM_ORD_ResetLockValue                    ((TPM_COMMAND_CODE) 0x00000040)
+#define TPM_ORD_RevokeTrust                       ((TPM_COMMAND_CODE) 0x00000080)
+#define TPM_ORD_SaveAuthContext                   ((TPM_COMMAND_CODE) 0x000000B6)
+#define TPM_ORD_SaveContext                       ((TPM_COMMAND_CODE) 0x000000B8)
+#define TPM_ORD_SaveKeyContext                    ((TPM_COMMAND_CODE) 0x000000B4)
+#define TPM_ORD_SaveState                         ((TPM_COMMAND_CODE) 0x00000098)
+#define TPM_ORD_Seal                              ((TPM_COMMAND_CODE) 0x00000017)
+#define TPM_ORD_Sealx                             ((TPM_COMMAND_CODE) 0x0000003D)
+#define TPM_ORD_SelfTestFull                      ((TPM_COMMAND_CODE) 0x00000050)
+#define TPM_ORD_SetCapability                     ((TPM_COMMAND_CODE) 0x0000003F)
+#define TPM_ORD_SetOperatorAuth                   ((TPM_COMMAND_CODE) 0x00000074)
+#define TPM_ORD_SetOrdinalAuditStatus             ((TPM_COMMAND_CODE) 0x0000008D)
+#define TPM_ORD_SetOwnerInstall                   ((TPM_COMMAND_CODE) 0x00000071)
+#define TPM_ORD_SetOwnerPointer                   ((TPM_COMMAND_CODE) 0x00000075)
+#define TPM_ORD_SetRedirection                    ((TPM_COMMAND_CODE) 0x0000009A)
+#define TPM_ORD_SetTempDeactivated                ((TPM_COMMAND_CODE) 0x00000073)
+#define TPM_ORD_SHA1Complete                      ((TPM_COMMAND_CODE) 0x000000A2)
+#define TPM_ORD_SHA1CompleteExtend                ((TPM_COMMAND_CODE) 0x000000A3)
+#define TPM_ORD_SHA1Start                         ((TPM_COMMAND_CODE) 0x000000A0)
+#define TPM_ORD_SHA1Update                        ((TPM_COMMAND_CODE) 0x000000A1)
+#define TPM_ORD_Sign                              ((TPM_COMMAND_CODE) 0x0000003C)
+#define TPM_ORD_Startup                           ((TPM_COMMAND_CODE) 0x00000099)
+#define TPM_ORD_StirRandom                        ((TPM_COMMAND_CODE) 0x00000047)
+#define TPM_ORD_TakeOwnership                     ((TPM_COMMAND_CODE) 0x0000000D)
+#define TPM_ORD_Terminate_Handle                  ((TPM_COMMAND_CODE) 0x00000096)
+#define TPM_ORD_TickStampBlob                     ((TPM_COMMAND_CODE) 0x000000F2)
+#define TPM_ORD_UnBind                            ((TPM_COMMAND_CODE) 0x0000001E)
+#define TPM_ORD_Unseal                            ((TPM_COMMAND_CODE) 0x00000018)
+#define TSC_ORD_PhysicalPresence                  ((TPM_COMMAND_CODE) 0x4000000A)
+#define TSC_ORD_ResetEstablishmentBit             ((TPM_COMMAND_CODE) 0x4000000B)
+
+//
+// Part 2, section 18: Context structures
+//
+
+///
+/// Part 2, section 18.1: TPM_CONTEXT_BLOB
+///
+typedef struct tdTPM_CONTEXT_BLOB {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_RESOURCE_TYPE               resourceType;
+  TPM_HANDLE                      handle;
+  UINT8                           label[16];
+  UINT32                          contextCount;
+  TPM_DIGEST                      integrityDigest;
+  UINT32                          additionalSize;
+  UINT8                           *additionalData;
+  UINT32                          sensitiveSize;
+  UINT8                           *sensitiveData;
+} TPM_CONTEXT_BLOB;
+
+///
+/// Part 2, section 18.2 TPM_CONTEXT_SENSITIVE
+///
+typedef struct tdTPM_CONTEXT_SENSITIVE {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_NONCE                       contextNonce;
+  UINT32                          internalSize;
+  UINT8                           *internalData;
+} TPM_CONTEXT_SENSITIVE;
+
+//
+// Part 2, section 19: NV Structures
+//
+
+//
+// Part 2, section 19.1.1: Required TPM_NV_INDEX values
+//
+#define TPM_NV_INDEX_LOCK              ((UINT32)0xffffffff)
+#define TPM_NV_INDEX0                  ((UINT32)0x00000000)
+#define TPM_NV_INDEX_DIR               ((UINT32)0x10000001)
+#define TPM_NV_INDEX_EKCert            ((UINT32)0x0000f000)
+#define TPM_NV_INDEX_TPM_CC            ((UINT32)0x0000f001)
+#define TPM_NV_INDEX_PlatformCert      ((UINT32)0x0000f002)
+#define TPM_NV_INDEX_Platform_CC       ((UINT32)0x0000f003)
+//
+// Part 2, section 19.1.2: Reserved Index values
+//
+#define TPM_NV_INDEX_TSS_BASE          ((UINT32)0x00011100)
+#define TPM_NV_INDEX_PC_BASE           ((UINT32)0x00011200)
+#define TPM_NV_INDEX_SERVER_BASE       ((UINT32)0x00011300)
+#define TPM_NV_INDEX_MOBILE_BASE       ((UINT32)0x00011400)
+#define TPM_NV_INDEX_PERIPHERAL_BASE   ((UINT32)0x00011500)
+#define TPM_NV_INDEX_GROUP_RESV_BASE   ((UINT32)0x00010000)
+
+///
+/// Part 2, section 19.2: TPM_NV_ATTRIBUTES
+///
+typedef struct tdTPM_NV_ATTRIBUTES {
+  TPM_STRUCTURE_TAG               tag;
+  UINT32                          attributes;
+} TPM_NV_ATTRIBUTES;
+
+#define TPM_NV_PER_READ_STCLEAR        (BIT31)
+#define TPM_NV_PER_AUTHREAD            (BIT18)
+#define TPM_NV_PER_OWNERREAD           (BIT17)
+#define TPM_NV_PER_PPREAD              (BIT16)
+#define TPM_NV_PER_GLOBALLOCK          (BIT15)
+#define TPM_NV_PER_WRITE_STCLEAR       (BIT14)
+#define TPM_NV_PER_WRITEDEFINE         (BIT13)
+#define TPM_NV_PER_WRITEALL            (BIT12)
+#define TPM_NV_PER_AUTHWRITE           (BIT2)
+#define TPM_NV_PER_OWNERWRITE          (BIT1)
+#define TPM_NV_PER_PPWRITE             (BIT0)
+
+///
+/// Part 2, section 19.3: TPM_NV_DATA_PUBLIC
+///
+typedef struct tdTPM_NV_DATA_PUBLIC {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_NV_INDEX                    nvIndex;
+  TPM_PCR_INFO_SHORT              pcrInfoRead;
+  TPM_PCR_INFO_SHORT              pcrInfoWrite;
+  TPM_NV_ATTRIBUTES               permission;
+  BOOLEAN                         bReadSTClear;
+  BOOLEAN                         bWriteSTClear;
+  BOOLEAN                         bWriteDefine;
+  UINT32                          dataSize;
+} TPM_NV_DATA_PUBLIC;
+
+//
+// Part 2, section 20: Delegate Structures
+//
+
+#define TPM_DEL_OWNER_BITS          ((UINT32)0x00000001)
+#define TPM_DEL_KEY_BITS            ((UINT32)0x00000002)
+///
+/// Part 2, section 20.2: Delegate Definitions
+///
+typedef struct tdTPM_DELEGATIONS {
+  TPM_STRUCTURE_TAG               tag;
+  UINT32                          delegateType;
+  UINT32                          per1;
+  UINT32                          per2;
+} TPM_DELEGATIONS;
+
+//
+// Part 2, section 20.2.1: Owner Permission Settings
+//
+#define TPM_DELEGATE_SetOrdinalAuditStatus          (BIT30)
+#define TPM_DELEGATE_DirWriteAuth                   (BIT29)
+#define TPM_DELEGATE_CMK_ApproveMA                  (BIT28)
+#define TPM_DELEGATE_NV_WriteValue                  (BIT27)
+#define TPM_DELEGATE_CMK_CreateTicket               (BIT26)
+#define TPM_DELEGATE_NV_ReadValue                   (BIT25)
+#define TPM_DELEGATE_Delegate_LoadOwnerDelegation   (BIT24)
+#define TPM_DELEGATE_DAA_Join                       (BIT23)
+#define TPM_DELEGATE_AuthorizeMigrationKey          (BIT22)
+#define TPM_DELEGATE_CreateMaintenanceArchive       (BIT21)
+#define TPM_DELEGATE_LoadMaintenanceArchive         (BIT20)
+#define TPM_DELEGATE_KillMaintenanceFeature         (BIT19)
+#define TPM_DELEGATE_OwnerReadInteralPub            (BIT18)
+#define TPM_DELEGATE_ResetLockValue                 (BIT17)
+#define TPM_DELEGATE_OwnerClear                     (BIT16)
+#define TPM_DELEGATE_DisableOwnerClear              (BIT15)
+#define TPM_DELEGATE_NV_DefineSpace                 (BIT14)
+#define TPM_DELEGATE_OwnerSetDisable                (BIT13)
+#define TPM_DELEGATE_SetCapability                  (BIT12)
+#define TPM_DELEGATE_MakeIdentity                   (BIT11)
+#define TPM_DELEGATE_ActivateIdentity               (BIT10)
+#define TPM_DELEGATE_OwnerReadPubek                 (BIT9)
+#define TPM_DELEGATE_DisablePubekRead               (BIT8)
+#define TPM_DELEGATE_SetRedirection                 (BIT7)
+#define TPM_DELEGATE_FieldUpgrade                   (BIT6)
+#define TPM_DELEGATE_Delegate_UpdateVerification    (BIT5)
+#define TPM_DELEGATE_CreateCounter                  (BIT4)
+#define TPM_DELEGATE_ReleaseCounterOwner            (BIT3)
+#define TPM_DELEGATE_DelegateManage                 (BIT2)
+#define TPM_DELEGATE_Delegate_CreateOwnerDelegation (BIT1)
+#define TPM_DELEGATE_DAA_Sign                       (BIT0)
+
+//
+// Part 2, section 20.2.3: Key Permission settings
+//
+#define TPM_KEY_DELEGATE_CMK_ConvertMigration       (BIT28)
+#define TPM_KEY_DELEGATE_TickStampBlob              (BIT27)
+#define TPM_KEY_DELEGATE_ChangeAuthAsymStart        (BIT26)
+#define TPM_KEY_DELEGATE_ChangeAuthAsymFinish       (BIT25)
+#define TPM_KEY_DELEGATE_CMK_CreateKey              (BIT24)
+#define TPM_KEY_DELEGATE_MigrateKey                 (BIT23)
+#define TPM_KEY_DELEGATE_LoadKey2                   (BIT22)
+#define TPM_KEY_DELEGATE_EstablishTransport         (BIT21)
+#define TPM_KEY_DELEGATE_ReleaseTransportSigned     (BIT20)
+#define TPM_KEY_DELEGATE_Quote2                     (BIT19)
+#define TPM_KEY_DELEGATE_Sealx                      (BIT18)
+#define TPM_KEY_DELEGATE_MakeIdentity               (BIT17)
+#define TPM_KEY_DELEGATE_ActivateIdentity           (BIT16)
+#define TPM_KEY_DELEGATE_GetAuditDigestSigned       (BIT15)
+#define TPM_KEY_DELEGATE_Sign                       (BIT14)
+#define TPM_KEY_DELEGATE_CertifyKey2                (BIT13)
+#define TPM_KEY_DELEGATE_CertifyKey                 (BIT12)
+#define TPM_KEY_DELEGATE_CreateWrapKey              (BIT11)
+#define TPM_KEY_DELEGATE_CMK_CreateBlob             (BIT10)
+#define TPM_KEY_DELEGATE_CreateMigrationBlob        (BIT9)
+#define TPM_KEY_DELEGATE_ConvertMigrationBlob       (BIT8)
+#define TPM_KEY_DELEGATE_CreateKeyDelegation        (BIT7)
+#define TPM_KEY_DELEGATE_ChangeAuth                 (BIT6)
+#define TPM_KEY_DELEGATE_GetPubKey                  (BIT5)
+#define TPM_KEY_DELEGATE_UnBind                     (BIT4)
+#define TPM_KEY_DELEGATE_Quote                      (BIT3)
+#define TPM_KEY_DELEGATE_Unseal                     (BIT2)
+#define TPM_KEY_DELEGATE_Seal                       (BIT1)
+#define TPM_KEY_DELEGATE_LoadKey                    (BIT0)
+
+//
+// Part 2, section 20.3: TPM_FAMILY_FLAGS
+//
+#define TPM_DELEGATE_ADMIN_LOCK           (BIT1)
+#define TPM_FAMFLAG_ENABLE                (BIT0)
+
+///
+/// Part 2, section 20.4: TPM_FAMILY_LABEL
+///
+typedef struct tdTPM_FAMILY_LABEL {
+  UINT8                           label;
+} TPM_FAMILY_LABEL;
+
+///
+/// Part 2, section 20.5: TPM_FAMILY_TABLE_ENTRY
+///
+typedef struct tdTPM_FAMILY_TABLE_ENTRY {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_FAMILY_LABEL                label;
+  TPM_FAMILY_ID                   familyID;
+  TPM_FAMILY_VERIFICATION         verificationCount;
+  TPM_FAMILY_FLAGS                flags;
+} TPM_FAMILY_TABLE_ENTRY;
+
+//
+// Part 2, section 20.6: TPM_FAMILY_TABLE
+//
+#define TPM_NUM_FAMILY_TABLE_ENTRY_MIN 8
+
+typedef struct tdTPM_FAMILY_TABLE{
+  TPM_FAMILY_TABLE_ENTRY famTableRow[TPM_NUM_FAMILY_TABLE_ENTRY_MIN];
+} TPM_FAMILY_TABLE;
+
+///
+/// Part 2, section 20.7: TPM_DELEGATE_LABEL
+///
+typedef struct tdTPM_DELEGATE_LABEL {
+  UINT8                           label;
+} TPM_DELEGATE_LABEL;
+
+///
+/// Part 2, section 20.8: TPM_DELEGATE_PUBLIC
+///
+typedef struct tdTPM_DELEGATE_PUBLIC {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DELEGATE_LABEL              label;
+  TPM_PCR_INFO_SHORT              pcrInfo;
+  TPM_DELEGATIONS                 permissions;
+  TPM_FAMILY_ID                   familyID;
+  TPM_FAMILY_VERIFICATION         verificationCount;
+} TPM_DELEGATE_PUBLIC;
+
+///
+/// Part 2, section 20.9: TPM_DELEGATE_TABLE_ROW
+///
+typedef struct tdTPM_DELEGATE_TABLE_ROW {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DELEGATE_PUBLIC             pub;
+  TPM_SECRET                      authValue;
+} TPM_DELEGATE_TABLE_ROW;
+
+//
+// Part 2, section 20.10: TPM_DELEGATE_TABLE
+//
+#define TPM_NUM_DELEGATE_TABLE_ENTRY_MIN 2
+
+typedef struct tdTPM_DELEGATE_TABLE{
+  TPM_DELEGATE_TABLE_ROW delRow[TPM_NUM_DELEGATE_TABLE_ENTRY_MIN];
+} TPM_DELEGATE_TABLE;
+
+///
+/// Part 2, section 20.11: TPM_DELEGATE_SENSITIVE
+///
+typedef struct tdTPM_DELEGATE_SENSITIVE {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_SECRET                      authValue;
+} TPM_DELEGATE_SENSITIVE;
+
+///
+/// Part 2, section 20.12: TPM_DELEGATE_OWNER_BLOB
+///
+typedef struct tdTPM_DELEGATE_OWNER_BLOB {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DELEGATE_PUBLIC             pub;
+  TPM_DIGEST                      integrityDigest;
+  UINT32                          additionalSize;
+  UINT8                           *additionalArea;
+  UINT32                          sensitiveSize;
+  UINT8                           *sensitiveArea;
+} TPM_DELEGATE_OWNER_BLOB;
+
+///
+/// Part 2, section 20.13: TTPM_DELEGATE_KEY_BLOB
+///
+typedef struct tdTPM_DELEGATE_KEY_BLOB {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DELEGATE_PUBLIC             pub;
+  TPM_DIGEST                      integrityDigest;
+  TPM_DIGEST                      pubKeyDigest;
+  UINT32                          additionalSize;
+  UINT8                           *additionalArea;
+  UINT32                          sensitiveSize;
+  UINT8                           *sensitiveArea;
+} TPM_DELEGATE_KEY_BLOB;
+
+//
+// Part 2, section 20.14: TPM_FAMILY_OPERATION Values
+//
+#define TPM_FAMILY_CREATE                 ((UINT32)0x00000001)
+#define TPM_FAMILY_ENABLE                 ((UINT32)0x00000002)
+#define TPM_FAMILY_ADMIN                  ((UINT32)0x00000003)
+#define TPM_FAMILY_INVALIDATE             ((UINT32)0x00000004)
+
+//
+// Part 2, section 21.1: TPM_CAPABILITY_AREA for GetCapability
+//
+#define TPM_CAP_ORD                     ((TPM_CAPABILITY_AREA) 0x00000001)
+#define TPM_CAP_ALG                     ((TPM_CAPABILITY_AREA) 0x00000002)
+#define TPM_CAP_PID                     ((TPM_CAPABILITY_AREA) 0x00000003)
+#define TPM_CAP_FLAG                    ((TPM_CAPABILITY_AREA) 0x00000004)
+#define TPM_CAP_PROPERTY                ((TPM_CAPABILITY_AREA) 0x00000005)
+#define TPM_CAP_VERSION                 ((TPM_CAPABILITY_AREA) 0x00000006)
+#define TPM_CAP_KEY_HANDLE              ((TPM_CAPABILITY_AREA) 0x00000007)
+#define TPM_CAP_CHECK_LOADED            ((TPM_CAPABILITY_AREA) 0x00000008)
+#define TPM_CAP_SYM_MODE                ((TPM_CAPABILITY_AREA) 0x00000009)
+#define TPM_CAP_KEY_STATUS              ((TPM_CAPABILITY_AREA) 0x0000000C)
+#define TPM_CAP_NV_LIST                 ((TPM_CAPABILITY_AREA) 0x0000000D)
+#define TPM_CAP_MFR                     ((TPM_CAPABILITY_AREA) 0x00000010)
+#define TPM_CAP_NV_INDEX                ((TPM_CAPABILITY_AREA) 0x00000011)
+#define TPM_CAP_TRANS_ALG               ((TPM_CAPABILITY_AREA) 0x00000012)
+#define TPM_CAP_HANDLE                  ((TPM_CAPABILITY_AREA) 0x00000014)
+#define TPM_CAP_TRANS_ES                ((TPM_CAPABILITY_AREA) 0x00000015)
+#define TPM_CAP_AUTH_ENCRYPT            ((TPM_CAPABILITY_AREA) 0x00000017)
+#define TPM_CAP_SELECT_SIZE             ((TPM_CAPABILITY_AREA) 0x00000018)
+#define TPM_CAP_VERSION_VAL             ((TPM_CAPABILITY_AREA) 0x0000001A)
+
+#define TPM_CAP_FLAG_PERMANENT          ((TPM_CAPABILITY_AREA) 0x00000108)
+#define TPM_CAP_FLAG_VOLATILE           ((TPM_CAPABILITY_AREA) 0x00000109)
+
+//
+// Part 2, section 21.2: CAP_PROPERTY Subcap values for GetCapability
+//
+#define TPM_CAP_PROP_PCR                ((TPM_CAPABILITY_AREA) 0x00000101)
+#define TPM_CAP_PROP_DIR                ((TPM_CAPABILITY_AREA) 0x00000102)
+#define TPM_CAP_PROP_MANUFACTURER       ((TPM_CAPABILITY_AREA) 0x00000103)
+#define TPM_CAP_PROP_KEYS               ((TPM_CAPABILITY_AREA) 0x00000104)
+#define TPM_CAP_PROP_MIN_COUNTER        ((TPM_CAPABILITY_AREA) 0x00000107)
+#define TPM_CAP_PROP_AUTHSESS           ((TPM_CAPABILITY_AREA) 0x0000010A)
+#define TPM_CAP_PROP_TRANSESS           ((TPM_CAPABILITY_AREA) 0x0000010B)
+#define TPM_CAP_PROP_COUNTERS           ((TPM_CAPABILITY_AREA) 0x0000010C)
+#define TPM_CAP_PROP_MAX_AUTHSESS       ((TPM_CAPABILITY_AREA) 0x0000010D)
+#define TPM_CAP_PROP_MAX_TRANSESS       ((TPM_CAPABILITY_AREA) 0x0000010E)
+#define TPM_CAP_PROP_MAX_COUNTERS       ((TPM_CAPABILITY_AREA) 0x0000010F)
+#define TPM_CAP_PROP_MAX_KEYS           ((TPM_CAPABILITY_AREA) 0x00000110)
+#define TPM_CAP_PROP_OWNER              ((TPM_CAPABILITY_AREA) 0x00000111)
+#define TPM_CAP_PROP_CONTEXT            ((TPM_CAPABILITY_AREA) 0x00000112)
+#define TPM_CAP_PROP_MAX_CONTEXT        ((TPM_CAPABILITY_AREA) 0x00000113)
+#define TPM_CAP_PROP_FAMILYROWS         ((TPM_CAPABILITY_AREA) 0x00000114)
+#define TPM_CAP_PROP_TIS_TIMEOUT        ((TPM_CAPABILITY_AREA) 0x00000115)
+#define TPM_CAP_PROP_STARTUP_EFFECT     ((TPM_CAPABILITY_AREA) 0x00000116)
+#define TPM_CAP_PROP_DELEGATE_ROW       ((TPM_CAPABILITY_AREA) 0x00000117)
+#define TPM_CAP_PROP_DAA_MAX            ((TPM_CAPABILITY_AREA) 0x00000119)
+#define CAP_PROP_SESSION_DAA            ((TPM_CAPABILITY_AREA) 0x0000011A)
+#define TPM_CAP_PROP_CONTEXT_DIST       ((TPM_CAPABILITY_AREA) 0x0000011B)
+#define TPM_CAP_PROP_DAA_INTERRUPT      ((TPM_CAPABILITY_AREA) 0x0000011C)
+#define TPM_CAP_PROP_SESSIONS           ((TPM_CAPABILITY_AREA) 0x0000011D)
+#define TPM_CAP_PROP_MAX_SESSIONS       ((TPM_CAPABILITY_AREA) 0x0000011E)
+#define TPM_CAP_PROP_CMK_RESTRICTION    ((TPM_CAPABILITY_AREA) 0x0000011F)
+#define TPM_CAP_PROP_DURATION           ((TPM_CAPABILITY_AREA) 0x00000120)
+#define TPM_CAP_PROP_ACTIVE_COUNTER     ((TPM_CAPABILITY_AREA) 0x00000122)
+#define TPM_CAP_PROP_MAX_NV_AVAILABLE   ((TPM_CAPABILITY_AREA) 0x00000123)
+#define TPM_CAP_PROP_INPUT_BUFFER       ((TPM_CAPABILITY_AREA) 0x00000124)
+
+//
+// Part 2, section 21.4: TPM_CAPABILITY_AREA for SetCapability
+//
+#define TPM_SET_PERM_FLAGS              ((TPM_CAPABILITY_AREA) 0x00000001)
+#define TPM_SET_PERM_DATA               ((TPM_CAPABILITY_AREA) 0x00000002)
+#define TPM_SET_STCLEAR_FLAGS           ((TPM_CAPABILITY_AREA) 0x00000003)
+#define TPM_SET_STCLEAR_DATA            ((TPM_CAPABILITY_AREA) 0x00000004)
+#define TPM_SET_STANY_FLAGS             ((TPM_CAPABILITY_AREA) 0x00000005)
+#define TPM_SET_STANY_DATA              ((TPM_CAPABILITY_AREA) 0x00000006)
+
+///
+/// Part 2, section 21.6: TPM_CAP_VERSION_INFO
+///   [size_is(vendorSpecificSize)] BYTE* vendorSpecific;
+///
+typedef struct tdTPM_CAP_VERSION_INFO {
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_VERSION                       version;
+  UINT16                            specLevel;
+  UINT8                             errataRev;
+  UINT8                             tpmVendorID[4];
+  UINT16                            vendorSpecificSize;
+  UINT8                             *vendorSpecific;
+} TPM_CAP_VERSION_INFO;
+
+///
+/// Part 2, section 21.10: TPM_DA_ACTION_TYPE
+///
+typedef struct tdTPM_DA_ACTION_TYPE {
+  TPM_STRUCTURE_TAG                 tag;
+  UINT32                            actions;
+} TPM_DA_ACTION_TYPE;
+
+#define TPM_DA_ACTION_FAILURE_MODE     (((UINT32)1)<<3)
+#define TPM_DA_ACTION_DEACTIVATE       (((UINT32)1)<<2)
+#define TPM_DA_ACTION_DISABLE          (((UINT32)1)<<1)
+#define TPM_DA_ACTION_TIMEOUT          (((UINT32)1)<<0)
+
+///
+/// Part 2, section 21.7: TPM_DA_INFO
+///
+typedef struct tdTPM_DA_INFO {
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_DA_STATE                      state;
+  UINT16                            currentCount;
+  UINT16                            thresholdCount;
+  TPM_DA_ACTION_TYPE                actionAtThreshold;
+  UINT32                            actionDependValue;
+  UINT32                            vendorDataSize;
+  UINT8                             *vendorData;
+} TPM_DA_INFO;
+
+///
+/// Part 2, section 21.8: TPM_DA_INFO_LIMITED
+///
+typedef struct tdTPM_DA_INFO_LIMITED {
+  TPM_STRUCTURE_TAG                 tag;
+  TPM_DA_STATE                      state;
+  TPM_DA_ACTION_TYPE                actionAtThreshold;
+  UINT32                            vendorDataSize;
+  UINT8                             *vendorData;
+} TPM_DA_INFO_LIMITED;
+
+//
+// Part 2, section 21.9: CAP_PROPERTY Subcap values for GetCapability
+//
+#define TPM_DA_STATE_INACTIVE          ((UINT8)0x00)
+#define TPM_DA_STATE_ACTIVE            ((UINT8)0x01)
+
+//
+// Part 2, section 22: DAA Structures
+//
+
+//
+// Part 2, section 22.1: Size definitions
+//
+#define TPM_DAA_SIZE_r0                (43)
+#define TPM_DAA_SIZE_r1                (43)
+#define TPM_DAA_SIZE_r2                (128)
+#define TPM_DAA_SIZE_r3                (168)
+#define TPM_DAA_SIZE_r4                (219)
+#define TPM_DAA_SIZE_NT                (20)
+#define TPM_DAA_SIZE_v0                (128)
+#define TPM_DAA_SIZE_v1                (192)
+#define TPM_DAA_SIZE_NE                (256)
+#define TPM_DAA_SIZE_w                 (256)
+#define TPM_DAA_SIZE_issuerModulus     (256)
+//
+// Part 2, section 22.2: Constant definitions
+//
+#define TPM_DAA_power0                 (104)
+#define TPM_DAA_power1                 (1024)
+
+///
+/// Part 2, section 22.3: TPM_DAA_ISSUER
+///
+typedef struct tdTPM_DAA_ISSUER {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DIGEST                      DAA_digest_R0;
+  TPM_DIGEST                      DAA_digest_R1;
+  TPM_DIGEST                      DAA_digest_S0;
+  TPM_DIGEST                      DAA_digest_S1;
+  TPM_DIGEST                      DAA_digest_n;
+  TPM_DIGEST                      DAA_digest_gamma;
+  UINT8                           DAA_generic_q[26];
+} TPM_DAA_ISSUER;
+
+///
+/// Part 2, section 22.4: TPM_DAA_TPM
+///
+typedef struct tdTPM_DAA_TPM {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DIGEST                      DAA_digestIssuer;
+  TPM_DIGEST                      DAA_digest_v0;
+  TPM_DIGEST                      DAA_digest_v1;
+  TPM_DIGEST                      DAA_rekey;
+  UINT32                          DAA_count;
+} TPM_DAA_TPM;
+
+///
+/// Part 2, section 22.5: TPM_DAA_CONTEXT
+///
+typedef struct tdTPM_DAA_CONTEXT {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_DIGEST                      DAA_digestContext;
+  TPM_DIGEST                      DAA_digest;
+  TPM_DAA_CONTEXT_SEED            DAA_contextSeed;
+  UINT8                           DAA_scratch[256];
+  UINT8                           DAA_stage;
+} TPM_DAA_CONTEXT;
+
+///
+/// Part 2, section 22.6: TPM_DAA_JOINDATA
+///
+typedef struct tdTPM_DAA_JOINDATA {
+  UINT8                           DAA_join_u0[128];
+  UINT8                           DAA_join_u1[138];
+  TPM_DIGEST                      DAA_digest_n0;
+} TPM_DAA_JOINDATA;
+
+///
+/// Part 2, section 22.8: TPM_DAA_BLOB
+///
+typedef struct tdTPM_DAA_BLOB {
+  TPM_STRUCTURE_TAG               tag;
+  TPM_RESOURCE_TYPE               resourceType;
+  UINT8                           label[16];
+  TPM_DIGEST                      blobIntegrity;
+  UINT32                          additionalSize;
+  UINT8                           *additionalData;
+  UINT32                          sensitiveSize;
+  UINT8                           *sensitiveData;
+} TPM_DAA_BLOB;
+
+///
+/// Part 2, section 22.9: TPM_DAA_SENSITIVE
+///
+typedef struct tdTPM_DAA_SENSITIVE {
+  TPM_STRUCTURE_TAG               tag;
+  UINT32                          internalSize;
+  UINT8                           *internalData;
+} TPM_DAA_SENSITIVE;
+
+
+//
+// Part 2, section 23: Redirection
+//
+
+///
+/// Part 2 section 23.1: TPM_REDIR_COMMAND
+/// This section defines exactly one value but does not
+/// give it a name. The definition of TPM_SetRedirection in Part3
+/// refers to exactly one name but does not give its value. We join
+/// them here.
+///
+#define TPM_REDIR_GPIO              (0x00000001)
+
+///
+/// TPM Command Headers defined in Part 3
+///
+typedef struct tdTPM_RQU_COMMAND_HDR {
+  TPM_STRUCTURE_TAG                 tag;
+  UINT32                            paramSize;
+  TPM_COMMAND_CODE                  ordinal;
+} TPM_RQU_COMMAND_HDR;
+
+///
+/// TPM Response Headers defined in Part 3
+///
+typedef struct tdTPM_RSP_COMMAND_HDR {
+  TPM_STRUCTURE_TAG                 tag;
+  UINT32                            paramSize;
+  TPM_RESULT                        returnCode;
+} TPM_RSP_COMMAND_HDR;
+
+#pragma pack ()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Tpm20.h b/libedk2_tpm/include/IndustryStandard/Tpm20.h
new file mode 100644
index 0000000..39332b1
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Tpm20.h
@@ -0,0 +1,1814 @@
+/** @file
+  TPM2.0 Specification data structures
+  (Trusted Platform Module Library Specification, Family "2.0", Level 00, Revision 00.96,
+  @http://www.trustedcomputinggroup.org/resources/tpm_library_specification)
+
+  Check http://trustedcomputinggroup.org for latest specification updates.
+
+Copyright (c) 2013 - 2015, Intel Corporation. All rights reserved. <BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+
+#ifndef _TPM20_H_
+#define _TPM20_H_
+
+#include <IndustryStandard/Tpm12.h>
+
+#pragma pack (1)
+
+// Annex A Algorithm Constants
+
+// Table 205 - Defines for SHA1 Hash Values
+#define SHA1_DIGEST_SIZE 20
+#define SHA1_BLOCK_SIZE  64
+
+// Table 206 - Defines for SHA256 Hash Values
+#define SHA256_DIGEST_SIZE 32
+#define SHA256_BLOCK_SIZE  64
+
+// Table 207 - Defines for SHA384 Hash Values
+#define SHA384_DIGEST_SIZE 48
+#define SHA384_BLOCK_SIZE  128
+
+// Table 208 - Defines for SHA512 Hash Values
+#define SHA512_DIGEST_SIZE 64
+#define SHA512_BLOCK_SIZE  128
+
+// Table 209 - Defines for SM3_256 Hash Values
+#define SM3_256_DIGEST_SIZE 32
+#define SM3_256_BLOCK_SIZE  64
+
+// Table 210 - Defines for Architectural Limits Values
+#define MAX_SESSION_NUMBER 3
+
+// Annex B Implementation Definitions
+
+// Table 211 - Defines for Logic Values
+#define YES   1
+#define NO    0
+#define SET   1
+#define CLEAR 0
+
+// Table 215 - Defines for RSA Algorithm Constants
+#define MAX_RSA_KEY_BITS  2048
+#define MAX_RSA_KEY_BYTES ((MAX_RSA_KEY_BITS + 7) / 8)
+
+// Table 216 - Defines for ECC Algorithm Constants
+#define MAX_ECC_KEY_BITS  256
+#define MAX_ECC_KEY_BYTES ((MAX_ECC_KEY_BITS + 7) / 8)
+
+// Table 217 - Defines for AES Algorithm Constants
+#define MAX_AES_KEY_BITS         128
+#define MAX_AES_BLOCK_SIZE_BYTES 16
+#define MAX_AES_KEY_BYTES        ((MAX_AES_KEY_BITS + 7) / 8)
+
+// Table 218 - Defines for SM4 Algorithm Constants
+#define MAX_SM4_KEY_BITS         128
+#define MAX_SM4_BLOCK_SIZE_BYTES 16
+#define MAX_SM4_KEY_BYTES        ((MAX_SM4_KEY_BITS + 7) / 8)
+
+// Table 219 - Defines for Symmetric Algorithm Constants
+#define MAX_SYM_KEY_BITS   MAX_AES_KEY_BITS
+#define MAX_SYM_KEY_BYTES  MAX_AES_KEY_BYTES
+#define MAX_SYM_BLOCK_SIZE MAX_AES_BLOCK_SIZE_BYTES
+
+// Table 220 - Defines for Implementation Values
+typedef UINT16                        BSIZE;
+#define BUFFER_ALIGNMENT              4
+#define IMPLEMENTATION_PCR            24
+#define PLATFORM_PCR                  24
+#define DRTM_PCR                      17
+#define NUM_LOCALITIES                5
+#define MAX_HANDLE_NUM                3
+#define MAX_ACTIVE_SESSIONS           64
+typedef UINT16                        CONTEXT_SLOT;
+typedef UINT64                        CONTEXT_COUNTER;
+#define MAX_LOADED_SESSIONS           3
+#define MAX_SESSION_NUM               3
+#define MAX_LOADED_OBJECTS            3
+#define MIN_EVICT_OBJECTS             2
+#define PCR_SELECT_MIN                ((PLATFORM_PCR + 7) / 8)
+#define PCR_SELECT_MAX                ((IMPLEMENTATION_PCR + 7) / 8)
+#define NUM_POLICY_PCR_GROUP          1
+#define NUM_AUTHVALUE_PCR_GROUP       1
+#define MAX_CONTEXT_SIZE              4000
+#define MAX_DIGEST_BUFFER             1024
+#define MAX_NV_INDEX_SIZE             1024
+#define MAX_CAP_BUFFER                1024
+#define NV_MEMORY_SIZE                16384
+#define NUM_STATIC_PCR                16
+#define MAX_ALG_LIST_SIZE             64
+#define TIMER_PRESCALE                100000
+#define PRIMARY_SEED_SIZE             32
+#define CONTEXT_ENCRYPT_ALG           TPM_ALG_AES
+#define CONTEXT_ENCRYPT_KEY_BITS      MAX_SYM_KEY_BITS
+#define CONTEXT_ENCRYPT_KEY_BYTES     ((CONTEXT_ENCRYPT_KEY_BITS + 7) / 8)
+#define CONTEXT_INTEGRITY_HASH_ALG    TPM_ALG_SHA256
+#define CONTEXT_INTEGRITY_HASH_SIZE   SHA256_DIGEST_SIZE
+#define PROOF_SIZE                    CONTEXT_INTEGRITY_HASH_SIZE
+#define NV_CLOCK_UPDATE_INTERVAL      12
+#define NUM_POLICY_PCR                1
+#define MAX_COMMAND_SIZE              4096
+#define MAX_RESPONSE_SIZE             4096
+#define ORDERLY_BITS                  8
+#define MAX_ORDERLY_COUNT             ((1 << ORDERLY_BITS) - 1)
+#define ALG_ID_FIRST                  TPM_ALG_FIRST
+#define ALG_ID_LAST                   TPM_ALG_LAST
+#define MAX_SYM_DATA                  128
+#define MAX_RNG_ENTROPY_SIZE          64
+#define RAM_INDEX_SPACE               512
+#define RSA_DEFAULT_PUBLIC_EXPONENT   0x00010001
+#define CRT_FORMAT_RSA                YES
+#define PRIVATE_VENDOR_SPECIFIC_BYTES ((MAX_RSA_KEY_BYTES / 2) * ( 3 + CRT_FORMAT_RSA * 2))
+
+// Capability related MAX_ value
+#define MAX_CAP_DATA       (MAX_CAP_BUFFER - sizeof(TPM_CAP) - sizeof(UINT32))
+#define MAX_CAP_ALGS       (MAX_CAP_DATA / sizeof(TPMS_ALG_PROPERTY))
+#define MAX_CAP_HANDLES    (MAX_CAP_DATA / sizeof(TPM_HANDLE))
+#define MAX_CAP_CC         (MAX_CAP_DATA / sizeof(TPM_CC))
+#define MAX_TPM_PROPERTIES (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PROPERTY))
+#define MAX_PCR_PROPERTIES (MAX_CAP_DATA / sizeof(TPMS_TAGGED_PCR_SELECT))
+#define MAX_ECC_CURVES     (MAX_CAP_DATA / sizeof(TPM_ECC_CURVE))
+
+//
+// Always set 5 here, because we want to support all hash algo in BIOS.
+//
+#define HASH_COUNT 5
+
+// 5 Base Types
+
+// Table 3 - Definition of Base Types
+typedef UINT8 BYTE;
+
+// Table 4 - Definition of Types for Documentation Clarity
+//
+// NOTE: Comment because it has same name as TPM1.2 (value is same, so not runtime issue)
+//
+//typedef UINT32 TPM_ALGORITHM_ID;
+//typedef UINT32 TPM_MODIFIER_INDICATOR;
+typedef UINT32 TPM_AUTHORIZATION_SIZE;
+typedef UINT32 TPM_PARAMETER_SIZE;
+typedef UINT16 TPM_KEY_SIZE;
+typedef UINT16 TPM_KEY_BITS;
+
+// 6 Constants
+
+// Table 6 - TPM_GENERATED Constants
+typedef UINT32 TPM_GENERATED;
+#define TPM_GENERATED_VALUE (TPM_GENERATED)(0xff544347)
+
+// Table 7 - TPM_ALG_ID Constants
+typedef UINT16 TPM_ALG_ID;
+//
+// NOTE: Comment some algo which has same name as TPM1.2 (value is same, so not runtime issue)
+//
+#define TPM_ALG_ERROR          (TPM_ALG_ID)(0x0000)
+#define TPM_ALG_FIRST          (TPM_ALG_ID)(0x0001)
+//#define TPM_ALG_RSA            (TPM_ALG_ID)(0x0001)
+//#define TPM_ALG_SHA            (TPM_ALG_ID)(0x0004)
+#define TPM_ALG_SHA1           (TPM_ALG_ID)(0x0004)
+//#define TPM_ALG_HMAC           (TPM_ALG_ID)(0x0005)
+#define TPM_ALG_AES            (TPM_ALG_ID)(0x0006)
+//#define TPM_ALG_MGF1           (TPM_ALG_ID)(0x0007)
+#define TPM_ALG_KEYEDHASH      (TPM_ALG_ID)(0x0008)
+//#define TPM_ALG_XOR            (TPM_ALG_ID)(0x000A)
+#define TPM_ALG_SHA256         (TPM_ALG_ID)(0x000B)
+#define TPM_ALG_SHA384         (TPM_ALG_ID)(0x000C)
+#define TPM_ALG_SHA512         (TPM_ALG_ID)(0x000D)
+#define TPM_ALG_NULL           (TPM_ALG_ID)(0x0010)
+#define TPM_ALG_SM3_256        (TPM_ALG_ID)(0x0012)
+#define TPM_ALG_SM4            (TPM_ALG_ID)(0x0013)
+#define TPM_ALG_RSASSA         (TPM_ALG_ID)(0x0014)
+#define TPM_ALG_RSAES          (TPM_ALG_ID)(0x0015)
+#define TPM_ALG_RSAPSS         (TPM_ALG_ID)(0x0016)
+#define TPM_ALG_OAEP           (TPM_ALG_ID)(0x0017)
+#define TPM_ALG_ECDSA          (TPM_ALG_ID)(0x0018)
+#define TPM_ALG_ECDH           (TPM_ALG_ID)(0x0019)
+#define TPM_ALG_ECDAA          (TPM_ALG_ID)(0x001A)
+#define TPM_ALG_SM2            (TPM_ALG_ID)(0x001B)
+#define TPM_ALG_ECSCHNORR      (TPM_ALG_ID)(0x001C)
+#define TPM_ALG_ECMQV          (TPM_ALG_ID)(0x001D)
+#define TPM_ALG_KDF1_SP800_56a (TPM_ALG_ID)(0x0020)
+#define TPM_ALG_KDF2           (TPM_ALG_ID)(0x0021)
+#define TPM_ALG_KDF1_SP800_108 (TPM_ALG_ID)(0x0022)
+#define TPM_ALG_ECC            (TPM_ALG_ID)(0x0023)
+#define TPM_ALG_SYMCIPHER      (TPM_ALG_ID)(0x0025)
+#define TPM_ALG_CTR            (TPM_ALG_ID)(0x0040)
+#define TPM_ALG_OFB            (TPM_ALG_ID)(0x0041)
+#define TPM_ALG_CBC            (TPM_ALG_ID)(0x0042)
+#define TPM_ALG_CFB            (TPM_ALG_ID)(0x0043)
+#define TPM_ALG_ECB            (TPM_ALG_ID)(0x0044)
+#define TPM_ALG_LAST           (TPM_ALG_ID)(0x0044)
+
+// Table 8 - TPM_ECC_CURVE Constants
+typedef UINT16 TPM_ECC_CURVE;
+#define TPM_ECC_NONE      (TPM_ECC_CURVE)(0x0000)
+#define TPM_ECC_NIST_P192 (TPM_ECC_CURVE)(0x0001)
+#define TPM_ECC_NIST_P224 (TPM_ECC_CURVE)(0x0002)
+#define TPM_ECC_NIST_P256 (TPM_ECC_CURVE)(0x0003)
+#define TPM_ECC_NIST_P384 (TPM_ECC_CURVE)(0x0004)
+#define TPM_ECC_NIST_P521 (TPM_ECC_CURVE)(0x0005)
+#define TPM_ECC_BN_P256   (TPM_ECC_CURVE)(0x0010)
+#define TPM_ECC_BN_P638   (TPM_ECC_CURVE)(0x0011)
+#define TPM_ECC_SM2_P256  (TPM_ECC_CURVE)(0x0020)
+
+// Table 11 - TPM_CC Constants (Numeric Order)
+typedef UINT32 TPM_CC;
+#define TPM_CC_FIRST                      (TPM_CC)(0x0000011F)
+#define TPM_CC_PP_FIRST                   (TPM_CC)(0x0000011F)
+#define TPM_CC_NV_UndefineSpaceSpecial    (TPM_CC)(0x0000011F)
+#define TPM_CC_EvictControl               (TPM_CC)(0x00000120)
+#define TPM_CC_HierarchyControl           (TPM_CC)(0x00000121)
+#define TPM_CC_NV_UndefineSpace           (TPM_CC)(0x00000122)
+#define TPM_CC_ChangeEPS                  (TPM_CC)(0x00000124)
+#define TPM_CC_ChangePPS                  (TPM_CC)(0x00000125)
+#define TPM_CC_Clear                      (TPM_CC)(0x00000126)
+#define TPM_CC_ClearControl               (TPM_CC)(0x00000127)
+#define TPM_CC_ClockSet                   (TPM_CC)(0x00000128)
+#define TPM_CC_HierarchyChangeAuth        (TPM_CC)(0x00000129)
+#define TPM_CC_NV_DefineSpace             (TPM_CC)(0x0000012A)
+#define TPM_CC_PCR_Allocate               (TPM_CC)(0x0000012B)
+#define TPM_CC_PCR_SetAuthPolicy          (TPM_CC)(0x0000012C)
+#define TPM_CC_PP_Commands                (TPM_CC)(0x0000012D)
+#define TPM_CC_SetPrimaryPolicy           (TPM_CC)(0x0000012E)
+#define TPM_CC_FieldUpgradeStart          (TPM_CC)(0x0000012F)
+#define TPM_CC_ClockRateAdjust            (TPM_CC)(0x00000130)
+#define TPM_CC_CreatePrimary              (TPM_CC)(0x00000131)
+#define TPM_CC_NV_GlobalWriteLock         (TPM_CC)(0x00000132)
+#define TPM_CC_PP_LAST                    (TPM_CC)(0x00000132)
+#define TPM_CC_GetCommandAuditDigest      (TPM_CC)(0x00000133)
+#define TPM_CC_NV_Increment               (TPM_CC)(0x00000134)
+#define TPM_CC_NV_SetBits                 (TPM_CC)(0x00000135)
+#define TPM_CC_NV_Extend                  (TPM_CC)(0x00000136)
+#define TPM_CC_NV_Write                   (TPM_CC)(0x00000137)
+#define TPM_CC_NV_WriteLock               (TPM_CC)(0x00000138)
+#define TPM_CC_DictionaryAttackLockReset  (TPM_CC)(0x00000139)
+#define TPM_CC_DictionaryAttackParameters (TPM_CC)(0x0000013A)
+#define TPM_CC_NV_ChangeAuth              (TPM_CC)(0x0000013B)
+#define TPM_CC_PCR_Event                  (TPM_CC)(0x0000013C)
+#define TPM_CC_PCR_Reset                  (TPM_CC)(0x0000013D)
+#define TPM_CC_SequenceComplete           (TPM_CC)(0x0000013E)
+#define TPM_CC_SetAlgorithmSet            (TPM_CC)(0x0000013F)
+#define TPM_CC_SetCommandCodeAuditStatus  (TPM_CC)(0x00000140)
+#define TPM_CC_FieldUpgradeData           (TPM_CC)(0x00000141)
+#define TPM_CC_IncrementalSelfTest        (TPM_CC)(0x00000142)
+#define TPM_CC_SelfTest                   (TPM_CC)(0x00000143)
+#define TPM_CC_Startup                    (TPM_CC)(0x00000144)
+#define TPM_CC_Shutdown                   (TPM_CC)(0x00000145)
+#define TPM_CC_StirRandom                 (TPM_CC)(0x00000146)
+#define TPM_CC_ActivateCredential         (TPM_CC)(0x00000147)
+#define TPM_CC_Certify                    (TPM_CC)(0x00000148)
+#define TPM_CC_PolicyNV                   (TPM_CC)(0x00000149)
+#define TPM_CC_CertifyCreation            (TPM_CC)(0x0000014A)
+#define TPM_CC_Duplicate                  (TPM_CC)(0x0000014B)
+#define TPM_CC_GetTime                    (TPM_CC)(0x0000014C)
+#define TPM_CC_GetSessionAuditDigest      (TPM_CC)(0x0000014D)
+#define TPM_CC_NV_Read                    (TPM_CC)(0x0000014E)
+#define TPM_CC_NV_ReadLock                (TPM_CC)(0x0000014F)
+#define TPM_CC_ObjectChangeAuth           (TPM_CC)(0x00000150)
+#define TPM_CC_PolicySecret               (TPM_CC)(0x00000151)
+#define TPM_CC_Rewrap                     (TPM_CC)(0x00000152)
+#define TPM_CC_Create                     (TPM_CC)(0x00000153)
+#define TPM_CC_ECDH_ZGen                  (TPM_CC)(0x00000154)
+#define TPM_CC_HMAC                       (TPM_CC)(0x00000155)
+#define TPM_CC_Import                     (TPM_CC)(0x00000156)
+#define TPM_CC_Load                       (TPM_CC)(0x00000157)
+#define TPM_CC_Quote                      (TPM_CC)(0x00000158)
+#define TPM_CC_RSA_Decrypt                (TPM_CC)(0x00000159)
+#define TPM_CC_HMAC_Start                 (TPM_CC)(0x0000015B)
+#define TPM_CC_SequenceUpdate             (TPM_CC)(0x0000015C)
+#define TPM_CC_Sign                       (TPM_CC)(0x0000015D)
+#define TPM_CC_Unseal                     (TPM_CC)(0x0000015E)
+#define TPM_CC_PolicySigned               (TPM_CC)(0x00000160)
+#define TPM_CC_ContextLoad                (TPM_CC)(0x00000161)
+#define TPM_CC_ContextSave                (TPM_CC)(0x00000162)
+#define TPM_CC_ECDH_KeyGen                (TPM_CC)(0x00000163)
+#define TPM_CC_EncryptDecrypt             (TPM_CC)(0x00000164)
+#define TPM_CC_FlushContext               (TPM_CC)(0x00000165)
+#define TPM_CC_LoadExternal               (TPM_CC)(0x00000167)
+#define TPM_CC_MakeCredential             (TPM_CC)(0x00000168)
+#define TPM_CC_NV_ReadPublic              (TPM_CC)(0x00000169)
+#define TPM_CC_PolicyAuthorize            (TPM_CC)(0x0000016A)
+#define TPM_CC_PolicyAuthValue            (TPM_CC)(0x0000016B)
+#define TPM_CC_PolicyCommandCode          (TPM_CC)(0x0000016C)
+#define TPM_CC_PolicyCounterTimer         (TPM_CC)(0x0000016D)
+#define TPM_CC_PolicyCpHash               (TPM_CC)(0x0000016E)
+#define TPM_CC_PolicyLocality             (TPM_CC)(0x0000016F)
+#define TPM_CC_PolicyNameHash             (TPM_CC)(0x00000170)
+#define TPM_CC_PolicyOR                   (TPM_CC)(0x00000171)
+#define TPM_CC_PolicyTicket               (TPM_CC)(0x00000172)
+#define TPM_CC_ReadPublic                 (TPM_CC)(0x00000173)
+#define TPM_CC_RSA_Encrypt                (TPM_CC)(0x00000174)
+#define TPM_CC_StartAuthSession           (TPM_CC)(0x00000176)
+#define TPM_CC_VerifySignature            (TPM_CC)(0x00000177)
+#define TPM_CC_ECC_Parameters             (TPM_CC)(0x00000178)
+#define TPM_CC_FirmwareRead               (TPM_CC)(0x00000179)
+#define TPM_CC_GetCapability              (TPM_CC)(0x0000017A)
+#define TPM_CC_GetRandom                  (TPM_CC)(0x0000017B)
+#define TPM_CC_GetTestResult              (TPM_CC)(0x0000017C)
+#define TPM_CC_Hash                       (TPM_CC)(0x0000017D)
+#define TPM_CC_PCR_Read                   (TPM_CC)(0x0000017E)
+#define TPM_CC_PolicyPCR                  (TPM_CC)(0x0000017F)
+#define TPM_CC_PolicyRestart              (TPM_CC)(0x00000180)
+#define TPM_CC_ReadClock                  (TPM_CC)(0x00000181)
+#define TPM_CC_PCR_Extend                 (TPM_CC)(0x00000182)
+#define TPM_CC_PCR_SetAuthValue           (TPM_CC)(0x00000183)
+#define TPM_CC_NV_Certify                 (TPM_CC)(0x00000184)
+#define TPM_CC_EventSequenceComplete      (TPM_CC)(0x00000185)
+#define TPM_CC_HashSequenceStart          (TPM_CC)(0x00000186)
+#define TPM_CC_PolicyPhysicalPresence     (TPM_CC)(0x00000187)
+#define TPM_CC_PolicyDuplicationSelect    (TPM_CC)(0x00000188)
+#define TPM_CC_PolicyGetDigest            (TPM_CC)(0x00000189)
+#define TPM_CC_TestParms                  (TPM_CC)(0x0000018A)
+#define TPM_CC_Commit                     (TPM_CC)(0x0000018B)
+#define TPM_CC_PolicyPassword             (TPM_CC)(0x0000018C)
+#define TPM_CC_ZGen_2Phase                (TPM_CC)(0x0000018D)
+#define TPM_CC_EC_Ephemeral               (TPM_CC)(0x0000018E)
+#define TPM_CC_LAST                       (TPM_CC)(0x0000018E)
+
+// Table 15 - TPM_RC Constants (Actions)
+typedef UINT32 TPM_RC;
+#define TPM_RC_SUCCESS           (TPM_RC)(0x000)
+#define TPM_RC_BAD_TAG           (TPM_RC)(0x030)
+#define RC_VER1                  (TPM_RC)(0x100)
+#define TPM_RC_INITIALIZE        (TPM_RC)(RC_VER1 + 0x000)
+#define TPM_RC_FAILURE           (TPM_RC)(RC_VER1 + 0x001)
+#define TPM_RC_SEQUENCE          (TPM_RC)(RC_VER1 + 0x003)
+#define TPM_RC_PRIVATE           (TPM_RC)(RC_VER1 + 0x00B)
+#define TPM_RC_HMAC              (TPM_RC)(RC_VER1 + 0x019)
+#define TPM_RC_DISABLED          (TPM_RC)(RC_VER1 + 0x020)
+#define TPM_RC_EXCLUSIVE         (TPM_RC)(RC_VER1 + 0x021)
+#define TPM_RC_AUTH_TYPE         (TPM_RC)(RC_VER1 + 0x024)
+#define TPM_RC_AUTH_MISSING      (TPM_RC)(RC_VER1 + 0x025)
+#define TPM_RC_POLICY            (TPM_RC)(RC_VER1 + 0x026)
+#define TPM_RC_PCR               (TPM_RC)(RC_VER1 + 0x027)
+#define TPM_RC_PCR_CHANGED       (TPM_RC)(RC_VER1 + 0x028)
+#define TPM_RC_UPGRADE           (TPM_RC)(RC_VER1 + 0x02D)
+#define TPM_RC_TOO_MANY_CONTEXTS (TPM_RC)(RC_VER1 + 0x02E)
+#define TPM_RC_AUTH_UNAVAILABLE  (TPM_RC)(RC_VER1 + 0x02F)
+#define TPM_RC_REBOOT            (TPM_RC)(RC_VER1 + 0x030)
+#define TPM_RC_UNBALANCED        (TPM_RC)(RC_VER1 + 0x031)
+#define TPM_RC_COMMAND_SIZE      (TPM_RC)(RC_VER1 + 0x042)
+#define TPM_RC_COMMAND_CODE      (TPM_RC)(RC_VER1 + 0x043)
+#define TPM_RC_AUTHSIZE          (TPM_RC)(RC_VER1 + 0x044)
+#define TPM_RC_AUTH_CONTEXT      (TPM_RC)(RC_VER1 + 0x045)
+#define TPM_RC_NV_RANGE          (TPM_RC)(RC_VER1 + 0x046)
+#define TPM_RC_NV_SIZE           (TPM_RC)(RC_VER1 + 0x047)
+#define TPM_RC_NV_LOCKED         (TPM_RC)(RC_VER1 + 0x048)
+#define TPM_RC_NV_AUTHORIZATION  (TPM_RC)(RC_VER1 + 0x049)
+#define TPM_RC_NV_UNINITIALIZED  (TPM_RC)(RC_VER1 + 0x04A)
+#define TPM_RC_NV_SPACE          (TPM_RC)(RC_VER1 + 0x04B)
+#define TPM_RC_NV_DEFINED        (TPM_RC)(RC_VER1 + 0x04C)
+#define TPM_RC_BAD_CONTEXT       (TPM_RC)(RC_VER1 + 0x050)
+#define TPM_RC_CPHASH            (TPM_RC)(RC_VER1 + 0x051)
+#define TPM_RC_PARENT            (TPM_RC)(RC_VER1 + 0x052)
+#define TPM_RC_NEEDS_TEST        (TPM_RC)(RC_VER1 + 0x053)
+#define TPM_RC_NO_RESULT         (TPM_RC)(RC_VER1 + 0x054)
+#define TPM_RC_SENSITIVE         (TPM_RC)(RC_VER1 + 0x055)
+#define RC_MAX_FM0               (TPM_RC)(RC_VER1 + 0x07F)
+#define RC_FMT1                  (TPM_RC)(0x080)
+#define TPM_RC_ASYMMETRIC        (TPM_RC)(RC_FMT1 + 0x001)
+#define TPM_RC_ATTRIBUTES        (TPM_RC)(RC_FMT1 + 0x002)
+#define TPM_RC_HASH              (TPM_RC)(RC_FMT1 + 0x003)
+#define TPM_RC_VALUE             (TPM_RC)(RC_FMT1 + 0x004)
+#define TPM_RC_HIERARCHY         (TPM_RC)(RC_FMT1 + 0x005)
+#define TPM_RC_KEY_SIZE          (TPM_RC)(RC_FMT1 + 0x007)
+#define TPM_RC_MGF               (TPM_RC)(RC_FMT1 + 0x008)
+#define TPM_RC_MODE              (TPM_RC)(RC_FMT1 + 0x009)
+#define TPM_RC_TYPE              (TPM_RC)(RC_FMT1 + 0x00A)
+#define TPM_RC_HANDLE            (TPM_RC)(RC_FMT1 + 0x00B)
+#define TPM_RC_KDF               (TPM_RC)(RC_FMT1 + 0x00C)
+#define TPM_RC_RANGE             (TPM_RC)(RC_FMT1 + 0x00D)
+#define TPM_RC_AUTH_FAIL         (TPM_RC)(RC_FMT1 + 0x00E)
+#define TPM_RC_NONCE             (TPM_RC)(RC_FMT1 + 0x00F)
+#define TPM_RC_PP                (TPM_RC)(RC_FMT1 + 0x010)
+#define TPM_RC_SCHEME            (TPM_RC)(RC_FMT1 + 0x012)
+#define TPM_RC_SIZE              (TPM_RC)(RC_FMT1 + 0x015)
+#define TPM_RC_SYMMETRIC         (TPM_RC)(RC_FMT1 + 0x016)
+#define TPM_RC_TAG               (TPM_RC)(RC_FMT1 + 0x017)
+#define TPM_RC_SELECTOR          (TPM_RC)(RC_FMT1 + 0x018)
+#define TPM_RC_INSUFFICIENT      (TPM_RC)(RC_FMT1 + 0x01A)
+#define TPM_RC_SIGNATURE         (TPM_RC)(RC_FMT1 + 0x01B)
+#define TPM_RC_KEY               (TPM_RC)(RC_FMT1 + 0x01C)
+#define TPM_RC_POLICY_FAIL       (TPM_RC)(RC_FMT1 + 0x01D)
+#define TPM_RC_INTEGRITY         (TPM_RC)(RC_FMT1 + 0x01F)
+#define TPM_RC_TICKET            (TPM_RC)(RC_FMT1 + 0x020)
+#define TPM_RC_RESERVED_BITS     (TPM_RC)(RC_FMT1 + 0x021)
+#define TPM_RC_BAD_AUTH          (TPM_RC)(RC_FMT1 + 0x022)
+#define TPM_RC_EXPIRED           (TPM_RC)(RC_FMT1 + 0x023)
+#define TPM_RC_POLICY_CC         (TPM_RC)(RC_FMT1 + 0x024 )
+#define TPM_RC_BINDING           (TPM_RC)(RC_FMT1 + 0x025)
+#define TPM_RC_CURVE             (TPM_RC)(RC_FMT1 + 0x026)
+#define TPM_RC_ECC_POINT         (TPM_RC)(RC_FMT1 + 0x027)
+#define RC_WARN                  (TPM_RC)(0x900)
+#define TPM_RC_CONTEXT_GAP       (TPM_RC)(RC_WARN + 0x001)
+#define TPM_RC_OBJECT_MEMORY     (TPM_RC)(RC_WARN + 0x002)
+#define TPM_RC_SESSION_MEMORY    (TPM_RC)(RC_WARN + 0x003)
+#define TPM_RC_MEMORY            (TPM_RC)(RC_WARN + 0x004)
+#define TPM_RC_SESSION_HANDLES   (TPM_RC)(RC_WARN + 0x005)
+#define TPM_RC_OBJECT_HANDLES    (TPM_RC)(RC_WARN + 0x006)
+#define TPM_RC_LOCALITY          (TPM_RC)(RC_WARN + 0x007)
+#define TPM_RC_YIELDED           (TPM_RC)(RC_WARN + 0x008)
+#define TPM_RC_CANCELED          (TPM_RC)(RC_WARN + 0x009)
+#define TPM_RC_TESTING           (TPM_RC)(RC_WARN + 0x00A)
+#define TPM_RC_REFERENCE_H0      (TPM_RC)(RC_WARN + 0x010)
+#define TPM_RC_REFERENCE_H1      (TPM_RC)(RC_WARN + 0x011)
+#define TPM_RC_REFERENCE_H2      (TPM_RC)(RC_WARN + 0x012)
+#define TPM_RC_REFERENCE_H3      (TPM_RC)(RC_WARN + 0x013)
+#define TPM_RC_REFERENCE_H4      (TPM_RC)(RC_WARN + 0x014)
+#define TPM_RC_REFERENCE_H5      (TPM_RC)(RC_WARN + 0x015)
+#define TPM_RC_REFERENCE_H6      (TPM_RC)(RC_WARN + 0x016)
+#define TPM_RC_REFERENCE_S0      (TPM_RC)(RC_WARN + 0x018)
+#define TPM_RC_REFERENCE_S1      (TPM_RC)(RC_WARN + 0x019)
+#define TPM_RC_REFERENCE_S2      (TPM_RC)(RC_WARN + 0x01A)
+#define TPM_RC_REFERENCE_S3      (TPM_RC)(RC_WARN + 0x01B)
+#define TPM_RC_REFERENCE_S4      (TPM_RC)(RC_WARN + 0x01C)
+#define TPM_RC_REFERENCE_S5      (TPM_RC)(RC_WARN + 0x01D)
+#define TPM_RC_REFERENCE_S6      (TPM_RC)(RC_WARN + 0x01E)
+#define TPM_RC_NV_RATE           (TPM_RC)(RC_WARN + 0x020)
+#define TPM_RC_LOCKOUT           (TPM_RC)(RC_WARN + 0x021)
+#define TPM_RC_RETRY             (TPM_RC)(RC_WARN + 0x022)
+#define TPM_RC_NV_UNAVAILABLE    (TPM_RC)(RC_WARN + 0x023)
+#define TPM_RC_NOT_USED          (TPM_RC)(RC_WARN + 0x7F)
+#define TPM_RC_H                 (TPM_RC)(0x000)
+#define TPM_RC_P                 (TPM_RC)(0x040)
+#define TPM_RC_S                 (TPM_RC)(0x800)
+#define TPM_RC_1                 (TPM_RC)(0x100)
+#define TPM_RC_2                 (TPM_RC)(0x200)
+#define TPM_RC_3                 (TPM_RC)(0x300)
+#define TPM_RC_4                 (TPM_RC)(0x400)
+#define TPM_RC_5                 (TPM_RC)(0x500)
+#define TPM_RC_6                 (TPM_RC)(0x600)
+#define TPM_RC_7                 (TPM_RC)(0x700)
+#define TPM_RC_8                 (TPM_RC)(0x800)
+#define TPM_RC_9                 (TPM_RC)(0x900)
+#define TPM_RC_A                 (TPM_RC)(0xA00)
+#define TPM_RC_B                 (TPM_RC)(0xB00)
+#define TPM_RC_C                 (TPM_RC)(0xC00)
+#define TPM_RC_D                 (TPM_RC)(0xD00)
+#define TPM_RC_E                 (TPM_RC)(0xE00)
+#define TPM_RC_F                 (TPM_RC)(0xF00)
+#define TPM_RC_N_MASK            (TPM_RC)(0xF00)
+
+// Table 16 - TPM_CLOCK_ADJUST Constants
+typedef INT8 TPM_CLOCK_ADJUST;
+#define TPM_CLOCK_COARSE_SLOWER (TPM_CLOCK_ADJUST)(-3)
+#define TPM_CLOCK_MEDIUM_SLOWER (TPM_CLOCK_ADJUST)(-2)
+#define TPM_CLOCK_FINE_SLOWER   (TPM_CLOCK_ADJUST)(-1)
+#define TPM_CLOCK_NO_CHANGE     (TPM_CLOCK_ADJUST)(0)
+#define TPM_CLOCK_FINE_FASTER   (TPM_CLOCK_ADJUST)(1)
+#define TPM_CLOCK_MEDIUM_FASTER (TPM_CLOCK_ADJUST)(2)
+#define TPM_CLOCK_COARSE_FASTER (TPM_CLOCK_ADJUST)(3)
+
+// Table 17 - TPM_EO Constants
+typedef UINT16 TPM_EO;
+#define TPM_EO_EQ          (TPM_EO)(0x0000)
+#define TPM_EO_NEQ         (TPM_EO)(0x0001)
+#define TPM_EO_SIGNED_GT   (TPM_EO)(0x0002)
+#define TPM_EO_UNSIGNED_GT (TPM_EO)(0x0003)
+#define TPM_EO_SIGNED_LT   (TPM_EO)(0x0004)
+#define TPM_EO_UNSIGNED_LT (TPM_EO)(0x0005)
+#define TPM_EO_SIGNED_GE   (TPM_EO)(0x0006)
+#define TPM_EO_UNSIGNED_GE (TPM_EO)(0x0007)
+#define TPM_EO_SIGNED_LE   (TPM_EO)(0x0008)
+#define TPM_EO_UNSIGNED_LE (TPM_EO)(0x0009)
+#define TPM_EO_BITSET      (TPM_EO)(0x000A)
+#define TPM_EO_BITCLEAR    (TPM_EO)(0x000B)
+
+// Table 18 - TPM_ST Constants
+typedef UINT16 TPM_ST;
+#define TPM_ST_RSP_COMMAND          (TPM_ST)(0x00C4)
+#define TPM_ST_NULL                 (TPM_ST)(0X8000)
+#define TPM_ST_NO_SESSIONS          (TPM_ST)(0x8001)
+#define TPM_ST_SESSIONS             (TPM_ST)(0x8002)
+#define TPM_ST_ATTEST_NV            (TPM_ST)(0x8014)
+#define TPM_ST_ATTEST_COMMAND_AUDIT (TPM_ST)(0x8015)
+#define TPM_ST_ATTEST_SESSION_AUDIT (TPM_ST)(0x8016)
+#define TPM_ST_ATTEST_CERTIFY       (TPM_ST)(0x8017)
+#define TPM_ST_ATTEST_QUOTE         (TPM_ST)(0x8018)
+#define TPM_ST_ATTEST_TIME          (TPM_ST)(0x8019)
+#define TPM_ST_ATTEST_CREATION      (TPM_ST)(0x801A)
+#define TPM_ST_CREATION             (TPM_ST)(0x8021)
+#define TPM_ST_VERIFIED             (TPM_ST)(0x8022)
+#define TPM_ST_AUTH_SECRET          (TPM_ST)(0x8023)
+#define TPM_ST_HASHCHECK            (TPM_ST)(0x8024)
+#define TPM_ST_AUTH_SIGNED          (TPM_ST)(0x8025)
+#define TPM_ST_FU_MANIFEST          (TPM_ST)(0x8029)
+
+// Table 19 - TPM_SU Constants
+typedef UINT16 TPM_SU;
+#define TPM_SU_CLEAR (TPM_SU)(0x0000)
+#define TPM_SU_STATE (TPM_SU)(0x0001)
+
+// Table 20 - TPM_SE Constants
+typedef UINT8 TPM_SE;
+#define TPM_SE_HMAC   (TPM_SE)(0x00)
+#define TPM_SE_POLICY (TPM_SE)(0x01)
+#define TPM_SE_TRIAL  (TPM_SE)(0x03)
+
+// Table 21 - TPM_CAP Constants
+typedef UINT32 TPM_CAP;
+#define TPM_CAP_FIRST           (TPM_CAP)(0x00000000)
+#define TPM_CAP_ALGS            (TPM_CAP)(0x00000000)
+#define TPM_CAP_HANDLES         (TPM_CAP)(0x00000001)
+#define TPM_CAP_COMMANDS        (TPM_CAP)(0x00000002)
+#define TPM_CAP_PP_COMMANDS     (TPM_CAP)(0x00000003)
+#define TPM_CAP_AUDIT_COMMANDS  (TPM_CAP)(0x00000004)
+#define TPM_CAP_PCRS            (TPM_CAP)(0x00000005)
+#define TPM_CAP_TPM_PROPERTIES  (TPM_CAP)(0x00000006)
+#define TPM_CAP_PCR_PROPERTIES  (TPM_CAP)(0x00000007)
+#define TPM_CAP_ECC_CURVES      (TPM_CAP)(0x00000008)
+#define TPM_CAP_LAST            (TPM_CAP)(0x00000008)
+#define TPM_CAP_VENDOR_PROPERTY (TPM_CAP)(0x00000100)
+
+// Table 22 - TPM_PT Constants
+typedef UINT32 TPM_PT;
+#define TPM_PT_NONE                (TPM_PT)(0x00000000)
+#define PT_GROUP                   (TPM_PT)(0x00000100)
+#define PT_FIXED                   (TPM_PT)(PT_GROUP * 1)
+#define TPM_PT_FAMILY_INDICATOR    (TPM_PT)(PT_FIXED + 0)
+#define TPM_PT_LEVEL               (TPM_PT)(PT_FIXED + 1)
+#define TPM_PT_REVISION            (TPM_PT)(PT_FIXED + 2)
+#define TPM_PT_DAY_OF_YEAR         (TPM_PT)(PT_FIXED + 3)
+#define TPM_PT_YEAR                (TPM_PT)(PT_FIXED + 4)
+#define TPM_PT_MANUFACTURER        (TPM_PT)(PT_FIXED + 5)
+#define TPM_PT_VENDOR_STRING_1     (TPM_PT)(PT_FIXED + 6)
+#define TPM_PT_VENDOR_STRING_2     (TPM_PT)(PT_FIXED + 7)
+#define TPM_PT_VENDOR_STRING_3     (TPM_PT)(PT_FIXED + 8)
+#define TPM_PT_VENDOR_STRING_4     (TPM_PT)(PT_FIXED + 9)
+#define TPM_PT_VENDOR_TPM_TYPE     (TPM_PT)(PT_FIXED + 10)
+#define TPM_PT_FIRMWARE_VERSION_1  (TPM_PT)(PT_FIXED + 11)
+#define TPM_PT_FIRMWARE_VERSION_2  (TPM_PT)(PT_FIXED + 12)
+#define TPM_PT_INPUT_BUFFER        (TPM_PT)(PT_FIXED + 13)
+#define TPM_PT_HR_TRANSIENT_MIN    (TPM_PT)(PT_FIXED + 14)
+#define TPM_PT_HR_PERSISTENT_MIN   (TPM_PT)(PT_FIXED + 15)
+#define TPM_PT_HR_LOADED_MIN       (TPM_PT)(PT_FIXED + 16)
+#define TPM_PT_ACTIVE_SESSIONS_MAX (TPM_PT)(PT_FIXED + 17)
+#define TPM_PT_PCR_COUNT           (TPM_PT)(PT_FIXED + 18)
+#define TPM_PT_PCR_SELECT_MIN      (TPM_PT)(PT_FIXED + 19)
+#define TPM_PT_CONTEXT_GAP_MAX     (TPM_PT)(PT_FIXED + 20)
+#define TPM_PT_NV_COUNTERS_MAX     (TPM_PT)(PT_FIXED + 22)
+#define TPM_PT_NV_INDEX_MAX        (TPM_PT)(PT_FIXED + 23)
+#define TPM_PT_MEMORY              (TPM_PT)(PT_FIXED + 24)
+#define TPM_PT_CLOCK_UPDATE        (TPM_PT)(PT_FIXED + 25)
+#define TPM_PT_CONTEXT_HASH        (TPM_PT)(PT_FIXED + 26)
+#define TPM_PT_CONTEXT_SYM         (TPM_PT)(PT_FIXED + 27)
+#define TPM_PT_CONTEXT_SYM_SIZE    (TPM_PT)(PT_FIXED + 28)
+#define TPM_PT_ORDERLY_COUNT       (TPM_PT)(PT_FIXED + 29)
+#define TPM_PT_MAX_COMMAND_SIZE    (TPM_PT)(PT_FIXED + 30)
+#define TPM_PT_MAX_RESPONSE_SIZE   (TPM_PT)(PT_FIXED + 31)
+#define TPM_PT_MAX_DIGEST          (TPM_PT)(PT_FIXED + 32)
+#define TPM_PT_MAX_OBJECT_CONTEXT  (TPM_PT)(PT_FIXED + 33)
+#define TPM_PT_MAX_SESSION_CONTEXT (TPM_PT)(PT_FIXED + 34)
+#define TPM_PT_PS_FAMILY_INDICATOR (TPM_PT)(PT_FIXED + 35)
+#define TPM_PT_PS_LEVEL            (TPM_PT)(PT_FIXED + 36)
+#define TPM_PT_PS_REVISION         (TPM_PT)(PT_FIXED + 37)
+#define TPM_PT_PS_DAY_OF_YEAR      (TPM_PT)(PT_FIXED + 38)
+#define TPM_PT_PS_YEAR             (TPM_PT)(PT_FIXED + 39)
+#define TPM_PT_SPLIT_MAX           (TPM_PT)(PT_FIXED + 40)
+#define TPM_PT_TOTAL_COMMANDS      (TPM_PT)(PT_FIXED + 41)
+#define TPM_PT_LIBRARY_COMMANDS    (TPM_PT)(PT_FIXED + 42)
+#define TPM_PT_VENDOR_COMMANDS     (TPM_PT)(PT_FIXED + 43)
+#define PT_VAR                     (TPM_PT)(PT_GROUP * 2)
+#define TPM_PT_PERMANENT           (TPM_PT)(PT_VAR + 0)
+#define TPM_PT_STARTUP_CLEAR       (TPM_PT)(PT_VAR + 1)
+#define TPM_PT_HR_NV_INDEX         (TPM_PT)(PT_VAR + 2)
+#define TPM_PT_HR_LOADED           (TPM_PT)(PT_VAR + 3)
+#define TPM_PT_HR_LOADED_AVAIL     (TPM_PT)(PT_VAR + 4)
+#define TPM_PT_HR_ACTIVE           (TPM_PT)(PT_VAR + 5)
+#define TPM_PT_HR_ACTIVE_AVAIL     (TPM_PT)(PT_VAR + 6)
+#define TPM_PT_HR_TRANSIENT_AVAIL  (TPM_PT)(PT_VAR + 7)
+#define TPM_PT_HR_PERSISTENT       (TPM_PT)(PT_VAR + 8)
+#define TPM_PT_HR_PERSISTENT_AVAIL (TPM_PT)(PT_VAR + 9)
+#define TPM_PT_NV_COUNTERS         (TPM_PT)(PT_VAR + 10)
+#define TPM_PT_NV_COUNTERS_AVAIL   (TPM_PT)(PT_VAR + 11)
+#define TPM_PT_ALGORITHM_SET       (TPM_PT)(PT_VAR + 12)
+#define TPM_PT_LOADED_CURVES       (TPM_PT)(PT_VAR + 13)
+#define TPM_PT_LOCKOUT_COUNTER     (TPM_PT)(PT_VAR + 14)
+#define TPM_PT_MAX_AUTH_FAIL       (TPM_PT)(PT_VAR + 15)
+#define TPM_PT_LOCKOUT_INTERVAL    (TPM_PT)(PT_VAR + 16)
+#define TPM_PT_LOCKOUT_RECOVERY    (TPM_PT)(PT_VAR + 17)
+#define TPM_PT_NV_WRITE_RECOVERY   (TPM_PT)(PT_VAR + 18)
+#define TPM_PT_AUDIT_COUNTER_0     (TPM_PT)(PT_VAR + 19)
+#define TPM_PT_AUDIT_COUNTER_1     (TPM_PT)(PT_VAR + 20)
+
+// Table 23 - TPM_PT_PCR Constants
+typedef UINT32 TPM_PT_PCR;
+#define TPM_PT_PCR_FIRST        (TPM_PT_PCR)(0x00000000)
+#define TPM_PT_PCR_SAVE         (TPM_PT_PCR)(0x00000000)
+#define TPM_PT_PCR_EXTEND_L0    (TPM_PT_PCR)(0x00000001)
+#define TPM_PT_PCR_RESET_L0     (TPM_PT_PCR)(0x00000002)
+#define TPM_PT_PCR_EXTEND_L1    (TPM_PT_PCR)(0x00000003)
+#define TPM_PT_PCR_RESET_L1     (TPM_PT_PCR)(0x00000004)
+#define TPM_PT_PCR_EXTEND_L2    (TPM_PT_PCR)(0x00000005)
+#define TPM_PT_PCR_RESET_L2     (TPM_PT_PCR)(0x00000006)
+#define TPM_PT_PCR_EXTEND_L3    (TPM_PT_PCR)(0x00000007)
+#define TPM_PT_PCR_RESET_L3     (TPM_PT_PCR)(0x00000008)
+#define TPM_PT_PCR_EXTEND_L4    (TPM_PT_PCR)(0x00000009)
+#define TPM_PT_PCR_RESET_L4     (TPM_PT_PCR)(0x0000000A)
+#define TPM_PT_PCR_NO_INCREMENT (TPM_PT_PCR)(0x00000011)
+#define TPM_PT_PCR_DRTM_RESET   (TPM_PT_PCR)(0x00000012)
+#define TPM_PT_PCR_POLICY       (TPM_PT_PCR)(0x00000013)
+#define TPM_PT_PCR_AUTH         (TPM_PT_PCR)(0x00000014)
+#define TPM_PT_PCR_LAST         (TPM_PT_PCR)(0x00000014)
+
+// Table 24 - TPM_PS Constants
+typedef UINT32 TPM_PS;
+#define TPM_PS_MAIN           (TPM_PS)(0x00000000)
+#define TPM_PS_PC             (TPM_PS)(0x00000001)
+#define TPM_PS_PDA            (TPM_PS)(0x00000002)
+#define TPM_PS_CELL_PHONE     (TPM_PS)(0x00000003)
+#define TPM_PS_SERVER         (TPM_PS)(0x00000004)
+#define TPM_PS_PERIPHERAL     (TPM_PS)(0x00000005)
+#define TPM_PS_TSS            (TPM_PS)(0x00000006)
+#define TPM_PS_STORAGE        (TPM_PS)(0x00000007)
+#define TPM_PS_AUTHENTICATION (TPM_PS)(0x00000008)
+#define TPM_PS_EMBEDDED       (TPM_PS)(0x00000009)
+#define TPM_PS_HARDCOPY       (TPM_PS)(0x0000000A)
+#define TPM_PS_INFRASTRUCTURE (TPM_PS)(0x0000000B)
+#define TPM_PS_VIRTUALIZATION (TPM_PS)(0x0000000C)
+#define TPM_PS_TNC            (TPM_PS)(0x0000000D)
+#define TPM_PS_MULTI_TENANT   (TPM_PS)(0x0000000E)
+#define TPM_PS_TC             (TPM_PS)(0x0000000F)
+
+// 7 Handles
+
+// Table 25 - Handles Types
+//
+// NOTE: Comment because it has same name as TPM1.2 (value is same, so not runtime issue)
+//
+//typedef UINT32    TPM_HANDLE;
+
+// Table 26 - TPM_HT Constants
+typedef UINT8 TPM_HT;
+#define TPM_HT_PCR            (TPM_HT)(0x00)
+#define TPM_HT_NV_INDEX       (TPM_HT)(0x01)
+#define TPM_HT_HMAC_SESSION   (TPM_HT)(0x02)
+#define TPM_HT_LOADED_SESSION (TPM_HT)(0x02)
+#define TPM_HT_POLICY_SESSION (TPM_HT)(0x03)
+#define TPM_HT_ACTIVE_SESSION (TPM_HT)(0x03)
+#define TPM_HT_PERMANENT      (TPM_HT)(0x40)
+#define TPM_HT_TRANSIENT      (TPM_HT)(0x80)
+#define TPM_HT_PERSISTENT     (TPM_HT)(0x81)
+
+// Table 27 - TPM_RH Constants
+typedef UINT32 TPM_RH;
+#define TPM_RH_FIRST       (TPM_RH)(0x40000000)
+#define TPM_RH_SRK         (TPM_RH)(0x40000000)
+#define TPM_RH_OWNER       (TPM_RH)(0x40000001)
+#define TPM_RH_REVOKE      (TPM_RH)(0x40000002)
+#define TPM_RH_TRANSPORT   (TPM_RH)(0x40000003)
+#define TPM_RH_OPERATOR    (TPM_RH)(0x40000004)
+#define TPM_RH_ADMIN       (TPM_RH)(0x40000005)
+#define TPM_RH_EK          (TPM_RH)(0x40000006)
+#define TPM_RH_NULL        (TPM_RH)(0x40000007)
+#define TPM_RH_UNASSIGNED  (TPM_RH)(0x40000008)
+#define TPM_RS_PW          (TPM_RH)(0x40000009)
+#define TPM_RH_LOCKOUT     (TPM_RH)(0x4000000A)
+#define TPM_RH_ENDORSEMENT (TPM_RH)(0x4000000B)
+#define TPM_RH_PLATFORM    (TPM_RH)(0x4000000C)
+#define TPM_RH_PLATFORM_NV (TPM_RH)(0x4000000D)
+#define TPM_RH_AUTH_00     (TPM_RH)(0x40000010)
+#define TPM_RH_AUTH_FF     (TPM_RH)(0x4000010F)
+#define TPM_RH_LAST        (TPM_RH)(0x4000010F)
+
+// Table 28 - TPM_HC Constants
+typedef TPM_HANDLE TPM_HC;
+#define HR_HANDLE_MASK       (TPM_HC)(0x00FFFFFF)
+#define HR_RANGE_MASK        (TPM_HC)(0xFF000000)
+#define HR_SHIFT             (TPM_HC)(24)
+#define HR_PCR               (TPM_HC)((TPM_HC)TPM_HT_PCR << HR_SHIFT)
+#define HR_HMAC_SESSION      (TPM_HC)((TPM_HC)TPM_HT_HMAC_SESSION << HR_SHIFT)
+#define HR_POLICY_SESSION    (TPM_HC)((TPM_HC)TPM_HT_POLICY_SESSION << HR_SHIFT)
+#define HR_TRANSIENT         (TPM_HC)((TPM_HC)TPM_HT_TRANSIENT << HR_SHIFT)
+#define HR_PERSISTENT        (TPM_HC)((TPM_HC)TPM_HT_PERSISTENT << HR_SHIFT)
+#define HR_NV_INDEX          (TPM_HC)((TPM_HC)TPM_HT_NV_INDEX << HR_SHIFT)
+#define HR_PERMANENT         (TPM_HC)((TPM_HC)TPM_HT_PERMANENT << HR_SHIFT)
+#define PCR_FIRST            (TPM_HC)(HR_PCR + 0)
+#define PCR_LAST             (TPM_HC)(PCR_FIRST + IMPLEMENTATION_PCR - 1)
+#define HMAC_SESSION_FIRST   (TPM_HC)(HR_HMAC_SESSION + 0)
+#define HMAC_SESSION_LAST    (TPM_HC)(HMAC_SESSION_FIRST + MAX_ACTIVE_SESSIONS - 1)
+#define LOADED_SESSION_FIRST (TPM_HC)(HMAC_SESSION_FIRST)
+#define LOADED_SESSION_LAST  (TPM_HC)(HMAC_SESSION_LAST)
+#define POLICY_SESSION_FIRST (TPM_HC)(HR_POLICY_SESSION + 0)
+#define POLICY_SESSION_LAST  (TPM_HC)(POLICY_SESSION_FIRST + MAX_ACTIVE_SESSIONS - 1)
+#define TRANSIENT_FIRST      (TPM_HC)(HR_TRANSIENT + 0)
+#define ACTIVE_SESSION_FIRST (TPM_HC)(POLICY_SESSION_FIRST)
+#define ACTIVE_SESSION_LAST  (TPM_HC)(POLICY_SESSION_LAST)
+#define TRANSIENT_LAST       (TPM_HC)(TRANSIENT_FIRST+MAX_LOADED_OBJECTS - 1)
+#define PERSISTENT_FIRST     (TPM_HC)(HR_PERSISTENT + 0)
+#define PERSISTENT_LAST      (TPM_HC)(PERSISTENT_FIRST + 0x00FFFFFF)
+#define PLATFORM_PERSISTENT  (TPM_HC)(PERSISTENT_FIRST + 0x00800000)
+#define NV_INDEX_FIRST       (TPM_HC)(HR_NV_INDEX + 0)
+#define NV_INDEX_LAST        (TPM_HC)(NV_INDEX_FIRST + 0x00FFFFFF)
+#define PERMANENT_FIRST      (TPM_HC)(TPM_RH_FIRST)
+#define PERMANENT_LAST       (TPM_HC)(TPM_RH_LAST)
+
+// 8 Attribute Structures
+
+// Table 29 - TPMA_ALGORITHM Bits
+typedef struct {
+  UINT32 asymmetric    : 1;
+  UINT32 symmetric     : 1;
+  UINT32 hash          : 1;
+  UINT32 object        : 1;
+  UINT32 reserved4_7   : 4;
+  UINT32 signing       : 1;
+  UINT32 encrypting    : 1;
+  UINT32 method        : 1;
+  UINT32 reserved11_31 : 21;
+} TPMA_ALGORITHM;
+
+// Table 30 - TPMA_OBJECT Bits
+typedef struct {
+  UINT32 reserved1            : 1;
+  UINT32 fixedTPM             : 1;
+  UINT32 stClear              : 1;
+  UINT32 reserved4            : 1;
+  UINT32 fixedParent          : 1;
+  UINT32 sensitiveDataOrigin  : 1;
+  UINT32 userWithAuth         : 1;
+  UINT32 adminWithPolicy      : 1;
+  UINT32 reserved8_9          : 2;
+  UINT32 noDA                 : 1;
+  UINT32 encryptedDuplication : 1;
+  UINT32 reserved12_15        : 4;
+  UINT32 restricted           : 1;
+  UINT32 decrypt              : 1;
+  UINT32 sign                 : 1;
+  UINT32 reserved19_31        : 13;
+} TPMA_OBJECT;
+
+// Table 31 - TPMA_SESSION Bits
+typedef struct {
+  UINT8 continueSession : 1;
+  UINT8 auditExclusive  : 1;
+  UINT8 auditReset      : 1;
+  UINT8 reserved3_4     : 2;
+  UINT8 decrypt         : 1;
+  UINT8 encrypt         : 1;
+  UINT8 audit           : 1;
+} TPMA_SESSION;
+
+// Table 32 - TPMA_LOCALITY Bits
+//
+// NOTE: Use low case here to resolve conflict
+//
+typedef struct {
+  UINT8 locZero  : 1;
+  UINT8 locOne   : 1;
+  UINT8 locTwo   : 1;
+  UINT8 locThree : 1;
+  UINT8 locFour  : 1;
+  UINT8 Extended : 3;
+} TPMA_LOCALITY;
+
+// Table 33 - TPMA_PERMANENT Bits
+typedef struct {
+  UINT32 ownerAuthSet       : 1;
+  UINT32 endorsementAuthSet : 1;
+  UINT32 lockoutAuthSet     : 1;
+  UINT32 reserved3_7        : 5;
+  UINT32 disableClear       : 1;
+  UINT32 inLockout          : 1;
+  UINT32 tpmGeneratedEPS    : 1;
+  UINT32 reserved11_31      : 21;
+} TPMA_PERMANENT;
+
+// Table 34 - TPMA_STARTUP_CLEAR Bits
+typedef struct {
+  UINT32 phEnable     : 1;
+  UINT32 shEnable     : 1;
+  UINT32 ehEnable     : 1;
+  UINT32 reserved3_30 : 28;
+  UINT32 orderly      : 1;
+} TPMA_STARTUP_CLEAR;
+
+// Table 35 - TPMA_MEMORY Bits
+typedef struct {
+  UINT32 sharedRAM         : 1;
+  UINT32 sharedNV          : 1;
+  UINT32 objectCopiedToRam : 1;
+  UINT32 reserved3_31      : 29;
+} TPMA_MEMORY;
+
+// Table 36 - TPMA_CC Bits
+typedef struct {
+  UINT32 commandIndex  : 16;
+  UINT32 reserved16_21 : 6;
+  UINT32 nv            : 1;
+  UINT32 extensive     : 1;
+  UINT32 flushed       : 1;
+  UINT32 cHandles      : 3;
+  UINT32 rHandle       : 1;
+  UINT32 V             : 1;
+  UINT32 Res           : 2;
+} TPMA_CC;
+
+// 9 Interface Types
+
+// Table 37 - TPMI_YES_NO Type
+typedef BYTE TPMI_YES_NO;
+
+// Table 38 - TPMI_DH_OBJECT Type
+typedef TPM_HANDLE TPMI_DH_OBJECT;
+
+// Table 39 - TPMI_DH_PERSISTENT Type
+typedef TPM_HANDLE TPMI_DH_PERSISTENT;
+
+// Table 40 - TPMI_DH_ENTITY Type
+typedef TPM_HANDLE TPMI_DH_ENTITY;
+
+// Table 41 - TPMI_DH_PCR Type
+typedef TPM_HANDLE TPMI_DH_PCR;
+
+// Table 42 - TPMI_SH_AUTH_SESSION Type
+typedef TPM_HANDLE TPMI_SH_AUTH_SESSION;
+
+// Table 43 - TPMI_SH_HMAC Type
+typedef TPM_HANDLE TPMI_SH_HMAC;
+
+// Table 44 - TPMI_SH_POLICY Type
+typedef TPM_HANDLE TPMI_SH_POLICY;
+
+// Table 45 - TPMI_DH_CONTEXT Type
+typedef TPM_HANDLE TPMI_DH_CONTEXT;
+
+// Table 46 - TPMI_RH_HIERARCHY Type
+typedef TPM_HANDLE TPMI_RH_HIERARCHY;
+
+// Table 47 - TPMI_RH_HIERARCHY_AUTH Type
+typedef TPM_HANDLE TPMI_RH_HIERARCHY_AUTH;
+
+// Table 48 - TPMI_RH_PLATFORM Type
+typedef TPM_HANDLE TPMI_RH_PLATFORM;
+
+// Table 49 - TPMI_RH_OWNER Type
+typedef TPM_HANDLE TPMI_RH_OWNER;
+
+// Table 50 - TPMI_RH_ENDORSEMENT Type
+typedef TPM_HANDLE TPMI_RH_ENDORSEMENT;
+
+// Table 51 - TPMI_RH_PROVISION Type
+typedef TPM_HANDLE TPMI_RH_PROVISION;
+
+// Table 52 - TPMI_RH_CLEAR Type
+typedef TPM_HANDLE TPMI_RH_CLEAR;
+
+// Table 53 - TPMI_RH_NV_AUTH Type
+typedef TPM_HANDLE TPMI_RH_NV_AUTH;
+
+// Table 54 - TPMI_RH_LOCKOUT Type
+typedef TPM_HANDLE TPMI_RH_LOCKOUT;
+
+// Table 55 - TPMI_RH_NV_INDEX Type
+typedef TPM_HANDLE TPMI_RH_NV_INDEX;
+
+// Table 56 - TPMI_ALG_HASH Type
+typedef TPM_ALG_ID TPMI_ALG_HASH;
+
+// Table 57 - TPMI_ALG_ASYM Type
+typedef TPM_ALG_ID TPMI_ALG_ASYM;
+
+// Table 58 - TPMI_ALG_SYM Type
+typedef TPM_ALG_ID TPMI_ALG_SYM;
+
+// Table 59 - TPMI_ALG_SYM_OBJECT Type
+typedef TPM_ALG_ID TPMI_ALG_SYM_OBJECT;
+
+// Table 60 - TPMI_ALG_SYM_MODE Type
+typedef TPM_ALG_ID TPMI_ALG_SYM_MODE;
+
+// Table 61 - TPMI_ALG_KDF Type
+typedef TPM_ALG_ID TPMI_ALG_KDF;
+
+// Table 62 - TPMI_ALG_SIG_SCHEME Type
+typedef TPM_ALG_ID TPMI_ALG_SIG_SCHEME;
+
+// Table 63 - TPMI_ECC_KEY_EXCHANGE Type
+typedef TPM_ALG_ID TPMI_ECC_KEY_EXCHANGE;
+
+// Table 64 - TPMI_ST_COMMAND_TAG Type
+typedef TPM_ST TPMI_ST_COMMAND_TAG;
+
+// 10 Structure Definitions
+
+// Table 65 - TPMS_ALGORITHM_DESCRIPTION Structure
+typedef struct {
+  TPM_ALG_ID     alg;
+  TPMA_ALGORITHM attributes;
+} TPMS_ALGORITHM_DESCRIPTION;
+
+// Table 66 - TPMU_HA Union
+typedef union {
+  BYTE sha1[SHA1_DIGEST_SIZE];
+  BYTE sha256[SHA256_DIGEST_SIZE];
+  BYTE sm3_256[SM3_256_DIGEST_SIZE];
+  BYTE sha384[SHA384_DIGEST_SIZE];
+  BYTE sha512[SHA512_DIGEST_SIZE];
+} TPMU_HA;
+
+// Table 67 - TPMT_HA Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+  TPMU_HA       digest;
+} TPMT_HA;
+
+// Table 68 - TPM2B_DIGEST Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[sizeof(TPMU_HA)];
+} TPM2B_DIGEST;
+
+// Table 69 - TPM2B_DATA Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[sizeof(TPMT_HA)];
+} TPM2B_DATA;
+
+// Table 70 - TPM2B_NONCE Types
+typedef TPM2B_DIGEST TPM2B_NONCE;
+
+// Table 71 - TPM2B_AUTH Types
+typedef TPM2B_DIGEST TPM2B_AUTH;
+
+// Table 72 - TPM2B_OPERAND Types
+typedef TPM2B_DIGEST TPM2B_OPERAND;
+
+// Table 73 - TPM2B_EVENT Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[1024];
+} TPM2B_EVENT;
+
+// Table 74 - TPM2B_MAX_BUFFER Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_DIGEST_BUFFER];
+} TPM2B_MAX_BUFFER;
+
+// Table 75 - TPM2B_MAX_NV_BUFFER Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_NV_INDEX_SIZE];
+} TPM2B_MAX_NV_BUFFER;
+
+// Table 76 - TPM2B_TIMEOUT Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[sizeof(UINT64)];
+} TPM2B_TIMEOUT;
+
+// Table 77 -- TPM2B_IV Structure <I/O>
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_SYM_BLOCK_SIZE];
+} TPM2B_IV;
+
+// Table 78 - TPMU_NAME Union
+typedef union {
+  TPMT_HA    digest;
+  TPM_HANDLE handle;
+} TPMU_NAME;
+
+// Table 79 - TPM2B_NAME Structure
+typedef struct {
+  UINT16 size;
+  BYTE   name[sizeof(TPMU_NAME)];
+} TPM2B_NAME;
+
+// Table 80 - TPMS_PCR_SELECT Structure
+typedef struct {
+  UINT8 sizeofSelect;
+  BYTE  pcrSelect[PCR_SELECT_MAX];
+} TPMS_PCR_SELECT;
+
+// Table 81 - TPMS_PCR_SELECTION Structure
+typedef struct {
+  TPMI_ALG_HASH hash;
+  UINT8         sizeofSelect;
+  BYTE          pcrSelect[PCR_SELECT_MAX];
+} TPMS_PCR_SELECTION;
+
+// Table 84 - TPMT_TK_CREATION Structure
+typedef struct {
+  TPM_ST            tag;
+  TPMI_RH_HIERARCHY hierarchy;
+  TPM2B_DIGEST      digest;
+} TPMT_TK_CREATION;
+
+// Table 85 - TPMT_TK_VERIFIED Structure
+typedef struct {
+  TPM_ST            tag;
+  TPMI_RH_HIERARCHY hierarchy;
+  TPM2B_DIGEST      digest;
+} TPMT_TK_VERIFIED;
+
+// Table 86 - TPMT_TK_AUTH Structure
+typedef struct {
+  TPM_ST            tag;
+  TPMI_RH_HIERARCHY hierarchy;
+  TPM2B_DIGEST      digest;
+} TPMT_TK_AUTH;
+
+// Table 87 - TPMT_TK_HASHCHECK Structure
+typedef struct {
+  TPM_ST            tag;
+  TPMI_RH_HIERARCHY hierarchy;
+  TPM2B_DIGEST      digest;
+} TPMT_TK_HASHCHECK;
+
+// Table 88 - TPMS_ALG_PROPERTY Structure
+typedef struct {
+  TPM_ALG_ID     alg;
+  TPMA_ALGORITHM algProperties;
+} TPMS_ALG_PROPERTY;
+
+// Table 89 - TPMS_TAGGED_PROPERTY Structure
+typedef struct {
+  TPM_PT property;
+  UINT32 value;
+} TPMS_TAGGED_PROPERTY;
+
+// Table 90 - TPMS_TAGGED_PCR_SELECT Structure
+typedef struct {
+  TPM_PT tag;
+  UINT8  sizeofSelect;
+  BYTE   pcrSelect[PCR_SELECT_MAX];
+} TPMS_TAGGED_PCR_SELECT;
+
+// Table 91 - TPML_CC Structure
+typedef struct {
+  UINT32 count;
+  TPM_CC commandCodes[MAX_CAP_CC];
+} TPML_CC;
+
+// Table 92 - TPML_CCA Structure
+typedef struct {
+  UINT32  count;
+  TPMA_CC commandAttributes[MAX_CAP_CC];
+} TPML_CCA;
+
+// Table 93 - TPML_ALG Structure
+typedef struct {
+  UINT32     count;
+  TPM_ALG_ID algorithms[MAX_ALG_LIST_SIZE];
+} TPML_ALG;
+
+// Table 94 - TPML_HANDLE Structure
+typedef struct {
+  UINT32     count;
+  TPM_HANDLE handle[MAX_CAP_HANDLES];
+} TPML_HANDLE;
+
+// Table 95 - TPML_DIGEST Structure
+typedef struct {
+  UINT32       count;
+  TPM2B_DIGEST digests[8];
+} TPML_DIGEST;
+
+// Table 96 -- TPML_DIGEST_VALUES Structure <I/O>
+typedef struct {
+  UINT32  count;
+  TPMT_HA digests[HASH_COUNT];
+} TPML_DIGEST_VALUES;
+
+// Table 97 - TPM2B_DIGEST_VALUES Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[sizeof(TPML_DIGEST_VALUES)];
+} TPM2B_DIGEST_VALUES;
+
+// Table 98 - TPML_PCR_SELECTION Structure
+typedef struct {
+  UINT32             count;
+  TPMS_PCR_SELECTION pcrSelections[HASH_COUNT];
+} TPML_PCR_SELECTION;
+
+// Table 99 - TPML_ALG_PROPERTY Structure
+typedef struct {
+  UINT32            count;
+  TPMS_ALG_PROPERTY algProperties[MAX_CAP_ALGS];
+} TPML_ALG_PROPERTY;
+
+// Table 100 - TPML_TAGGED_TPM_PROPERTY Structure
+typedef struct {
+  UINT32               count;
+  TPMS_TAGGED_PROPERTY tpmProperty[MAX_TPM_PROPERTIES];
+} TPML_TAGGED_TPM_PROPERTY;
+
+// Table 101 - TPML_TAGGED_PCR_PROPERTY Structure
+typedef struct {
+  UINT32                 count;
+  TPMS_TAGGED_PCR_SELECT pcrProperty[MAX_PCR_PROPERTIES];
+} TPML_TAGGED_PCR_PROPERTY;
+
+// Table 102 - TPML_ECC_CURVE Structure
+typedef struct {
+  UINT32        count;
+  TPM_ECC_CURVE eccCurves[MAX_ECC_CURVES];
+} TPML_ECC_CURVE;
+
+// Table 103 - TPMU_CAPABILITIES Union
+typedef union {
+  TPML_ALG_PROPERTY        algorithms;
+  TPML_HANDLE              handles;
+  TPML_CCA                 command;
+  TPML_CC                  ppCommands;
+  TPML_CC                  auditCommands;
+  TPML_PCR_SELECTION       assignedPCR;
+  TPML_TAGGED_TPM_PROPERTY tpmProperties;
+  TPML_TAGGED_PCR_PROPERTY pcrProperties;
+  TPML_ECC_CURVE           eccCurves;
+} TPMU_CAPABILITIES;
+
+// Table 104 - TPMS_CAPABILITY_DATA Structure
+typedef struct {
+  TPM_CAP           capability;
+  TPMU_CAPABILITIES data;
+} TPMS_CAPABILITY_DATA;
+
+// Table 105 - TPMS_CLOCK_INFO Structure
+typedef struct {
+  UINT64      clock;
+  UINT32      resetCount;
+  UINT32      restartCount;
+  TPMI_YES_NO safe;
+} TPMS_CLOCK_INFO;
+
+// Table 106 - TPMS_TIME_INFO Structure
+typedef struct {
+  UINT64          time;
+  TPMS_CLOCK_INFO clockInfo;
+} TPMS_TIME_INFO;
+
+// Table 107 - TPMS_TIME_ATTEST_INFO Structure
+typedef struct {
+  TPMS_TIME_INFO time;
+  UINT64         firmwareVersion;
+} TPMS_TIME_ATTEST_INFO;
+
+// Table 108 - TPMS_CERTIFY_INFO Structure
+typedef struct {
+  TPM2B_NAME name;
+  TPM2B_NAME qualifiedName;
+} TPMS_CERTIFY_INFO;
+
+// Table 109 - TPMS_QUOTE_INFO Structure
+typedef struct {
+  TPML_PCR_SELECTION pcrSelect;
+  TPM2B_DIGEST       pcrDigest;
+} TPMS_QUOTE_INFO;
+
+// Table 110 - TPMS_COMMAND_AUDIT_INFO Structure
+typedef struct {
+  UINT64       auditCounter;
+  TPM_ALG_ID   digestAlg;
+  TPM2B_DIGEST auditDigest;
+  TPM2B_DIGEST commandDigest;
+} TPMS_COMMAND_AUDIT_INFO;
+
+// Table 111 - TPMS_SESSION_AUDIT_INFO Structure
+typedef struct {
+  TPMI_YES_NO  exclusiveSession;
+  TPM2B_DIGEST sessionDigest;
+} TPMS_SESSION_AUDIT_INFO;
+
+// Table 112 - TPMS_CREATION_INFO Structure
+typedef struct {
+  TPM2B_NAME   objectName;
+  TPM2B_DIGEST creationHash;
+} TPMS_CREATION_INFO;
+
+// Table 113 - TPMS_NV_CERTIFY_INFO Structure
+typedef struct {
+  TPM2B_NAME          indexName;
+  UINT16              offset;
+  TPM2B_MAX_NV_BUFFER nvContents;
+} TPMS_NV_CERTIFY_INFO;
+
+// Table 114 - TPMI_ST_ATTEST Type
+typedef TPM_ST TPMI_ST_ATTEST;
+
+// Table 115 - TPMU_ATTEST Union
+typedef union {
+  TPMS_CERTIFY_INFO       certify;
+  TPMS_CREATION_INFO      creation;
+  TPMS_QUOTE_INFO         quote;
+  TPMS_COMMAND_AUDIT_INFO commandAudit;
+  TPMS_SESSION_AUDIT_INFO sessionAudit;
+  TPMS_TIME_ATTEST_INFO   time;
+  TPMS_NV_CERTIFY_INFO    nv;
+} TPMU_ATTEST;
+
+// Table 116 - TPMS_ATTEST Structure
+typedef struct {
+  TPM_GENERATED   magic;
+  TPMI_ST_ATTEST  type;
+  TPM2B_NAME      qualifiedSigner;
+  TPM2B_DATA      extraData;
+  TPMS_CLOCK_INFO clockInfo;
+  UINT64          firmwareVersion;
+  TPMU_ATTEST     attested;
+} TPMS_ATTEST;
+
+// Table 117 - TPM2B_ATTEST Structure
+typedef struct {
+  UINT16 size;
+  BYTE   attestationData[sizeof(TPMS_ATTEST)];
+} TPM2B_ATTEST;
+
+// Table 118 - TPMS_AUTH_COMMAND Structure
+typedef struct {
+  TPMI_SH_AUTH_SESSION sessionHandle;
+  TPM2B_NONCE          nonce;
+  TPMA_SESSION         sessionAttributes;
+  TPM2B_AUTH           hmac;
+} TPMS_AUTH_COMMAND;
+
+// Table 119 - TPMS_AUTH_RESPONSE Structure
+typedef struct {
+  TPM2B_NONCE  nonce;
+  TPMA_SESSION sessionAttributes;
+  TPM2B_AUTH   hmac;
+} TPMS_AUTH_RESPONSE;
+
+// 11 Algorithm Parameters and Structures
+
+// Table 120 - TPMI_AES_KEY_BITS Type
+typedef TPM_KEY_BITS TPMI_AES_KEY_BITS;
+
+// Table 121 - TPMI_SM4_KEY_BITS Type
+typedef TPM_KEY_BITS TPMI_SM4_KEY_BITS;
+
+// Table 122 - TPMU_SYM_KEY_BITS Union
+typedef union {
+  TPMI_AES_KEY_BITS aes;
+  TPMI_SM4_KEY_BITS SM4;
+  TPM_KEY_BITS      sym;
+  TPMI_ALG_HASH     xor;
+} TPMU_SYM_KEY_BITS;
+
+// Table 123 - TPMU_SYM_MODE Union
+typedef union {
+  TPMI_ALG_SYM_MODE aes;
+  TPMI_ALG_SYM_MODE SM4;
+  TPMI_ALG_SYM_MODE sym;
+} TPMU_SYM_MODE;
+
+// Table 125 - TPMT_SYM_DEF Structure
+typedef struct {
+  TPMI_ALG_SYM      algorithm;
+  TPMU_SYM_KEY_BITS keyBits;
+  TPMU_SYM_MODE     mode;
+} TPMT_SYM_DEF;
+
+// Table 126 - TPMT_SYM_DEF_OBJECT Structure
+typedef struct {
+  TPMI_ALG_SYM_OBJECT algorithm;
+  TPMU_SYM_KEY_BITS   keyBits;
+  TPMU_SYM_MODE       mode;
+} TPMT_SYM_DEF_OBJECT;
+
+// Table 127 - TPM2B_SYM_KEY Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_SYM_KEY_BYTES];
+} TPM2B_SYM_KEY;
+
+// Table 128 - TPMS_SYMCIPHER_PARMS Structure
+typedef struct {
+  TPMT_SYM_DEF_OBJECT sym;
+} TPMS_SYMCIPHER_PARMS;
+
+// Table 129 - TPM2B_SENSITIVE_DATA Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_SYM_DATA];
+} TPM2B_SENSITIVE_DATA;
+
+// Table 130 - TPMS_SENSITIVE_CREATE Structure
+typedef struct {
+  TPM2B_AUTH           userAuth;
+  TPM2B_SENSITIVE_DATA data;
+} TPMS_SENSITIVE_CREATE;
+
+// Table 131 - TPM2B_SENSITIVE_CREATE Structure
+typedef struct {
+  UINT16                size;
+  TPMS_SENSITIVE_CREATE sensitive;
+} TPM2B_SENSITIVE_CREATE;
+
+// Table 132 - TPMS_SCHEME_SIGHASH Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+} TPMS_SCHEME_SIGHASH;
+
+// Table 133 - TPMI_ALG_KEYEDHASH_SCHEME Type
+typedef TPM_ALG_ID TPMI_ALG_KEYEDHASH_SCHEME;
+
+// Table 134 - HMAC_SIG_SCHEME Types
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_HMAC;
+
+// Table 135 - TPMS_SCHEME_XOR Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+  TPMI_ALG_KDF  kdf;
+} TPMS_SCHEME_XOR;
+
+// Table 136 - TPMU_SCHEME_KEYEDHASH Union
+typedef union {
+  TPMS_SCHEME_HMAC hmac;
+  TPMS_SCHEME_XOR  xor;
+} TPMU_SCHEME_KEYEDHASH;
+
+// Table 137 - TPMT_KEYEDHASH_SCHEME Structure
+typedef struct {
+  TPMI_ALG_KEYEDHASH_SCHEME scheme;
+  TPMU_SCHEME_KEYEDHASH     details;
+} TPMT_KEYEDHASH_SCHEME;
+
+// Table 138 - RSA_SIG_SCHEMES Types
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_RSASSA;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_RSAPSS;
+
+// Table 139 - ECC_SIG_SCHEMES Types
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_ECDSA;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_SM2;
+typedef TPMS_SCHEME_SIGHASH TPMS_SCHEME_ECSCHNORR;
+
+// Table 140 - TPMS_SCHEME_ECDAA Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+  UINT16        count;
+} TPMS_SCHEME_ECDAA;
+
+// Table 141 - TPMU_SIG_SCHEME Union
+typedef union {
+  TPMS_SCHEME_RSASSA    rsassa;
+  TPMS_SCHEME_RSAPSS    rsapss;
+  TPMS_SCHEME_ECDSA     ecdsa;
+  TPMS_SCHEME_ECDAA     ecdaa;
+  TPMS_SCHEME_ECSCHNORR ecSchnorr;
+  TPMS_SCHEME_HMAC      hmac;
+  TPMS_SCHEME_SIGHASH   any;
+} TPMU_SIG_SCHEME;
+
+// Table 142 - TPMT_SIG_SCHEME Structure
+typedef struct {
+  TPMI_ALG_SIG_SCHEME scheme;
+  TPMU_SIG_SCHEME     details;
+} TPMT_SIG_SCHEME;
+
+// Table 143 - TPMS_SCHEME_OAEP Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+} TPMS_SCHEME_OAEP;
+
+// Table 144 - TPMS_SCHEME_ECDH Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+} TPMS_SCHEME_ECDH;
+
+// Table 145 - TPMS_SCHEME_MGF1 Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+} TPMS_SCHEME_MGF1;
+
+// Table 146 - TPMS_SCHEME_KDF1_SP800_56a Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+} TPMS_SCHEME_KDF1_SP800_56a;
+
+// Table 147 - TPMS_SCHEME_KDF2 Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+} TPMS_SCHEME_KDF2;
+
+// Table 148 - TPMS_SCHEME_KDF1_SP800_108 Structure
+typedef struct {
+  TPMI_ALG_HASH hashAlg;
+} TPMS_SCHEME_KDF1_SP800_108;
+
+// Table 149 - TPMU_KDF_SCHEME Union
+typedef union {
+  TPMS_SCHEME_MGF1           mgf1;
+  TPMS_SCHEME_KDF1_SP800_56a kdf1_SP800_56a;
+  TPMS_SCHEME_KDF2           kdf2;
+  TPMS_SCHEME_KDF1_SP800_108 kdf1_sp800_108;
+} TPMU_KDF_SCHEME;
+
+// Table 150 - TPMT_KDF_SCHEME Structure
+typedef struct {
+  TPMI_ALG_KDF    scheme;
+  TPMU_KDF_SCHEME details;
+} TPMT_KDF_SCHEME;
+
+// Table 151 - TPMI_ALG_ASYM_SCHEME Type
+typedef TPM_ALG_ID TPMI_ALG_ASYM_SCHEME;
+
+// Table 152 - TPMU_ASYM_SCHEME Union
+typedef union {
+  TPMS_SCHEME_RSASSA    rsassa;
+  TPMS_SCHEME_RSAPSS    rsapss;
+  TPMS_SCHEME_OAEP      oaep;
+  TPMS_SCHEME_ECDSA     ecdsa;
+  TPMS_SCHEME_ECDAA     ecdaa;
+  TPMS_SCHEME_ECSCHNORR ecSchnorr;
+  TPMS_SCHEME_SIGHASH   anySig;
+} TPMU_ASYM_SCHEME;
+
+// Table 153 - TPMT_ASYM_SCHEME Structure
+typedef struct {
+  TPMI_ALG_ASYM_SCHEME scheme;
+  TPMU_ASYM_SCHEME     details;
+} TPMT_ASYM_SCHEME;
+
+// Table 154 - TPMI_ALG_RSA_SCHEME Type
+typedef TPM_ALG_ID TPMI_ALG_RSA_SCHEME;
+
+// Table 155 - TPMT_RSA_SCHEME Structure
+typedef struct {
+  TPMI_ALG_RSA_SCHEME scheme;
+  TPMU_ASYM_SCHEME    details;
+} TPMT_RSA_SCHEME;
+
+// Table 156 - TPMI_ALG_RSA_DECRYPT Type
+typedef TPM_ALG_ID TPMI_ALG_RSA_DECRYPT;
+
+// Table 157 - TPMT_RSA_DECRYPT Structure
+typedef struct {
+  TPMI_ALG_RSA_DECRYPT scheme;
+  TPMU_ASYM_SCHEME     details;
+} TPMT_RSA_DECRYPT;
+
+// Table 158 - TPM2B_PUBLIC_KEY_RSA Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_RSA_KEY_BYTES];
+} TPM2B_PUBLIC_KEY_RSA;
+
+// Table 159 - TPMI_RSA_KEY_BITS Type
+typedef TPM_KEY_BITS TPMI_RSA_KEY_BITS;
+
+// Table 160 - TPM2B_PRIVATE_KEY_RSA Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_RSA_KEY_BYTES/2];
+} TPM2B_PRIVATE_KEY_RSA;
+
+// Table 161 - TPM2B_ECC_PARAMETER Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_ECC_KEY_BYTES];
+} TPM2B_ECC_PARAMETER;
+
+// Table 162 - TPMS_ECC_POINT Structure
+typedef struct {
+  TPM2B_ECC_PARAMETER x;
+  TPM2B_ECC_PARAMETER y;
+} TPMS_ECC_POINT;
+
+// Table 163 -- TPM2B_ECC_POINT Structure <I/O>
+typedef struct {
+  UINT16         size;
+  TPMS_ECC_POINT point;
+} TPM2B_ECC_POINT;
+
+// Table 164 - TPMI_ALG_ECC_SCHEME Type
+typedef TPM_ALG_ID TPMI_ALG_ECC_SCHEME;
+
+// Table 165 - TPMI_ECC_CURVE Type
+typedef TPM_ECC_CURVE TPMI_ECC_CURVE;
+
+// Table 166 - TPMT_ECC_SCHEME Structure
+typedef struct {
+  TPMI_ALG_ECC_SCHEME scheme;
+  TPMU_SIG_SCHEME     details;
+} TPMT_ECC_SCHEME;
+
+// Table 167 - TPMS_ALGORITHM_DETAIL_ECC Structure
+typedef struct {
+  TPM_ECC_CURVE       curveID;
+  UINT16              keySize;
+  TPMT_KDF_SCHEME     kdf;
+  TPMT_ECC_SCHEME     sign;
+  TPM2B_ECC_PARAMETER p;
+  TPM2B_ECC_PARAMETER a;
+  TPM2B_ECC_PARAMETER b;
+  TPM2B_ECC_PARAMETER gX;
+  TPM2B_ECC_PARAMETER gY;
+  TPM2B_ECC_PARAMETER n;
+  TPM2B_ECC_PARAMETER h;
+} TPMS_ALGORITHM_DETAIL_ECC;
+
+// Table 168 - TPMS_SIGNATURE_RSASSA Structure
+typedef struct {
+  TPMI_ALG_HASH        hash;
+  TPM2B_PUBLIC_KEY_RSA sig;
+} TPMS_SIGNATURE_RSASSA;
+
+// Table 169 - TPMS_SIGNATURE_RSAPSS Structure
+typedef struct {
+  TPMI_ALG_HASH        hash;
+  TPM2B_PUBLIC_KEY_RSA sig;
+} TPMS_SIGNATURE_RSAPSS;
+
+// Table 170 - TPMS_SIGNATURE_ECDSA Structure
+typedef struct {
+  TPMI_ALG_HASH       hash;
+  TPM2B_ECC_PARAMETER signatureR;
+  TPM2B_ECC_PARAMETER signatureS;
+} TPMS_SIGNATURE_ECDSA;
+
+// Table 171 - TPMU_SIGNATURE Union
+typedef union {
+  TPMS_SIGNATURE_RSASSA rsassa;
+  TPMS_SIGNATURE_RSAPSS rsapss;
+  TPMS_SIGNATURE_ECDSA  ecdsa;
+  TPMS_SIGNATURE_ECDSA  sm2;
+  TPMS_SIGNATURE_ECDSA  ecdaa;
+  TPMS_SIGNATURE_ECDSA  ecschnorr;
+  TPMT_HA               hmac;
+  TPMS_SCHEME_SIGHASH   any;
+} TPMU_SIGNATURE;
+
+// Table 172 - TPMT_SIGNATURE Structure
+typedef struct {
+  TPMI_ALG_SIG_SCHEME sigAlg;
+  TPMU_SIGNATURE      signature;
+} TPMT_SIGNATURE;
+
+// Table 173 - TPMU_ENCRYPTED_SECRET Union
+typedef union {
+  BYTE ecc[sizeof(TPMS_ECC_POINT)];
+  BYTE rsa[MAX_RSA_KEY_BYTES];
+  BYTE symmetric[sizeof(TPM2B_DIGEST)];
+  BYTE keyedHash[sizeof(TPM2B_DIGEST)];
+} TPMU_ENCRYPTED_SECRET;
+
+// Table 174 - TPM2B_ENCRYPTED_SECRET Structure
+typedef struct {
+  UINT16 size;
+  BYTE   secret[sizeof(TPMU_ENCRYPTED_SECRET)];
+} TPM2B_ENCRYPTED_SECRET;
+
+// 12 Key/Object Complex
+
+// Table 175 - TPMI_ALG_PUBLIC Type
+typedef TPM_ALG_ID TPMI_ALG_PUBLIC;
+
+// Table 176 - TPMU_PUBLIC_ID Union
+typedef union {
+  TPM2B_DIGEST         keyedHash;
+  TPM2B_DIGEST         sym;
+  TPM2B_PUBLIC_KEY_RSA rsa;
+  TPMS_ECC_POINT       ecc;
+} TPMU_PUBLIC_ID;
+
+// Table 177 - TPMS_KEYEDHASH_PARMS Structure
+typedef struct {
+  TPMT_KEYEDHASH_SCHEME scheme;
+} TPMS_KEYEDHASH_PARMS;
+
+// Table 178 - TPMS_ASYM_PARMS Structure
+typedef struct {
+  TPMT_SYM_DEF_OBJECT symmetric;
+  TPMT_ASYM_SCHEME    scheme;
+} TPMS_ASYM_PARMS;
+
+// Table 179 - TPMS_RSA_PARMS Structure
+typedef struct {
+  TPMT_SYM_DEF_OBJECT symmetric;
+  TPMT_RSA_SCHEME     scheme;
+  TPMI_RSA_KEY_BITS   keyBits;
+  UINT32              exponent;
+} TPMS_RSA_PARMS;
+
+// Table 180 - TPMS_ECC_PARMS Structure
+typedef struct {
+  TPMT_SYM_DEF_OBJECT symmetric;
+  TPMT_ECC_SCHEME     scheme;
+  TPMI_ECC_CURVE      curveID;
+  TPMT_KDF_SCHEME     kdf;
+} TPMS_ECC_PARMS;
+
+// Table 181 - TPMU_PUBLIC_PARMS Union
+typedef union {
+  TPMS_KEYEDHASH_PARMS keyedHashDetail;
+  TPMT_SYM_DEF_OBJECT  symDetail;
+  TPMS_RSA_PARMS       rsaDetail;
+  TPMS_ECC_PARMS       eccDetail;
+  TPMS_ASYM_PARMS      asymDetail;
+} TPMU_PUBLIC_PARMS;
+
+// Table 182 - TPMT_PUBLIC_PARMS Structure
+typedef struct {
+  TPMI_ALG_PUBLIC   type;
+  TPMU_PUBLIC_PARMS parameters;
+} TPMT_PUBLIC_PARMS;
+
+// Table 183 - TPMT_PUBLIC Structure
+typedef struct {
+  TPMI_ALG_PUBLIC   type;
+  TPMI_ALG_HASH     nameAlg;
+  TPMA_OBJECT       objectAttributes;
+  TPM2B_DIGEST      authPolicy;
+  TPMU_PUBLIC_PARMS parameters;
+  TPMU_PUBLIC_ID    unique;
+} TPMT_PUBLIC;
+
+// Table 184 - TPM2B_PUBLIC Structure
+typedef struct {
+  UINT16      size;
+  TPMT_PUBLIC publicArea;
+} TPM2B_PUBLIC;
+
+// Table 185 - TPM2B_PRIVATE_VENDOR_SPECIFIC Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[PRIVATE_VENDOR_SPECIFIC_BYTES];
+} TPM2B_PRIVATE_VENDOR_SPECIFIC;
+
+// Table 186 - TPMU_SENSITIVE_COMPOSITE Union
+typedef union {
+  TPM2B_PRIVATE_KEY_RSA         rsa;
+  TPM2B_ECC_PARAMETER           ecc;
+  TPM2B_SENSITIVE_DATA          bits;
+  TPM2B_SYM_KEY                 sym;
+  TPM2B_PRIVATE_VENDOR_SPECIFIC any;
+} TPMU_SENSITIVE_COMPOSITE;
+
+// Table 187 - TPMT_SENSITIVE Structure
+typedef struct {
+  TPMI_ALG_PUBLIC          sensitiveType;
+  TPM2B_AUTH               authValue;
+  TPM2B_DIGEST             seedValue;
+  TPMU_SENSITIVE_COMPOSITE sensitive;
+} TPMT_SENSITIVE;
+
+// Table 188 - TPM2B_SENSITIVE Structure
+typedef struct {
+  UINT16         size;
+  TPMT_SENSITIVE sensitiveArea;
+} TPM2B_SENSITIVE;
+
+// Table 189 - _PRIVATE Structure
+typedef struct {
+  TPM2B_DIGEST   integrityOuter;
+  TPM2B_DIGEST   integrityInner;
+  TPMT_SENSITIVE sensitive;
+} _PRIVATE;
+
+// Table 190 - TPM2B_PRIVATE Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[sizeof(_PRIVATE)];
+} TPM2B_PRIVATE;
+
+// Table 191 - _ID_OBJECT Structure
+typedef struct {
+  TPM2B_DIGEST integrityHMAC;
+  TPM2B_DIGEST encIdentity;
+} _ID_OBJECT;
+
+// Table 192 - TPM2B_ID_OBJECT Structure
+typedef struct {
+  UINT16 size;
+  BYTE   credential[sizeof(_ID_OBJECT)];
+} TPM2B_ID_OBJECT;
+
+// 13 NV Storage Structures
+
+// Table 193 - TPM_NV_INDEX Bits
+//
+// NOTE: Comment here to resolve conflict
+//
+//typedef struct {
+//  UINT32 index : 22;
+//  UINT32 space : 2;
+//  UINT32 RH_NV : 8;
+//} TPM_NV_INDEX;
+
+// Table 195 - TPMA_NV Bits
+typedef struct {
+  UINT32 TPMA_NV_PPWRITE        : 1;
+  UINT32 TPMA_NV_OWNERWRITE     : 1;
+  UINT32 TPMA_NV_AUTHWRITE      : 1;
+  UINT32 TPMA_NV_POLICYWRITE    : 1;
+  UINT32 TPMA_NV_COUNTER        : 1;
+  UINT32 TPMA_NV_BITS           : 1;
+  UINT32 TPMA_NV_EXTEND         : 1;
+  UINT32 reserved7_9            : 3;
+  UINT32 TPMA_NV_POLICY_DELETE  : 1;
+  UINT32 TPMA_NV_WRITELOCKED    : 1;
+  UINT32 TPMA_NV_WRITEALL       : 1;
+  UINT32 TPMA_NV_WRITEDEFINE    : 1;
+  UINT32 TPMA_NV_WRITE_STCLEAR  : 1;
+  UINT32 TPMA_NV_GLOBALLOCK     : 1;
+  UINT32 TPMA_NV_PPREAD         : 1;
+  UINT32 TPMA_NV_OWNERREAD      : 1;
+  UINT32 TPMA_NV_AUTHREAD       : 1;
+  UINT32 TPMA_NV_POLICYREAD     : 1;
+  UINT32 reserved20_24          : 5;
+  UINT32 TPMA_NV_NO_DA          : 1;
+  UINT32 TPMA_NV_ORDERLY        : 1;
+  UINT32 TPMA_NV_CLEAR_STCLEAR  : 1;
+  UINT32 TPMA_NV_READLOCKED     : 1;
+  UINT32 TPMA_NV_WRITTEN        : 1;
+  UINT32 TPMA_NV_PLATFORMCREATE : 1;
+  UINT32 TPMA_NV_READ_STCLEAR   : 1;
+} TPMA_NV;
+
+// Table 196 - TPMS_NV_PUBLIC Structure
+typedef struct {
+  TPMI_RH_NV_INDEX nvIndex;
+  TPMI_ALG_HASH    nameAlg;
+  TPMA_NV          attributes;
+  TPM2B_DIGEST     authPolicy;
+  UINT16           dataSize;
+} TPMS_NV_PUBLIC;
+
+// Table 197 - TPM2B_NV_PUBLIC Structure
+typedef struct {
+  UINT16         size;
+  TPMS_NV_PUBLIC nvPublic;
+} TPM2B_NV_PUBLIC;
+
+// 14 Context Data
+
+// Table 198 - TPM2B_CONTEXT_SENSITIVE Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[MAX_CONTEXT_SIZE];
+} TPM2B_CONTEXT_SENSITIVE;
+
+// Table 199 - TPMS_CONTEXT_DATA Structure
+typedef struct {
+  TPM2B_DIGEST            integrity;
+  TPM2B_CONTEXT_SENSITIVE encrypted;
+} TPMS_CONTEXT_DATA;
+
+// Table 200 - TPM2B_CONTEXT_DATA Structure
+typedef struct {
+  UINT16 size;
+  BYTE   buffer[sizeof(TPMS_CONTEXT_DATA)];
+} TPM2B_CONTEXT_DATA;
+
+// Table 201 - TPMS_CONTEXT Structure
+typedef struct {
+  UINT64             sequence;
+  TPMI_DH_CONTEXT    savedHandle;
+  TPMI_RH_HIERARCHY  hierarchy;
+  TPM2B_CONTEXT_DATA contextBlob;
+} TPMS_CONTEXT;
+
+// 15 Creation Data
+
+// Table 203 - TPMS_CREATION_DATA Structure
+typedef struct {
+  TPML_PCR_SELECTION pcrSelect;
+  TPM2B_DIGEST       pcrDigest;
+  TPMA_LOCALITY      locality;
+  TPM_ALG_ID         parentNameAlg;
+  TPM2B_NAME         parentName;
+  TPM2B_NAME         parentQualifiedName;
+  TPM2B_DATA         outsideInfo;
+} TPMS_CREATION_DATA;
+
+// Table 204 - TPM2B_CREATION_DATA Structure
+typedef struct {
+  UINT16             size;
+  TPMS_CREATION_DATA creationData;
+} TPM2B_CREATION_DATA;
+
+
+//
+// Command Header
+//
+typedef struct {
+  TPM_ST tag;
+  UINT32 paramSize;
+  TPM_CC commandCode;
+} TPM2_COMMAND_HEADER;
+
+typedef struct {
+  TPM_ST tag;
+  UINT32 paramSize;
+  TPM_RC responseCode;
+} TPM2_RESPONSE_HEADER;
+
+#pragma pack ()
+
+//
+// TCG Algorithm Registry
+//
+#define HASH_ALG_SHA1    0x00000001
+#define HASH_ALG_SHA256  0x00000002
+#define HASH_ALG_SHA384  0x00000004
+#define HASH_ALG_SHA512  0x00000008
+#define HASH_ALG_SM3_256 0x00000010
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Tpm2Acpi.h b/libedk2_tpm/include/IndustryStandard/Tpm2Acpi.h
new file mode 100755
index 0000000..7bfde94
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Tpm2Acpi.h
@@ -0,0 +1,66 @@
+/** @file
+  TPM2 ACPI table definition.
+
+Copyright (c) 2013 - 2019, Intel Corporation. All rights reserved. <BR>
+Copyright (c) 2021, Ampere Computing LLC. All rights reserved. <BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _TPM2_ACPI_H_
+#define _TPM2_ACPI_H_
+
+#include <IndustryStandard/Acpi.h>
+
+#pragma pack (1)
+
+#define EFI_TPM2_ACPI_TABLE_REVISION_3  3
+#define EFI_TPM2_ACPI_TABLE_REVISION_4  4
+#define EFI_TPM2_ACPI_TABLE_REVISION    EFI_TPM2_ACPI_TABLE_REVISION_4
+
+typedef struct {
+  EFI_ACPI_DESCRIPTION_HEADER Header;
+  // Flags field is replaced in version 4 and above
+  //    BIT0~15:  PlatformClass      This field is only valid for version 4 and above
+  //    BIT16~31: Reserved
+  UINT32                      Flags;
+  UINT64                      AddressOfControlArea;
+  UINT32                      StartMethod;
+  UINT8                       PlatformSpecificParameters[12];
+  UINT32                      LogAreaMinimumLen;
+  UINT64                      LogAreaStartAddress;
+} EFI_TPM2_ACPI_TABLE;
+
+#define EFI_TPM2_ACPI_TABLE_START_METHOD_ACPI                                          2
+#define EFI_TPM2_ACPI_TABLE_START_METHOD_TIS                                           6
+#define EFI_TPM2_ACPI_TABLE_START_METHOD_COMMAND_RESPONSE_BUFFER_INTERFACE             7
+#define EFI_TPM2_ACPI_TABLE_START_METHOD_COMMAND_RESPONSE_BUFFER_INTERFACE_WITH_ACPI   8
+#define EFI_TPM2_ACPI_TABLE_START_METHOD_COMMAND_RESPONSE_BUFFER_INTERFACE_WITH_SMC    11
+
+typedef struct {
+  UINT32   Reserved;
+  UINT32   Error;
+  UINT32   Cancel;
+  UINT32   Start;
+  UINT64   InterruptControl;
+  UINT32   CommandSize;
+  UINT64   Command;
+  UINT32   ResponseSize;
+  UINT64   Response;
+} EFI_TPM2_ACPI_CONTROL_AREA;
+
+//
+// Start Method Specific Parameters for ARM SMC Start Method (11)
+// Refer to Table 9: Start Method Specific Parameters for ARM SMC
+//
+typedef struct {
+  UINT32   Interrupt;
+  UINT8    Flags;
+  UINT8    OperationFlags;
+  UINT8    Reserved[2];
+  UINT32   SmcFunctionId;
+} EFI_TPM2_ACPI_START_METHOD_SPECIFIC_PARAMETERS_ARM_SMC;
+
+#pragma pack ()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/TpmPtp.h b/libedk2_tpm/include/IndustryStandard/TpmPtp.h
new file mode 100644
index 0000000..4481a08
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/TpmPtp.h
@@ -0,0 +1,517 @@
+/** @file
+  Platform TPM Profile Specification definition for TPM2.0.
+  It covers both FIFO and CRB interface.
+
+Copyright (c) 2016 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _TPM_PTP_H_
+#define _TPM_PTP_H_
+
+//
+// PTP FIFO definition
+//
+
+//
+// Set structure alignment to 1-byte
+//
+#pragma pack (1)
+
+//
+// Register set map as specified in PTP specification Chapter 5
+//
+typedef struct {
+  ///
+  /// Used to gain ownership for this particular port.
+  ///
+  UINT8                             Access;             // 0
+  UINT8                             Reserved1[7];       // 1
+  ///
+  /// Controls interrupts.
+  ///
+  UINT32                            IntEnable;          // 8
+  ///
+  /// SIRQ vector to be used by the TPM.
+  ///
+  UINT8                             IntVector;          // 0ch
+  UINT8                             Reserved2[3];       // 0dh
+  ///
+  /// What caused interrupt.
+  ///
+  UINT32                            IntSts;             // 10h
+  ///
+  /// Shows which interrupts are supported by that particular TPM.
+  ///
+  UINT32                            InterfaceCapability;// 14h
+  ///
+  /// Status Register. Provides status of the TPM.
+  ///
+  UINT8                             Status;             // 18h
+  ///
+  /// Number of consecutive writes that can be done to the TPM.
+  ///
+  UINT16                            BurstCount;         // 19h
+  ///
+  /// Additional Status Register.
+  ///
+  UINT8                             StatusEx;           // 1Bh
+  UINT8                             Reserved3[8];
+  ///
+  /// Read or write FIFO, depending on transaction.
+  ///
+  UINT32                            DataFifo;           // 24h
+  UINT8                             Reserved4[8];       // 28h
+  ///
+  /// Used to identify the Interface types supported by the TPM.
+  ///
+  UINT32                            InterfaceId;        // 30h
+  UINT8                             Reserved5[0x4c];    // 34h
+  ///
+  /// Extended ReadFIFO or WriteFIFO, depending on the current bus cycle (read or write)
+  ///
+  UINT32                            XDataFifo;          // 80h
+  UINT8                             Reserved6[0xe7c];   // 84h
+  ///
+  /// Vendor ID
+  ///
+  UINT16                            Vid;                // 0f00h
+  ///
+  /// Device ID
+  ///
+  UINT16                            Did;                // 0f02h
+  ///
+  /// Revision ID
+  ///
+  UINT8                             Rid;                // 0f04h
+  UINT8                             Reserved[0xfb];     // 0f05h
+} PTP_FIFO_REGISTERS;
+
+//
+// Restore original structure alignment
+//
+#pragma pack ()
+
+//
+// Define pointer types used to access TIS registers on PC
+//
+typedef PTP_FIFO_REGISTERS  *PTP_FIFO_REGISTERS_PTR;
+
+//
+// Define bits of FIFO Interface Identifier Register
+//
+typedef union {
+  struct {
+    UINT32   InterfaceType:4;
+    UINT32   InterfaceVersion:4;
+    UINT32   CapLocality:1;
+    UINT32   Reserved1:2;
+    UINT32   CapDataXferSizeSupport:2;
+    UINT32   CapFIFO:1;
+    UINT32   CapCRB:1;
+    UINT32   CapIFRes:2;
+    UINT32   InterfaceSelector:2;
+    UINT32   IntfSelLock:1;
+    UINT32   Reserved2:4;
+    UINT32   Reserved3:8;
+  } Bits;
+  UINT32   Uint32;
+} PTP_FIFO_INTERFACE_IDENTIFIER;
+
+//
+// Define bits of FIFO Interface Capability Register
+//
+typedef union {
+  struct {
+    UINT32   DataAvailIntSupport:1;
+    UINT32   StsValidIntSupport:1;
+    UINT32   LocalityChangeIntSupport:1;
+    UINT32   InterruptLevelHigh:1;
+    UINT32   InterruptLevelLow:1;
+    UINT32   InterruptEdgeRising:1;
+    UINT32   InterruptEdgeFalling:1;
+    UINT32   CommandReadyIntSupport:1;
+    UINT32   BurstCountStatic:1;
+    UINT32   DataTransferSizeSupport:2;
+    UINT32   Reserved:17;
+    UINT32   InterfaceVersion:3;
+    UINT32   Reserved2:1;
+  } Bits;
+  UINT32   Uint32;
+} PTP_FIFO_INTERFACE_CAPABILITY;
+
+///
+/// InterfaceVersion
+///
+#define INTERFACE_CAPABILITY_INTERFACE_VERSION_TIS_12  0x0
+#define INTERFACE_CAPABILITY_INTERFACE_VERSION_TIS_13  0x2
+#define INTERFACE_CAPABILITY_INTERFACE_VERSION_PTP     0x3
+
+
+//
+// Define bits of ACCESS and STATUS registers
+//
+
+///
+/// This bit is a 1 to indicate that the other bits in this register are valid.
+///
+#define PTP_FIFO_VALID                BIT7
+///
+/// Indicate that this locality is active.
+///
+#define PTP_FIFO_ACC_ACTIVE           BIT5
+///
+/// Set to 1 to indicate that this locality had the TPM taken away while
+/// this locality had the TIS_PC_ACC_ACTIVE bit set.
+///
+#define PTP_FIFO_ACC_SEIZED           BIT4
+///
+/// Set to 1 to indicate that TPM MUST reset the
+/// TIS_PC_ACC_ACTIVE bit and remove ownership for localities less than the
+/// locality that is writing this bit.
+///
+#define PTP_FIFO_ACC_SEIZE            BIT3
+///
+/// When this bit is 1, another locality is requesting usage of the TPM.
+///
+#define PTP_FIFO_ACC_PENDIND          BIT2
+///
+/// Set to 1 to indicate that this locality is requesting to use TPM.
+///
+#define PTP_FIFO_ACC_RQUUSE           BIT1
+///
+/// A value of 1 indicates that a T/OS has not been established on the platform
+///
+#define PTP_FIFO_ACC_ESTABLISH        BIT0
+
+///
+/// This field indicates that STS_DATA and STS_EXPECT are valid
+///
+#define PTP_FIFO_STS_VALID            BIT7
+///
+/// When this bit is 1, TPM is in the Ready state,
+/// indicating it is ready to receive a new command.
+///
+#define PTP_FIFO_STS_READY            BIT6
+///
+/// Write a 1 to this bit to cause the TPM to execute that command.
+///
+#define PTP_FIFO_STS_GO               BIT5
+///
+/// This bit indicates that the TPM has data available as a response.
+///
+#define PTP_FIFO_STS_DATA             BIT4
+///
+/// The TPM sets this bit to a value of 1 when it expects another byte of data for a command.
+///
+#define PTP_FIFO_STS_EXPECT           BIT3
+///
+/// Indicates that the TPM has completed all self-test actions following a TPM_ContinueSelfTest command.
+///
+#define PTP_FIFO_STS_SELFTEST_DONE    BIT2
+///
+/// Writes a 1 to this bit to force the TPM to re-send the response.
+///
+#define PTP_FIFO_STS_RETRY            BIT1
+
+///
+/// TPM Family Identifier.
+/// 00: TPM 1.2 Family
+/// 01: TPM 2.0 Family
+///
+#define PTP_FIFO_STS_EX_TPM_FAMILY    (BIT2 | BIT3)
+#define PTP_FIFO_STS_EX_TPM_FAMILY_OFFSET    (2)
+#define PTP_FIFO_STS_EX_TPM_FAMILY_TPM12    (0)
+#define PTP_FIFO_STS_EX_TPM_FAMILY_TPM20    (BIT2)
+///
+/// A write of 1 after tpmGo and before dataAvail aborts the currently executing command, resulting in a response of TPM_RC_CANCELLED.
+/// A write of 1 after dataAvail and before tpmGo is ignored by the TPM.
+///
+#define PTP_FIFO_STS_EX_CANCEL        BIT0
+
+
+//
+// PTP CRB definition
+//
+
+//
+// Set structure alignment to 1-byte
+//
+#pragma pack (1)
+
+//
+// Register set map as specified in PTP specification Chapter 5
+//
+typedef struct {
+  ///
+  /// Used to determine current state of Locality of the TPM.
+  ///
+  UINT32                            LocalityState;             // 0
+  UINT8                             Reserved1[4];              // 4
+  ///
+  /// Used to gain control of the TPM by this Locality.
+  ///
+  UINT32                            LocalityControl;           // 8
+  ///
+  /// Used to determine whether Locality has been granted or Seized.
+  ///
+  UINT32                            LocalityStatus;            // 0ch
+  UINT8                             Reserved2[0x20];           // 10h
+  ///
+  /// Used to identify the Interface types supported by the TPM.
+  ///
+  UINT32                            InterfaceId;               // 30h
+  ///
+  /// Vendor ID
+  ///
+  UINT16                            Vid;                       // 34h
+  ///
+  /// Device ID
+  ///
+  UINT16                            Did;                       // 36h
+  ///
+  /// Optional Register used in low memory environments prior to CRB_DATA_BUFFER availability.
+  ///
+  UINT64                            CrbControlExtension;       // 38h
+  ///
+  /// Register used to initiate transactions for the CRB interface.
+  ///
+  UINT32                            CrbControlRequest;         // 40h
+  ///
+  /// Register used by the TPM to provide status of the CRB interface.
+  ///
+  UINT32                            CrbControlStatus;          // 44h
+  ///
+  /// Register used by software to cancel command processing.
+  ///
+  UINT32                            CrbControlCancel;          // 48h
+  ///
+  /// Register used to indicate presence of command or response data in the CRB buffer.
+  ///
+  UINT32                            CrbControlStart;           // 4Ch
+  ///
+  /// Register used to configure and respond to interrupts.
+  ///
+  UINT32                            CrbInterruptEnable;        // 50h
+  UINT32                            CrbInterruptStatus;        // 54h
+  ///
+  /// Size of the Command buffer.
+  ///
+  UINT32                            CrbControlCommandSize;     // 58h
+  ///
+  /// Command buffer start address
+  ///
+  UINT32                            CrbControlCommandAddressLow;   // 5Ch
+  UINT32                            CrbControlCommandAddressHigh;  // 60h
+  ///
+  /// Size of the Response buffer
+  ///
+  UINT32                            CrbControlResponseSize;    // 64h
+  ///
+  /// Address of the start of the Response buffer
+  ///
+  UINT64                            CrbControlResponseAddrss;  // 68h
+  UINT8                             Reserved4[0x10];           // 70h
+  ///
+  /// Command/Response Data may be defined as large as 3968 (0xF80).
+  ///
+  UINT8                             CrbDataBuffer[0xF80];      // 80h
+} PTP_CRB_REGISTERS;
+
+//
+// Define pointer types used to access CRB registers on PTP
+//
+typedef PTP_CRB_REGISTERS  *PTP_CRB_REGISTERS_PTR;
+
+//
+// Define bits of CRB Interface Identifier Register
+//
+typedef union {
+  struct {
+    UINT32   InterfaceType:4;
+    UINT32   InterfaceVersion:4;
+    UINT32   CapLocality:1;
+    UINT32   CapCRBIdleBypass:1;
+    UINT32   Reserved1:1;
+    UINT32   CapDataXferSizeSupport:2;
+    UINT32   CapFIFO:1;
+    UINT32   CapCRB:1;
+    UINT32   CapIFRes:2;
+    UINT32   InterfaceSelector:2;
+    UINT32   IntfSelLock:1;
+    UINT32   Reserved2:4;
+    UINT32   Rid:8;
+  } Bits;
+  UINT32   Uint32;
+} PTP_CRB_INTERFACE_IDENTIFIER;
+
+///
+/// InterfaceType
+///
+#define PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_FIFO  0x0
+#define PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_CRB   0x1
+#define PTP_INTERFACE_IDENTIFIER_INTERFACE_TYPE_TIS   0xF
+
+///
+/// InterfaceVersion
+///
+#define PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_FIFO  0x0
+#define PTP_INTERFACE_IDENTIFIER_INTERFACE_VERSION_CRB   0x1
+
+///
+/// InterfaceSelector
+///
+#define PTP_INTERFACE_IDENTIFIER_INTERFACE_SELECTOR_FIFO  0x0
+#define PTP_INTERFACE_IDENTIFIER_INTERFACE_SELECTOR_CRB   0x1
+
+//
+// Define bits of Locality State Register
+//
+
+///
+/// This bit indicates whether all other bits of this register contain valid values, if it is a 1.
+///
+#define PTP_CRB_LOCALITY_STATE_TPM_REG_VALID_STATUS       BIT7
+
+///
+/// 000 - Locality 0
+/// 001 - Locality 1
+/// 010 - Locality 2
+/// 011 - Locality 3
+/// 100 - Locality 4
+///
+#define PTP_CRB_LOCALITY_STATE_ACTIVE_LOCALITY_MASK       (BIT2 | BIT3 | BIT4)
+#define PTP_CRB_LOCALITY_STATE_ACTIVE_LOCALITY_0          (0)
+#define PTP_CRB_LOCALITY_STATE_ACTIVE_LOCALITY_1          (BIT2)
+#define PTP_CRB_LOCALITY_STATE_ACTIVE_LOCALITY_2          (BIT3)
+#define PTP_CRB_LOCALITY_STATE_ACTIVE_LOCALITY_3          (BIT2 | BIT3)
+#define PTP_CRB_LOCALITY_STATE_ACTIVE_LOCALITY_4          (BIT4)
+
+///
+/// A 0 indicates to the host that no locality is assigned.
+/// A 1 indicates a locality has been assigned.
+///
+#define PTP_CRB_LOCALITY_STATE_LOCALITY_ASSIGNED          BIT1
+
+///
+/// The TPM clears this bit to 0 upon receipt of _TPM_Hash_End
+/// The TPM sets this bit to a 1 when the TPM_LOC_CTRL_x.resetEstablishment field is set to 1.
+///
+#define PTP_CRB_LOCALITY_STATE_TPM_ESTABLISHED            BIT0
+
+//
+// Define bits of Locality Control Register
+//
+
+///
+/// Writes (1): Reset TPM_LOC_STATE_x.tpmEstablished bit if the write occurs from Locality 3 or 4.
+///
+#define PTP_CRB_LOCALITY_CONTROL_RESET_ESTABLISHMENT_BIT  BIT3
+
+///
+/// Writes (1): The TPM gives control of the TPM to the locality setting this bit if it is the higher priority locality.
+///
+#define PTP_CRB_LOCALITY_CONTROL_SEIZE                    BIT2
+
+///
+/// Writes (1): The active Locality is done with the TPM.
+///
+#define PTP_CRB_LOCALITY_CONTROL_RELINQUISH               BIT1
+
+///
+/// Writes (1): Interrupt the TPM and generate a locality arbitration algorithm.
+///
+#define PTP_CRB_LOCALITY_CONTROL_REQUEST_ACCESS           BIT0
+
+//
+// Define bits of Locality Status Register
+//
+
+///
+/// 0: A higher locality has not initiated a Seize arbitration process.
+/// 1: A higher locality has Seized the TPM from this locality.
+///
+#define PTP_CRB_LOCALITY_STATUS_BEEN_SEIZED               BIT1
+
+///
+/// 0: Locality has not been granted to the TPM.
+/// 1: Locality has been granted access to the TPM
+///
+#define PTP_CRB_LOCALITY_STATUS_GRANTED                   BIT0
+
+//
+// Define bits of CRB Control Area Request Register
+//
+
+///
+/// Used by Software to indicate transition the TPM to and from the Idle state
+/// 1: Set by Software to indicate response has been read from the response buffer and TPM can transition to Idle
+/// 0: Cleared to 0 by TPM to acknowledge the request when TPM enters Idle state.
+/// TPM SHALL complete this transition within TIMEOUT_C.
+///
+#define PTP_CRB_CONTROL_AREA_REQUEST_GO_IDLE              BIT1
+
+///
+/// Used by Software to request the TPM transition to the Ready State.
+/// 1: Set to 1 by Software to indicate the TPM should be ready to receive a command.
+/// 0: Cleared to 0 by TPM to acknowledge the request.
+/// TPM SHALL complete this transition within TIMEOUT_C.
+///
+#define PTP_CRB_CONTROL_AREA_REQUEST_COMMAND_READY        BIT0
+
+//
+// Define bits of CRB Control Area Status Register
+//
+
+///
+/// Used by TPM to indicate it is in the Idle State
+/// 1: Set by TPM when in the Idle State
+/// 0: Cleared by TPM on receipt of TPM_CRB_CTRL_REQ_x.cmdReady when TPM transitions to the Ready State.
+/// SHALL be cleared by TIMEOUT_C.
+///
+#define PTP_CRB_CONTROL_AREA_STATUS_TPM_IDLE              BIT1
+
+///
+/// Used by the TPM to indicate current status.
+/// 1: Set by TPM to indicate a FATAL Error
+/// 0: Indicates TPM is operational
+///
+#define PTP_CRB_CONTROL_AREA_STATUS_TPM_STATUS            BIT0
+
+//
+// Define bits of CRB Control Cancel Register
+//
+
+///
+/// Used by software to cancel command processing Reads return correct value
+/// Writes (0000 0001h): Cancel a command
+/// Writes (0000 0000h): Clears field when command has been cancelled
+///
+#define PTP_CRB_CONTROL_CANCEL                            BIT0
+
+//
+// Define bits of CRB Control Start Register
+//
+
+///
+/// When set by software, indicates a command is ready for processing.
+/// Writes (0000 0001h): TPM transitions to Command Execution
+/// Writes (0000 0000h): TPM clears this field and transitions to Command Completion
+///
+#define PTP_CRB_CONTROL_START                             BIT0
+
+//
+// Restore original structure alignment
+//
+#pragma pack ()
+
+//
+// Default TimeOut value
+//
+#define PTP_TIMEOUT_A               (750 * 1000)   // 750ms
+#define PTP_TIMEOUT_B               (2000 * 1000)  // 2s
+#define PTP_TIMEOUT_C               (200 * 1000)   // 200ms
+#define PTP_TIMEOUT_D               (30 * 1000)    // 30ms
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/TpmTis.h b/libedk2_tpm/include/IndustryStandard/TpmTis.h
new file mode 100644
index 0000000..85c2969
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/TpmTis.h
@@ -0,0 +1,181 @@
+/** @file
+  TPM Interface Specification definition.
+  It covers both TPM1.2 and TPM2.0.
+
+Copyright (c) 2016 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef _TPM_TIS_H_
+#define _TPM_TIS_H_
+
+//
+// Set structure alignment to 1-byte
+//
+#pragma pack (1)
+
+//
+// Register set map as specified in TIS specification Chapter 10
+//
+typedef struct {
+  ///
+  /// Used to gain ownership for this particular port.
+  ///
+  UINT8                             Access;             // 0
+  UINT8                             Reserved1[7];       // 1
+  ///
+  /// Controls interrupts.
+  ///
+  UINT32                            IntEnable;          // 8
+  ///
+  /// SIRQ vector to be used by the TPM.
+  ///
+  UINT8                             IntVector;          // 0ch
+  UINT8                             Reserved2[3];       // 0dh
+  ///
+  /// What caused interrupt.
+  ///
+  UINT32                            IntSts;             // 10h
+  ///
+  /// Shows which interrupts are supported by that particular TPM.
+  ///
+  UINT32                            IntfCapability;     // 14h
+  ///
+  /// Status Register. Provides status of the TPM.
+  ///
+  UINT8                             Status;             // 18h
+  ///
+  /// Number of consecutive writes that can be done to the TPM.
+  ///
+  UINT16                            BurstCount;         // 19h
+  UINT8                             Reserved3[9];
+  ///
+  /// Read or write FIFO, depending on transaction.
+  ///
+  UINT32                            DataFifo;           // 24h
+  UINT8                             Reserved4[0xed8];   // 28h
+  ///
+  /// Vendor ID
+  ///
+  UINT16                            Vid;                // 0f00h
+  ///
+  /// Device ID
+  ///
+  UINT16                            Did;                // 0f02h
+  ///
+  /// Revision ID
+  ///
+  UINT8                             Rid;                // 0f04h
+  UINT8                             Reserved[0x7b];     // 0f05h
+  ///
+  /// Alias to I/O legacy space.
+  ///
+  UINT32                            LegacyAddress1;     // 0f80h
+  ///
+  /// Additional 8 bits for I/O legacy space extension.
+  ///
+  UINT32                            LegacyAddress1Ex;   // 0f84h
+  ///
+  /// Alias to second I/O legacy space.
+  ///
+  UINT32                            LegacyAddress2;     // 0f88h
+  ///
+  /// Additional 8 bits for second I/O legacy space extension.
+  ///
+  UINT32                            LegacyAddress2Ex;   // 0f8ch
+  ///
+  /// Vendor-defined configuration registers.
+  ///
+  UINT8                             VendorDefined[0x70];// 0f90h
+} TIS_PC_REGISTERS;
+
+//
+// Restore original structure alignment
+//
+#pragma pack ()
+
+//
+// Define pointer types used to access TIS registers on PC
+//
+typedef TIS_PC_REGISTERS  *TIS_PC_REGISTERS_PTR;
+
+//
+// Define bits of ACCESS and STATUS registers
+//
+
+///
+/// This bit is a 1 to indicate that the other bits in this register are valid.
+///
+#define TIS_PC_VALID                BIT7
+///
+/// Indicate that this locality is active.
+///
+#define TIS_PC_ACC_ACTIVE           BIT5
+///
+/// Set to 1 to indicate that this locality had the TPM taken away while
+/// this locality had the TIS_PC_ACC_ACTIVE bit set.
+///
+#define TIS_PC_ACC_SEIZED           BIT4
+///
+/// Set to 1 to indicate that TPM MUST reset the
+/// TIS_PC_ACC_ACTIVE bit and remove ownership for localities less than the
+/// locality that is writing this bit.
+///
+#define TIS_PC_ACC_SEIZE            BIT3
+///
+/// When this bit is 1, another locality is requesting usage of the TPM.
+///
+#define TIS_PC_ACC_PENDIND          BIT2
+///
+/// Set to 1 to indicate that this locality is requesting to use TPM.
+///
+#define TIS_PC_ACC_RQUUSE           BIT1
+///
+/// A value of 1 indicates that a T/OS has not been established on the platform
+///
+#define TIS_PC_ACC_ESTABLISH        BIT0
+
+///
+/// Write a 1 to this bit to notify TPM to cancel currently executing command
+///
+#define TIS_PC_STS_CANCEL           BIT24
+///
+/// This field indicates that STS_DATA and STS_EXPECT are valid
+///
+#define TIS_PC_STS_VALID            BIT7
+///
+/// When this bit is 1, TPM is in the Ready state,
+/// indicating it is ready to receive a new command.
+///
+#define TIS_PC_STS_READY            BIT6
+///
+/// Write a 1 to this bit to cause the TPM to execute that command.
+///
+#define TIS_PC_STS_GO               BIT5
+///
+/// This bit indicates that the TPM has data available as a response.
+///
+#define TIS_PC_STS_DATA             BIT4
+///
+/// The TPM sets this bit to a value of 1 when it expects another byte of data for a command.
+///
+#define TIS_PC_STS_EXPECT           BIT3
+///
+/// Indicates that the TPM has completed all self-test actions following a TPM_ContinueSelfTest command.
+///
+#define TIS_PC_STS_SELFTEST_DONE    BIT2
+///
+/// Writes a 1 to this bit to force the TPM to re-send the response.
+///
+#define TIS_PC_STS_RETRY            BIT1
+
+//
+// Default TimeOut value
+//
+#define TIS_TIMEOUT_A               (750  * 1000)  // 750ms
+#define TIS_TIMEOUT_B               (2000 * 1000)  // 2s
+#define TIS_TIMEOUT_C               (750  * 1000)  // 750ms
+#define TIS_TIMEOUT_D               (750  * 1000)  // 750ms
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/UefiTcgPlatform.h b/libedk2_tpm/include/IndustryStandard/UefiTcgPlatform.h
new file mode 100644
index 0000000..d1cd715
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/UefiTcgPlatform.h
@@ -0,0 +1,498 @@
+/** @file
+  TCG EFI Platform Definition in TCG_EFI_Platform_1_20_Final and
+  TCG PC Client Platform Firmware Profile Specification, Revision 1.05
+
+  Copyright (c) 2006 - 2019, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __UEFI_TCG_PLATFORM_H__
+#define __UEFI_TCG_PLATFORM_H__
+
+#include <Uefi.h>
+#include <IndustryStandard/Tpm12.h>
+#include <IndustryStandard/Tpm20.h>
+
+//
+// Standard event types
+//
+#define EV_PREBOOT_CERT             ((TCG_EVENTTYPE) 0x00000000)
+#define EV_POST_CODE                ((TCG_EVENTTYPE) 0x00000001)
+#define EV_NO_ACTION                ((TCG_EVENTTYPE) 0x00000003)
+#define EV_SEPARATOR                ((TCG_EVENTTYPE) 0x00000004)
+#define EV_ACTION                   ((TCG_EVENTTYPE) 0x00000005)
+#define EV_EVENT_TAG                ((TCG_EVENTTYPE) 0x00000006)
+#define EV_S_CRTM_CONTENTS          ((TCG_EVENTTYPE) 0x00000007)
+#define EV_S_CRTM_VERSION           ((TCG_EVENTTYPE) 0x00000008)
+#define EV_CPU_MICROCODE            ((TCG_EVENTTYPE) 0x00000009)
+#define EV_PLATFORM_CONFIG_FLAGS    ((TCG_EVENTTYPE) 0x0000000A)
+#define EV_TABLE_OF_DEVICES         ((TCG_EVENTTYPE) 0x0000000B)
+#define EV_COMPACT_HASH             ((TCG_EVENTTYPE) 0x0000000C)
+#define EV_NONHOST_CODE             ((TCG_EVENTTYPE) 0x0000000F)
+#define EV_NONHOST_CONFIG           ((TCG_EVENTTYPE) 0x00000010)
+#define EV_NONHOST_INFO             ((TCG_EVENTTYPE) 0x00000011)
+#define EV_OMIT_BOOT_DEVICE_EVENTS  ((TCG_EVENTTYPE) 0x00000012)
+
+//
+// EFI specific event types
+//
+#define EV_EFI_EVENT_BASE                   ((TCG_EVENTTYPE) 0x80000000)
+#define EV_EFI_VARIABLE_DRIVER_CONFIG       (EV_EFI_EVENT_BASE + 1)
+#define EV_EFI_VARIABLE_BOOT                (EV_EFI_EVENT_BASE + 2)
+#define EV_EFI_BOOT_SERVICES_APPLICATION    (EV_EFI_EVENT_BASE + 3)
+#define EV_EFI_BOOT_SERVICES_DRIVER         (EV_EFI_EVENT_BASE + 4)
+#define EV_EFI_RUNTIME_SERVICES_DRIVER      (EV_EFI_EVENT_BASE + 5)
+#define EV_EFI_GPT_EVENT                    (EV_EFI_EVENT_BASE + 6)
+#define EV_EFI_ACTION                       (EV_EFI_EVENT_BASE + 7)
+#define EV_EFI_PLATFORM_FIRMWARE_BLOB       (EV_EFI_EVENT_BASE + 8)
+#define EV_EFI_HANDOFF_TABLES               (EV_EFI_EVENT_BASE + 9)
+#define EV_EFI_PLATFORM_FIRMWARE_BLOB2      (EV_EFI_EVENT_BASE + 0xA)
+#define EV_EFI_HANDOFF_TABLES2              (EV_EFI_EVENT_BASE + 0xB)
+#define EV_EFI_HCRTM_EVENT                  (EV_EFI_EVENT_BASE + 0x10)
+#define EV_EFI_VARIABLE_AUTHORITY           (EV_EFI_EVENT_BASE + 0xE0)
+#define EV_EFI_SPDM_FIRMWARE_BLOB           (EV_EFI_EVENT_BASE + 0xE1)
+#define EV_EFI_SPDM_FIRMWARE_CONFIG         (EV_EFI_EVENT_BASE + 0xE2)
+
+#define EFI_CALLING_EFI_APPLICATION         \
+  "Calling EFI Application from Boot Option"
+#define EFI_RETURNING_FROM_EFI_APPLICATION  \
+  "Returning from EFI Application from Boot Option"
+#define EFI_EXIT_BOOT_SERVICES_INVOCATION   \
+  "Exit Boot Services Invocation"
+#define EFI_EXIT_BOOT_SERVICES_FAILED       \
+  "Exit Boot Services Returned with Failure"
+#define EFI_EXIT_BOOT_SERVICES_SUCCEEDED    \
+  "Exit Boot Services Returned with Success"
+
+
+#define EV_POSTCODE_INFO_POST_CODE    "POST CODE"
+#define POST_CODE_STR_LEN             (sizeof(EV_POSTCODE_INFO_POST_CODE) - 1)
+
+#define EV_POSTCODE_INFO_SMM_CODE     "SMM CODE"
+#define SMM_CODE_STR_LEN              (sizeof(EV_POSTCODE_INFO_SMM_CODE) - 1)
+
+#define EV_POSTCODE_INFO_ACPI_DATA    "ACPI DATA"
+#define ACPI_DATA_LEN                 (sizeof(EV_POSTCODE_INFO_ACPI_DATA) - 1)
+
+#define EV_POSTCODE_INFO_BIS_CODE     "BIS CODE"
+#define BIS_CODE_LEN                  (sizeof(EV_POSTCODE_INFO_BIS_CODE) - 1)
+
+#define EV_POSTCODE_INFO_UEFI_PI      "UEFI PI"
+#define UEFI_PI_LEN                   (sizeof(EV_POSTCODE_INFO_UEFI_PI) - 1)
+
+#define EV_POSTCODE_INFO_OPROM        "Embedded Option ROM"
+#define OPROM_LEN                     (sizeof(EV_POSTCODE_INFO_OPROM) - 1)
+
+#define EV_POSTCODE_INFO_EMBEDDED_UEFI_DRIVER  "Embedded UEFI Driver"
+#define EMBEDDED_UEFI_DRIVER_LEN               (sizeof(EV_POSTCODE_INFO_EMBEDDED_UEFI_DRIVER) - 1)
+
+#define FIRMWARE_DEBUGGER_EVENT_STRING      "UEFI Debug Mode"
+#define FIRMWARE_DEBUGGER_EVENT_STRING_LEN  (sizeof(FIRMWARE_DEBUGGER_EVENT_STRING) - 1)
+
+//
+// Set structure alignment to 1-byte
+//
+#pragma pack (1)
+
+typedef UINT32                     TCG_EVENTTYPE;
+typedef TPM_PCRINDEX               TCG_PCRINDEX;
+typedef TPM_DIGEST                 TCG_DIGEST;
+///
+/// Event Log Entry Structure Definition
+///
+typedef struct tdTCG_PCR_EVENT {
+  TCG_PCRINDEX                      PCRIndex;  ///< PCRIndex event extended to
+  TCG_EVENTTYPE                     EventType; ///< TCG EFI event type
+  TCG_DIGEST                        Digest;    ///< Value extended into PCRIndex
+  UINT32                            EventSize; ///< Size of the event data
+  UINT8                             Event[1];  ///< The event data
+} TCG_PCR_EVENT;
+
+#define TSS_EVENT_DATA_MAX_SIZE   256
+
+///
+/// TCG_PCR_EVENT_HDR
+///
+typedef struct tdTCG_PCR_EVENT_HDR {
+  TCG_PCRINDEX                      PCRIndex;
+  TCG_EVENTTYPE                     EventType;
+  TCG_DIGEST                        Digest;
+  UINT32                            EventSize;
+} TCG_PCR_EVENT_HDR;
+
+///
+/// EFI_PLATFORM_FIRMWARE_BLOB
+///
+/// BlobLength should be of type UINTN but we use UINT64 here
+/// because PEI is 32-bit while DXE is 64-bit on x64 platforms
+///
+typedef struct tdEFI_PLATFORM_FIRMWARE_BLOB {
+  EFI_PHYSICAL_ADDRESS              BlobBase;
+  UINT64                            BlobLength;
+} EFI_PLATFORM_FIRMWARE_BLOB;
+
+///
+/// UEFI_PLATFORM_FIRMWARE_BLOB
+///
+/// This structure is used in EV_EFI_PLATFORM_FIRMWARE_BLOB
+/// event to facilitate the measurement of firmware volume.
+///
+typedef struct tdUEFI_PLATFORM_FIRMWARE_BLOB {
+  EFI_PHYSICAL_ADDRESS              BlobBase;
+  UINT64                            BlobLength;
+} UEFI_PLATFORM_FIRMWARE_BLOB;
+
+///
+/// UEFI_PLATFORM_FIRMWARE_BLOB2
+///
+/// This structure is used in EV_EFI_PLATFORM_FIRMWARE_BLOB2
+/// event to facilitate the measurement of firmware volume.
+///
+typedef struct tdUEFI_PLATFORM_FIRMWARE_BLOB2 {
+  UINT8                             BlobDescriptionSize;
+//UINT8                             BlobDescription[BlobDescriptionSize];
+//EFI_PHYSICAL_ADDRESS              BlobBase;
+//UINT64                            BlobLength;
+} UEFI_PLATFORM_FIRMWARE_BLOB2;
+
+///
+/// EFI_IMAGE_LOAD_EVENT
+///
+/// This structure is used in EV_EFI_BOOT_SERVICES_APPLICATION,
+/// EV_EFI_BOOT_SERVICES_DRIVER and EV_EFI_RUNTIME_SERVICES_DRIVER
+///
+typedef struct tdEFI_IMAGE_LOAD_EVENT {
+  EFI_PHYSICAL_ADDRESS              ImageLocationInMemory;
+  UINTN                             ImageLengthInMemory;
+  UINTN                             ImageLinkTimeAddress;
+  UINTN                             LengthOfDevicePath;
+  EFI_DEVICE_PATH_PROTOCOL          DevicePath[1];
+} EFI_IMAGE_LOAD_EVENT;
+
+///
+/// UEFI_IMAGE_LOAD_EVENT
+///
+/// This structure is used in EV_EFI_BOOT_SERVICES_APPLICATION,
+/// EV_EFI_BOOT_SERVICES_DRIVER and EV_EFI_RUNTIME_SERVICES_DRIVER
+///
+typedef struct tdUEFI_IMAGE_LOAD_EVENT {
+  EFI_PHYSICAL_ADDRESS              ImageLocationInMemory;
+  UINT64                            ImageLengthInMemory;
+  UINT64                            ImageLinkTimeAddress;
+  UINT64                            LengthOfDevicePath;
+  EFI_DEVICE_PATH_PROTOCOL          DevicePath[1];
+} UEFI_IMAGE_LOAD_EVENT;
+
+///
+/// EFI_HANDOFF_TABLE_POINTERS
+///
+/// This structure is used in EV_EFI_HANDOFF_TABLES event to facilitate
+/// the measurement of given configuration tables.
+///
+typedef struct tdEFI_HANDOFF_TABLE_POINTERS {
+  UINTN                             NumberOfTables;
+  EFI_CONFIGURATION_TABLE           TableEntry[1];
+} EFI_HANDOFF_TABLE_POINTERS;
+
+///
+/// UEFI_HANDOFF_TABLE_POINTERS
+///
+/// This structure is used in EV_EFI_HANDOFF_TABLES event to facilitate
+/// the measurement of given configuration tables.
+///
+typedef struct tdUEFI_HANDOFF_TABLE_POINTERS {
+  UINT64                            NumberOfTables;
+  EFI_CONFIGURATION_TABLE           TableEntry[1];
+} UEFI_HANDOFF_TABLE_POINTERS;
+
+///
+/// UEFI_HANDOFF_TABLE_POINTERS2
+///
+/// This structure is used in EV_EFI_HANDOFF_TABLES2 event to facilitate
+/// the measurement of given configuration tables.
+///
+typedef struct tdUEFI_HANDOFF_TABLE_POINTERS2 {
+  UINT8                             TableDescriptionSize;
+//UINT8                             TableDescription[TableDescriptionSize];
+//UINT64                            NumberOfTables;
+//EFI_CONFIGURATION_TABLE           TableEntry[1];
+} UEFI_HANDOFF_TABLE_POINTERS2;
+
+///
+/// EFI_VARIABLE_DATA
+///
+/// This structure serves as the header for measuring variables. The name of the
+/// variable (in Unicode format) should immediately follow, then the variable
+/// data.
+/// This is defined in TCG EFI Platform Spec for TPM1.1 or 1.2 V1.22
+///
+typedef struct tdEFI_VARIABLE_DATA {
+  EFI_GUID                          VariableName;
+  UINTN                             UnicodeNameLength;
+  UINTN                             VariableDataLength;
+  CHAR16                            UnicodeName[1];
+  INT8                              VariableData[1];  ///< Driver or platform-specific data
+} EFI_VARIABLE_DATA;
+
+///
+/// UEFI_VARIABLE_DATA
+///
+/// This structure serves as the header for measuring variables. The name of the
+/// variable (in Unicode format) should immediately follow, then the variable
+/// data.
+/// This is defined in TCG PC Client Firmware Profile Spec 00.21
+///
+typedef struct tdUEFI_VARIABLE_DATA {
+  EFI_GUID                          VariableName;
+  UINT64                            UnicodeNameLength;
+  UINT64                            VariableDataLength;
+  CHAR16                            UnicodeName[1];
+  INT8                              VariableData[1];  ///< Driver or platform-specific data
+} UEFI_VARIABLE_DATA;
+
+//
+// For TrEE1.0 compatibility
+//
+typedef struct {
+  EFI_GUID                          VariableName;
+  UINT64                            UnicodeNameLength;   // The TCG Definition used UINTN
+  UINT64                            VariableDataLength;  // The TCG Definition used UINTN
+  CHAR16                            UnicodeName[1];
+  INT8                              VariableData[1];
+} EFI_VARIABLE_DATA_TREE;
+
+typedef struct tdEFI_GPT_DATA {
+  EFI_PARTITION_TABLE_HEADER  EfiPartitionHeader;
+  UINTN                       NumberOfPartitions;
+  EFI_PARTITION_ENTRY         Partitions[1];
+} EFI_GPT_DATA;
+
+typedef struct tdUEFI_GPT_DATA {
+  EFI_PARTITION_TABLE_HEADER  EfiPartitionHeader;
+  UINT64                      NumberOfPartitions;
+  EFI_PARTITION_ENTRY         Partitions[1];
+} UEFI_GPT_DATA;
+
+#define TCG_DEVICE_SECURITY_EVENT_DATA_SIGNATURE "SPDM Device Sec"
+#define TCG_DEVICE_SECURITY_EVENT_DATA_VERSION   1
+
+#define TCG_DEVICE_SECURITY_EVENT_DATA_DEVICE_TYPE_NULL  0
+#define TCG_DEVICE_SECURITY_EVENT_DATA_DEVICE_TYPE_PCI   1
+#define TCG_DEVICE_SECURITY_EVENT_DATA_DEVICE_TYPE_USB   2
+
+///
+/// TCG_DEVICE_SECURITY_EVENT_DATA_HEADER
+/// This is the header of TCG_DEVICE_SECURITY_EVENT_DATA, which is
+/// used in EV_EFI_SPDM_FIRMWARE_BLOB and EV_EFI_SPDM_FIRMWARE_CONFIG.
+///
+typedef struct {
+  UINT8                          Signature[16];
+  UINT16                         Version;
+  UINT16                         Length;
+  UINT32                         SpdmHashAlgo;
+  UINT32                         DeviceType;
+//SPDM_MEASUREMENT_BLOCK         SpdmMeasurementBlock;
+} TCG_DEVICE_SECURITY_EVENT_DATA_HEADER;
+
+#define TCG_DEVICE_SECURITY_EVENT_DATA_PCI_CONTEXT_VERSION  0
+
+///
+/// TCG_DEVICE_SECURITY_EVENT_DATA_PCI_CONTEXT
+/// This is the PCI context data of TCG_DEVICE_SECURITY_EVENT_DATA, which is
+/// used in EV_EFI_SPDM_FIRMWARE_BLOB and EV_EFI_SPDM_FIRMWARE_CONFIG.
+///
+typedef struct {
+  UINT16  Version;
+  UINT16  Length;
+  UINT16  VendorId;
+  UINT16  DeviceId;
+  UINT8   RevisionID;
+  UINT8   ClassCode[3];
+  UINT16  SubsystemVendorID;
+  UINT16  SubsystemID;
+} TCG_DEVICE_SECURITY_EVENT_DATA_PCI_CONTEXT;
+
+#define TCG_DEVICE_SECURITY_EVENT_DATA_USB_CONTEXT_VERSION  0
+
+///
+/// TCG_DEVICE_SECURITY_EVENT_DATA_USB_CONTEXT
+/// This is the USB context data of TCG_DEVICE_SECURITY_EVENT_DATA, which is
+/// used in EV_EFI_SPDM_FIRMWARE_BLOB and EV_EFI_SPDM_FIRMWARE_CONFIG.
+///
+typedef struct {
+  UINT16  Version;
+  UINT16  Length;
+//UINT8   DeviceDescriptor[DescLen];
+//UINT8   BodDescriptor[DescLen];
+//UINT8   ConfigurationDescriptor[DescLen][NumOfConfiguration];
+} TCG_DEVICE_SECURITY_EVENT_DATA_USB_CONTEXT;
+
+//
+// Crypto Agile Log Entry Format
+//
+typedef struct tdTCG_PCR_EVENT2 {
+  TCG_PCRINDEX        PCRIndex;
+  TCG_EVENTTYPE       EventType;
+  TPML_DIGEST_VALUES  Digest;
+  UINT32              EventSize;
+  UINT8               Event[1];
+} TCG_PCR_EVENT2;
+
+//
+// TCG PCR Event2 Header
+// Follow TCG EFI Protocol Spec 5.2 Crypto Agile Log Entry Format
+//
+typedef struct tdTCG_PCR_EVENT2_HDR{
+  TCG_PCRINDEX        PCRIndex;
+  TCG_EVENTTYPE       EventType;
+  TPML_DIGEST_VALUES  Digests;
+  UINT32              EventSize;
+} TCG_PCR_EVENT2_HDR;
+
+//
+// Log Header Entry Data
+//
+typedef struct {
+  //
+  // TCG defined hashing algorithm ID.
+  //
+  UINT16              algorithmId;
+  //
+  // The size of the digest for the respective hashing algorithm.
+  //
+  UINT16              digestSize;
+} TCG_EfiSpecIdEventAlgorithmSize;
+
+#define TCG_EfiSpecIDEventStruct_SIGNATURE_02 "Spec ID Event02"
+#define TCG_EfiSpecIDEventStruct_SIGNATURE_03 "Spec ID Event03"
+
+#define TCG_EfiSpecIDEventStruct_SPEC_VERSION_MAJOR_TPM12   1
+#define TCG_EfiSpecIDEventStruct_SPEC_VERSION_MINOR_TPM12   2
+#define TCG_EfiSpecIDEventStruct_SPEC_ERRATA_TPM12          2
+
+#define TCG_EfiSpecIDEventStruct_SPEC_VERSION_MAJOR_TPM2   2
+#define TCG_EfiSpecIDEventStruct_SPEC_VERSION_MINOR_TPM2   0
+#define TCG_EfiSpecIDEventStruct_SPEC_ERRATA_TPM2          0
+#define TCG_EfiSpecIDEventStruct_SPEC_ERRATA_TPM2_REV_105  105
+
+typedef struct {
+  UINT8               signature[16];
+  //
+  // The value for the Platform Class.
+  // The enumeration is defined in the TCG ACPI Specification Client Common Header.
+  //
+  UINT32              platformClass;
+  //
+  // The TCG EFI Platform Specification minor version number this BIOS supports.
+  // Any BIOS supporting version (1.22) MUST set this value to 02h.
+  // Any BIOS supporting version (2.0) SHALL set this value to 0x00.
+  //
+  UINT8               specVersionMinor;
+  //
+  // The TCG EFI Platform Specification major version number this BIOS supports.
+  // Any BIOS supporting version (1.22) MUST set this value to 01h.
+  // Any BIOS supporting version (2.0) SHALL set this value to 0x02.
+  //
+  UINT8               specVersionMajor;
+  //
+  // The TCG EFI Platform Specification errata for this specification this BIOS supports.
+  // Any BIOS supporting version and errata (1.22) MUST set this value to 02h.
+  // Any BIOS supporting version and errata (2.0) SHALL set this value to 0x00.
+  //
+  UINT8               specErrata;
+  //
+  // Specifies the size of the UINTN fields used in various data structures used in this specification.
+  // 0x01 indicates UINT32 and 0x02 indicates UINT64.
+  //
+  UINT8               uintnSize;
+  //
+  // This field is added in "Spec ID Event03".
+  // The number of hashing algorithms used in this event log (except the first event).
+  // All events in this event log use all hashing algorithms defined here.
+  //
+//UINT32              numberOfAlgorithms;
+  //
+  // This field is added in "Spec ID Event03".
+  // An array of size numberOfAlgorithms of value pairs.
+  //
+//TCG_EfiSpecIdEventAlgorithmSize digestSize[numberOfAlgorithms];
+  //
+  // Size in bytes of the VendorInfo field.
+  // Maximum value SHALL be FFh bytes.
+  //
+//UINT8               vendorInfoSize;
+  //
+  // Provided for use by the BIOS implementer.
+  // The value might be used, for example, to provide more detailed information about the specific BIOS such as BIOS revision numbers, etc.
+  // The values within this field are not standardized and are implementer-specific.
+  // Platform-specific or -unique information SHALL NOT be provided in this field.
+  //
+//UINT8               vendorInfo[vendorInfoSize];
+} TCG_EfiSpecIDEventStruct;
+
+typedef struct tdTCG_PCClientTaggedEvent {
+  UINT32              taggedEventID;
+  UINT32              taggedEventDataSize;
+//UINT8               taggedEventData[taggedEventDataSize];
+} TCG_PCClientTaggedEvent;
+
+#define TCG_Sp800_155_PlatformId_Event_SIGNATURE  "SP800-155 Event"
+#define TCG_Sp800_155_PlatformId_Event2_SIGNATURE "SP800-155 Event2"
+
+typedef struct tdTCG_Sp800_155_PlatformId_Event2 {
+  UINT8               Signature[16];
+  //
+  // Where Vendor ID is an integer defined
+  // at http://www.iana.org/assignments/enterprisenumbers
+  //
+  UINT32              VendorId;
+  //
+  // 16-byte identifier of a given platform's static configuration of code
+  //
+  EFI_GUID            ReferenceManifestGuid;
+  //
+  // Below structure is newly added in TCG_Sp800_155_PlatformId_Event2.
+  //
+//UINT8               PlatformManufacturerStrSize;
+//UINT8               PlatformManufacturerStr[PlatformManufacturerStrSize];
+//UINT8               PlatformModelSize;
+//UINT8               PlatformModel[PlatformModelSize];
+//UINT8               PlatformVersionSize;
+//UINT8               PlatformVersion[PlatformVersionSize];
+//UINT8               PlatformModelSize;
+//UINT8               PlatformModel[PlatformModelSize];
+//UINT8               FirmwareManufacturerStrSize;
+//UINT8               FirmwareManufacturerStr[FirmwareManufacturerStrSize];
+//UINT32              FirmwareManufacturerId;
+//UINT8               FirmwareVersion;
+//UINT8               FirmwareVersion[FirmwareVersionSize]];
+} TCG_Sp800_155_PlatformId_Event2;
+
+#define TCG_EfiStartupLocalityEvent_SIGNATURE      "StartupLocality"
+
+
+//
+// The Locality Indicator which sent the TPM2_Startup command
+//
+#define LOCALITY_0_INDICATOR        0x00
+#define LOCALITY_3_INDICATOR        0x03
+
+//
+// Startup Locality Event
+//
+typedef struct tdTCG_EfiStartupLocalityEvent{
+  UINT8       Signature[16];
+  //
+  // The Locality Indicator which sent the TPM2_Startup command
+  //
+  UINT8       StartupLocality;
+} TCG_EfiStartupLocalityEvent;
+
+
+//
+// Restore original structure alignment
+//
+#pragma pack ()
+
+#endif
diff --git a/libedk2_tpm/include/IndustryStandard/Usb.h b/libedk2_tpm/include/IndustryStandard/Usb.h
new file mode 100644
index 0000000..e7c02e5
--- /dev/null
+++ b/libedk2_tpm/include/IndustryStandard/Usb.h
@@ -0,0 +1,380 @@
+/** @file
+  Support for USB 2.0 standard.
+
+  Copyright (c) 2006 - 2014, Intel Corporation. All rights reserved.<BR>
+  SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __USB_H__
+#define __USB_H__
+
+//
+// Subset of Class and Subclass definitions from USB Specs
+//
+
+//
+// Usb mass storage class code
+//
+#define USB_MASS_STORE_CLASS    0x08
+
+//
+// Usb mass storage subclass code, specify the command set used.
+//
+#define USB_MASS_STORE_RBC      0x01 ///< Reduced Block Commands
+#define USB_MASS_STORE_8020I    0x02 ///< SFF-8020i, typically a CD/DVD device
+#define USB_MASS_STORE_QIC      0x03 ///< Typically a tape device
+#define USB_MASS_STORE_UFI      0x04 ///< Typically a floppy disk driver device
+#define USB_MASS_STORE_8070I    0x05 ///< SFF-8070i, typically a floppy disk driver device.
+#define USB_MASS_STORE_SCSI     0x06 ///< SCSI transparent command set
+
+//
+// Usb mass storage protocol code, specify the transport protocol
+//
+#define USB_MASS_STORE_CBI0     0x00 ///< CBI protocol with command completion interrupt
+#define USB_MASS_STORE_CBI1     0x01 ///< CBI protocol without command completion interrupt
+#define USB_MASS_STORE_BOT      0x50 ///< Bulk-Only Transport
+
+//
+// Standard device request and request type
+// USB 2.0 spec, Section 9.4
+//
+#define USB_DEV_GET_STATUS                  0x00
+#define USB_DEV_GET_STATUS_REQ_TYPE_D       0x80 // Receiver : Device
+#define USB_DEV_GET_STATUS_REQ_TYPE_I       0x81 // Receiver : Interface
+#define USB_DEV_GET_STATUS_REQ_TYPE_E       0x82 // Receiver : Endpoint
+
+#define USB_DEV_CLEAR_FEATURE               0x01
+#define USB_DEV_CLEAR_FEATURE_REQ_TYPE_D    0x00 // Receiver : Device
+#define USB_DEV_CLEAR_FEATURE_REQ_TYPE_I    0x01 // Receiver : Interface
+#define USB_DEV_CLEAR_FEATURE_REQ_TYPE_E    0x02 // Receiver : Endpoint
+
+#define USB_DEV_SET_FEATURE                 0x03
+#define USB_DEV_SET_FEATURE_REQ_TYPE_D      0x00 // Receiver : Device
+#define USB_DEV_SET_FEATURE_REQ_TYPE_I      0x01 // Receiver : Interface
+#define USB_DEV_SET_FEATURE_REQ_TYPE_E      0x02 // Receiver : Endpoint
+
+#define USB_DEV_SET_ADDRESS                 0x05
+#define USB_DEV_SET_ADDRESS_REQ_TYPE        0x00
+
+#define USB_DEV_GET_DESCRIPTOR              0x06
+#define USB_DEV_GET_DESCRIPTOR_REQ_TYPE     0x80
+
+#define USB_DEV_SET_DESCRIPTOR              0x07
+#define USB_DEV_SET_DESCRIPTOR_REQ_TYPE     0x00
+
+#define USB_DEV_GET_CONFIGURATION           0x08
+#define USB_DEV_GET_CONFIGURATION_REQ_TYPE  0x80
+
+#define USB_DEV_SET_CONFIGURATION           0x09
+#define USB_DEV_SET_CONFIGURATION_REQ_TYPE  0x00
+
+#define USB_DEV_GET_INTERFACE               0x0A
+#define USB_DEV_GET_INTERFACE_REQ_TYPE      0x81
+
+#define USB_DEV_SET_INTERFACE               0x0B
+#define USB_DEV_SET_INTERFACE_REQ_TYPE      0x01
+
+#define USB_DEV_SYNCH_FRAME                 0x0C
+#define USB_DEV_SYNCH_FRAME_REQ_TYPE        0x82
+
+
+//
+// USB standard descriptors and reqeust
+//
+#pragma pack(1)
+
+///
+/// Format of Setup Data for USB Device Requests
+/// USB 2.0 spec, Section 9.3
+///
+typedef struct {
+  UINT8           RequestType;
+  UINT8           Request;
+  UINT16          Value;
+  UINT16          Index;
+  UINT16          Length;
+} USB_DEVICE_REQUEST;
+
+///
+/// Standard Device Descriptor
+/// USB 2.0 spec, Section 9.6.1
+///
+typedef struct {
+  UINT8           Length;
+  UINT8           DescriptorType;
+  UINT16          BcdUSB;
+  UINT8           DeviceClass;
+  UINT8           DeviceSubClass;
+  UINT8           DeviceProtocol;
+  UINT8           MaxPacketSize0;
+  UINT16          IdVendor;
+  UINT16          IdProduct;
+  UINT16          BcdDevice;
+  UINT8           StrManufacturer;
+  UINT8           StrProduct;
+  UINT8           StrSerialNumber;
+  UINT8           NumConfigurations;
+} USB_DEVICE_DESCRIPTOR;
+
+///
+/// Standard Configuration Descriptor
+/// USB 2.0 spec, Section 9.6.3
+///
+typedef struct {
+  UINT8           Length;
+  UINT8           DescriptorType;
+  UINT16          TotalLength;
+  UINT8           NumInterfaces;
+  UINT8           ConfigurationValue;
+  UINT8           Configuration;
+  UINT8           Attributes;
+  UINT8           MaxPower;
+} USB_CONFIG_DESCRIPTOR;
+
+///
+/// Standard Interface Descriptor
+/// USB 2.0 spec, Section 9.6.5
+///
+typedef struct {
+  UINT8           Length;
+  UINT8           DescriptorType;
+  UINT8           InterfaceNumber;
+  UINT8           AlternateSetting;
+  UINT8           NumEndpoints;
+  UINT8           InterfaceClass;
+  UINT8           InterfaceSubClass;
+  UINT8           InterfaceProtocol;
+  UINT8           Interface;
+} USB_INTERFACE_DESCRIPTOR;
+
+///
+/// Standard Endpoint Descriptor
+/// USB 2.0 spec, Section 9.6.6
+///
+typedef struct {
+  UINT8           Length;
+  UINT8           DescriptorType;
+  UINT8           EndpointAddress;
+  UINT8           Attributes;
+  UINT16          MaxPacketSize;
+  UINT8           Interval;
+} USB_ENDPOINT_DESCRIPTOR;
+
+///
+/// UNICODE String Descriptor
+/// USB 2.0 spec, Section 9.6.7
+///
+typedef struct {
+  UINT8           Length;
+  UINT8           DescriptorType;
+  CHAR16          String[1];
+} EFI_USB_STRING_DESCRIPTOR;
+
+#pragma pack()
+
+
+typedef enum {
+  //
+  // USB request type
+  //
+  USB_REQ_TYPE_STANDARD   = (0x00 << 5),
+  USB_REQ_TYPE_CLASS      = (0x01 << 5),
+  USB_REQ_TYPE_VENDOR     = (0x02 << 5),
+
+  //
+  // Standard control transfer request type, or the value
+  // to fill in EFI_USB_DEVICE_REQUEST.Request
+  //
+  USB_REQ_GET_STATUS      = 0x00,
+  USB_REQ_CLEAR_FEATURE   = 0x01,
+  USB_REQ_SET_FEATURE     = 0x03,
+  USB_REQ_SET_ADDRESS     = 0x05,
+  USB_REQ_GET_DESCRIPTOR  = 0x06,
+  USB_REQ_SET_DESCRIPTOR  = 0x07,
+  USB_REQ_GET_CONFIG      = 0x08,
+  USB_REQ_SET_CONFIG      = 0x09,
+  USB_REQ_GET_INTERFACE   = 0x0A,
+  USB_REQ_SET_INTERFACE   = 0x0B,
+  USB_REQ_SYNCH_FRAME     = 0x0C,
+
+  //
+  // Usb control transfer target
+  //
+  USB_TARGET_DEVICE       = 0,
+  USB_TARGET_INTERFACE    = 0x01,
+  USB_TARGET_ENDPOINT     = 0x02,
+  USB_TARGET_OTHER        = 0x03,
+
+  //
+  // USB Descriptor types
+  //
+  USB_DESC_TYPE_DEVICE    = 0x01,
+  USB_DESC_TYPE_CONFIG    = 0x02,
+  USB_DESC_TYPE_STRING    = 0x03,
+  USB_DESC_TYPE_INTERFACE = 0x04,
+  USB_DESC_TYPE_ENDPOINT  = 0x05,
+  USB_DESC_TYPE_HID       = 0x21,
+  USB_DESC_TYPE_REPORT    = 0x22,
+
+  //
+  // Features to be cleared by CLEAR_FEATURE requests
+  //
+  USB_FEATURE_ENDPOINT_HALT = 0,
+
+  //
+  // USB endpoint types: 00: control, 01: isochronous, 10: bulk, 11: interrupt
+  //
+  USB_ENDPOINT_CONTROL    = 0x00,
+  USB_ENDPOINT_ISO        = 0x01,
+  USB_ENDPOINT_BULK       = 0x02,
+  USB_ENDPOINT_INTERRUPT  = 0x03,
+
+  USB_ENDPOINT_TYPE_MASK  = 0x03,
+  USB_ENDPOINT_DIR_IN     = 0x80,
+
+  //
+  //Use 200 ms to increase the error handling response time
+  //
+  EFI_USB_INTERRUPT_DELAY = 2000000
+} USB_TYPES_DEFINITION;
+
+
+//
+// HID constants definition, see Device Class Definition
+// for Human Interface Devices (HID) rev1.11
+//
+
+//
+// HID standard GET_DESCRIPTOR request.
+//
+#define USB_HID_GET_DESCRIPTOR_REQ_TYPE  0x81
+
+//
+// HID specific requests.
+//
+#define USB_HID_CLASS_GET_REQ_TYPE       0xa1
+#define USB_HID_CLASS_SET_REQ_TYPE       0x21
+
+//
+// HID report item format
+//
+#define HID_ITEM_FORMAT_SHORT 0
+#define HID_ITEM_FORMAT_LONG  1
+
+//
+// Special tag indicating long items
+//
+#define HID_ITEM_TAG_LONG 15
+
+//
+// HID report descriptor item type (prefix bit 2,3)
+//
+#define HID_ITEM_TYPE_MAIN      0
+#define HID_ITEM_TYPE_GLOBAL    1
+#define HID_ITEM_TYPE_LOCAL     2
+#define HID_ITEM_TYPE_RESERVED  3
+
+//
+// HID report descriptor main item tags
+//
+#define HID_MAIN_ITEM_TAG_INPUT             8
+#define HID_MAIN_ITEM_TAG_OUTPUT            9
+#define HID_MAIN_ITEM_TAG_FEATURE           11
+#define HID_MAIN_ITEM_TAG_BEGIN_COLLECTION  10
+#define HID_MAIN_ITEM_TAG_END_COLLECTION    12
+
+//
+// HID report descriptor main item contents
+//
+#define HID_MAIN_ITEM_CONSTANT      0x001
+#define HID_MAIN_ITEM_VARIABLE      0x002
+#define HID_MAIN_ITEM_RELATIVE      0x004
+#define HID_MAIN_ITEM_WRAP          0x008
+#define HID_MAIN_ITEM_NONLINEAR     0x010
+#define HID_MAIN_ITEM_NO_PREFERRED  0x020
+#define HID_MAIN_ITEM_NULL_STATE    0x040
+#define HID_MAIN_ITEM_VOLATILE      0x080
+#define HID_MAIN_ITEM_BUFFERED_BYTE 0x100
+
+//
+// HID report descriptor collection item types
+//
+#define HID_COLLECTION_PHYSICAL     0
+#define HID_COLLECTION_APPLICATION  1
+#define HID_COLLECTION_LOGICAL      2
+
+//
+// HID report descriptor global item tags
+//
+#define HID_GLOBAL_ITEM_TAG_USAGE_PAGE        0
+#define HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM   1
+#define HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM   2
+#define HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM  3
+#define HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM  4
+#define HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT     5
+#define HID_GLOBAL_ITEM_TAG_UNIT              6
+#define HID_GLOBAL_ITEM_TAG_REPORT_SIZE       7
+#define HID_GLOBAL_ITEM_TAG_REPORT_ID         8
+#define HID_GLOBAL_ITEM_TAG_REPORT_COUNT      9
+#define HID_GLOBAL_ITEM_TAG_PUSH              10
+#define HID_GLOBAL_ITEM_TAG_POP               11
+
+//
+// HID report descriptor local item tags
+//
+#define HID_LOCAL_ITEM_TAG_USAGE              0
+#define HID_LOCAL_ITEM_TAG_USAGE_MINIMUM      1
+#define HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM      2
+#define HID_LOCAL_ITEM_TAG_DESIGNATOR_INDEX   3
+#define HID_LOCAL_ITEM_TAG_DESIGNATOR_MINIMUM 4
+#define HID_LOCAL_ITEM_TAG_DESIGNATOR_MAXIMUM 5
+#define HID_LOCAL_ITEM_TAG_STRING_INDEX       7
+#define HID_LOCAL_ITEM_TAG_STRING_MINIMUM     8
+#define HID_LOCAL_ITEM_TAG_STRING_MAXIMUM     9
+#define HID_LOCAL_ITEM_TAG_DELIMITER          10
+
+//
+// HID report types
+//
+#define HID_INPUT_REPORT    1
+#define HID_OUTPUT_REPORT   2
+#define HID_FEATURE_REPORT  3
+
+//
+// HID class protocol request
+//
+#define EFI_USB_GET_REPORT_REQUEST    0x01
+#define EFI_USB_GET_IDLE_REQUEST      0x02
+#define EFI_USB_GET_PROTOCOL_REQUEST  0x03
+#define EFI_USB_SET_REPORT_REQUEST    0x09
+#define EFI_USB_SET_IDLE_REQUEST      0x0a
+#define EFI_USB_SET_PROTOCOL_REQUEST  0x0b
+
+#pragma pack(1)
+///
+/// Descriptor header for Report/Physical Descriptors
+/// HID 1.1, section 6.2.1
+///
+typedef struct hid_class_descriptor {
+  UINT8   DescriptorType;
+  UINT16  DescriptorLength;
+} EFI_USB_HID_CLASS_DESCRIPTOR;
+
+///
+/// The HID descriptor identifies the length and type
+/// of subordinate descriptors for a device.
+/// HID 1.1, section 6.2.1
+///
+typedef struct hid_descriptor {
+  UINT8                         Length;
+  UINT8                         DescriptorType;
+  UINT16                        BcdHID;
+  UINT8                         CountryCode;
+  UINT8                         NumDescriptors;
+  EFI_USB_HID_CLASS_DESCRIPTOR  HidClassDesc[1];
+} EFI_USB_HID_DESCRIPTOR;
+
+#pragma pack()
+
+#endif
diff --git a/libedk2_tpm/include/IoLib.h b/libedk2_tpm/include/IoLib.h
new file mode 100644
index 0000000..f2e6bbc
--- /dev/null
+++ b/libedk2_tpm/include/IoLib.h
@@ -0,0 +1,2808 @@
+/** @file
+  Provide services to access I/O Ports and MMIO registers.
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+Copyright (c) 2017, AMD Incorporated. All rights reserved.<BR>
+
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __IO_LIB_H__
+#define __IO_LIB_H__
+
+/**
+  Macro that converts PCI Segment and I/O Port to an address that can be
+  passed to the I/O Library functions.
+
+  Computes an address that is compatible with the I/O Library functions.
+  The unused upper bits of Segment, and Port are stripped prior to the
+  generation of the address.
+
+  @param  Segment   PCI Segment number.  Range 0..65535.
+  @param  Port      I/O Port number.  Range 0..65535.
+
+  @return An address that the I/o Library functions need.
+
+**/
+
+#define IO_LIB_ADDRESS(Segment,Port) \
+  ( ((Port) & 0xffff) | (((Segment) & 0xffff) << 16) )
+
+/**
+  Reads an 8-bit I/O port.
+
+  Reads the 8-bit I/O port specified by Port. The 8-bit read value is returned.
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port  The I/O port to read.
+
+  @return The value read.
+
+**/
+UINT8
+EFIAPI
+IoRead8 (
+  IN      UINTN                     Port
+  );
+
+/**
+  Writes an 8-bit I/O port.
+
+  Writes the 8-bit I/O port specified by Port with the value specified by Value
+  and returns Value. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port  The I/O port to write.
+  @param  Value The value to write to the I/O port.
+
+  @return The value written the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoWrite8 (
+  IN      UINTN                     Port,
+  IN      UINT8                     Value
+  );
+
+/**
+  Reads an 8-bit I/O port fifo into a block of memory.
+
+  Reads the 8-bit I/O fifo port specified by Port.
+  The port is read Count times, and the read data is
+  stored in the provided Buffer.
+
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to read.
+  @param  Count   The number of times to read I/O port.
+  @param  Buffer  The buffer to store the read data into.
+
+**/
+VOID
+EFIAPI
+IoReadFifo8 (
+  IN      UINTN                     Port,
+  IN      UINTN                     Count,
+  OUT     VOID                      *Buffer
+  );
+
+/**
+  Writes a block of memory into an 8-bit I/O port fifo.
+
+  Writes the 8-bit I/O fifo port specified by Port.
+  The port is written Count times, and the write data is
+  retrieved from the provided Buffer.
+
+  This function must guarantee that all I/O write and write operations are
+  serialized.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  Count   The number of times to write I/O port.
+  @param  Buffer  The buffer to retrieve the write data from.
+
+**/
+VOID
+EFIAPI
+IoWriteFifo8 (
+  IN      UINTN                     Port,
+  IN      UINTN                     Count,
+  IN      VOID                      *Buffer
+  );
+
+/**
+  Reads an 8-bit I/O port, performs a bitwise OR, and writes the
+  result back to the 8-bit I/O port.
+
+  Reads the 8-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 8-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  OrData  The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoOr8 (
+  IN      UINTN                     Port,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads an 8-bit I/O port, performs a bitwise AND, and writes the result back
+  to the 8-bit I/O port.
+
+  Reads the 8-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 8-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoAnd8 (
+  IN      UINTN                     Port,
+  IN      UINT8                     AndData
+  );
+
+/**
+  Reads an 8-bit I/O port, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 8-bit I/O port.
+
+  Reads the 8-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, performs a bitwise OR
+  between the result of the AND operation and the value specified by OrData,
+  and writes the result to the 8-bit I/O port specified by Port. The value
+  written to the I/O port is returned. This function must guarantee that all
+  I/O read and write operations are serialized.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoAndThenOr8 (
+  IN      UINTN                     Port,
+  IN      UINT8                     AndData,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads a bit field of an I/O register.
+
+  Reads the bit field in an 8-bit I/O register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Port      The I/O port to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+
+  @return The value read.
+
+**/
+UINT8
+EFIAPI
+IoBitFieldRead8 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to an I/O register.
+
+  Writes Value to the bit field of the I/O register. The bit field is specified
+  by the StartBit and the EndBit. All other bits in the destination I/O
+  register are preserved. The value written to the I/O port is returned.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoBitFieldWrite8 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     Value
+  );
+
+/**
+  Reads a bit field in an 8-bit port, performs a bitwise OR, and writes the
+  result back to the bit field in the 8-bit port.
+
+  Reads the 8-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 8-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized. Extra left bits in OrData are stripped.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  OrData    The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoBitFieldOr8 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads a bit field in an 8-bit port, performs a bitwise AND, and writes the
+  result back to the bit field in the 8-bit port.
+
+  Reads the 8-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 8-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized. Extra left bits in AndData are stripped.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoBitFieldAnd8 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData
+  );
+
+/**
+  Reads a bit field in an 8-bit port, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  8-bit port.
+
+  Reads the 8-bit I/O port specified by Port, performs a bitwise AND followed
+  by a bitwise OR between the read result and the value specified by
+  AndData, and writes the result to the 8-bit I/O port specified by Port. The
+  value written to the I/O port is returned. This function must guarantee that
+  all I/O read and write operations are serialized. Extra left bits in both
+  AndData and OrData are stripped.
+
+  If 8-bit I/O port operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with the read value from the I/O port.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT8
+EFIAPI
+IoBitFieldAndThenOr8 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads a 16-bit I/O port.
+
+  Reads the 16-bit I/O port specified by Port. The 16-bit read value is returned.
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to read.
+
+  @return The value read.
+
+**/
+UINT16
+EFIAPI
+IoRead16 (
+  IN      UINTN                     Port
+  );
+
+/**
+  Writes a 16-bit I/O port.
+
+  Writes the 16-bit I/O port specified by Port with the value specified by Value
+  and returns Value. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to write.
+  @param  Value The value to write to the I/O port.
+
+  @return The value written the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoWrite16 (
+  IN      UINTN                     Port,
+  IN      UINT16                    Value
+  );
+
+/**
+  Reads a 16-bit I/O port fifo into a block of memory.
+
+  Reads the 16-bit I/O fifo port specified by Port.
+  The port is read Count times, and the read data is
+  stored in the provided Buffer.
+
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to read.
+  @param  Count   The number of times to read I/O port.
+  @param  Buffer  The buffer to store the read data into.
+
+**/
+VOID
+EFIAPI
+IoReadFifo16 (
+  IN      UINTN                     Port,
+  IN      UINTN                     Count,
+  OUT     VOID                      *Buffer
+  );
+
+/**
+  Writes a block of memory into a 16-bit I/O port fifo.
+
+  Writes the 16-bit I/O fifo port specified by Port.
+  The port is written Count times, and the write data is
+  retrieved from the provided Buffer.
+
+  This function must guarantee that all I/O write and write operations are
+  serialized.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  Count   The number of times to write I/O port.
+  @param  Buffer  The buffer to retrieve the write data from.
+
+**/
+VOID
+EFIAPI
+IoWriteFifo16 (
+  IN      UINTN                     Port,
+  IN      UINTN                     Count,
+  IN      VOID                      *Buffer
+  );
+
+/**
+  Reads a 16-bit I/O port, performs a bitwise OR, and writes the
+  result back to the 16-bit I/O port.
+
+  Reads the 16-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 16-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  OrData  The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoOr16 (
+  IN      UINTN                     Port,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a 16-bit I/O port, performs a bitwise AND, and writes the result back
+  to the 16-bit I/O port.
+
+  Reads the 16-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 16-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoAnd16 (
+  IN      UINTN                     Port,
+  IN      UINT16                    AndData
+  );
+
+/**
+  Reads a 16-bit I/O port, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 16-bit I/O port.
+
+  Reads the 16-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, performs a bitwise OR
+  between the result of the AND operation and the value specified by OrData,
+  and writes the result to the 16-bit I/O port specified by Port. The value
+  written to the I/O port is returned. This function must guarantee that all
+  I/O read and write operations are serialized.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoAndThenOr16 (
+  IN      UINTN                     Port,
+  IN      UINT16                    AndData,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a bit field of an I/O register.
+
+  Reads the bit field in a 16-bit I/O register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Port      The I/O port to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+
+  @return The value read.
+
+**/
+UINT16
+EFIAPI
+IoBitFieldRead16 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to an I/O register.
+
+  Writes Value to the bit field of the I/O register. The bit field is specified
+  by the StartBit and the EndBit. All other bits in the destination I/O
+  register are preserved. The value written to the I/O port is returned. Extra
+  left bits in Value are stripped.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoBitFieldWrite16 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    Value
+  );
+
+/**
+  Reads a bit field in a 16-bit port, performs a bitwise OR, and writes the
+  result back to the bit field in the 16-bit port.
+
+  Reads the 16-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 16-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized. Extra left bits in OrData are stripped.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  OrData    The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoBitFieldOr16 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a bit field in a 16-bit port, performs a bitwise AND, and writes the
+  result back to the bit field in the 16-bit port.
+
+  Reads the 16-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 16-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized. Extra left bits in AndData are stripped.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoBitFieldAnd16 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData
+  );
+
+/**
+  Reads a bit field in a 16-bit port, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  16-bit port.
+
+  Reads the 16-bit I/O port specified by Port, performs a bitwise AND followed
+  by a bitwise OR between the read result and the value specified by
+  AndData, and writes the result to the 16-bit I/O port specified by Port. The
+  value written to the I/O port is returned. This function must guarantee that
+  all I/O read and write operations are serialized. Extra left bits in both
+  AndData and OrData are stripped.
+
+  If 16-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with the read value from the I/O port.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT16
+EFIAPI
+IoBitFieldAndThenOr16 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a 32-bit I/O port.
+
+  Reads the 32-bit I/O port specified by Port. The 32-bit read value is returned.
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to read.
+
+  @return The value read.
+
+**/
+UINT32
+EFIAPI
+IoRead32 (
+  IN      UINTN                     Port
+  );
+
+/**
+  Writes a 32-bit I/O port.
+
+  Writes the 32-bit I/O port specified by Port with the value specified by Value
+  and returns Value. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to write.
+  @param  Value The value to write to the I/O port.
+
+  @return The value written the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoWrite32 (
+  IN      UINTN                     Port,
+  IN      UINT32                    Value
+  );
+
+/**
+  Reads a 32-bit I/O port fifo into a block of memory.
+
+  Reads the 32-bit I/O fifo port specified by Port.
+  The port is read Count times, and the read data is
+  stored in the provided Buffer.
+
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to read.
+  @param  Count   The number of times to read I/O port.
+  @param  Buffer  The buffer to store the read data into.
+
+**/
+VOID
+EFIAPI
+IoReadFifo32 (
+  IN      UINTN                     Port,
+  IN      UINTN                     Count,
+  OUT     VOID                      *Buffer
+  );
+
+/**
+  Writes a block of memory into a 32-bit I/O port fifo.
+
+  Writes the 32-bit I/O fifo port specified by Port.
+  The port is written Count times, and the write data is
+  retrieved from the provided Buffer.
+
+  This function must guarantee that all I/O write and write operations are
+  serialized.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  Count   The number of times to write I/O port.
+  @param  Buffer  The buffer to retrieve the write data from.
+
+**/
+VOID
+EFIAPI
+IoWriteFifo32 (
+  IN      UINTN                     Port,
+  IN      UINTN                     Count,
+  IN      VOID                      *Buffer
+  );
+
+/**
+  Reads a 32-bit I/O port, performs a bitwise OR, and writes the
+  result back to the 32-bit I/O port.
+
+  Reads the 32-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 32-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  OrData  The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoOr32 (
+  IN      UINTN                     Port,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a 32-bit I/O port, performs a bitwise AND, and writes the result back
+  to the 32-bit I/O port.
+
+  Reads the 32-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 32-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoAnd32 (
+  IN      UINTN                     Port,
+  IN      UINT32                    AndData
+  );
+
+/**
+  Reads a 32-bit I/O port, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 32-bit I/O port.
+
+  Reads the 32-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, performs a bitwise OR
+  between the result of the AND operation and the value specified by OrData,
+  and writes the result to the 32-bit I/O port specified by Port. The value
+  written to the I/O port is returned. This function must guarantee that all
+  I/O read and write operations are serialized.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoAndThenOr32 (
+  IN      UINTN                     Port,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a bit field of an I/O register.
+
+  Reads the bit field in a 32-bit I/O register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Port      The I/O port to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+
+  @return The value read.
+
+**/
+UINT32
+EFIAPI
+IoBitFieldRead32 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to an I/O register.
+
+  Writes Value to the bit field of the I/O register. The bit field is specified
+  by the StartBit and the EndBit. All other bits in the destination I/O
+  register are preserved. The value written to the I/O port is returned. Extra
+  left bits in Value are stripped.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoBitFieldWrite32 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    Value
+  );
+
+/**
+  Reads a bit field in a 32-bit port, performs a bitwise OR, and writes the
+  result back to the bit field in the 32-bit port.
+
+  Reads the 32-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 32-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized. Extra left bits in OrData are stripped.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  OrData    The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoBitFieldOr32 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a bit field in a 32-bit port, performs a bitwise AND, and writes the
+  result back to the bit field in the 32-bit port.
+
+  Reads the 32-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 32-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized. Extra left bits in AndData are stripped.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoBitFieldAnd32 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData
+  );
+
+/**
+  Reads a bit field in a 32-bit port, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  32-bit port.
+
+  Reads the 32-bit I/O port specified by Port, performs a bitwise AND followed
+  by a bitwise OR between the read result and the value specified by
+  AndData, and writes the result to the 32-bit I/O port specified by Port. The
+  value written to the I/O port is returned. This function must guarantee that
+  all I/O read and write operations are serialized. Extra left bits in both
+  AndData and OrData are stripped.
+
+  If 32-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with the read value from the I/O port.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT32
+EFIAPI
+IoBitFieldAndThenOr32 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a 64-bit I/O port.
+
+  Reads the 64-bit I/O port specified by Port. The 64-bit read value is returned.
+  This function must guarantee that all I/O read and write operations are
+  serialized.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to read.
+
+  @return The value read.
+
+**/
+UINT64
+EFIAPI
+IoRead64 (
+  IN      UINTN                     Port
+  );
+
+/**
+  Writes a 64-bit I/O port.
+
+  Writes the 64-bit I/O port specified by Port with the value specified by Value
+  and returns Value. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Port  The I/O port to write.
+  @param  Value The value to write to the I/O port.
+
+  @return The value written the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoWrite64 (
+  IN      UINTN                     Port,
+  IN      UINT64                    Value
+  );
+
+/**
+  Reads a 64-bit I/O port, performs a bitwise OR, and writes the
+  result back to the 64-bit I/O port.
+
+  Reads the 64-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 64-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  OrData  The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoOr64 (
+  IN      UINTN                     Port,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads a 64-bit I/O port, performs a bitwise AND, and writes the result back
+  to the 64-bit I/O port.
+
+  Reads the 64-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 64-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoAnd64 (
+  IN      UINTN                     Port,
+  IN      UINT64                    AndData
+  );
+
+/**
+  Reads a 64-bit I/O port, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 64-bit I/O port.
+
+  Reads the 64-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, performs a bitwise OR
+  between the result of the AND operation and the value specified by OrData,
+  and writes the result to the 64-bit I/O port specified by Port. The value
+  written to the I/O port is returned. This function must guarantee that all
+  I/O read and write operations are serialized.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Port    The I/O port to write.
+  @param  AndData The value to AND with the read value from the I/O port.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoAndThenOr64 (
+  IN      UINTN                     Port,
+  IN      UINT64                    AndData,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads a bit field of an I/O register.
+
+  Reads the bit field in a 64-bit I/O register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Port      The I/O port to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+
+  @return The value read.
+
+**/
+UINT64
+EFIAPI
+IoBitFieldRead64 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to an I/O register.
+
+  Writes Value to the bit field of the I/O register. The bit field is specified
+  by the StartBit and the EndBit. All other bits in the destination I/O
+  register are preserved. The value written to the I/O port is returned. Extra
+  left bits in Value are stripped.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoBitFieldWrite64 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    Value
+  );
+
+/**
+  Reads a bit field in a 64-bit port, performs a bitwise OR, and writes the
+  result back to the bit field in the 64-bit port.
+
+  Reads the 64-bit I/O port specified by Port, performs a bitwise OR
+  between the read result and the value specified by OrData, and writes the
+  result to the 64-bit I/O port specified by Port. The value written to the I/O
+  port is returned. This function must guarantee that all I/O read and write
+  operations are serialized. Extra left bits in OrData are stripped.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  OrData    The value to OR with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoBitFieldOr64 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads a bit field in a 64-bit port, performs a bitwise AND, and writes the
+  result back to the bit field in the 64-bit port.
+
+  Reads the 64-bit I/O port specified by Port, performs a bitwise AND between
+  the read result and the value specified by AndData, and writes the result to
+  the 64-bit I/O port specified by Port. The value written to the I/O port is
+  returned. This function must guarantee that all I/O read and write operations
+  are serialized. Extra left bits in AndData are stripped.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with the read value from the I/O port.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoBitFieldAnd64 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData
+  );
+
+/**
+  Reads a bit field in a 64-bit port, performs a bitwise AND followed by a
+  bitwise OR, and writes the result back to the bit field in the
+  64-bit port.
+
+  Reads the 64-bit I/O port specified by Port, performs a bitwise AND followed
+  by a bitwise OR between the read result and the value specified by
+  AndData, and writes the result to the 64-bit I/O port specified by Port. The
+  value written to the I/O port is returned. This function must guarantee that
+  all I/O read and write operations are serialized. Extra left bits in both
+  AndData and OrData are stripped.
+
+  If 64-bit I/O port operations are not supported, then ASSERT().
+  If Port is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Port      The I/O port to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with the read value from the I/O port.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the I/O port.
+
+**/
+UINT64
+EFIAPI
+IoBitFieldAndThenOr64 (
+  IN      UINTN                     Port,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads an 8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address. The 8-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT8
+EFIAPI
+MmioRead8 (
+  IN      UINTN                     Address
+  );
+
+/**
+  Writes an 8-bit MMIO register.
+
+  Writes the 8-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+  @return Value.
+
+**/
+UINT8
+EFIAPI
+MmioWrite8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     Value
+  );
+
+/**
+  Reads an 8-bit MMIO register, performs a bitwise OR, and writes the
+  result back to the 8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 8-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  OrData  The value to OR with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT8
+EFIAPI
+MmioOr8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads an 8-bit MMIO register, performs a bitwise AND, and writes the result
+  back to the 8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 8-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT8
+EFIAPI
+MmioAnd8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     AndData
+  );
+
+/**
+  Reads an 8-bit MMIO register, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, performs a
+  bitwise OR between the result of the AND operation and the value specified by
+  OrData, and writes the result to the 8-bit MMIO register specified by
+  Address. The value written to the MMIO register is returned. This function
+  must guarantee that all MMIO read and write operations are serialized.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT8
+EFIAPI
+MmioAndThenOr8 (
+  IN      UINTN                     Address,
+  IN      UINT8                     AndData,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads a bit field of a MMIO register.
+
+  Reads the bit field in an 8-bit MMIO register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Address   MMIO register to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+
+  @return The value read.
+
+**/
+UINT8
+EFIAPI
+MmioBitFieldRead8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to a MMIO register.
+
+  Writes Value to the bit field of the MMIO register. The bit field is
+  specified by the StartBit and the EndBit. All other bits in the destination
+  MMIO register are preserved. The new value of the 8-bit register is returned.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT8
+EFIAPI
+MmioBitFieldWrite8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     Value
+  );
+
+/**
+  Reads a bit field in an 8-bit MMIO register, performs a bitwise OR, and
+  writes the result back to the bit field in the 8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 8-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized. Extra left bits in OrData
+  are stripped.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  OrData    The value to OR with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT8
+EFIAPI
+MmioBitFieldOr8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads a bit field in an 8-bit MMIO register, performs a bitwise AND, and
+  writes the result back to the bit field in the 8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 8-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized. Extra left bits in AndData are
+  stripped.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT8
+EFIAPI
+MmioBitFieldAnd8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData
+  );
+
+/**
+  Reads a bit field in an 8-bit MMIO register, performs a bitwise AND followed
+  by a bitwise OR, and writes the result back to the bit field in the
+  8-bit MMIO register.
+
+  Reads the 8-bit MMIO register specified by Address, performs a bitwise AND
+  followed by a bitwise OR between the read result and the value
+  specified by AndData, and writes the result to the 8-bit MMIO register
+  specified by Address. The value written to the MMIO register is returned.
+  This function must guarantee that all MMIO read and write operations are
+  serialized. Extra left bits in both AndData and OrData are stripped.
+
+  If 8-bit MMIO register operations are not supported, then ASSERT().
+  If StartBit is greater than 7, then ASSERT().
+  If EndBit is greater than 7, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..7.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..7.
+  @param  AndData   The value to AND with read value from the MMIO register.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT8
+EFIAPI
+MmioBitFieldAndThenOr8 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT8                     AndData,
+  IN      UINT8                     OrData
+  );
+
+/**
+  Reads a 16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address. The 16-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT16
+EFIAPI
+MmioRead16_1 (
+  IN      UINTN                     Address
+  );
+
+/**
+  Writes a 16-bit MMIO register.
+
+  Writes the 16-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+  @return Value.
+
+**/
+UINT16
+EFIAPI
+MmioWrite16_1 (
+  IN      UINTN                     Address,
+  IN      UINT16                    Value
+  );
+
+/**
+  Reads a 16-bit MMIO register, performs a bitwise OR, and writes the
+  result back to the 16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 16-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  OrData  The value to OR with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT16
+EFIAPI
+MmioOr16 (
+  IN      UINTN                     Address,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a 16-bit MMIO register, performs a bitwise AND, and writes the result
+  back to the 16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 16-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT16
+EFIAPI
+MmioAnd16 (
+  IN      UINTN                     Address,
+  IN      UINT16                    AndData
+  );
+
+/**
+  Reads a 16-bit MMIO register, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, performs a
+  bitwise OR between the result of the AND operation and the value specified by
+  OrData, and writes the result to the 16-bit MMIO register specified by
+  Address. The value written to the MMIO register is returned. This function
+  must guarantee that all MMIO read and write operations are serialized.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT16
+EFIAPI
+MmioAndThenOr16 (
+  IN      UINTN                     Address,
+  IN      UINT16                    AndData,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a bit field of a MMIO register.
+
+  Reads the bit field in a 16-bit MMIO register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Address   MMIO register to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+
+  @return The value read.
+
+**/
+UINT16
+EFIAPI
+MmioBitFieldRead16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to a MMIO register.
+
+  Writes Value to the bit field of the MMIO register. The bit field is
+  specified by the StartBit and the EndBit. All other bits in the destination
+  MMIO register are preserved. The new value of the 16-bit register is returned.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT16
+EFIAPI
+MmioBitFieldWrite16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    Value
+  );
+
+/**
+  Reads a bit field in a 16-bit MMIO register, performs a bitwise OR, and
+  writes the result back to the bit field in the 16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 16-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized. Extra left bits in OrData
+  are stripped.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  OrData    The value to OR with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT16
+EFIAPI
+MmioBitFieldOr16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a bit field in a 16-bit MMIO register, performs a bitwise AND, and
+  writes the result back to the bit field in the 16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 16-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized. Extra left bits in AndData are
+  stripped.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT16
+EFIAPI
+MmioBitFieldAnd16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData
+  );
+
+/**
+  Reads a bit field in a 16-bit MMIO register, performs a bitwise AND followed
+  by a bitwise OR, and writes the result back to the bit field in the
+  16-bit MMIO register.
+
+  Reads the 16-bit MMIO register specified by Address, performs a bitwise AND
+  followed by a bitwise OR between the read result and the value
+  specified by AndData, and writes the result to the 16-bit MMIO register
+  specified by Address. The value written to the MMIO register is returned.
+  This function must guarantee that all MMIO read and write operations are
+  serialized. Extra left bits in both AndData and OrData are stripped.
+
+  If 16-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 16-bit boundary, then ASSERT().
+  If StartBit is greater than 15, then ASSERT().
+  If EndBit is greater than 15, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..15.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..15.
+  @param  AndData   The value to AND with read value from the MMIO register.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT16
+EFIAPI
+MmioBitFieldAndThenOr16 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT16                    AndData,
+  IN      UINT16                    OrData
+  );
+
+/**
+  Reads a 32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address. The 32-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT32
+EFIAPI
+MmioRead32 (
+  IN      UINTN                     Address
+  );
+
+/**
+  Writes a 32-bit MMIO register.
+
+  Writes the 32-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+  @return Value.
+
+**/
+UINT32
+EFIAPI
+MmioWrite32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    Value
+  );
+
+/**
+  Reads a 32-bit MMIO register, performs a bitwise OR, and writes the
+  result back to the 32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 32-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  OrData  The value to OR with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT32
+EFIAPI
+MmioOr32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a 32-bit MMIO register, performs a bitwise AND, and writes the result
+  back to the 32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 32-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT32
+EFIAPI
+MmioAnd32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    AndData
+  );
+
+/**
+  Reads a 32-bit MMIO register, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, performs a
+  bitwise OR between the result of the AND operation and the value specified by
+  OrData, and writes the result to the 32-bit MMIO register specified by
+  Address. The value written to the MMIO register is returned. This function
+  must guarantee that all MMIO read and write operations are serialized.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT32
+EFIAPI
+MmioAndThenOr32 (
+  IN      UINTN                     Address,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a bit field of a MMIO register.
+
+  Reads the bit field in a 32-bit MMIO register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Address   MMIO register to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+
+  @return The value read.
+
+**/
+UINT32
+EFIAPI
+MmioBitFieldRead32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to a MMIO register.
+
+  Writes Value to the bit field of the MMIO register. The bit field is
+  specified by the StartBit and the EndBit. All other bits in the destination
+  MMIO register are preserved. The new value of the 32-bit register is returned.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT32
+EFIAPI
+MmioBitFieldWrite32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    Value
+  );
+
+/**
+  Reads a bit field in a 32-bit MMIO register, performs a bitwise OR, and
+  writes the result back to the bit field in the 32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 32-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized. Extra left bits in OrData
+  are stripped.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  OrData    The value to OR with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT32
+EFIAPI
+MmioBitFieldOr32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a bit field in a 32-bit MMIO register, performs a bitwise AND, and
+  writes the result back to the bit field in the 32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 32-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized. Extra left bits in AndData are
+  stripped.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT32
+EFIAPI
+MmioBitFieldAnd32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData
+  );
+
+/**
+  Reads a bit field in a 32-bit MMIO register, performs a bitwise AND followed
+  by a bitwise OR, and writes the result back to the bit field in the
+  32-bit MMIO register.
+
+  Reads the 32-bit MMIO register specified by Address, performs a bitwise AND
+  followed by a bitwise OR between the read result and the value
+  specified by AndData, and writes the result to the 32-bit MMIO register
+  specified by Address. The value written to the MMIO register is returned.
+  This function must guarantee that all MMIO read and write operations are
+  serialized. Extra left bits in both AndData and OrData are stripped.
+
+  If 32-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 32-bit boundary, then ASSERT().
+  If StartBit is greater than 31, then ASSERT().
+  If EndBit is greater than 31, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..31.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..31.
+  @param  AndData   The value to AND with read value from the MMIO register.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT32
+EFIAPI
+MmioBitFieldAndThenOr32 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT32                    AndData,
+  IN      UINT32                    OrData
+  );
+
+/**
+  Reads a 64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address. The 64-bit read value is
+  returned. This function must guarantee that all MMIO read and write
+  operations are serialized.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to read.
+
+  @return The value read.
+
+**/
+UINT64
+EFIAPI
+MmioRead64 (
+  IN      UINTN                     Address
+  );
+
+/**
+  Writes a 64-bit MMIO register.
+
+  Writes the 64-bit MMIO register specified by Address with the value specified
+  by Value and returns Value. This function must guarantee that all MMIO read
+  and write operations are serialized.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  Value   The value to write to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioWrite64 (
+  IN      UINTN                     Address,
+  IN      UINT64                    Value
+  );
+
+/**
+  Reads a 64-bit MMIO register, performs a bitwise OR, and writes the
+  result back to the 64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 64-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  OrData  The value to OR with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioOr64 (
+  IN      UINTN                     Address,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads a 64-bit MMIO register, performs a bitwise AND, and writes the result
+  back to the 64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 64-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioAnd64 (
+  IN      UINTN                     Address,
+  IN      UINT64                    AndData
+  );
+
+/**
+  Reads a 64-bit MMIO register, performs a bitwise AND followed by a bitwise
+  OR, and writes the result back to the 64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, performs a
+  bitwise OR between the result of the AND operation and the value specified by
+  OrData, and writes the result to the 64-bit MMIO register specified by
+  Address. The value written to the MMIO register is returned. This function
+  must guarantee that all MMIO read and write operations are serialized.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  Address The MMIO register to write.
+  @param  AndData The value to AND with the read value from the MMIO register.
+  @param  OrData  The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioAndThenOr64 (
+  IN      UINTN                     Address,
+  IN      UINT64                    AndData,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads a bit field of a MMIO register.
+
+  Reads the bit field in a 64-bit MMIO register. The bit field is specified by
+  the StartBit and the EndBit. The value of the bit field is returned.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+
+  @param  Address   MMIO register to read.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+
+  @return The value read.
+
+**/
+UINT64
+EFIAPI
+MmioBitFieldRead64 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit
+  );
+
+/**
+  Writes a bit field to a MMIO register.
+
+  Writes Value to the bit field of the MMIO register. The bit field is
+  specified by the StartBit and the EndBit. All other bits in the destination
+  MMIO register are preserved. The new value of the 64-bit register is returned.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If Value is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  Value     New value of the bit field.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioBitFieldWrite64 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    Value
+  );
+
+/**
+  Reads a bit field in a 64-bit MMIO register, performs a bitwise OR, and
+  writes the result back to the bit field in the 64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address, performs a bitwise
+  OR between the read result and the value specified by OrData, and
+  writes the result to the 64-bit MMIO register specified by Address. The value
+  written to the MMIO register is returned. This function must guarantee that
+  all MMIO read and write operations are serialized. Extra left bits in OrData
+  are stripped.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  OrData    The value to OR with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioBitFieldOr64 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Reads a bit field in a 64-bit MMIO register, performs a bitwise AND, and
+  writes the result back to the bit field in the 64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address, performs a bitwise AND
+  between the read result and the value specified by AndData, and writes the
+  result to the 64-bit MMIO register specified by Address. The value written to
+  the MMIO register is returned. This function must guarantee that all MMIO
+  read and write operations are serialized. Extra left bits in AndData are
+  stripped.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with read value from the MMIO register.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioBitFieldAnd64 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData
+  );
+
+/**
+  Reads a bit field in a 64-bit MMIO register, performs a bitwise AND followed
+  by a bitwise OR, and writes the result back to the bit field in the
+  64-bit MMIO register.
+
+  Reads the 64-bit MMIO register specified by Address, performs a bitwise AND
+  followed by a bitwise OR between the read result and the value
+  specified by AndData, and writes the result to the 64-bit MMIO register
+  specified by Address. The value written to the MMIO register is returned.
+  This function must guarantee that all MMIO read and write operations are
+  serialized. Extra left bits in both AndData and OrData are stripped.
+
+  If 64-bit MMIO register operations are not supported, then ASSERT().
+  If Address is not aligned on a 64-bit boundary, then ASSERT().
+  If StartBit is greater than 63, then ASSERT().
+  If EndBit is greater than 63, then ASSERT().
+  If EndBit is less than StartBit, then ASSERT().
+  If AndData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+  If OrData is larger than the bitmask value range specified by StartBit and EndBit, then ASSERT().
+
+  @param  Address   MMIO register to write.
+  @param  StartBit  The ordinal of the least significant bit in the bit field.
+                    Range 0..63.
+  @param  EndBit    The ordinal of the most significant bit in the bit field.
+                    Range 0..63.
+  @param  AndData   The value to AND with read value from the MMIO register.
+  @param  OrData    The value to OR with the result of the AND operation.
+
+  @return The value written back to the MMIO register.
+
+**/
+UINT64
+EFIAPI
+MmioBitFieldAndThenOr64 (
+  IN      UINTN                     Address,
+  IN      UINTN                     StartBit,
+  IN      UINTN                     EndBit,
+  IN      UINT64                    AndData,
+  IN      UINT64                    OrData
+  );
+
+/**
+  Copy data from MMIO region to system memory by using 8-bit access.
+
+  Copy data from MMIO region specified by starting address StartAddress
+  to system memory specified by Buffer by using 8-bit access. The total
+  number of byte to be copied is specified by Length. Buffer is returned.
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+
+  @param  StartAddress    Starting address for the MMIO region to be copied from.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer receiving the data read.
+
+  @return Buffer
+
+**/
+UINT8 *
+EFIAPI
+MmioReadBuffer8 (
+  IN  UINTN       StartAddress,
+  IN  UINTN       Length,
+  OUT UINT8       *Buffer
+  );
+
+/**
+  Copy data from MMIO region to system memory by using 16-bit access.
+
+  Copy data from MMIO region specified by starting address StartAddress
+  to system memory specified by Buffer by using 16-bit access. The total
+  number of byte to be copied is specified by Length. Buffer is returned.
+
+  If StartAddress is not aligned on a 16-bit boundary, then ASSERT().
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  If Length is not aligned on a 16-bit boundary, then ASSERT().
+  If Buffer is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  StartAddress    Starting address for the MMIO region to be copied from.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer receiving the data read.
+
+  @return Buffer
+
+**/
+UINT16 *
+EFIAPI
+MmioReadBuffer16 (
+  IN  UINTN       StartAddress,
+  IN  UINTN       Length,
+  OUT UINT16      *Buffer
+  );
+
+/**
+  Copy data from MMIO region to system memory by using 32-bit access.
+
+  Copy data from MMIO region specified by starting address StartAddress
+  to system memory specified by Buffer by using 32-bit access. The total
+  number of byte to be copied is specified by Length. Buffer is returned.
+
+  If StartAddress is not aligned on a 32-bit boundary, then ASSERT().
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  If Length is not aligned on a 32-bit boundary, then ASSERT().
+  If Buffer is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  StartAddress    Starting address for the MMIO region to be copied from.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer receiving the data read.
+
+  @return Buffer
+
+**/
+UINT32 *
+EFIAPI
+MmioReadBuffer32 (
+  IN  UINTN       StartAddress,
+  IN  UINTN       Length,
+  OUT UINT32      *Buffer
+  );
+
+/**
+  Copy data from MMIO region to system memory by using 64-bit access.
+
+  Copy data from MMIO region specified by starting address StartAddress
+  to system memory specified by Buffer by using 64-bit access. The total
+  number of byte to be copied is specified by Length. Buffer is returned.
+
+  If StartAddress is not aligned on a 64-bit boundary, then ASSERT().
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS - Buffer + 1), then ASSERT().
+
+  If Length is not aligned on a 64-bit boundary, then ASSERT().
+  If Buffer is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  StartAddress    Starting address for the MMIO region to be copied from.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer receiving the data read.
+
+  @return Buffer
+
+**/
+UINT64 *
+EFIAPI
+MmioReadBuffer64 (
+  IN  UINTN       StartAddress,
+  IN  UINTN       Length,
+  OUT UINT64      *Buffer
+  );
+
+/**
+  Copy data from system memory to MMIO region by using 8-bit access.
+
+  Copy data from system memory specified by Buffer to MMIO region specified
+  by starting address StartAddress by using 8-bit access. The total number
+  of byte to be copied is specified by Length. Buffer is returned.
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS -Buffer + 1), then ASSERT().
+
+
+  @param  StartAddress    Starting address for the MMIO region to be copied to.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer containing the data to write.
+
+  @return Buffer
+
+**/
+UINT8 *
+EFIAPI
+MmioWriteBuffer8 (
+  IN  UINTN         StartAddress,
+  IN  UINTN         Length,
+  IN  CONST UINT8   *Buffer
+  );
+
+/**
+  Copy data from system memory to MMIO region by using 16-bit access.
+
+  Copy data from system memory specified by Buffer to MMIO region specified
+  by starting address StartAddress by using 16-bit access. The total number
+  of byte to be copied is specified by Length. Buffer is returned.
+
+  If StartAddress is not aligned on a 16-bit boundary, then ASSERT().
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS -Buffer + 1), then ASSERT().
+
+  If Length is not aligned on a 16-bit boundary, then ASSERT().
+
+  If Buffer is not aligned on a 16-bit boundary, then ASSERT().
+
+  @param  StartAddress    Starting address for the MMIO region to be copied to.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer containing the data to write.
+
+  @return Buffer
+
+**/
+UINT16 *
+EFIAPI
+MmioWriteBuffer16 (
+  IN  UINTN        StartAddress,
+  IN  UINTN        Length,
+  IN  CONST UINT16 *Buffer
+  );
+
+/**
+  Copy data from system memory to MMIO region by using 32-bit access.
+
+  Copy data from system memory specified by Buffer to MMIO region specified
+  by starting address StartAddress by using 32-bit access. The total number
+  of byte to be copied is specified by Length. Buffer is returned.
+
+  If StartAddress is not aligned on a 32-bit boundary, then ASSERT().
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS -Buffer + 1), then ASSERT().
+
+  If Length is not aligned on a 32-bit boundary, then ASSERT().
+
+  If Buffer is not aligned on a 32-bit boundary, then ASSERT().
+
+  @param  StartAddress    Starting address for the MMIO region to be copied to.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer containing the data to write.
+
+  @return Buffer
+
+**/
+UINT32 *
+EFIAPI
+MmioWriteBuffer32 (
+  IN  UINTN        StartAddress,
+  IN  UINTN        Length,
+  IN  CONST UINT32 *Buffer
+  );
+
+/**
+  Copy data from system memory to MMIO region by using 64-bit access.
+
+  Copy data from system memory specified by Buffer to MMIO region specified
+  by starting address StartAddress by using 64-bit access. The total number
+  of byte to be copied is specified by Length. Buffer is returned.
+
+  If StartAddress is not aligned on a 64-bit boundary, then ASSERT().
+
+  If Length is greater than (MAX_ADDRESS - StartAddress + 1), then ASSERT().
+  If Length is greater than (MAX_ADDRESS -Buffer + 1), then ASSERT().
+
+  If Length is not aligned on a 64-bit boundary, then ASSERT().
+
+  If Buffer is not aligned on a 64-bit boundary, then ASSERT().
+
+  @param  StartAddress    Starting address for the MMIO region to be copied to.
+  @param  Length          The size, in bytes, of Buffer.
+  @param  Buffer          Pointer to a system memory buffer containing the data to write.
+
+  @return Buffer
+
+**/
+UINT64 *
+EFIAPI
+MmioWriteBuffer64 (
+  IN  UINTN        StartAddress,
+  IN  UINTN        Length,
+  IN  CONST UINT64 *Buffer
+  );
+
+
+#endif
diff --git a/libedk2_tpm/include/PcdLib.h b/libedk2_tpm/include/PcdLib.h
new file mode 100644
index 0000000..f1e1cfb
--- /dev/null
+++ b/libedk2_tpm/include/PcdLib.h
@@ -0,0 +1,1734 @@
+/** @file
+  Provides library services to get and set Platform Configuration Database entries.
+
+  PCD Library Class provides a PCD usage macro interface for all PCD types.
+  It should be included in any module that uses PCD. If a module uses dynamic/dynamicex
+  PCD, module should be linked to a PEIM/DXE library instance to access that PCD.
+  If a module uses PatchableInModule type PCD, it also needs the library instance to produce
+  LibPatchPcdSetPtr() interface. For FeatureFlag/Fixed PCD, the macro interface is
+  translated to a variable or macro that is auto-generated by build tool in
+  module's autogen.h/autogen.c.
+  The PcdGetXX(), PcdSetXX(), PcdToken(), and PcdGetNextTokenSpace() operations are
+  only available prior to ExitBootServices().  If access to PCD values are required
+  at runtime, then their values must be collected prior to ExitBootServices().
+  There are no restrictions on the use of FeaturePcd(), FixedPcdGetXX(),
+  PatchPcdGetXX(), and PatchPcdSetXX().
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __PCD_LIB_H__
+#define __PCD_LIB_H__
+
+#include <Base.h>
+/**
+  Retrieves a token number based on a token name.
+
+  Returns the token number associated with the PCD token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve the token number for.
+
+  @return  The token number associated with the PCD.
+
+**/
+#define PcdToken(TokenName)                 _PCD_TOKEN_##TokenName
+
+
+/**
+  Retrieves a Boolean PCD feature flag based on a token name.
+
+  Returns the Boolean value for the PCD feature flag specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a feature flag PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  Boolean value for the PCD feature flag.
+
+**/
+#define FeaturePcdGet(TokenName)            _PCD_GET_MODE_BOOL_##TokenName
+
+
+/**
+  Retrieves an 8-bit fixed PCD token value based on a token name.
+
+  Returns the 8-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a fixed at build PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  8-bit value for the token specified by TokenName.
+
+**/
+#define FixedPcdGet8(TokenName)             _PCD_VALUE_##TokenName
+
+
+/**
+  Retrieves a 16-bit fixed PCD token value based on a token name.
+
+  Returns the 16-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a fixed at build PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  16-bit value for the token specified by TokenName.
+
+**/
+#define FixedPcdGet16(TokenName)            _PCD_VALUE_##TokenName
+
+
+/**
+  Retrieves a 32-bit fixed PCD token value based on a token name.
+
+  Returns the 32-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a fixed at build PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  32-bit value for the token specified by TokenName.
+
+**/
+#define FixedPcdGet32(TokenName)            _PCD_VALUE_##TokenName
+
+
+/**
+  Retrieves a 64-bit fixed PCD token value based on a token name.
+
+  Returns the 64-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a fixed at build PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  64-bit value for the token specified by TokenName.
+
+**/
+#define FixedPcdGet64(TokenName)            _PCD_VALUE_##TokenName
+
+
+/**
+  Retrieves a Boolean fixed PCD token value based on a token name.
+
+  Returns the Boolean value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a fixed at build PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  The Boolean value for the token.
+
+**/
+#define FixedPcdGetBool(TokenName)          _PCD_VALUE_##TokenName
+
+
+/**
+  Retrieves a pointer to a fixed PCD token buffer based on a token name.
+
+  Returns a pointer to the buffer for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a fixed at build PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  A pointer to the buffer.
+
+**/
+#define FixedPcdGetPtr(TokenName)           ((VOID *)_PCD_VALUE_##TokenName)
+
+
+/**
+  Retrieves an 8-bit binary patchable PCD token value based on a token name.
+
+  Returns the 8-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  An 8-bit binary patchable PCD token value.
+
+**/
+#define PatchPcdGet8(TokenName)             _gPcd_BinaryPatch_##TokenName
+
+/**
+  Retrieves a 16-bit binary patchable PCD token value based on a token name.
+
+  Returns the 16-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  A 16-bit binary patchable PCD token value.
+
+**/
+#define PatchPcdGet16(TokenName)            _gPcd_BinaryPatch_##TokenName
+
+
+/**
+  Retrieves a 32-bit binary patchable PCD token value based on a token name.
+
+  Returns the 32-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  A 32-bit binary patchable PCD token value.
+
+**/
+#define PatchPcdGet32(TokenName)            _gPcd_BinaryPatch_##TokenName
+
+
+/**
+  Retrieves a 64-bit binary patchable PCD token value based on a token name.
+
+  Returns the 64-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  A 64-bit binary patchable PCD token value.
+
+**/
+#define PatchPcdGet64(TokenName)            _gPcd_BinaryPatch_##TokenName
+
+
+/**
+  Retrieves a Boolean binary patchable PCD token value based on a token name.
+
+  Returns the Boolean value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  The Boolean value for the token.
+
+**/
+#define PatchPcdGetBool(TokenName)          _gPcd_BinaryPatch_##TokenName
+
+
+/**
+  Retrieves a pointer to a binary patchable PCD token buffer based on a token name.
+
+  Returns a pointer to the buffer for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  A pointer to the buffer for the token.
+
+**/
+#define PatchPcdGetPtr(TokenName)           ((VOID *)_gPcd_BinaryPatch_##TokenName)
+
+
+/**
+  Sets an 8-bit binary patchable PCD token value based on a token name.
+
+  Sets the 8-bit value for the token specified by TokenName. Value is returned.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
+  @param   Value      The 8-bit value to set.
+
+  @return Return the Value that was set.
+
+**/
+#define PatchPcdSet8(TokenName, Value)      (_gPcd_BinaryPatch_##TokenName = (Value))
+
+
+/**
+  Sets a 16-bit binary patchable PCD token value based on a token name.
+
+  Sets the 16-bit value for the token specified by TokenName. Value is returned.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
+  @param   Value      The 16-bit value to set.
+
+  @return Return the Value that was set.
+
+**/
+#define PatchPcdSet16(TokenName, Value)     (_gPcd_BinaryPatch_##TokenName = (Value))
+
+
+/**
+  Sets a 32-bit binary patchable PCD token value based on a token name.
+
+  Sets the 32-bit value for the token specified by TokenName. Value is returned.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
+  @param   Value      The 32-bit value to set.
+
+  @return Return the Value that was set.
+
+**/
+#define PatchPcdSet32(TokenName, Value)     (_gPcd_BinaryPatch_##TokenName = (Value))
+
+
+/**
+  Sets a 64-bit binary patchable PCD token value based on a token name.
+
+  Sets the 64-bit value for the token specified by TokenName. Value is returned.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
+  @param   Value      The 64-bit value to set.
+
+  @return Return the Value that was set.
+
+**/
+#define PatchPcdSet64(TokenName, Value)     (_gPcd_BinaryPatch_##TokenName = (Value))
+
+
+/**
+  Sets a Boolean binary patchable PCD token value based on a token name.
+
+  Sets the Boolean value for the token specified by TokenName. Value is returned.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  @param   TokenName  The name of the binary patchable PCD token to set the current value for.
+  @param   Value      The boolean value to set.
+
+  @return Return the Value that was set.
+
+**/
+#define PatchPcdSetBool(TokenName, Value)   (_gPcd_BinaryPatch_##TokenName = (Value))
+
+
+/**
+  Sets a pointer to a binary patchable PCD token buffer based on a token name.
+
+  Sets the buffer for the token specified by TokenName.  Buffer is returned.
+  If SizeOfBuffer is greater than the maximum size supported by TokenName, then set SizeOfBuffer
+  to the maximum size supported by TokenName and return NULL to indicate that the set operation
+  was not actually performed.  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be
+  set to the maximum size supported by TokenName and NULL must be returned.
+  If TokenName is not a valid token in the token space, then the module will not build.
+  If TokenName is not a patchable in module PCD, then the module will not build.
+
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param   TokenName      The name of the binary patchable PCD token to set the current value for.
+  @param   SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
+  @param   Buffer         Pointer to the value to set.
+
+  @return Return the pointer to the Buffer that was set.
+
+**/
+#define PatchPcdSetPtr(TokenName, Size, Buffer) \
+                                            LibPatchPcdSetPtrAndSize (                 \
+                                              (VOID *)_gPcd_BinaryPatch_##TokenName,   \
+                                              &_gPcd_BinaryPatch_Size_##TokenName,     \
+                                              (UINTN)_PCD_PATCHABLE_##TokenName##_SIZE, \
+                                              (Size),                                  \
+                                              (Buffer)                                 \
+                                              )
+/**
+  Retrieves an 8-bit PCD token value based on a token name.
+
+  Returns the 8-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  8-bit value for the token specified by TokenName.
+
+**/
+#define PcdGet8(TokenName)                  _PCD_GET_MODE_8_##TokenName
+
+
+/**
+  Retrieves a 16-bit PCD token value based on a token name.
+
+  Returns the 16-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  16-bit value for the token specified by TokenName.
+
+**/
+#define PcdGet16(TokenName)                 _PCD_GET_MODE_16_##TokenName
+
+
+/**
+  Retrieves a 32-bit PCD token value based on a token name.
+
+  Returns the 32-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  32-bit value for the token specified by TokenName.
+
+**/
+#define PcdGet32(TokenName)                 _PCD_GET_MODE_32_##TokenName
+
+
+/**
+  Retrieves a 64-bit PCD token value based on a token name.
+
+  Returns the 64-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  64-bit value for the token specified by TokenName.
+
+**/
+#define PcdGet64(TokenName)                 _PCD_GET_MODE_64_##TokenName
+
+
+/**
+  Retrieves a pointer to a PCD token buffer based on a token name.
+
+  Returns a pointer to the buffer for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  A pointer to the buffer.
+
+**/
+#define PcdGetPtr(TokenName)                _PCD_GET_MODE_PTR_##TokenName
+
+
+/**
+  Retrieves a Boolean PCD token value based on a token name.
+
+  Returns the Boolean value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   TokenName  The name of the PCD token to retrieve a current value for.
+
+  @return  A Boolean PCD token value.
+
+**/
+#define PcdGetBool(TokenName)               _PCD_GET_MODE_BOOL_##TokenName
+
+
+/**
+  Retrieves the size of a fixed PCD token based on a token name.
+
+  Returns the size of the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.
+
+  @return     Return the size
+
+**/
+#define FixedPcdGetSize(TokenName)    _PCD_SIZE_##TokenName
+
+
+/**
+  Retrieves the size of a binary patchable PCD token based on a token name.
+
+  Returns the size of the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param[in]  TokenName  The name of the PCD token to retrieve a current value size for.
+
+  @return     Return the size
+
+**/
+#define PatchPcdGetSize(TokenName)    _gPcd_BinaryPatch_Size_##TokenName
+
+
+/**
+  Retrieves the size of the PCD token based on a token name.
+
+  Returns the size of the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param[in]   TokenName  The name of the PCD token to retrieve a current value size for.
+
+  @return      Return the size
+
+**/
+#define PcdGetSize(TokenName)         _PCD_GET_MODE_SIZE_##TokenName
+
+
+/**
+  Retrieve the size of a given PCD token.
+
+  Returns the size of the token specified by TokenNumber and Guid.
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid          Pointer to a 128-bit unique value that designates
+                            which namespace to retrieve a value from.
+  @param[in]  TokenNumber   The PCD token number to retrieve a current value size for.
+
+  @return     Return the size.
+
+**/
+#define PcdGetExSize(Guid, TokenName) LibPcdGetExSize ((Guid), PcdTokenEx(Guid,TokenName))
+
+/**
+  Sets a 8-bit PCD token value based on a token name.
+
+  Sets the 8-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param TokenName  The name of the PCD token to retrieve a current value for.
+  @param Value      The 8-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSet8S(TokenName, Value)          _PCD_SET_MODE_8_S_##TokenName    ((Value))
+
+/**
+  Sets a 16-bit PCD token value based on a token name.
+
+  Sets the 16-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param TokenName  The name of the PCD token to retrieve a current value for.
+  @param Value      The 16-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSet16S(TokenName, Value)         _PCD_SET_MODE_16_S_##TokenName    ((Value))
+
+/**
+  Sets a 32-bit PCD token value based on a token name.
+
+  Sets the 32-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param TokenName  The name of the PCD token to retrieve a current value for.
+  @param Value      The 32-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSet32S(TokenName, Value)         _PCD_SET_MODE_32_S_##TokenName    ((Value))
+
+/**
+  Sets a 64-bit PCD token value based on a token name.
+
+  Sets the 64-bit value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param TokenName  The name of the PCD token to retrieve a current value for.
+  @param Value      The 64-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSet64S(TokenName, Value)         _PCD_SET_MODE_64_S_##TokenName    ((Value))
+
+/**
+  Sets a pointer to a PCD token buffer based on a token name.
+
+  Sets the buffer for the token specified by TokenName.
+  If SizeOfBuffer is greater than the maximum size supported by TokenName,
+  then set SizeOfBuffer to the maximum size supported by TokenName and return
+  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
+  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
+  supported by TokenName and RETURN_INVALID_PARAMETER must be returned.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param TokenName      The name of the PCD token to set the current value for.
+  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
+  @param Buffer         A pointer to the buffer to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetPtrS(TokenName, SizeOfBuffer, Buffer) \
+                                            _PCD_SET_MODE_PTR_S_##TokenName   ((SizeOfBuffer), (Buffer))
+
+
+
+/**
+  Sets a boolean PCD token value based on a token name.
+
+  Sets the boolean value for the token specified by TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param TokenName  The name of the PCD token to retrieve a current value for.
+  @param Value      The boolean value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetBoolS(TokenName, Value)       _PCD_SET_MODE_BOOL_S_##TokenName    ((Value))
+
+/**
+  Retrieves a token number based on a GUID and a token name.
+
+  Returns the token number for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space, then the module will not build.
+
+  @param   Guid        Pointer to a 128-bit unique value that designates
+                       which namespace to retrieve a value from.
+  @param   TokenName   The name of the PCD token to retrieve a current value for.
+
+  @return  Return the token number.
+
+**/
+#define PcdTokenEx(Guid,TokenName)  _PCD_TOKEN_EX_##TokenName(Guid)
+
+/**
+  Retrieves an 8-bit PCD token value based on a GUID and a token name.
+
+  Returns the 8-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param   Guid        Pointer to a 128-bit unique value that designates
+                       which namespace to retrieve a value from.
+  @param   TokenName   The name of the PCD token to retrieve a current value for.
+
+  @return  An 8-bit PCD token value.
+
+**/
+#define PcdGetEx8(Guid, TokenName)          LibPcdGetEx8 ((Guid), PcdTokenEx(Guid,TokenName))
+
+/**
+  Retrieves a 16-bit PCD token value based on a GUID and a token name.
+
+  Returns the 16-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param   Guid        Pointer to a 128-bit unique value that designates
+                       which namespace to retrieve a value from.
+  @param   TokenName   The name of the PCD token to retrieve a current value for.
+
+  @return  A 16-bit PCD token value.
+
+**/
+#define PcdGetEx16(Guid, TokenName)         LibPcdGetEx16 ((Guid), PcdTokenEx(Guid,TokenName))
+
+
+/**
+  Retrieves a 32-bit PCD token value based on a GUID and a token name.
+
+  Returns the 32-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param   Guid        Pointer to a 128-bit unique value that designates
+                       which namespace to retrieve a value from.
+  @param   TokenName   The name of the PCD token to retrieve a current value for.
+
+  @return  A 32-bit PCD token value.
+
+**/
+#define PcdGetEx32(Guid, TokenName)         LibPcdGetEx32 ((Guid), PcdTokenEx(Guid,TokenName))
+
+
+/**
+  Retrieves a 64-bit PCD token value based on a GUID and a token name.
+
+  Returns the 64-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param   Guid        Pointer to a 128-bit unique value that designates
+                       which namespace to retrieve a value from.
+  @param   TokenName   The name of the PCD token to retrieve a current value for.
+
+  @return  A 64-bit PCD token value.
+
+**/
+#define PcdGetEx64(Guid, TokenName)         LibPcdGetEx64 ((Guid), PcdTokenEx(Guid,TokenName))
+
+
+/**
+  Retrieves a pointer to a PCD token buffer based on a GUID and a token name.
+
+  Returns a pointer to the buffer for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param   Guid        Pointer to a 128-bit unique value that designates
+                       which namespace to retrieve a value from.
+  @param   TokenName   The name of the PCD token to retrieve a current value for.
+
+  @return  A pointer to a PCD token buffer.
+
+**/
+#define PcdGetExPtr(Guid, TokenName)        LibPcdGetExPtr ((Guid), PcdTokenEx(Guid,TokenName))
+
+
+/**
+  Retrieves a Boolean PCD token value based on a GUID and a token name.
+
+  Returns the Boolean value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param   Guid        Pointer to a 128-bit unique value that designates
+                       which namespace to retrieve a value from.
+  @param   TokenName   The name of the PCD token to retrieve a current value for.
+
+  @return  A Boolean PCD token value.
+
+**/
+#define PcdGetExBool(Guid, TokenName)       LibPcdGetExBool  ((Guid), PcdTokenEx(Guid,TokenName))
+
+
+
+/**
+  Sets an 8-bit PCD token value based on a GUID and a token name.
+
+  Sets the 8-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param Guid       Pointer to a 128-bit unique value that designates
+                    which namespace to retrieve a value from.
+  @param TokenName  The name of the PCD token to set the current value for.
+  @param Value      The 8-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetEx8S(Guid, TokenName, Value)     LibPcdSetEx8S ((Guid), PcdTokenEx(Guid,TokenName), (Value))
+
+/**
+  Sets an 16-bit PCD token value based on a GUID and a token name.
+
+  Sets the 16-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param Guid       Pointer to a 128-bit unique value that designates
+                    which namespace to retrieve a value from.
+  @param TokenName  The name of the PCD token to set the current value for.
+  @param Value      The 16-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetEx16S(Guid, TokenName, Value)    LibPcdSetEx16S ((Guid), PcdTokenEx(Guid,TokenName), (Value))
+
+/**
+  Sets an 32-bit PCD token value based on a GUID and a token name.
+
+  Sets the 32-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param Guid       Pointer to a 128-bit unique value that designates
+                    which namespace to retrieve a value from.
+  @param TokenName  The name of the PCD token to set the current value for.
+  @param Value      The 32-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetEx32S(Guid, TokenName, Value)    LibPcdSetEx32S ((Guid), PcdTokenEx(Guid,TokenName), (Value))
+
+/**
+  Sets an 64-bit PCD token value based on a GUID and a token name.
+
+  Sets the 64-bit value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param Guid       Pointer to a 128-bit unique value that designates
+                    which namespace to retrieve a value from.
+  @param TokenName  The name of the PCD token to set the current value for.
+  @param Value      The 64-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetEx64S(Guid, TokenName, Value)    LibPcdSetEx64S ((Guid), PcdTokenEx(Guid,TokenName), (Value))
+
+/**
+  Sets a pointer to a PCD token buffer based on a GUID and a token name.
+
+  Sets the buffer for the token specified by Guid and TokenName.
+  If SizeOfBuffer is greater than the maximum size supported by Guid and TokenName,
+  then set SizeOfBuffer to the maximum size supported by Guid and TokenName and return
+  RETURN_INVALID_PARAMETER to indicate that the set operation was not actually performed.
+  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the maximum size
+  supported by Guid and TokenName and RETURN_INVALID_PARAMETER must be returned.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param Guid           Pointer to a 128-bit unique value that designates
+                        which namespace to retrieve a value from.
+  @param TokenName      The name of the PCD token to set the current value for.
+  @param SizeOfBuffer   A pointer to the size, in bytes, of Buffer.
+  @param Buffer         Pointer to the buffer to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetExPtrS(Guid, TokenName, SizeOfBuffer, Buffer) \
+                                            LibPcdSetExPtrS ((Guid), PcdTokenEx(Guid,TokenName), (SizeOfBuffer), (Buffer))
+
+
+/**
+  Sets an boolean PCD token value based on a GUID and a token name.
+
+  Sets the boolean value for the token specified by Guid and TokenName.
+  If TokenName is not a valid token in the token space specified by Guid,
+  then the module will not build.
+
+  If Guid is NULL, then ASSERT().
+
+  @param Guid       Pointer to a 128-bit unique value that designates
+                    which namespace to retrieve a value from.
+  @param TokenName  The name of the PCD token to set the current value for.
+  @param Value      The boolean value to set.
+
+  @return The status of the set operation.
+
+**/
+#define PcdSetExBoolS(Guid, TokenName, Value) \
+                                            LibPcdSetExBoolS ((Guid), PcdTokenEx(Guid,TokenName), (Value))
+
+/**
+  This function provides a means by which SKU support can be established in the PCD infrastructure.
+
+  Sets the current SKU in the PCD database to the value specified by SkuId.  SkuId is returned.
+
+  @param  SkuId   The SKU value that will be used when the PCD service retrieves and sets values
+                  associated with a PCD token.
+
+  @return  Return the SKU ID that was set.
+
+**/
+UINTN
+EFIAPI
+LibPcdSetSku (
+  IN UINTN   SkuId
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the 8-bit value for the token specified by TokenNumber.
+
+  @param[in]  TokenNumber The PCD token number to retrieve a current value for.
+
+  @return Returns the 8-bit value for the token specified by TokenNumber.
+
+**/
+UINT8
+EFIAPI
+LibPcdGet8 (
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the 16-bit value for the token specified by TokenNumber.
+
+  @param[in]  TokenNumber The PCD token number to retrieve a current value for.
+
+  @return Returns the 16-bit value for the token specified by TokenNumber.
+
+**/
+UINT16
+EFIAPI
+LibPcdGet16 (
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the 32-bit value for the token specified by TokenNumber.
+
+  @param[in]  TokenNumber The PCD token number to retrieve a current value for.
+
+  @return Returns the 32-bit value for the token specified by TokenNumber.
+
+**/
+UINT32
+EFIAPI
+LibPcdGet32 (
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the 64-bit value for the token specified by TokenNumber.
+
+  @param[in]  TokenNumber The PCD token number to retrieve a current value for.
+
+  @return Returns the 64-bit value for the token specified by TokenNumber.
+
+**/
+UINT64
+EFIAPI
+LibPcdGet64 (
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the pointer to the buffer of the token specified by TokenNumber.
+
+  @param[in]  TokenNumber The PCD token number to retrieve a current value for.
+
+  @return Returns the pointer to the token specified by TokenNumber.
+
+**/
+VOID *
+EFIAPI
+LibPcdGetPtr (
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the Boolean value of the token specified by TokenNumber.
+
+  @param[in]  TokenNumber The PCD token number to retrieve a current value for.
+
+  @return Returns the Boolean value of the token specified by TokenNumber.
+
+**/
+BOOLEAN
+EFIAPI
+LibPcdGetBool (
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve the size of a given PCD token.
+
+  @param[in]  TokenNumber The PCD token number to retrieve a current value for.
+
+  @return Returns the size of the token specified by TokenNumber.
+
+**/
+UINTN
+EFIAPI
+LibPcdGetSize (
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the 8-bit value for the token specified by TokenNumber and Guid.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid         Pointer to a 128-bit unique value that designates
+                           which namespace to retrieve a value from.
+  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.
+
+  @return Return the UINT8.
+
+**/
+UINT8
+EFIAPI
+LibPcdGetEx8 (
+  IN CONST GUID        *Guid,
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the 16-bit value for the token specified by TokenNumber and Guid.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid         Pointer to a 128-bit unique value that designates
+                           which namespace to retrieve a value from.
+  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.
+
+  @return Return the UINT16.
+
+**/
+UINT16
+EFIAPI
+LibPcdGetEx16 (
+  IN CONST GUID        *Guid,
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  Returns the 32-bit value for the token specified by TokenNumber and Guid.
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid         Pointer to a 128-bit unique value that designates
+                           which namespace to retrieve a value from.
+  @param[in]  TokenNumber  The PCD token number to retrieve a current value for.
+
+  @return Return the UINT32.
+
+**/
+UINT32
+EFIAPI
+LibPcdGetEx32 (
+  IN CONST GUID        *Guid,
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the 64-bit value for the token specified by TokenNumber and Guid.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid          Pointer to a 128-bit unique value that designates
+                            which namespace to retrieve a value from.
+  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.
+
+  @return Return the UINT64.
+
+**/
+UINT64
+EFIAPI
+LibPcdGetEx64 (
+  IN CONST GUID        *Guid,
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the pointer to the buffer of token specified by TokenNumber and Guid.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid          Pointer to a 128-bit unique value that designates
+                            which namespace to retrieve a value from.
+  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.
+
+  @return Return the VOID* pointer.
+
+**/
+VOID *
+EFIAPI
+LibPcdGetExPtr (
+  IN CONST GUID        *Guid,
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve a value for a given PCD token.
+
+  Returns the Boolean value of the token specified by TokenNumber and Guid.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid          Pointer to a 128-bit unique value that designates
+                            which namespace to retrieve a value from.
+  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.
+
+  @return Return the BOOLEAN.
+
+**/
+BOOLEAN
+EFIAPI
+LibPcdGetExBool (
+  IN CONST GUID        *Guid,
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to retrieve the size of a given PCD token.
+
+  Returns the size of the token specified by TokenNumber and Guid.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in]  Guid          Pointer to a 128-bit unique value that designates
+                            which namespace to retrieve a value from.
+  @param[in]  TokenNumber   The PCD token number to retrieve a current value for.
+
+  @return Return the size.
+
+**/
+UINTN
+EFIAPI
+LibPcdGetExSize (
+  IN CONST GUID        *Guid,
+  IN UINTN             TokenNumber
+  );
+
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 8-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 8-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSet8S (
+  IN UINTN          TokenNumber,
+  IN UINT8          Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 16-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 16-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSet16S (
+  IN UINTN          TokenNumber,
+  IN UINT16         Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 32-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 32-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSet32S (
+  IN UINTN          TokenNumber,
+  IN UINT32         Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 64-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 64-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSet64S (
+  IN UINTN          TokenNumber,
+  IN UINT64         Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets a buffer for the token specified by TokenNumber to the value specified
+  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
+  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
+  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
+  was not actually performed.
+
+  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to the
+  maximum size supported by TokenName and RETURN_INVALID_PARAMETER must be returned.
+
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param[in]      TokenNumber   The PCD token number to set a current value for.
+  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
+  @param[in]      Buffer        A pointer to the buffer to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetPtrS (
+  IN       UINTN    TokenNumber,
+  IN OUT   UINTN    *SizeOfBuffer,
+  IN CONST VOID     *Buffer
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the boolean value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The boolean value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetBoolS (
+  IN UINTN          TokenNumber,
+  IN BOOLEAN        Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 8-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in] Guid           The pointer to a 128-bit unique value that
+                            designates which namespace to set a value from.
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 8-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetEx8S (
+  IN CONST GUID     *Guid,
+  IN UINTN          TokenNumber,
+  IN UINT8          Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 16-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in] Guid           The pointer to a 128-bit unique value that
+                            designates which namespace to set a value from.
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 16-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetEx16S (
+  IN CONST GUID     *Guid,
+  IN UINTN          TokenNumber,
+  IN UINT16         Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 32-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in] Guid           The pointer to a 128-bit unique value that
+                            designates which namespace to set a value from.
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 32-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetEx32S (
+  IN CONST GUID     *Guid,
+  IN UINTN          TokenNumber,
+  IN UINT32         Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the 64-bit value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in] Guid           The pointer to a 128-bit unique value that
+                            designates which namespace to set a value from.
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The 64-bit value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetEx64S (
+  IN CONST GUID     *Guid,
+  IN UINTN          TokenNumber,
+  IN UINT64         Value
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets a buffer for the token specified by TokenNumber to the value specified by
+  Buffer and SizeOfBuffer. If SizeOfBuffer is greater than the maximum size
+  support by TokenNumber, then set SizeOfBuffer to the maximum size supported by
+  TokenNumber and return RETURN_INVALID_PARAMETER to indicate that the set operation
+  was not actually performed.
+
+  If Guid is NULL, then ASSERT().
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param[in]      Guid          Pointer to a 128-bit unique value that
+                                designates which namespace to set a value from.
+  @param[in]      TokenNumber   The PCD token number to set a current value for.
+  @param[in, out] SizeOfBuffer  The size, in bytes, of Buffer.
+  @param[in]      Buffer        A pointer to the buffer to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetExPtrS (
+  IN CONST GUID     *Guid,
+  IN       UINTN    TokenNumber,
+  IN OUT   UINTN    *SizeOfBuffer,
+  IN       VOID     *Buffer
+  );
+
+/**
+  This function provides a means by which to set a value for a given PCD token.
+
+  Sets the boolean value for the token specified by TokenNumber
+  to the value specified by Value.
+
+  If Guid is NULL, then ASSERT().
+
+  @param[in] Guid           The pointer to a 128-bit unique value that
+                            designates which namespace to set a value from.
+  @param[in] TokenNumber    The PCD token number to set a current value for.
+  @param[in] Value          The boolean value to set.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPcdSetExBoolS (
+  IN CONST GUID     *Guid,
+  IN UINTN          TokenNumber,
+  IN BOOLEAN        Value
+  );
+
+/**
+  This notification function serves two purposes.
+
+  Firstly, it notifies the module that did the registration that the value of this
+  PCD token has been set.
+  Secondly, it provides a mechanism for the module that did the registration to intercept
+  the set operation and override the value been set if necessary. After the invocation of
+  the callback function, TokenData will be used by PCD service PEIM or driver to modify th
+  internal data in PCD database.
+
+  @param[in]      CallBackGuid    The PCD token GUID being set.
+  @param[in]      CallBackToken   The PCD token number being set.
+  @param[in, out] TokenData       A pointer to the token data being set.
+  @param[in]      TokenDataSize   The size, in bytes, of the data being set.
+
+**/
+typedef
+VOID
+(EFIAPI *PCD_CALLBACK)(
+  IN        CONST GUID        *CallBackGuid, OPTIONAL
+  IN        UINTN             CallBackToken,
+  IN  OUT   VOID              *TokenData,
+  IN        UINTN             TokenDataSize
+  );
+
+
+/**
+  Set up a notification function that is called when a specified token is set.
+
+  When the token specified by TokenNumber and Guid is set,
+  then notification function specified by NotificationFunction is called.
+  If Guid is NULL, then the default token space is used.
+  If NotificationFunction is NULL, then ASSERT().
+
+  @param[in]  Guid                  Pointer to a 128-bit unique value that designates which
+                                    namespace to set a value from.  If NULL, then the default
+                                    token space is used.
+  @param[in]  TokenNumber           The PCD token number to monitor.
+  @param[in]  NotificationFunction  The function to call when the token
+                                    specified by Guid and TokenNumber is set.
+
+**/
+VOID
+EFIAPI
+LibPcdCallbackOnSet (
+  IN CONST GUID               *Guid,       OPTIONAL
+  IN UINTN                    TokenNumber,
+  IN PCD_CALLBACK             NotificationFunction
+  );
+
+
+/**
+  Disable a notification function that was established with LibPcdCallbackonSet().
+
+  Disable a notification function that was previously established with LibPcdCallbackOnSet().
+  If NotificationFunction is NULL, then ASSERT().
+  If LibPcdCallbackOnSet() was not previously called with Guid, TokenNumber,
+  and NotificationFunction, then ASSERT().
+
+  @param[in]  Guid                 Specify the GUID token space.
+  @param[in]  TokenNumber          Specify the token number.
+  @param[in]  NotificationFunction The callback function to be unregistered.
+
+**/
+VOID
+EFIAPI
+LibPcdCancelCallback (
+  IN CONST GUID               *Guid,       OPTIONAL
+  IN UINTN                    TokenNumber,
+  IN PCD_CALLBACK             NotificationFunction
+  );
+
+
+/**
+  Retrieves the next token in a token space.
+
+  Retrieves the next PCD token number from the token space specified by Guid.
+  If Guid is NULL, then the default token space is used.  If TokenNumber is 0,
+  then the first token number is returned.  Otherwise, the token number that
+  follows TokenNumber in the token space is returned.  If TokenNumber is the last
+  token number in the token space, then 0 is returned.
+
+  If TokenNumber is not 0 and is not in the token space specified by Guid, then ASSERT().
+
+  @param[in]  Guid        Pointer to a 128-bit unique value that designates which namespace
+                          to set a value from.  If NULL, then the default token space is used.
+  @param[in]  TokenNumber The previous PCD token number.  If 0, then retrieves the first PCD
+                          token number.
+
+  @return The next valid token number.
+
+**/
+UINTN
+EFIAPI
+LibPcdGetNextToken (
+  IN CONST GUID               *Guid,       OPTIONAL
+  IN UINTN                    TokenNumber
+  );
+
+
+
+/**
+  Used to retrieve the list of available PCD token space GUIDs.
+
+  Returns the PCD token space GUID that follows TokenSpaceGuid in the list of token spaces
+  in the platform.
+  If TokenSpaceGuid is NULL, then a pointer to the first PCD token spaces returned.
+  If TokenSpaceGuid is the last PCD token space GUID in the list, then NULL is returned.
+
+  @param  TokenSpaceGuid  Pointer to the a PCD token space GUID
+
+  @return The next valid token namespace.
+
+**/
+GUID *
+EFIAPI
+LibPcdGetNextTokenSpace (
+  IN CONST GUID  *TokenSpaceGuid
+  );
+
+
+/**
+  Sets a value of a patchable PCD entry that is type pointer.
+
+  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
+  and SizeOfBuffer.  Buffer is returned.  If SizeOfBuffer is greater than
+  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
+  NULL to indicate that the set operation was not actually performed.
+  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
+  MaximumDatumSize and NULL must be returned.
+
+  If PatchVariable is NULL, then ASSERT().
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param[out] PatchVariable     A pointer to the global variable in a module that is
+                                the target of the set operation.
+  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
+  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
+  @param[in] Buffer             A pointer to the buffer to used to set the target variable.
+
+  @return Return the pointer to the Buffer that was set.
+
+**/
+VOID *
+EFIAPI
+LibPatchPcdSetPtr (
+  OUT        VOID       *PatchVariable,
+  IN        UINTN       MaximumDatumSize,
+  IN OUT    UINTN       *SizeOfBuffer,
+  IN CONST  VOID        *Buffer
+  );
+
+/**
+  Sets a value of a patchable PCD entry that is type pointer.
+
+  Sets the PCD entry specified by PatchVariable to the value specified
+  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
+  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
+  to indicate that the set operation was not actually performed.
+  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
+  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.
+
+  If PatchVariable is NULL, then ASSERT().
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param[out] PatchVariable     A pointer to the global variable in a module that is
+                                the target of the set operation.
+  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
+  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
+  @param[in] Buffer             A pointer to the buffer to used to set the target variable.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPatchPcdSetPtrS (
+  OUT      VOID     *PatchVariable,
+  IN       UINTN    MaximumDatumSize,
+  IN OUT   UINTN    *SizeOfBuffer,
+  IN CONST VOID     *Buffer
+  );
+
+/**
+  Sets a value and size of a patchable PCD entry that is type pointer.
+
+  Sets the PCD entry specified by PatchVariable to the value specified by Buffer
+  and SizeOfBuffer. Buffer is returned.  If SizeOfBuffer is greater than
+  MaximumDatumSize, then set SizeOfBuffer to MaximumDatumSize and return
+  NULL to indicate that the set operation was not actually performed.
+  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
+  MaximumDatumSize and NULL must be returned.
+
+  If PatchVariable is NULL, then ASSERT().
+  If SizeOfPatchVariable is NULL, then ASSERT().
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param[out] PatchVariable     A pointer to the global variable in a module that is
+                                the target of the set operation.
+  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
+  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
+  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
+  @param[in] Buffer             A pointer to the buffer to used to set the target variable.
+
+  @return Return the pointer to the Buffer that was set.
+
+**/
+VOID *
+EFIAPI
+LibPatchPcdSetPtrAndSize (
+  OUT       VOID        *PatchVariable,
+  OUT       UINTN       *SizeOfPatchVariable,
+  IN        UINTN       MaximumDatumSize,
+  IN OUT    UINTN       *SizeOfBuffer,
+  IN CONST  VOID        *Buffer
+  );
+
+/**
+  Sets a value and size of a patchable PCD entry that is type pointer.
+
+  Sets the PCD entry specified by PatchVariable to the value specified
+  by Buffer and SizeOfBuffer. If SizeOfBuffer is greater than MaximumDatumSize,
+  then set SizeOfBuffer to MaximumDatumSize and return RETURN_INVALID_PARAMETER
+  to indicate that the set operation was not actually performed.
+  If SizeOfBuffer is set to MAX_ADDRESS, then SizeOfBuffer must be set to
+  MaximumDatumSize and RETURN_INVALID_PARAMETER must be returned.
+
+  If PatchVariable is NULL, then ASSERT().
+  If SizeOfPatchVariable is NULL, then ASSERT().
+  If SizeOfBuffer is NULL, then ASSERT().
+  If SizeOfBuffer > 0 and Buffer is NULL, then ASSERT().
+
+  @param[out] PatchVariable     A pointer to the global variable in a module that is
+                                the target of the set operation.
+  @param[out] SizeOfPatchVariable A pointer to the size, in bytes, of PatchVariable.
+  @param[in] MaximumDatumSize   The maximum size allowed for the PCD entry specified by PatchVariable.
+  @param[in, out] SizeOfBuffer  A pointer to the size, in bytes, of Buffer.
+  @param[in] Buffer             A pointer to the buffer to used to set the target variable.
+
+  @return The status of the set operation.
+
+**/
+RETURN_STATUS
+EFIAPI
+LibPatchPcdSetPtrAndSizeS (
+  OUT      VOID     *PatchVariable,
+  OUT      UINTN    *SizeOfPatchVariable,
+  IN       UINTN    MaximumDatumSize,
+  IN OUT   UINTN    *SizeOfBuffer,
+  IN CONST VOID     *Buffer
+  );
+
+typedef enum {
+  PCD_TYPE_8,
+  PCD_TYPE_16,
+  PCD_TYPE_32,
+  PCD_TYPE_64,
+  PCD_TYPE_BOOL,
+  PCD_TYPE_PTR
+} PCD_TYPE;
+
+typedef struct {
+  ///
+  /// The returned information associated with the requested TokenNumber. If
+  /// TokenNumber is 0, then PcdType is set to PCD_TYPE_8.
+  ///
+  PCD_TYPE          PcdType;
+  ///
+  /// The size of the data in bytes associated with the TokenNumber specified. If
+  /// TokenNumber is 0, then PcdSize is set 0.
+  ///
+  UINTN             PcdSize;
+  ///
+  /// The null-terminated ASCII string associated with a given token. If the
+  /// TokenNumber specified was 0, then this field corresponds to the null-terminated
+  /// ASCII string associated with the token's namespace Guid. If NULL, there is no
+  /// name associated with this request.
+  ///
+  CHAR8             *PcdName;
+} PCD_INFO;
+
+
+/**
+  Retrieve additional information associated with a PCD token.
+
+  This includes information such as the type of value the TokenNumber is associated with as well as possible
+  human readable name that is associated with the token.
+
+  If TokenNumber is not in the default token space specified, then ASSERT().
+
+  @param[in]    TokenNumber The PCD token number.
+  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
+                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
+**/
+VOID
+EFIAPI
+LibPcdGetInfo (
+  IN        UINTN           TokenNumber,
+  OUT       PCD_INFO        *PcdInfo
+  );
+
+/**
+  Retrieve additional information associated with a PCD token.
+
+  This includes information such as the type of value the TokenNumber is associated with as well as possible
+  human readable name that is associated with the token.
+
+  If TokenNumber is not in the token space specified by Guid, then ASSERT().
+
+  @param[in]    Guid        The 128-bit unique value that designates the namespace from which to extract the value.
+  @param[in]    TokenNumber The PCD token number.
+  @param[out]   PcdInfo     The returned information associated with the requested TokenNumber.
+                            The caller is responsible for freeing the buffer that is allocated by callee for PcdInfo->PcdName.
+**/
+VOID
+EFIAPI
+LibPcdGetInfoEx (
+  IN CONST  GUID            *Guid,
+  IN        UINTN           TokenNumber,
+  OUT       PCD_INFO        *PcdInfo
+  );
+
+/**
+  Retrieve the currently set SKU Id.
+
+  @return   The currently set SKU Id. If the platform has not set at a SKU Id, then the
+            default SKU Id value of 0 is returned. If the platform has set a SKU Id, then the currently set SKU
+            Id is returned.
+**/
+UINTN
+EFIAPI
+LibPcdGetSku (
+  VOID
+  );
+
+#endif
diff --git a/libedk2_tpm/include/ProcessorBind.h b/libedk2_tpm/include/ProcessorBind.h
new file mode 100644
index 0000000..dd5e7e7
--- /dev/null
+++ b/libedk2_tpm/include/ProcessorBind.h
@@ -0,0 +1,323 @@
+/** @file
+  Processor or Compiler specific defines and types for IA-32 architecture.
+
+Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef __PROCESSOR_BIND_H__
+#define __PROCESSOR_BIND_H__
+#include <efi.h>
+#include <efiapi.h>
+///
+/// Define the processor type so other code can make processor based choices.
+///
+#define MDE_CPU_IA32
+
+//
+// Make sure we are using the correct packing rules per EFI specification
+//
+#if !defined(__GNUC__)
+#pragma pack()
+#endif
+
+#if defined(__INTEL_COMPILER)
+//
+// Disable ICC's remark #869: "Parameter" was never referenced warning.
+// This is legal ANSI C code so we disable the remark that is turned on with -Wall
+//
+#pragma warning ( disable : 869 )
+
+//
+// Disable ICC's remark #1418: external function definition with no prior declaration.
+// This is legal ANSI C code so we disable the remark that is turned on with /W4
+//
+#pragma warning ( disable : 1418 )
+
+//
+// Disable ICC's remark #1419: external declaration in primary source file
+// This is legal ANSI C code so we disable the remark that is turned on with /W4
+//
+#pragma warning ( disable : 1419 )
+
+//
+// Disable ICC's remark #593: "Variable" was set but never used.
+// This is legal ANSI C code so we disable the remark that is turned on with /W4
+//
+#pragma warning ( disable : 593 )
+
+#endif
+
+
+#if defined(_MSC_EXTENSIONS)
+
+//
+// Disable warning that make it impossible to compile at /W4
+// This only works for Microsoft* tools
+//
+
+//
+// Disabling bitfield type checking warnings.
+//
+#pragma warning ( disable : 4214 )
+
+//
+// Disabling the unreferenced formal parameter warnings.
+//
+#pragma warning ( disable : 4100 )
+
+//
+// Disable slightly different base types warning as CHAR8 * can not be set
+// to a constant string.
+//
+#pragma warning ( disable : 4057 )
+
+//
+// ASSERT(FALSE) or while (TRUE) are legal constructs so suppress this warning
+//
+#pragma warning ( disable : 4127 )
+
+//
+// This warning is caused by functions defined but not used. For precompiled header only.
+//
+#pragma warning ( disable : 4505 )
+
+//
+// This warning is caused by empty (after preprocessing) source file. For precompiled header only.
+//
+#pragma warning ( disable : 4206 )
+
+#if defined(_MSC_VER) && _MSC_VER >= 1800
+
+//
+// Disable these warnings for VS2013.
+//
+
+//
+// This warning is for potentially uninitialized local variable, and it may cause false
+// positive issues in VS2013 and VS2015 build
+//
+#pragma warning ( disable : 4701 )
+
+//
+// This warning is for potentially uninitialized local pointer variable, and it may cause
+// false positive issues in VS2013 and VS2015 build
+//
+#pragma warning ( disable : 4703 )
+
+#endif
+
+#endif
+
+#if 0
+#if defined(_MSC_EXTENSIONS)
+
+  //
+  // use Microsoft C compiler dependent integer width types
+  //
+
+  ///
+  /// 8-byte unsigned value.
+  ///
+  typedef unsigned __int64    UINT64;
+  ///
+  /// 8-byte signed value.
+  ///
+  typedef __int64             INT64;
+  ///
+  /// 4-byte unsigned value.
+  ///
+  typedef unsigned __int32    UINT32;
+  ///
+  /// 4-byte signed value.
+  ///
+  typedef __int32             INT32;
+  ///
+  /// 2-byte unsigned value.
+  ///
+  typedef unsigned short      UINT16;
+  ///
+  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
+  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
+  ///
+  typedef unsigned short      CHAR16;
+  ///
+  /// 2-byte signed value.
+  ///
+  typedef short               INT16;
+  ///
+  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
+  /// values are undefined.
+  ///
+  typedef unsigned char       BOOLEAN;
+  ///
+  /// 1-byte unsigned value.
+  ///
+  typedef unsigned char       UINT8;
+  ///
+  /// 1-byte Character.
+  ///
+  typedef char                CHAR8;
+  ///
+  /// 1-byte signed value.
+  ///
+  typedef signed char         INT8;
+#else
+  ///
+  /// 8-byte unsigned value.
+  ///
+  typedef unsigned long long  UINT64;
+  ///
+  /// 8-byte signed value.
+  ///
+  typedef long long           INT64;
+  ///
+  /// 4-byte unsigned value.
+  ///
+  typedef unsigned int        UINT32;
+  ///
+  /// 4-byte signed value.
+  ///
+  typedef int                 INT32;
+  ///
+  /// 2-byte unsigned value.
+  ///
+  typedef unsigned short      UINT16;
+  ///
+  /// 2-byte Character.  Unless otherwise specified all strings are stored in the
+  /// UTF-16 encoding format as defined by Unicode 2.1 and ISO/IEC 10646 standards.
+  ///
+  typedef unsigned short      CHAR16;
+  ///
+  /// 2-byte signed value.
+  ///
+  typedef short               INT16;
+  ///
+  /// Logical Boolean.  1-byte value containing 0 for FALSE or a 1 for TRUE.  Other
+  /// values are undefined.
+  ///
+  typedef unsigned char       BOOLEAN;
+  ///
+  /// 1-byte unsigned value.
+  ///
+  typedef unsigned char       UINT8;
+  ///
+  /// 1-byte Character
+  ///
+  typedef char                CHAR8;
+  ///
+  /// 1-byte signed value
+  ///
+  typedef signed char         INT8;
+#endif
+
+#endif
+///
+/// Unsigned value of native width.  (4 bytes on supported 32-bit processor instructions;
+/// 8 bytes on supported 64-bit processor instructions.)
+///
+typedef UINT32  UINTN;
+///
+/// Signed value of native width.  (4 bytes on supported 32-bit processor instructions;
+/// 8 bytes on supported 64-bit processor instructions.)
+///
+typedef INT32   INTN;
+
+//
+// Processor specific defines
+//
+
+///
+/// A value of native width with the highest bit set.
+///
+#define MAX_BIT     0x80000000
+///
+/// A value of native width with the two highest bits set.
+///
+#define MAX_2_BITS  0xC0000000
+
+///
+/// Maximum legal IA-32 address.
+///
+#define MAX_ADDRESS   0xFFFFFFFF
+
+///
+/// Maximum usable address at boot time
+///
+#define MAX_ALLOC_ADDRESS   MAX_ADDRESS
+
+///
+/// Maximum legal IA-32 INTN and UINTN values.
+///
+#define MAX_INTN   ((INTN)0x7FFFFFFF)
+#define MAX_UINTN  ((UINTN)0xFFFFFFFF)
+
+///
+/// Minimum legal IA-32 INTN value.
+///
+#define MIN_INTN   (((INTN)-2147483647) - 1)
+
+///
+/// The stack alignment required for IA-32.
+///
+#define CPU_STACK_ALIGNMENT   sizeof(UINTN)
+
+///
+/// Page allocation granularity for IA-32.
+///
+#define DEFAULT_PAGE_ALLOCATION_GRANULARITY   (0x1000)
+#define RUNTIME_PAGE_ALLOCATION_GRANULARITY   (0x1000)
+
+//
+// Modifier to ensure that all protocol member functions and EFI intrinsics
+// use the correct C calling convention. All protocol member functions and
+// EFI intrinsics are required to modify their member functions with EFIAPI.
+//
+#ifdef EFIAPI
+  ///
+  /// If EFIAPI is already defined, then we use that definition.
+  ///
+#elif defined(_MSC_EXTENSIONS)
+  ///
+  /// Microsoft* compiler specific method for EFIAPI calling convention.
+  ///
+  #define EFIAPI __cdecl
+#elif defined(__GNUC__) || defined(__clang__)
+  ///
+  /// GCC specific method for EFIAPI calling convention.
+  ///
+  #define EFIAPI __attribute__((cdecl))
+#else
+  ///
+  /// The default for a non Microsoft* or GCC compiler is to assume the EFI ABI
+  /// is the standard.
+  ///
+  #define EFIAPI
+#endif
+
+#if defined(__GNUC__) || defined(__clang__)
+  ///
+  /// For GNU assembly code, .global or .globl can declare global symbols.
+  /// Define this macro to unify the usage.
+  ///
+  #define ASM_GLOBAL .globl
+#endif
+
+/**
+  Return the pointer to the first instruction of a function given a function pointer.
+  On IA-32 CPU architectures, these two pointer values are the same,
+  so the implementation of this macro is very simple.
+
+  @param  FunctionPointer   A pointer to a function.
+
+  @return The pointer to the first instruction of a function given a function pointer.
+
+**/
+#define FUNCTION_ENTRY_POINT(FunctionPointer) (VOID *)(UINTN)(FunctionPointer)
+
+#ifndef __USER_LABEL_PREFIX__
+#define __USER_LABEL_PREFIX__ _
+#endif
+
+#endif
diff --git a/libedk2_tpm/include/RegisterFilterLib.h b/libedk2_tpm/include/RegisterFilterLib.h
new file mode 100644
index 0000000..38e4de9
--- /dev/null
+++ b/libedk2_tpm/include/RegisterFilterLib.h
@@ -0,0 +1,243 @@
+/** @file
+  Public include file for the Port IO/MMIO/MSR RegisterFilterLib.
+
+Copyright (c) 2021, Intel Corporation. All rights reserved.<BR>
+
+SPDX-License-Identifier: BSD-2-Clause-Patent
+
+**/
+
+#ifndef REGISTER_FILTER_LIB_H_
+#define REGISTER_FILTER_LIB_H_
+
+typedef enum {
+  FilterWidth8,
+  FilterWidth16,
+  FilterWidth32,
+  FilterWidth64
+} FILTER_IO_WIDTH;
+
+/**
+  Filter IO read operation before read IO port.
+  It is used to filter IO read operation.
+
+  It will return the flag to decide whether require read real IO port.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in]       Buffer   The destination buffer to store the results.
+
+  @retval TRUE         Need to excute the IO read.
+  @retval FALSE        Skip the IO read.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeIoRead1 (
+  IN FILTER_IO_WIDTH   Width,
+  IN UINTN             Address,
+  IN OUT VOID          *Buffer
+  );
+
+/**
+  Trace IO read operation after read IO port.
+  It is used to trace IO operation.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in]       Buffer   The destination buffer to store the results.
+
+**/
+VOID
+EFIAPI
+FilterAfterIoRead1 (
+  IN FILTER_IO_WIDTH  Width,
+  IN UINTN            Address,
+  IN VOID             *Buffer
+  );
+/**
+  Filter IO Write operation before wirte IO port.
+  It is used to filter IO operation.
+
+  It will return the flag to decide whether require read write IO port.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in]       Buffer   The source buffer from which to BeforeWrite data.
+
+  @retval TRUE         Need to excute the IO write.
+  @retval FALSE        Skip the IO write.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeIoWrite1 (
+  IN FILTER_IO_WIDTH  Width,
+  IN UINTN            Address,
+  IN VOID             *Buffer
+  );
+
+  /**
+  Trace IO Write operation after wirte IO port.
+  It is used to trace IO operation.
+
+  @param[in]       Width    Signifies the width of the I/O operation.
+  @param[in]       Address  The base address of the I/O operation.
+  @param[in]       Buffer   The source buffer from which to BeforeWrite data.
+
+**/
+VOID
+EFIAPI
+FilterAfterIoWrite1 (
+  IN FILTER_IO_WIDTH  Width,
+  IN UINTN            Address,
+  IN VOID             *Buffer
+  );
+
+/**
+  Filter memory IO before Read operation.
+
+  It will return the flag to decide whether require read real MMIO.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in]       Buffer   The destination buffer to store the results.
+
+  @retval TRUE         Need to excute the MMIO read.
+  @retval FALSE        Skip the MMIO read.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMmIoRead1 (
+  IN FILTER_IO_WIDTH  Width,
+  IN UINTN            Address,
+  IN OUT VOID         *Buffer
+  );
+
+/**
+  Tracer memory IO after read operation
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in]       Buffer   The destination buffer to store the results.
+
+**/
+VOID
+EFIAPI
+FilterAfterMmIoRead1 (
+  IN FILTER_IO_WIDTH  Width,
+  IN UINTN            Address,
+  IN VOID             *Buffer
+  );
+
+/**
+  Filter memory IO before write operation
+
+  It will return the flag to decide whether require wirte real MMIO.
+  It can be used for emulation environment.
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in]       Buffer   The source buffer from which to BeforeWrite data.
+
+  @retval TRUE         Need to excute the MMIO write.
+  @retval FALSE        Skip the MMIO write.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMmIoWrite1 (
+  IN FILTER_IO_WIDTH  Width,
+  IN UINTN            Address,
+  IN VOID             *Buffer
+  );
+
+/**
+  Tracer memory IO after write operation
+
+  @param[in]       Width    Signifies the width of the memory I/O operation.
+  @param[in]       Address  The base address of the memory I/O operation.
+  @param[in]       Buffer   The source buffer from which to BeforeWrite data.
+
+**/
+VOID
+EFIAPI
+FilterAfterMmIoWrite1 (
+  IN FILTER_IO_WIDTH  Width,
+  IN UINTN            Address,
+  IN VOID             *Buffer
+  );
+
+/**
+  Filter MSR before read operation.
+
+  It will return the flag to decide whether require read real MSR.
+  It can be used for emulation environment.
+
+  @param  Index                     The 8-bit Machine Specific Register index to BeforeWrite.
+  @param  Value                     The 64-bit value to BeforeRead from the Machine Specific Register.
+
+  @retval TRUE         Need to excute the MSR read.
+  @retval FALSE        Skip the MSR read.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMsrRead1 (
+  IN UINT32           Index,
+  IN OUT UINT64       *Value
+  );
+
+/**
+  Trace MSR after read operation
+
+  @param  Index                     The 8-bit Machine Specific Register index to BeforeWrite.
+  @param  Value                     The 64-bit value to BeforeRead from the Machine Specific Register.
+
+**/
+VOID
+EFIAPI
+FilterAfterMsrRead1 (
+  IN UINT32            Index,
+  IN UINT64            *Value
+  );
+
+/**
+  Filter MSR before write operation
+
+  It will return the flag to decide whether require write real MSR.
+  It can be used for emulation environment.
+
+  @param  Index                     The 8-bit Machine Specific Register index to BeforeWrite.
+  @param  Value                     The 64-bit value to BeforeWrite to the Machine Specific Register.
+
+  @retval TRUE         Need to excute the MSR write.
+  @retval FALSE        Skip the MSR write.
+
+**/
+BOOLEAN
+EFIAPI
+FilterBeforeMsrWrite1 (
+  IN UINT32           Index,
+  IN UINT64           *Value
+  );
+
+/**
+  Trace MSR after write operation
+
+  @param  Index                     The 8-bit Machine Specific Register index to BeforeWrite.
+  @param  Value                     The 64-bit value to BeforeWrite to the Machine Specific Register.
+
+**/
+VOID
+EFIAPI
+FilterAfterMsrWrite1 (
+  IN UINT32            Index,
+  IN UINT64            *Value
+  );
+
+#endif // REGISTER_FILTER_LIB_H_
diff --git a/libedk2_tpm/include/Tpm12.h b/libedk2_tpm/include/Tpm12.h
index c09875f..4131b45 100644
--- a/libedk2_tpm/include/Tpm12.h
+++ b/libedk2_tpm/include/Tpm12.h
@@ -16,6 +16,9 @@
 #ifndef _TPM12_H_
 #define _TPM12_H_
 
+#include <efi.h>
+#include <efiapi.h>
+
 ///
 /// The start of TPM return codes
 ///
-- 
2.25.1

