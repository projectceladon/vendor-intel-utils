From 8e8493643ef7dff198f1eb9619fd60f86043ca00 Mon Sep 17 00:00:00 2001
From: Ming Tan <ming.tan@intel.com>
Date: Thu, 29 Aug 2019 15:10:51 +0800
Subject: [PATCH 5/6] Fix a bug about fastboot oem set-storage failed when run
 it twice.

Now if the command 'fastboot oem set-storage xxx' failed, will not change
the current boot device.

Change-Id: I6d4ce7ec9b3cc1670ba3b874d01267a28e0944ff
Tracked-On: OAM-85408
Signed-off-by: Ming Tan <ming.tan@intel.com>
Reviewed-on: https://android.intel.com:443/679104
---
 libfastboot/fastboot_oem.c |  1 +
 libkernelflinger/storage.c | 42 ++++++++++++++++++++++----------------
 2 files changed, 25 insertions(+), 18 deletions(-)

diff --git a/libfastboot/fastboot_oem.c b/libfastboot/fastboot_oem.c
index c4481e4..8dc1e36 100755
--- a/libfastboot/fastboot_oem.c
+++ b/libfastboot/fastboot_oem.c
@@ -387,6 +387,7 @@ static void cmd_oem_set_storage(INTN argc, CHAR8 **argv)
 	for (i = 0; i < total_types; i++) {
 		if ((boot_device_type == types[i]) && (user_lun == UFS_DEFAULT_USER_LUN) &&
 		    (factory_lun == UFS_DEFAULT_FACTORY_LUN)) {
+			warning(L"Already use such type device");
 			fastboot_info("Already use such type device");
 			fastboot_okay("");
 			return;
diff --git a/libkernelflinger/storage.c b/libkernelflinger/storage.c
index fcf48d1..a2bdbb8 100644
--- a/libkernelflinger/storage.c
+++ b/libkernelflinger/storage.c
@@ -115,8 +115,11 @@ EFI_STATUS identify_boot_device(enum storage_type filter)
 	struct storage *storage;
 	enum storage_type type;
 	EFI_HANDLE new_boot_device_handle = NULL;
+	PCI_DEVICE_PATH new_boot_device = { .Function = -1, .Device = -1 };
+	enum storage_type new_boot_device_type;
+	struct storage *new_storage;
 
-	cur_storage = NULL;
+	new_storage = NULL;
 	ret = uefi_call_wrapper(BS->LocateHandleBuffer, 5, ByProtocol,
 				&BlockIoProtocol, NULL, &nb_handle, &handles);
 	if (EFI_ERROR(ret)) {
@@ -124,7 +127,7 @@ EFI_STATUS identify_boot_device(enum storage_type filter)
 		return ret;
 	}
 
-	boot_device.Header.Type = 0;
+	new_boot_device.Header.Type = 0;
 	for (i = 0; i < nb_handle; i++) {
 		device_path = DevicePathFromHandle(handles[i]);
 		if (!device_path)
@@ -134,30 +137,30 @@ EFI_STATUS identify_boot_device(enum storage_type filter)
 		if (!pci)
 			continue;
 
-		if (boot_device.Function == pci->Function &&
-		    boot_device.Device == pci->Device &&
-		    boot_device.Header.Type == pci->Header.Type &&
-		    boot_device.Header.SubType == pci->Header.SubType)
+		if (new_boot_device.Function == pci->Function &&
+				new_boot_device.Device == pci->Device &&
+				new_boot_device.Header.Type == pci->Header.Type &&
+				new_boot_device.Header.SubType == pci->Header.SubType)
 			continue;
 
 		ret = identify_storage(device_path, filter, &storage, &type);
 		if (EFI_ERROR(ret))
 			continue;
 
-		if (!boot_device.Header.Type || boot_device_type >= type) {
-			memcpy(&boot_device, pci, sizeof(boot_device));
-			boot_device_type = type;
-			cur_storage = storage;
-			new_boot_device_handle = handles[i];
+		if (!new_boot_device.Header.Type || new_boot_device_type >= type) {
+				memcpy(&new_boot_device, pci, sizeof(new_boot_device));
+				new_boot_device_type = type;
+				new_storage = storage;
+				new_boot_device_handle = handles[i];
 			continue;
 		}
 
-		if (boot_device_type == type &&
-		    type != STORAGE_GENERAL_BLOCK &&
-		    filter > type) {
+		if (new_boot_device_type == type &&
+				type != STORAGE_GENERAL_BLOCK &&
+				filter > type) {
 			error(L"Multiple identifcal storage found! Can't make a decision");
-			cur_storage = NULL;
-			boot_device.Header.Type = 0;
+			new_storage = NULL;
+			new_boot_device.Header.Type = 0;
 			FreePool(handles);
 			return EFI_UNSUPPORTED;
 		}
@@ -165,11 +168,14 @@ EFI_STATUS identify_boot_device(enum storage_type filter)
 
 	FreePool(handles);
 
-	if (!cur_storage) {
-		error(L"No PCI storage found");
+	if (!new_storage) {
+		error(L"No PCI storage found for type %d", filter);
 		return EFI_UNSUPPORTED;
 	}
+	cur_storage = new_storage;
+	boot_device_type = new_boot_device_type;
 	boot_device_handle = new_boot_device_handle;
+	memcpy(&boot_device, &new_boot_device, sizeof(new_boot_device));
 
 	debug(L"%s storage selected", cur_storage->name);
 	return EFI_SUCCESS;
-- 
2.21.0

