From b74cead05524f9c00c82019accf351022d274a86 Mon Sep 17 00:00:00 2001
From: "xue.yifei" <yifei.xue@intel.com>
Date: Tue, 2 Jul 2019 13:41:50 +0800
Subject: [PATCH 1/8] minigbm-intel : add framebuffer device implementation in
 gralloc1

Change-Id: Id10d651e0ec0d1a373d8a2e6fbd473154614c00b
Signed-off-by: xue.yifei <yifei.xue@intel.com>
Reviewed-on: 674558
Reviewed-by: Shi, Zhongjie <zhongjie.shi@intel.com>
---
 Android.mk                                    |   4 +-
 cros_gralloc/cros_gralloc_buffer.cc           |   6 +
 cros_gralloc/cros_gralloc_buffer.h            |   2 +
 cros_gralloc/cros_gralloc_driver.cc           |  74 +-
 cros_gralloc/cros_gralloc_driver.h            |   7 +-
 cros_gralloc/gralloc0/gralloc0.cc             | 215 ++++-
 cros_gralloc/gralloc1/cros_gralloc1_module.cc | 343 ++++++--
 cros_gralloc/gralloc1/cros_gralloc1_module.h  |  22 +-
 drv.c                                         | 759 +++++++++++++++++-
 drv.h                                         |  21 +
 drv_priv.h                                    |  36 +-
 i915.c                                        |  36 +-
 12 files changed, 1428 insertions(+), 97 deletions(-)
 mode change 100644 => 100755 Android.mk
 mode change 100644 => 100755 cros_gralloc/cros_gralloc_buffer.cc
 mode change 100644 => 100755 cros_gralloc/cros_gralloc_buffer.h
 mode change 100644 => 100755 cros_gralloc/cros_gralloc_driver.cc
 mode change 100644 => 100755 cros_gralloc/cros_gralloc_driver.h
 mode change 100644 => 100755 cros_gralloc/gralloc0/gralloc0.cc
 mode change 100644 => 100755 cros_gralloc/gralloc1/cros_gralloc1_module.cc
 mode change 100644 => 100755 cros_gralloc/gralloc1/cros_gralloc1_module.h
 mode change 100644 => 100755 drv.c
 mode change 100644 => 100755 drv.h
 mode change 100644 => 100755 drv_priv.h
 mode change 100644 => 100755 i915.c

diff --git a/Android.mk b/Android.mk
old mode 100644
new mode 100755
index 2a598c6..c0b58fb
--- a/Android.mk
+++ b/Android.mk
@@ -53,7 +53,7 @@ LOCAL_C_INCLUDES += frameworks/native/libs/nativebase/include \
 ifneq ($(filter $(intel_drivers), $(BOARD_GPU_DRIVERS)),)
 LOCAL_CPPFLAGS += -DDRV_I915
 LOCAL_CFLAGS += -DDRV_I915
-LOCAL_SHARED_LIBRARIES += libdrm_intel
+LOCAL_SHARED_LIBRARIES += libdrm_intel libGLESv2
 endif
 
 ifeq ($(shell test $(PLATFORM_SDK_VERSION) -ge 27; echo $$?), 0)
@@ -64,7 +64,7 @@ LOCAL_CFLAGS += -DUSE_VNDK
 endif
 
 LOCAL_CFLAGS += -Wno-error
-LOCAL_MODULE := gralloc.$(TARGET_BOARD_PLATFORM)
+LOCAL_MODULE := gralloc.intel
 LOCAL_MODULE_TAGS := optional
 # The preferred path for vendor HALs is /vendor/lib/hw
 LOCAL_PROPRIETARY_MODULE := true
diff --git a/cros_gralloc/cros_gralloc_buffer.cc b/cros_gralloc/cros_gralloc_buffer.cc
old mode 100644
new mode 100755
index c1c8764..c760f15
--- a/cros_gralloc/cros_gralloc_buffer.cc
+++ b/cros_gralloc/cros_gralloc_buffer.cc
@@ -98,3 +98,9 @@ int32_t cros_gralloc_buffer::unlock()
 
 	return 0;
 }
+
+struct bo *cros_gralloc_buffer::get_bo() const
+{
+    return bo_;
+}
+
diff --git a/cros_gralloc/cros_gralloc_buffer.h b/cros_gralloc/cros_gralloc_buffer.h
old mode 100644
new mode 100755
index f629199..72bf971
--- a/cros_gralloc/cros_gralloc_buffer.h
+++ b/cros_gralloc/cros_gralloc_buffer.h
@@ -26,6 +26,8 @@ class cros_gralloc_buffer
 	int32_t lock(uint32_t map_flags, uint8_t *addr[DRV_MAX_PLANES]);
 	int32_t unlock();
 
+  	struct bo *get_bo() const;
+
       private:
 	cros_gralloc_buffer(cros_gralloc_buffer const &);
 	cros_gralloc_buffer operator=(cros_gralloc_buffer const &);
diff --git a/cros_gralloc/cros_gralloc_driver.cc b/cros_gralloc/cros_gralloc_driver.cc
old mode 100644
new mode 100755
index 7581fb6..fecef3e
--- a/cros_gralloc/cros_gralloc_driver.cc
+++ b/cros_gralloc/cros_gralloc_driver.cc
@@ -15,6 +15,8 @@
 #include <unistd.h>
 #include <xf86drm.h>
 
+#include <log/log.h>
+
 cros_gralloc_driver::cros_gralloc_driver() : drv_(nullptr)
 {
 }
@@ -41,10 +43,15 @@ int32_t cros_gralloc_driver::init()
 
 	int fd;
 	drmVersionPtr version;
-	char const *str = "%s/renderD%d";
-	const char *undesired[2] = { "vgem", nullptr };
-	uint32_t num_nodes = 63;
-	uint32_t min_node = 128;
+	//char const *str = "%s/renderD%d";
+	//const char *undesired[2] = { "vgem", nullptr };
+	//uint32_t num_nodes = 63;
+	//uint32_t min_node = 128;
+
+	char const *str = "%s/card%d";	
+    const char *undesired[2] = { "vgem", nullptr };
+	uint32_t num_nodes = 1;
+	uint32_t min_node = 0;
 	uint32_t max_node = (min_node + num_nodes);
 
 	for (uint32_t i = 0; i < ARRAY_SIZE(undesired); i++) {
@@ -53,6 +60,8 @@ int32_t cros_gralloc_driver::init()
 			if (asprintf(&node, str, DRM_DIR_NAME, j) < 0)
 				continue;
 
+            ALOGI("open(%s)", node);
+
 			fd = open(node, O_RDWR, 0);
 			free(node);
 
@@ -65,6 +74,8 @@ int32_t cros_gralloc_driver::init()
 				continue;
 			}
 
+            cros_gralloc_log("CROS_GRALLOC_INFO", __FILE__, __LINE__, "drm version->name =%s", version->name);
+
 			if (undesired[i] && !strcmp(version->name, undesired[i])) {
 				drmFreeVersion(version);
 				close(fd);
@@ -343,3 +354,58 @@ cros_gralloc_buffer *cros_gralloc_driver::get_buffer(cros_gralloc_handle_t hnd)
 
 	return nullptr;
 }
+
+int cros_gralloc_driver::init_kms()
+{
+    int ret = 0;
+
+    ALOGI("%s:%d", __func__, __LINE__);
+    
+    ret = drv_init_kms(drv_);
+    if(ret) {
+        cros_gralloc_error("Init kms failed");        
+    }
+    return ret;
+}
+
+int cros_gralloc_driver::get_kms_info(kms_info_t* info) 
+{
+    int ret = 0;
+
+    ALOGI("%s:%d", __func__, __LINE__);
+    
+    ret = drv_get_kms_info(drv_, info);
+    if(ret) {
+       cros_gralloc_error("Get kms info failed");  
+    }
+
+    return ret;
+}
+
+int cros_gralloc_driver::kms_present(buffer_handle_t handle)
+{
+    int ret = 0;
+
+	SCOPED_SPIN_LOCK(mutex_);
+	cros_gralloc_handle_t hnd = cros_gralloc_convert_handle(handle);
+	if (!hnd) {
+		cros_gralloc_error("Invalid handle.");
+		return -EINVAL;
+	}
+
+	cros_gralloc_buffer* buffer = get_buffer(hnd);
+	if (!buffer) {
+		cros_gralloc_error("Invalid Reference.");
+		return -EINVAL;
+	}
+
+    drv_present_bo(drv_, buffer->get_bo());
+
+    return ret;
+}
+
+void cros_gralloc_driver::fini_kms()
+{
+    ALOGI("%s:%d", __func__, __LINE__);
+    drv_fini_kms(drv_);
+}
diff --git a/cros_gralloc/cros_gralloc_driver.h b/cros_gralloc/cros_gralloc_driver.h
old mode 100644
new mode 100755
index 375506f..b6ae09c
--- a/cros_gralloc/cros_gralloc_driver.h
+++ b/cros_gralloc/cros_gralloc_driver.h
@@ -19,7 +19,7 @@ class cros_gralloc_driver
 	cros_gralloc_driver();
 	~cros_gralloc_driver();
 
-	int32_t init();
+	int32_t init();  
 	bool is_supported(const struct cros_gralloc_buffer_descriptor *descriptor);
 	int32_t allocate(const struct cros_gralloc_buffer_descriptor *descriptor,
 			 buffer_handle_t *out_handle);
@@ -33,6 +33,11 @@ class cros_gralloc_driver
 
 	int32_t get_backing_store(buffer_handle_t handle, uint64_t *out_store);
 
+    int init_kms();
+    int get_kms_info(kms_info_t* info);
+    int kms_present(buffer_handle_t handle);
+    void fini_kms();
+    
       private:
 	cros_gralloc_driver(cros_gralloc_driver const &);
 	cros_gralloc_driver operator=(cros_gralloc_driver const &);
diff --git a/cros_gralloc/gralloc0/gralloc0.cc b/cros_gralloc/gralloc0/gralloc0.cc
old mode 100644
new mode 100755
index 7d5b004..44c30e0
--- a/cros_gralloc/gralloc0/gralloc0.cc
+++ b/cros_gralloc/gralloc0/gralloc0.cc
@@ -7,14 +7,23 @@
 #include "../cros_gralloc_driver.h"
 
 #include <hardware/gralloc.h>
+#include <hardware/fb.h>
 #include <memory.h>
+#include <stdlib.h>
+
+#include <log/log.h>
+
+#include <GLES2/gl2.h>
 
 #include "../i915_private_android.h"
 #include "../i915_private_android_types.h"
 
+#define DEBUG_GRALLOC_API   1
+
 struct gralloc0_module {
 	gralloc_module_t base;
 	std::unique_ptr<alloc_device_t> alloc;
+    framebuffer_device_t* fb;
 	std::unique_ptr<cros_gralloc_driver> driver;
 	bool initialized;
 	SpinLock initialization_mutex;
@@ -35,6 +44,119 @@ enum {
 };
 // clang-format on
 
+
+
+
+/*
+  * framebuffer_device_t  implementation
+  */
+static int fb_setSwapInterval(struct framebuffer_device_t* dev, int interval)
+{
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+    auto mod = (struct gralloc0_module *)dev->common.module;  
+    if ((interval < dev->minSwapInterval) || (interval > dev->maxSwapInterval)) {
+	        return -EINVAL;
+    }
+    return 0;
+}
+
+static int fb_setUpdateRect(struct framebuffer_device_t* dev, int left, int top, int width, int height)
+{
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d", __func__, __LINE__);
+#endif 
+
+    auto mod = (struct gralloc0_module *)dev->common.module;  
+    return 0;
+}
+
+static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
+{
+#if DEBUG_GRALLOC_API	
+        ALOGI("fb_post(%p) starts", (void*)buffer);
+#endif 
+
+    auto mod = (struct gralloc0_module *)dev->common.module;  
+    int ret = 0;
+
+	if(!buffer)
+        return -EINVAL;		
+
+    // parser handle
+
+    // add fb if needed
+
+    // post
+
+#if DEBUG_GRALLOC_API
+    ALOGI("fb_post returns %d", ret);
+#endif 
+
+    return ret;
+}
+
+static int fb_compositionComplete(struct framebuffer_device_t* dev)
+{
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d", __func__, __LINE__);
+#endif 
+
+    auto mod = (struct gralloc0_module *)dev->common.module; 
+    int ret = 0;
+  
+    glFlush();
+    // glFinish();
+    
+    return ret;
+}
+
+
+void fb_dump(struct framebuffer_device_t* dev, char *buff, int buff_len)
+{
+#if DEBUG_GRALLOC_API
+    ALOGI("%s: %d", __func__, __LINE__);
+#endif 
+
+}
+
+
+int fb_enableScreen(struct framebuffer_device_t* dev, int enable)
+{
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+    auto mod = (struct gralloc0_module *)dev->common.module; 
+    int ret = 0;
+
+    return ret;
+}
+
+
+static int fb_close(struct hw_device_t* dev)
+{
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+
+    auto mod = (struct gralloc0_module *)dev->module; 
+    int ret = 0;
+
+
+    if(mod->fb) {
+        free(mod->fb);
+        mod->fb = nullptr;
+    }
+    
+    return ret;
+}
+
+
+
 static uint64_t gralloc0_convert_usage(int usage)
 {
 	uint64_t use_flags = BO_USE_NONE;
@@ -145,7 +267,7 @@ static int gralloc0_close(struct hw_device_t *dev)
 	return 0;
 }
 
-static int gralloc0_init(struct gralloc0_module *mod, bool initialize_alloc)
+static int gralloc0_init(struct gralloc0_module *mod, bool initialize_alloc, bool initialize_fb)
 {
 	SCOPED_SPIN_LOCK(mod->initialization_mutex);
 
@@ -168,6 +290,51 @@ static int gralloc0_init(struct gralloc0_module *mod, bool initialize_alloc)
 		mod->alloc->common.close = gralloc0_close;
 	}
 
+    if(initialize_fb) {
+        mod->fb = (framebuffer_device_t*)malloc(sizeof(framebuffer_device_t));
+        memset(mod->fb, 0, sizeof(framebuffer_device_t));
+        
+        mod->fb->setSwapInterval = fb_setSwapInterval;
+        mod->fb->setUpdateRect = fb_setUpdateRect;
+        mod->fb->post = fb_post;
+        mod->fb->compositionComplete = fb_compositionComplete;
+        mod->fb->dump = fb_dump;
+        mod->fb->enableScreen = fb_enableScreen;
+        mod->fb->common.close = fb_close;
+
+#if 0
+        yalloc_kms_info_t info;
+        memset(&info, 0, sizeof(yalloc_kms_info_t));
+        yalloc_drm_get_kms_info((struct yalloc_drm_t *)(_module->priv), &info);
+        const_cast<uint32_t&>(mod->fb->flags)     	= info.flags;
+        const_cast<uint32_t&>(mod->fb->width)      = info.width;
+        const_cast<uint32_t&>(mod->fb->height)     = info.height;
+        const_cast<int&>(mod->fb->stride)          = info.stride;
+
+        const_cast<int&>(mod->fb->.format)         	= info.format;
+        const_cast<float&>(mod->fb->.xdpi)          = info.xdpi;
+        const_cast<float&>(mod->fb->ydpi)          = info.ydpi;
+        const_cast<float&>(mod->fb->fps)           = info.fps;
+        const_cast<int&>(mod->fb->minSwapInterval)	= info.minSwapInterval;
+        const_cast<int&>(mod->fb->maxSwapInterval) = info.maxSwapInterval;
+        const_cast<int&>(mod->fb->numFramebuffers) = info.numFramebuffers;
+
+#endif     
+        ALOGI("fb.width  %d\n"
+              "fb.height %d\n"
+              "fb.fps    %f\n"
+              "fb.format 0x%x\n"
+              "fb.xdpi   %f\n"
+              "fb.ydpi   %f\n",
+              mod->fb->width,
+              mod->fb->height,
+              mod->fb->fps,
+              mod->fb->format,
+              mod->fb->xdpi, 
+              mod->fb->ydpi);
+            
+    }
+
 	mod->initialized = true;
 	return 0;
 }
@@ -175,25 +342,29 @@ static int gralloc0_init(struct gralloc0_module *mod, bool initialize_alloc)
 static int gralloc0_open(const struct hw_module_t *mod, const char *name, struct hw_device_t **dev)
 {
 	auto module = (struct gralloc0_module *)mod;
-
-	if (module->initialized) {
-		*dev = &module->alloc->common;
-		return 0;
-	}
-
-        /* On Android M, Surfaceflinger tries to open the gralloc device
-         * using name GRALLOC_HARDWARE_FB0.
-         */
-        if ((strcmp(name, GRALLOC_HARDWARE_GPU0)!=0) && (strcmp(name, GRALLOC_HARDWARE_FB0)!=0)) {
-		cros_gralloc_error("Incorrect device name - %s.", name);
-		return -EINVAL;
-	}
-
-	if (gralloc0_init(module, true))
-		return -ENODEV;
-
-	*dev = &module->alloc->common;
-	return 0;
+    int ret = 0;
+
+    if (strcmp(name, GRALLOC_HARDWARE_GPU0) == 0) {
+        ret = gralloc0_init(module, true, false);
+        if(!ret) {
+            if(dev) {
+                *dev = &module->alloc->common;    
+            }
+        }
+     }
+     else if (strcmp(name, GRALLOC_HARDWARE_FB0) == 0) {
+         ret = gralloc0_init(module, true, true);
+         if(!ret) {
+             if(dev) {
+                 *dev = &module->fb->common;    
+             }
+         }
+     }
+     else {
+         ret = -EINVAL;
+     }
+
+     return ret;
 }
 
 static int gralloc0_register_buffer(struct gralloc_module_t const *module, buffer_handle_t handle)
@@ -201,7 +372,7 @@ static int gralloc0_register_buffer(struct gralloc_module_t const *module, buffe
 	auto mod = (struct gralloc0_module *)module;
 
 	if (!mod->initialized)
-		if (gralloc0_init(mod, false))
+		if (gralloc0_init(mod, false, false))
 			return -ENODEV;
 
 	return mod->driver->retain(handle);
@@ -384,6 +555,7 @@ static int gralloc0_lock_async_ycbcr(struct gralloc_module_t const *module, buff
 	return 0;
 }
 
+
 // clang-format off
 static struct hw_module_methods_t gralloc0_module_methods = { .open = gralloc0_open };
 // clang-format on
@@ -414,6 +586,7 @@ struct gralloc0_module HAL_MODULE_INFO_SYM = {
 	    },
 
 	.alloc = nullptr,
+	.fb = nullptr,
 	.driver = nullptr,
 	.initialized = false,
 };
diff --git a/cros_gralloc/gralloc1/cros_gralloc1_module.cc b/cros_gralloc/gralloc1/cros_gralloc1_module.cc
old mode 100644
new mode 100755
index 566fd33..8aa0499
--- a/cros_gralloc/gralloc1/cros_gralloc1_module.cc
+++ b/cros_gralloc/gralloc1/cros_gralloc1_module.cc
@@ -22,7 +22,14 @@
 #include "cros_gralloc1_module.h"
 #include "drv.h"
 
+#include <stdlib.h>
+
 #include <hardware/gralloc.h>
+#include <hardware/fb.h>
+
+#include <log/log.h>
+#include <GLES2/gl2.h>
+
 
 #include <inttypes.h>
 #include "../i915_private_android.h"
@@ -123,8 +130,235 @@ namespace android
 
 /* CrosGralloc1 is a Singleton and pCrosGralloc1 holds pointer to its instance*/
 static CrosGralloc1 *pCrosGralloc1 = NULL;
-static uint32_t ref_count = 0;
-static SpinLock global_lock_;
+
+static uint32_t global_ref_count = 0;
+static SpinLock global_lock;
+static cros_gralloc_driver* global_driver = NULL; 
+
+cros_gralloc_driver* get_global_driver() {
+    static SpinLock global_lock;
+    if(global_driver) {
+        global_ref_count++;
+    }
+    else {
+        global_driver = new cros_gralloc_driver();
+        if(global_driver) {
+            if (global_driver->init() != 0) {
+        		cros_gralloc_error("Failed to initialize driver.");
+	        }
+            else {
+                global_ref_count = 1;
+            }         
+        }
+    }       
+
+    return global_driver;
+}
+
+
+void release_global_driver() {
+    static SpinLock global_lock;
+
+	if (global_ref_count > 0) {
+		global_ref_count--;
+	}
+
+	if (global_ref_count == 0) {
+		delete global_driver;
+        global_driver = nullptr;
+	}
+}
+
+
+
+
+/*
+  * framebuffer_device_t  implementation
+  */
+static int gralloc1_fb_setSwapInterval(struct framebuffer_device_t* dev, int interval)
+{
+    gralloc1_fb_dev_t* _device = (gralloc1_fb_dev_t*)dev; 
+    int ret = 0;
+    
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+    if ((interval < dev->minSwapInterval) || (interval > dev->maxSwapInterval)) {
+	        ret = -EINVAL;
+    }
+    return ret;
+}
+
+static int gralloc1_fb_setUpdateRect(struct framebuffer_device_t* dev, int left, int top, int width, int height)
+{
+
+    gralloc1_fb_dev_t* _device = (gralloc1_fb_dev_t*)dev; 
+    int ret = 0;
+
+#if DEBUG_GRALLOC_API
+    ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+    return 0;
+}
+
+static int gralloc1_fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
+{
+    gralloc1_fb_dev_t* _device = (gralloc1_fb_dev_t*)dev; 
+    int ret = 0;
+
+#if DEBUG_GRALLOC_API	
+     ALOGI("%s : %d : (dev = %p, buffer = %p)", __func__, __LINE__, dev, (void*)buffer);
+#endif 
+
+	if(!buffer)
+        return -EINVAL;		
+
+    if(_device->driver) {
+       ret = _device->driver->kms_present(buffer); 
+    }
+
+#if DEBUG_GRALLOC_API
+    ALOGI("%s : %d : returns %d", __func__, __LINE__, ret);
+#endif 
+
+    return ret;
+}
+
+static int gralloc1_fb_compositionComplete(struct framebuffer_device_t* dev)
+{
+    gralloc1_fb_dev_t* _device = (gralloc1_fb_dev_t*)dev; 
+    int ret = 0;
+    
+#if DEBUG_GRALLOC_API
+    ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+  
+    // glFlush();
+    glFinish();
+    
+    return ret;
+}
+
+
+void gralloc1_fb_dump(struct framebuffer_device_t* dev, char *buff, int buff_len)
+{
+#if DEBUG_GRALLOC_API
+    ALOGI("%s: %d", __func__, __LINE__);
+#endif 
+
+}
+
+
+int gralloc1_fb_enableScreen(struct framebuffer_device_t* dev, int enable)
+{
+    gralloc1_fb_dev_t* _device = (gralloc1_fb_dev_t*)dev; 
+    int ret = 0;
+
+#if DEBUG_GRALLOC_API
+    ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+    return ret;
+}
+
+
+static int gralloc1_fb_close(struct hw_device_t* dev)
+{
+    gralloc1_fb_dev_t* _device = (gralloc1_fb_dev_t*)dev;
+    int ret = 0;
+    
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d", __func__, __LINE__);
+#endif
+
+    if(_device->driver) {
+        release_global_driver();
+        _device->driver = nullptr;
+    }
+
+    free(_device);
+
+    return ret;
+}
+
+
+static int gralloc1_fb_open(const struct hw_module_t *mod, struct framebuffer_device_t **dev)
+{
+
+    gralloc1_fb_dev_t* _device = NULL;
+  
+
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d, mod = %p", __func__, __LINE__, mod);
+#endif
+	
+    _device = (gralloc1_fb_dev_t*)malloc(sizeof(gralloc1_fb_dev_t));
+    if(_device == NULL) {
+        ALOGE("%s: %d : out of memory!", __func__, __LINE__);
+        return -ENOMEM;
+    }
+
+    _device->base.setSwapInterval       = gralloc1_fb_setSwapInterval;
+	_device->base.setUpdateRect         = gralloc1_fb_setUpdateRect;
+	_device->base.post                  = gralloc1_fb_post;
+    _device->base.compositionComplete   = gralloc1_fb_compositionComplete;
+    _device->base.dump                  = gralloc1_fb_dump;
+    _device->base.enableScreen          = gralloc1_fb_enableScreen;
+    _device->base.common.close          = gralloc1_fb_close;
+    _device->base.common.module         = const_cast<hw_module_t *>(mod);
+
+    _device->driver = get_global_driver();
+    if(!_device->driver) {
+        ALOGE("%s: %d : init driver failed!", __func__, __LINE__);
+        free(_device);
+        return -EINVAL;   
+    }
+
+
+    if(_device->driver->init_kms()) {
+        ALOGE("%s: %d : init kms failed!", __func__, __LINE__);
+        free(_device);
+        return -EINVAL;   
+    }
+    
+    kms_info_t info;      
+    memset(&info, 0, sizeof(kms_info_t));
+    _device->driver->get_kms_info(&info);
+    
+    const_cast<uint32_t&>(_device->base.flags)     	= info.flags;
+    const_cast<uint32_t&>(_device->base.width)      = info.width;
+    const_cast<uint32_t&>(_device->base.height)     = info.height;
+    const_cast<int&>(_device->base.stride)          = info.stride;
+
+    const_cast<int&>(_device->base.format)         	= info.format;
+    const_cast<float&>(_device->base.xdpi)          = info.xdpi;
+    const_cast<float&>(_device->base.ydpi)          = info.ydpi;
+    const_cast<float&>(_device->base.fps)           = info.fps;
+    const_cast<int&>(_device->base.minSwapInterval)	= info.minSwapInterval;
+    const_cast<int&>(_device->base.maxSwapInterval) = info.maxSwapInterval;
+    const_cast<int&>(_device->base.numFramebuffers) = info.numFramebuffers;
+
+    
+#if DEBUG_GRALLOC_API
+    ALOGI("fb.flags = 0x%x", _device->base.flags);
+    ALOGI("fb.width  %d", _device->base.width);
+    ALOGI("fb.height %d", _device->base.height);
+    ALOGI("fb.stride %d", _device->base.height);
+    ALOGI("fb.format 0x%x" , _device->base.format);
+    ALOGI("fb.xdpi   %f", _device->base.xdpi);
+    ALOGI("fb.ydpi   %f", _device->base.ydpi);
+    ALOGI("fb.fps    %f", _device->base.fps);
+#endif 
+
+    *dev = &_device->base;
+
+    return 0;
+}
+
+
 
 CrosGralloc1::CrosGralloc1()
 {
@@ -132,25 +366,25 @@ CrosGralloc1::CrosGralloc1()
 	getFunction = getFunctionHook;
 	common.tag = HARDWARE_DEVICE_TAG;
 	common.version = HARDWARE_MODULE_API_VERSION(1, 0);
-	common.close = HookDevClose;
+	common.close = HookGrallocClose;
 }
 
 CrosGralloc1::~CrosGralloc1()
 {
+    if(driver) {
+        release_global_driver();
+    }
 }
 
 bool CrosGralloc1::Init()
 {
-	if (driver)
-		return true;
-
-	driver = std::make_unique<cros_gralloc_driver>();
-	if (driver->init()) {
+    driver = get_global_driver();
+    if(!driver) {
 		cros_gralloc_error("Failed to initialize driver.");
-		return false;
-	}
+		return false;        
+    }
 
-	return true;
+    return true;
 }
 
 void CrosGralloc1::doGetCapabilities(uint32_t *outCount, int32_t *outCapabilities)
@@ -647,61 +881,58 @@ int32_t CrosGralloc1::getByteStride(buffer_handle_t buffer, uint32_t *outStride,
 }
 
 // static
-int CrosGralloc1::HookDevOpen(const struct hw_module_t *mod, const char *name,
-			      struct hw_device_t **device)
+int CrosGralloc1::HookGrallocClose(hw_device_t * dev)
 {
-	if (strcmp(name, GRALLOC_HARDWARE_MODULE_ID)) {
-		ALOGE("Invalid module name- %s", name);
-		return -EINVAL;
-	}
-
-	ScopedSpinLock lock(global_lock_);
-	ref_count++;
-
-	if (pCrosGralloc1 != NULL) {
-		*device = &pCrosGralloc1->common;
-		return 0;
-	} else
-		pCrosGralloc1 = new CrosGralloc1();
-
-	std::unique_ptr<CrosGralloc1> ctx(pCrosGralloc1);
-	if (!ctx) {
-		ALOGE("Failed to allocate CrosGralloc1");
-		return -ENOMEM;
-	}
+    CrosGralloc1* pGralloc1 = CrosGralloc1::getAdapter((gralloc1_device_t*)dev);
 
-	if (!ctx->Init()) {
-		ALOGE("Failed to initialize CrosGralloc1. \n");
-		return -EINVAL;
-	}
-
-	ctx->common.module = const_cast<hw_module_t *>(mod);
-	*device = &ctx->common;
-	ctx.release();
+    if(pGralloc1) {
+        delete pGralloc1;
+    }    
 	return 0;
-}
+} // namespace android
 
 // static
-int CrosGralloc1::HookDevClose(hw_device_t * /*dev*/)
+int CrosGralloc1::HookDevOpen(const struct hw_module_t *mod, const char *name,
+			      struct hw_device_t **device)
 {
-	ScopedSpinLock lock(global_lock_);
-	if (ref_count > 0) {
-		ref_count--;
-	}
 
-	if (ref_count > 0) {
-		return 0;
-	}
+#if DEBUG_GRALLOC_API
+	ALOGI("%s: %d : mod = %p, name = %s)", __func__, __LINE__, mod, name);
+#endif
+
+    int ret = 0;
+
+    if (strcmp(name, GRALLOC_HARDWARE_MODULE_ID) == 0) {        
+        CrosGralloc1* pGralloc1 = new CrosGralloc1();
+        if(pGralloc1) {
+            if(pGralloc1->Init()) {
+                pGralloc1->common.module = const_cast<hw_module_t *>(mod);
+                *device = &pGralloc1->common;                        
+                ret = 0;
+            }
+            else {
+                ALOGE("Failed to initialize CrosGralloc1. \n");
+                ret = -EINVAL;                
+            }
+        }
+        else {
+    		ALOGE("Failed to allocate CrosGralloc1");
+    		ret = -ENOMEM;          
+        }
 
-	if (pCrosGralloc1) {
-		delete pCrosGralloc1;
-		pCrosGralloc1 = NULL;
-	}
+    }
+    else if (strcmp(name, GRALLOC_HARDWARE_FB0) == 0) {
+        ret = gralloc1_fb_open(mod, (struct framebuffer_device_t **)device);
+    }
+    else {
+        ALOGE("Invalid module name- %s", name);        
+        ret = -EINVAL;
+    }
 
-	return 0;
+    return ret;
 }
 
-} // namespace android
+};
 
 static struct hw_module_methods_t cros_gralloc_module_methods = {
 	.open = android::CrosGralloc1::HookDevOpen,
@@ -715,3 +946,5 @@ hw_module_t HAL_MODULE_INFO_SYM = {
 	.author = "Chrome OS",
 	.methods = &cros_gralloc_module_methods,
 };
+
+
diff --git a/cros_gralloc/gralloc1/cros_gralloc1_module.h b/cros_gralloc/gralloc1/cros_gralloc1_module.h
old mode 100644
new mode 100755
index 70e5176..5c4015c
--- a/cros_gralloc/gralloc1/cros_gralloc1_module.h
+++ b/cros_gralloc/gralloc1/cros_gralloc1_module.h
@@ -22,9 +22,14 @@
 #include "../cros_gralloc_driver.h"
 
 #include <hardware/gralloc1.h>
+#include <hardware/fb.h>
+
 #include <utils/Log.h>
 #include <unistd.h>
 
+#define DEBUG_GRALLOC_API   0
+
+
 struct cros_gralloc_module;
 
 namespace android
@@ -51,7 +56,7 @@ class CrosGralloc1 : public gralloc1_device_t
 
 	static int HookDevOpen(const struct hw_module_t *mod, const char *name,
 			       struct hw_device_t **device);
-	static int HookDevClose(hw_device_t *dev);
+	static int HookGrallocClose(hw_device_t *dev);
 
       private:
 	static inline CrosGralloc1 *getAdapter(gralloc1_device_t *device)
@@ -320,10 +325,23 @@ class CrosGralloc1 : public gralloc1_device_t
 		return getAdapter(device)->setModifier(descriptor, modifier);
 	}
 
+
+    // clang-format on
 	// Adapter internals
-	std::unique_ptr<cros_gralloc_driver> driver;
+	cros_gralloc_driver* driver;
 };
 
+
+struct gralloc1_fb_dev {
+    framebuffer_device_t base;
+    cros_gralloc_driver* driver;
+};
+typedef struct gralloc1_fb_dev gralloc1_fb_dev_t;
+
+cros_gralloc_driver* get_global_driver();
+void release_global_driver();
+
+
 } // namespace android
 
 #endif
diff --git a/drv.c b/drv.c
old mode 100644
new mode 100755
index f4af55f..330a1fd
--- a/drv.c
+++ b/drv.c
@@ -9,11 +9,18 @@
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <math.h>
 #include <string.h>
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <unistd.h>
 #include <xf86drm.h>
+#include <xf86drmMode.h>
+
+#include <system/graphics.h>
+#include <cutils/log.h>
+#include <cutils/properties.h>
+
 
 #include "drv_priv.h"
 #include "helpers.h"
@@ -31,6 +38,8 @@ extern struct backend backend_exynos;
 extern struct backend backend_gma500;
 #ifdef DRV_I915
 extern struct backend backend_i915;
+extern struct backend backend_i915_bpo;
+
 #endif
 #ifdef DRV_MARVELL
 extern struct backend backend_marvell;
@@ -76,6 +85,7 @@ static struct backend *drv_get_backend(int fd)
 		&backend_gma500,
 #ifdef DRV_I915
 		&backend_i915,
+	    &backend_i915_bpo,
 #endif
 #ifdef DRV_MARVELL
 		&backend_marvell,
@@ -114,7 +124,7 @@ struct driver *drv_create(int fd)
 {
 	struct driver *drv;
 	int ret;
-
+    
 	drv = (struct driver *)calloc(1, sizeof(*drv));
 
 	if (!drv)
@@ -123,13 +133,17 @@ struct driver *drv_create(int fd)
 	drv->fd = fd;
 	drv->backend = drv_get_backend(fd);
 
-	if (!drv->backend)
+	if (!drv->backend) {
+        ALOGE("%s: %d : get backend failed",__func__, __LINE__);
 		goto free_driver;
+    }
 
 	drv->buffer_table = drmHashCreate();
 	if (!drv->buffer_table)
 		goto free_driver;
 
+    ALOGI("%s : %d", __func__, __LINE__);
+
 	drv->map_table = drmHashCreate();
 	if (!drv->map_table)
 		goto free_buffer_table;
@@ -145,11 +159,13 @@ struct driver *drv_create(int fd)
 	if (drv->backend->init) {
 		ret = drv->backend->init(drv);
 		if (ret) {
+            ALOGE("%s: %d : backend init failed",__func__, __LINE__);
 			free(drv->combos.data);
 			goto free_map_table;
 		}
 	}
 
+
 	ATOMIC_VAR_INIT(drv->driver_lock);
 
 	return drv;
@@ -632,3 +648,742 @@ uint32_t drv_num_buffers_per_bo(struct bo *bo)
 
 	return count;
 }
+
+
+
+/* Picture aspect ratio flags */
+#define DRM_MODE_FLAG_PARMASK    (3<<19)
+#define DRM_MODE_FLAG_PARNONE    (0<<19)
+#define DRM_MODE_FLAG_PAR16_9    (1<<19)
+#define DRM_MODE_FLAG_PAR4_3     (2<<19)
+
+static const char *connector_type_names[] = {
+    "None",
+    "VGA",
+    "DVI",
+    "DVI",
+    "DVI",
+    "Composite",
+    "TV",
+    "LVDS",
+    "CTV",
+    "DIN",
+    "DP",
+    "HDMI",
+    "HDMI",
+    "TV",
+    "eDP",
+    "VIRTUAL",
+    "DSI",
+};
+
+
+
+static drmModeConnectorPtr fetch_connector(kms_t* kms, uint32_t type, uint32_t type_id)
+{
+    int i;
+
+    ALOGD("%s, type = %d, type_id = %d", __func__, type, type_id);
+
+    if (!kms->resources)
+        return NULL;
+
+    for (i = 0; i < kms->resources->count_connectors; i++) {
+        drmModeConnectorPtr connector =
+            connector = drmModeGetConnector(kms->fd,
+                                            kms->resources->connectors[i]);                       
+        if (connector) {
+            if ( (connector->connector_type == type) &&
+                 (connector->connector_type_id == type_id) && 
+                 (connector->connection == DRM_MODE_CONNECTED) ) {
+                ALOGD("%s, found connector[%d], id = 0x%x!", __func__, i, connector->connector_id);                 
+                return connector;
+            }
+            drmModeFreeConnector(connector);
+        }
+    }
+    return NULL;
+}
+
+static int find_crtc_for_connector(kms_t* kms, drmModeConnector *connector)
+{
+    drmModeEncoder *encoder;
+    uint32_t possible_crtcs;
+    int i, j;
+    uint32_t lxc_id = 1;
+
+    for (j = 0; j < connector->count_encoders; j++) {
+        encoder = drmModeGetEncoder(kms->fd, connector->encoders[j]);
+        if (encoder == NULL) {
+            printf("Failed to get encoder.\n");
+            return -1;
+        }
+        possible_crtcs = encoder->possible_crtcs;
+        drmModeFreeEncoder(encoder);
+
+        for (i = 0; i < kms->resources->count_crtcs; i++) {
+            if ( (possible_crtcs & (1 << i)) &&
+                 !(kms->crtc_allocator & (1 << i)) ) {
+                 if (lxc_id == kms->lxc_id) {
+                    return kms->resources->crtcs[i];
+                 }
+                 else {
+                    lxc_id++;
+                 }
+                 
+            }                
+        }
+    }
+
+    return -1;
+}
+
+
+#define MARGIN_PERCENT 1.8   /* % of active vertical image*/
+#define CELL_GRAN 8.0   /* assumed character cell granularity*/
+#define MIN_PORCH 1 /* minimum front porch   */
+#define V_SYNC_RQD 3 /* width of vsync in lines   */
+#define H_SYNC_PERCENT 8.0   /* width of hsync as % of total line */
+#define MIN_VSYNC_PLUS_BP 550.0 /* min time of vsync + back porch (microsec) */
+#define M 600.0 /* blanking formula gradient */
+#define C 40.0  /* blanking formula offset   */
+#define K 128.0 /* blanking formula scaling factor   */
+#define J 20.0  /* blanking formula scaling factor   */
+/* C' and M' are part of the Blanking Duty Cycle computation */
+#define C_PRIME   (((C - J) * K / 256.0) + J)
+#define M_PRIME   (K / 256.0 * M)
+
+static drmModeModeInfoPtr generate_mode(int h_pixels, int v_lines, float freq)
+{
+    float h_pixels_rnd;
+    float v_lines_rnd;
+    float v_field_rate_rqd;
+    float top_margin;
+    float bottom_margin;
+    float interlace;
+    float h_period_est;
+    float vsync_plus_bp;
+    float v_back_porch;
+    float total_v_lines;
+    float v_field_rate_est;
+    float h_period;
+    float v_field_rate;
+    float v_frame_rate;
+    float left_margin;
+    float right_margin;
+    float total_active_pixels;
+    float ideal_duty_cycle;
+    float h_blank;
+    float total_pixels;
+    float pixel_freq;
+    float h_freq;
+
+    float h_sync;
+    float h_front_porch;
+    float v_odd_front_porch_lines;
+    int interlaced = 0;
+    int margins = 0;
+
+    drmModeModeInfoPtr m = malloc(sizeof(drmModeModeInfo));
+
+    h_pixels_rnd = rint((float) h_pixels / CELL_GRAN) * CELL_GRAN;
+    v_lines_rnd = interlaced ? rint((float) v_lines) / 2.0 : rint((float) v_lines);
+    v_field_rate_rqd = interlaced ? (freq * 2.0) : (freq);
+    top_margin = margins ? rint(MARGIN_PERCENT / 100.0 * v_lines_rnd) : (0.0);
+    bottom_margin = margins ? rint(MARGIN_PERCENT / 100.0 * v_lines_rnd) : (0.0);
+    interlace = interlaced ? 0.5 : 0.0;
+    h_period_est = (((1.0 / v_field_rate_rqd) - (MIN_VSYNC_PLUS_BP / 1000000.0)) / (v_lines_rnd + (2 * top_margin) + MIN_PORCH + interlace) * 1000000.0);
+    vsync_plus_bp = rint(MIN_VSYNC_PLUS_BP / h_period_est);
+    v_back_porch = vsync_plus_bp - V_SYNC_RQD;
+    total_v_lines = v_lines_rnd + top_margin + bottom_margin + vsync_plus_bp + interlace + MIN_PORCH;
+    v_field_rate_est = 1.0 / h_period_est / total_v_lines * 1000000.0;
+    h_period = h_period_est / (v_field_rate_rqd / v_field_rate_est);
+    v_field_rate = 1.0 / h_period / total_v_lines * 1000000.0;
+    v_frame_rate = interlaced ? v_field_rate / 2.0 : v_field_rate;
+    left_margin = margins ? rint(h_pixels_rnd * MARGIN_PERCENT / 100.0 / CELL_GRAN) * CELL_GRAN : 0.0;
+    right_margin = margins ? rint(h_pixels_rnd * MARGIN_PERCENT / 100.0 / CELL_GRAN) * CELL_GRAN : 0.0;
+    total_active_pixels = h_pixels_rnd + left_margin + right_margin;
+    ideal_duty_cycle = C_PRIME - (M_PRIME * h_period / 1000.0);
+    h_blank = rint(total_active_pixels * ideal_duty_cycle / (100.0 - ideal_duty_cycle) / (2.0 * CELL_GRAN)) * (2.0 * CELL_GRAN);
+    total_pixels = total_active_pixels + h_blank;
+    pixel_freq = total_pixels / h_period;
+    h_freq = 1000.0 / h_period;
+    h_sync = rint(H_SYNC_PERCENT / 100.0 * total_pixels / CELL_GRAN) * CELL_GRAN;
+    h_front_porch = (h_blank / 2.0) - h_sync;
+    v_odd_front_porch_lines = MIN_PORCH + interlace;
+
+    m->clock = ceil(pixel_freq) * 1000;
+    m->hdisplay = (int) (h_pixels_rnd);
+    m->hsync_start = (int) (h_pixels_rnd + h_front_porch);
+    m->hsync_end = (int) (h_pixels_rnd + h_front_porch + h_sync);
+    m->htotal = (int) (total_pixels);
+    m->hskew = 0;
+    m->vdisplay = (int) (v_lines_rnd);
+    m->vsync_start = (int) (v_lines_rnd + v_odd_front_porch_lines);
+    m->vsync_end = (int) (int) (v_lines_rnd + v_odd_front_porch_lines + V_SYNC_RQD);
+    m->vtotal = (int) (total_v_lines);
+    m->vscan = 0;
+    m->vrefresh = freq;
+    m->flags = 10;
+    m->type = 64;
+
+    return (m);
+}
+
+static drmModeModeInfoPtr find_mode(drmModeConnectorPtr connector, int *bpp)
+{
+    char value[PROPERTY_VALUE_MAX];
+    drmModeModeInfoPtr mode;
+    int dist, i;
+    int xres = 0, yres = 0, rate = 0;
+    int forcemode = 0;
+    char property[256];
+
+    snprintf(property, 256, "debug.kms.%s.mode", (connector_type_names[connector->connector_type]));
+    if (property_get(property, value, NULL)) {
+        char *p = value, *end;
+
+        /* parse <xres>x<yres>[@<bpp>] */
+        if (sscanf(value, "%dx%d@%d", &xres, &yres, bpp) != 3) {
+            *bpp = 0;
+            if (sscanf(value, "%dx%d", &xres, &yres) != 2)
+                xres = yres = 0;
+        }
+
+        if ((xres && yres) || *bpp) {
+            ALOGI("will find the closest match for %dx%d@%d",
+                  xres, yres, *bpp);
+        }
+    } else if (property_get("debug.kms.mode.force", value, NULL)) {
+        char *p = value, *end;
+        *bpp = 0;
+
+        /* parse <xres>x<yres>[@<refreshrate>] */
+        if (sscanf(value, "%dx%d@%d", &xres, &yres, &rate) != 3) {
+            rate = 60;
+            if (sscanf(value, "%dx%d", &xres, &yres) != 2)
+                xres = yres = 0;
+        }
+
+        if (xres && yres && rate) {
+            ALOGI("will use %dx%d@%dHz", xres, yres, rate);
+            forcemode = 1;
+        }
+    } else {
+        *bpp = 0;
+    }
+
+    dist = INT_MAX;
+
+    if (forcemode)
+        mode = generate_mode(xres, yres, rate);
+    else {
+        mode = NULL;
+        for (i = 0; i < connector->count_modes; i++) {
+            drmModeModeInfoPtr m = &connector->modes[i];
+            int tmp;
+
+            if (xres && yres) {
+                tmp = (m->hdisplay - xres) * (m->hdisplay - xres) +
+                      (m->vdisplay - yres) * (m->vdisplay - yres);
+            }
+            else {
+                /* use the first preferred mode */
+                tmp = (m->type & DRM_MODE_TYPE_PREFERRED) ? 0 : dist;
+            }
+
+            if (tmp < dist) {
+                mode = m;
+                dist = tmp;
+                if (!dist)
+                    break;
+            }
+        }
+    }
+
+    /* fallback to the first mode */
+    if (!mode)
+        mode = &connector->modes[0];
+
+    /* Fix HDMI cert 7.27 AVI Info_Frame VIC(video code) failure to support 16:9 */
+    mode->flags |= DRM_MODE_FLAG_PAR16_9;
+
+    ALOGI("Established mode:");
+    ALOGI("clock: %d, hdisplay: %d, hsync_start: %d, hsync_end: %d, htotal: %d, hskew: %d", mode->clock, mode->hdisplay, mode->hsync_start, mode->hsync_end, mode->htotal, mode->hskew);
+    ALOGI("vdisplay: %d, vsync_start: %d, vsync_end: %d, vtotal: %d, vscan: %d, vrefresh: %d", mode->vdisplay, mode->vsync_start, mode->vsync_end, mode->vtotal, mode->vscan, mode->vrefresh);
+    ALOGI("flags: %d, type: %d, name %s", mode->flags, mode->type, mode->name);
+
+    *bpp /= 8;
+
+    return mode;
+}
+
+
+static int kms_init_with_connector(kms_t* kms, kms_output_t* output, drmModeConnectorPtr connector)
+{
+    drmModeEncoderPtr encoder;
+    drmModeModeInfoPtr mode;
+    static int used_crtcs = 0;
+    int bpp, i;
+    int lxc_id = 1;
+
+    if (!connector->count_modes)
+        return -EINVAL;
+
+    encoder = drmModeGetEncoder(kms->fd, connector->encoders[0]);
+    if (!encoder)
+        return -EINVAL;
+
+    /* find first possible crtc which is not used yet */
+    for (i = 0; i < kms->resources->count_crtcs; i++) {
+        if ( (encoder->possible_crtcs & (1 << i)) &&
+             ((used_crtcs & (1 << i)) != (1 << i)) ) {
+                if(lxc_id >= kms->lxc_id) {                    
+                    break;                    
+                }
+                else {
+                    lxc_id++;
+                }
+            }
+    }
+
+    used_crtcs |= (1 << i);
+
+    ALOGI("i = %d, used_crtcs = %x", i, used_crtcs);
+
+    drmModeFreeEncoder(encoder);
+    if (i == kms->resources->count_crtcs)
+        return -EINVAL;
+
+    output->crtc_id = find_crtc_for_connector(kms, connector);
+    output->connector_id = connector->connector_id;
+    output->pipe = i;
+    kms->crtc_allocator |= (1 << output->crtc_id);
+
+    /* print connector info */
+#if 1    
+    if (connector->count_modes > 1) {
+        ALOGI("there are %d modes on connector 0x%x, type %d",
+              connector->count_modes,
+              connector->connector_id,
+              connector->connector_type);
+        for (i = 0; i < connector->count_modes; i++)
+            ALOGI("  %s", connector->modes[i].name);
+    }
+    else {
+        ALOGI("there is one mode on connector 0x%d: %s",
+              connector->connector_id,
+              connector->modes[0].name);
+    }
+#endif
+    mode = find_mode(connector, &bpp);
+
+    ALOGI("the best mode is %s", mode->name);
+
+    output->mode = *mode;
+    switch (bpp) {
+    case 2:
+        output->fb_format = HAL_PIXEL_FORMAT_RGB_565;
+        break;
+    case 4:
+    default:
+        output->fb_format = HAL_PIXEL_FORMAT_BGRA_8888;
+        //output->fb_format = HAL_PIXEL_FORMAT_RGBA_8888;
+        break;
+    }
+
+    if (connector->mmWidth && connector->mmHeight) {
+        output->xdpi = (output->mode.hdisplay * 25.4 / connector->mmWidth);
+        output->ydpi = (output->mode.vdisplay * 25.4 / connector->mmHeight);
+    }
+    else {
+        output->xdpi = 75;
+        output->ydpi = 75;
+    }
+    
+    output->swap_interval = 1;
+
+    return 0;
+}
+
+
+#if USE_DRM_BXT
+#define LXC_INSTANCE_NO     1
+#define LXC_SHIFT_DISPLAY   0
+#else 
+#define LXC_INSTANCE_NO     0
+#define LXC_SHIFT_DISPLAY   1
+#endif 
+
+#if LXC_INSTANCE_NO
+#include "devns_ctl.h"
+//#include <lxc-mtab/devns_ctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+int devns_get_context(struct dnc_context_struct *cxt)
+{
+        int fd;
+        int ret;
+        if (cxt == NULL){
+                ALOGW("XELATEX - %s : Error cxt.", __func__);
+                return -1;
+        }
+        fd = open(DEV_PATH "/" DNC_NAME, O_WRONLY);
+        if (fd<0){
+                ALOGW("XELATEX - %s : Open dnc device failed.", __func__);
+                return -1;
+        }
+        ret = ioctl(fd, DNC_GET_CONTEXT, cxt);
+        if (ret < 0){
+                ALOGW("XELATEX - %s : dnc ioctl failed.", __func__);
+                close(fd);
+                return -1;
+        }
+        close(fd);
+        return 0;
+}
+
+#endif
+
+
+static int kms_wait_vblank(kms_t *kms)
+{
+    drmVBlank vbl;
+    int ret = 0;
+    
+    memset(&vbl, 0, sizeof(vbl));
+    vbl.request.type = DRM_VBLANK_RELATIVE;
+    vbl.request.sequence = 1;
+
+    ret = drmWaitVBlank(kms->fd, &vbl);
+    if (ret) {
+        ALOGW("%s : %d : wait vblank failed, error is (%s)", __func__, __LINE__, strerror(errno));
+    }
+
+    return ret;
+}
+
+
+
+int drv_init_kms(struct driver* drv)
+{
+    drmModeConnectorPtr lvds, hdmi, edp;
+    uint32_t lxc_id = 1;
+    uint32_t type_id = 1;
+    int connected_count = 0;
+    int i, ret;
+
+    ALOGI("%s: %d, drv = 0x%08x", __func__, __LINE__, drv);
+
+    kms_t* kms = &(drv->kms);
+
+    kms->fd = drv->fd;
+    
+    if (kms->resources)
+        return 0;
+
+    kms->resources = drmModeGetResources(kms->fd);
+    if (!kms->resources) {
+        ALOGE("failed to get modeset resources");
+        return -EINVAL;
+    }
+
+    kms->plane_resources = drmModeGetPlaneResources(kms->fd);
+    if (!kms->plane_resources) {
+        ALOGE("no planes found from drm resources");
+    } else {
+        unsigned int i, j;
+        ALOGE("found %d drm planes", kms->plane_resources->count_planes);
+        kms->planes = calloc(kms->plane_resources->count_planes, sizeof(drmModePlanePtr));
+        for (i = 0; i < kms->plane_resources->count_planes; i++) {
+            kms->planes[i] = drmModeGetPlane(drv->fd, kms->plane_resources->planes[i]);
+        }
+    }
+
+#if LXC_INSTANCE_NO
+    {
+        struct dnc_context_struct cxt;
+        int err;
+        err = devns_get_context(&cxt);
+        if (err < 0){
+            ALOGW("XELATEX - %s : devns_get_context failed.", __func__);
+            kms->lxc_id = 1;
+        }else {
+            ALOGW("cxt.process_devns_id for %d\n", cxt.process_devns_id);
+            kms->lxc_id = cxt.process_devns_id;
+        }
+        //    char lxc_prop[PROPERTY_VALUE_MAX];    
+        //    memset(lxc_prop, 0, sizeof(lxc_prop));
+        //    property_get("lxc.instance.no", lxc_prop, "1");
+        //    lxc_id = atoi(lxc_prop);    
+    }
+#else
+    kms->lxc_id = 1;
+#endif
+    ALOGD("LXC id = %d", kms->lxc_id);    
+
+
+
+    {
+        uint32_t connector_id;
+        uint32_t encoder_id;
+        uint32_t connector_type;
+        uint32_t connector_type_id;
+
+        ALOGD("count_connectors = %d", kms->resources->count_connectors);     
+
+        for (i = 0; i < kms->resources->count_connectors; i++) {
+            drmModeConnectorPtr connector;
+            connector = drmModeGetConnector(kms->fd, kms->resources->connectors[i]);
+
+            if (connector) {
+                ALOGD("connector %d : connector_id = %x, encoder_id = %x, connector_type = %d, connector_type_id = %d, connection = %d",
+                    i, connector->connector_id, connector->encoder_id, connector->connector_type, connector->connector_type_id, connector->connection);
+
+                if(connector->connection == DRM_MODE_CONNECTED) {
+                    connected_count++;
+                }
+
+                drmModeFreeConnector(connector);
+            }
+        }
+    }
+
+    if(connected_count > 1) {
+        kms->lxc_id += LXC_SHIFT_DISPLAY;
+        ALOGD("LXC id = %d after shift", kms->lxc_id);
+    }
+
+    /* find the crtc/connector/mode to use */
+    lvds = fetch_connector(kms, DRM_MODE_CONNECTOR_LVDS, 1);
+    if (lvds) {
+        ALOGI("init primary with LVDS");
+        kms_init_with_connector(kms, &kms->primary, lvds);
+        drmModeFreeConnector(lvds);
+        kms->primary.active = 1;
+    }
+
+    kms->edp_available = 0;
+    type_id = kms->lxc_id;
+
+    edp = fetch_connector(kms, DRM_MODE_CONNECTOR_DisplayPort, type_id);
+    if(!edp) {
+        edp = fetch_connector(kms, DRM_MODE_CONNECTOR_DisplayPort, type_id+1);        
+    }    
+    if(!edp) {
+        edp = fetch_connector(kms, DRM_MODE_CONNECTOR_eDP, type_id);        
+    }    
+    if(!edp) {
+        edp = fetch_connector(kms, DRM_MODE_CONNECTOR_eDP, type_id+1);        
+    }        
+
+    if (edp) {
+        kms->edp_available = 1;
+        ALOGI("init primary with eDP/DP");
+        kms_init_with_connector(kms, &kms->primary, edp);
+        drmModeFreeConnector(edp);
+        kms->primary.active = 1;
+    }
+
+
+    /* if still no connector, find first connected connector and try it */
+    if (!kms->primary.active) {
+        if(kms->edp_available) {
+            type_id = kms->lxc_id - 1;
+        }
+        else {
+#if USE_DRM_BXT
+            // Non AAAG eDP is always there,  type id = lxc_id -1
+            type_id = kms->lxc_id - 1;
+#else
+            type_id = kms->lxc_id;
+#endif
+        }
+        ALOGD("search connected connector with type_id = %d", type_id);
+
+
+        for (i = 0; i < kms->resources->count_connectors; i++) {
+            drmModeConnectorPtr connector;
+
+            connector = drmModeGetConnector(kms->fd,
+                                            kms->resources->connectors[i]);
+            if (connector) {
+                if ((connector->connection == DRM_MODE_CONNECTED) && 
+                    (connector->connector_type == DRM_MODE_CONNECTOR_HDMIA) && 
+                    (connector->connector_type_id  == type_id) ) {
+                    if (!kms_init_with_connector(kms, &kms->primary, connector)) {
+                        ALOGD("first connector is the primary connector");                        
+                        break;
+                    }
+                }
+
+                drmModeFreeConnector(connector);
+            }
+        }
+
+        if (i == kms->resources->count_connectors) {
+            ALOGE("failed to find a valid crtc/connector/mode combination");
+            drmModeFreeResources(kms->resources);
+            kms->resources = NULL;
+            return -EINVAL;
+        }
+    }
+
+
+    /* check if hdmi is connected already */
+    if (kms->lxc_id > 1) {   
+#if USE_DRM_BXT
+         // Non AAAG eDP is always there,  type id = lxc_id -1
+        type_id = kms->lxc_id - 1;
+#else
+        type_id = kms->lxc_id;
+#endif         
+        hdmi = fetch_connector(kms, DRM_MODE_CONNECTOR_HDMIA, type_id);
+        if (!hdmi) {
+            hdmi = fetch_connector(kms, DRM_MODE_CONNECTOR_HDMIB, type_id);
+        }
+
+        if (hdmi) {
+            if (hdmi->connector_id == kms->primary.connector_id) {
+                /* special case: our primary connector is hdmi */
+                ALOGD("hdmi is the primary connector");
+                goto skip_hdmi_modes;
+            }
+
+            drmModeFreeConnector(hdmi);
+        }
+   }
+   ALOGD("primary output crtc = %d, connector = %d, pipe = %d",
+         kms->primary.crtc_id, kms->primary.connector_id, kms->primary.pipe);
+
+skip_hdmi_modes:
+
+    kms->first_post = 1;
+    return 0;
+}
+
+void drv_fini_kms(struct driver* drv)
+{
+    kms_t* kms = &(drv->kms);
+
+    /* wait previous flip complete */
+    // kms_page_flip(drm, NULL);
+
+    /* restore crtc? */
+
+
+    if (kms->planes) {
+        unsigned int i;
+        for (i = 0; i < kms->plane_resources->count_planes; i++)
+            drmModeFreePlane(kms->planes[i]);
+        free(kms->planes);
+        kms->planes = NULL;
+    }
+
+    if (kms->plane_resources) {
+        drmModeFreePlaneResources(kms->plane_resources);
+        kms->plane_resources = NULL;
+    }
+
+    if (kms->resources) {
+        drmModeFreeResources(kms->resources);
+        kms->resources = NULL;
+    }
+
+    memset(kms, 0, sizeof(kms_t));
+}
+
+    
+int drv_get_kms_info(struct driver* drv, kms_info_t *info)
+{
+    kms_t* kms = &(drv->kms);
+    
+    info->flags             = 0x1;
+    info->width             = kms->primary.mode.hdisplay;
+    info->height            = kms->primary.mode.vdisplay;
+    info->stride            = kms->primary.mode.hdisplay;
+    info->fps               = kms->primary.mode.vrefresh;
+    info->format            = kms->primary.fb_format;
+    info->xdpi              = kms->primary.xdpi;
+    info->ydpi              = kms->primary.ydpi;
+    info->minSwapInterval   = kms->primary.swap_interval;
+    info->maxSwapInterval   = kms->primary.swap_interval;
+    info->numFramebuffers   = 3;
+    return 0;
+}
+
+
+int drv_present_bo(struct driver* drv, struct bo *bo)
+{
+    kms_t* kms = &(drv->kms);
+    int ret = 0;
+
+    if(!bo->fb_id) {
+        uint32_t gem_handles[DRV_MAX_PLANES] = {0};
+        int i = 0;
+
+        for (i = 0; i < DRV_MAX_PLANES; i++) {
+            gem_handles[i] = bo->handles[i].u32;
+        }
+        
+        ret = drmModeAddFB2(kms->fd, bo->width, bo->height, bo->format, 
+                            gem_handles, bo->strides, bo->offsets, &(bo->fb_id), 0);
+        if(ret) {
+            ALOGE("%s : %d : add fb failed %d", __func__, __LINE__, ret);
+        }
+    }
+
+    if(bo->fb_id) {
+        
+        if(kms->first_post) {
+            ALOGI("%s : %d : set crtc (crtc id = %d, fb_id = %d, connector_id = %d)",
+                  __func__, __LINE__, kms->primary.crtc_id, bo->fb_id, kms->primary.connector_id);
+
+            ret = drmModeSetCrtc(kms->fd, kms->primary.crtc_id, bo->fb_id,
+                                 0, 0, &(kms->primary.connector_id), 1, &(kms->primary.mode));
+            if (ret) {
+                ALOGE("%s : %d : failed to set crtc (crtc id = %d, fb_id = %d, connector_id = %d)",
+                      __func__, __LINE__, kms->primary.crtc_id, bo->fb_id, kms->primary.connector_id);
+            }
+        }
+
+        if (!ret) {
+            kms->first_post = 0;
+            kms->front_bo   = bo;
+            kms->back_bo    = NULL;
+        }            
+
+        
+        // 
+        if(!ret) {
+            uint32_t flags = 0;
+            ret = drmModePageFlip(kms->fd, kms->primary.crtc_id, bo->fb_id, flags, (void *)kms);        
+            if (ret) {
+                ALOGE("%s : %d : page flip failed (crtc_id = %d, fb_id =%d, flags = %d), error = %s)",
+                      __func__, __LINE__, kms->primary.crtc_id, bo->fb_id, flags, strerror(errno));
+                kms->first_post = 1;
+            }
+            else {
+                kms->back_bo = bo;
+            }            
+        }
+
+        if(!ret) {
+            ret = kms_wait_vblank(kms);
+            if(!ret) {
+                kms->front_bo = bo;
+                kms->back_bo = NULL;
+            }
+            else {
+                kms->first_post = 1;
+            }
+        }
+    }
+
+    
+    return ret;
+}
+
+
diff --git a/drv.h b/drv.h
old mode 100644
new mode 100755
index 7abaf79..9de214a
--- a/drv.h
+++ b/drv.h
@@ -87,6 +87,21 @@ struct map_info {
 	void *priv;
 };
 
+typedef struct _kms_info_t {
+      unsigned int    flags;
+      unsigned int    width;
+      unsigned int    height;
+      int             stride;
+      int             format;
+      float           xdpi;
+      float           ydpi;
+      float           fps;
+      int             minSwapInterval;
+      int             maxSwapInterval;
+      int             numFramebuffers;    
+}kms_info_t;
+
+
 struct driver *drv_create(int fd);
 
 void drv_destroy(struct driver *drv);
@@ -149,6 +164,12 @@ size_t drv_num_planes_from_format(uint32_t format);
 
 uint32_t drv_num_buffers_per_bo(struct bo *bo);
 
+int drv_init_kms(struct driver* drv);
+int drv_get_kms_info(struct driver* drv, kms_info_t *info);
+int drv_present_bo(struct driver* drv, struct bo *bo);
+void drv_fini_kms(struct driver* drv);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drv_priv.h b/drv_priv.h
old mode 100644
new mode 100755
index 26f98cf..aeb2ae3
--- a/drv_priv.h
+++ b/drv_priv.h
@@ -12,6 +12,8 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <stdatomic.h>
+#include <xf86drm.h>
+#include <xf86drmMode.h>
 
 #include "drv.h"
 
@@ -40,7 +42,8 @@ struct bo {
 	uint32_t strides[DRV_MAX_PLANES];
 	uint64_t format_modifiers[DRV_MAX_PLANES];
 	uint64_t use_flags;
-	size_t total_size;
+	size_t total_size;    
+    uint32_t fb_id;
 	void *priv;
 };
 
@@ -68,6 +71,35 @@ struct combinations {
 	uint32_t allocations;
 };
 
+typedef struct _kms_output {
+    uint32_t            crtc_id;
+    uint32_t            connector_id;
+    uint32_t            pipe;
+    drmModeModeInfo     mode;
+    drmModePropertyPtr  props;
+    float               xdpi;
+    float               ydpi;
+    int                 fb_format;
+    int                 bpp;
+    int                 active;    
+    int                 swap_interval;
+}kms_output_t;
+
+typedef struct _kms_t {
+    int                 fd;
+    drmModeResPtr       resources;
+    drmModePlaneResPtr  plane_resources;
+    drmModePlanePtr*    planes;    
+    kms_output_t        primary;
+    uint32_t            crtc_allocator;    
+    uint32_t            lxc_id;  
+    int                 edp_available;
+    int                 first_post;
+    struct bo *         front_bo;
+    struct bo *         back_bo;
+} kms_t;
+
+
 struct driver {
 	int fd;
 	struct backend *backend;
@@ -76,6 +108,8 @@ struct driver {
 	void *map_table;
 	struct combinations combos;
 	atomic_flag driver_lock;
+
+    kms_t kms;
 };
 
 struct backend {
diff --git a/i915.c b/i915.c
old mode 100644
new mode 100755
index 6529b02..880425d
--- a/i915.c
+++ b/i915.c
@@ -13,6 +13,9 @@
 #include <sys/mman.h>
 #include <xf86drm.h>
 
+#include <cutils/log.h>
+#include <cutils/properties.h>
+
 #include "drv_priv.h"
 #include "helpers.h"
 #include "util.h"
@@ -284,7 +287,7 @@ static int i915_init(struct driver *drv)
 	get_param.value = &device_id;
 	ret = drmIoctl(drv->fd, DRM_IOCTL_I915_GETPARAM, &get_param);
 	if (ret) {
-		fprintf(stderr, "drv: Failed to get I915_PARAM_CHIPSET_ID\n");
+		ALOGE("drv: Failed to get I915_PARAM_CHIPSET_ID\n");
 		free(i915);
 		return -EINVAL;
 	}
@@ -296,7 +299,7 @@ static int i915_init(struct driver *drv)
 	get_param.value = &i915->has_llc;
 	ret = drmIoctl(drv->fd, DRM_IOCTL_I915_GETPARAM, &get_param);
 	if (ret) {
-		fprintf(stderr, "drv: Failed to get I915_PARAM_HAS_LLC\n");
+		ALOGE("drv: Failed to get I915_PARAM_HAS_LLC\n");
 		free(i915);
 		return -EINVAL;
 	}
@@ -432,7 +435,7 @@ static int i915_bo_create_for_modifier(struct bo *bo, uint32_t width, uint32_t h
 
 	ret = drmIoctl(bo->drv->fd, DRM_IOCTL_I915_GEM_CREATE, &gem_create);
 	if (ret) {
-		fprintf(stderr, "drv: DRM_IOCTL_I915_GEM_CREATE failed (size=%llu)\n",
+		ALOGE( "drv: DRM_IOCTL_I915_GEM_CREATE failed (size=%llu)\n",
 			gem_create.size);
 		return ret;
 	}
@@ -452,7 +455,7 @@ static int i915_bo_create_for_modifier(struct bo *bo, uint32_t width, uint32_t h
 		gem_close.handle = bo->handles[0].u32;
 		drmIoctl(bo->drv->fd, DRM_IOCTL_GEM_CLOSE, &gem_close);
 
-		fprintf(stderr, "drv: DRM_IOCTL_I915_GEM_SET_TILING failed with %d", errno);
+		ALOGE( "drv: DRM_IOCTL_I915_GEM_SET_TILING failed with %d", errno);
 		return -errno;
 	}
 
@@ -509,7 +512,7 @@ static int i915_bo_import(struct bo *bo, struct drv_import_fd_data *data)
 	ret = drmIoctl(bo->drv->fd, DRM_IOCTL_I915_GEM_GET_TILING, &gem_get_tiling);
 	if (ret) {
 		drv_gem_bo_destroy(bo);
-		fprintf(stderr, "drv: DRM_IOCTL_I915_GEM_GET_TILING failed.");
+		ALOGE( "drv: DRM_IOCTL_I915_GEM_GET_TILING failed.");
 		return ret;
 	}
 
@@ -535,7 +538,7 @@ static void *i915_bo_map(struct bo *bo, struct map_info *data, size_t plane, uin
 
 		ret = drmIoctl(bo->drv->fd, DRM_IOCTL_I915_GEM_MMAP, &gem_map);
 		if (ret) {
-			fprintf(stderr, "drv: DRM_IOCTL_I915_GEM_MMAP failed\n");
+			ALOGE( "drv: DRM_IOCTL_I915_GEM_MMAP failed\n");
 			return MAP_FAILED;
 		}
 
@@ -548,7 +551,7 @@ static void *i915_bo_map(struct bo *bo, struct map_info *data, size_t plane, uin
 
 		ret = drmIoctl(bo->drv->fd, DRM_IOCTL_I915_GEM_MMAP_GTT, &gem_map);
 		if (ret) {
-			fprintf(stderr, "drv: DRM_IOCTL_I915_GEM_MMAP_GTT failed\n");
+			ALOGE( "drv: DRM_IOCTL_I915_GEM_MMAP_GTT failed\n");
 			return MAP_FAILED;
 		}
 
@@ -557,7 +560,7 @@ static void *i915_bo_map(struct bo *bo, struct map_info *data, size_t plane, uin
 	}
 
 	if (addr == MAP_FAILED) {
-		fprintf(stderr, "drv: i915 GEM mmap failed\n");
+		ALOGE( "drv: i915 GEM mmap failed\n");
 		return addr;
 	}
 
@@ -584,7 +587,7 @@ static int i915_bo_invalidate(struct bo *bo, struct map_info *data)
 
 	ret = drmIoctl(bo->drv->fd, DRM_IOCTL_I915_GEM_SET_DOMAIN, &set_domain);
 	if (ret) {
-		fprintf(stderr, "drv: DRM_IOCTL_I915_GEM_SET_DOMAIN with %d\n", ret);
+		ALOGE( "drv: DRM_IOCTL_I915_GEM_SET_DOMAIN with %d\n", ret);
 		return ret;
 	}
 
@@ -645,4 +648,19 @@ struct backend backend_i915 = {
 	.resolve_format = i915_resolve_format,
 };
 
+struct backend backend_i915_bpo = {
+	.name = "i915_bpo",
+	.init = i915_init,
+	.close = i915_close,
+	.bo_create = i915_bo_create,
+	.bo_create_with_modifiers = i915_bo_create_with_modifiers,
+	.bo_destroy = drv_gem_bo_destroy,
+	.bo_import = i915_bo_import,
+	.bo_map = i915_bo_map,
+	.bo_unmap = drv_bo_munmap,
+	.bo_invalidate = i915_bo_invalidate,
+	.bo_flush = i915_bo_flush,
+	.resolve_format = i915_resolve_format,
+};
+
 #endif
-- 
2.21.0

