From cec8be54f29fc82a3797a336fe0ad02e25d2efc7 Mon Sep 17 00:00:00 2001
From: Aiswarya Cyriac <aiswarya.cyriac@intel.com>
Date: Tue, 30 Mar 2021 15:39:13 +0530
Subject: [PATCH] Test: Fix to not suspend when firmware download is ongoing

Signed-off-by: Aiswarya Cyriac <aiswarya.cyriac@intel.com>
---
 drivers/bluetooth/btusb.c | 21 ++++++++++++++++-----
 net/bluetooth/hci_sock.c  |  4 ++++
 2 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 33bb0a88d8a3..33ad7f5f9e4a 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -605,6 +605,7 @@ static void btusb_qca_cmd_timeout(struct hci_dev *hdev)
 {
 	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
+	printk("%s",__func__);
 
 	if (++data->cmd_timeout_cnt < 5)
 		return;
@@ -615,7 +616,7 @@ static void btusb_qca_cmd_timeout(struct hci_dev *hdev)
 	if (!err)
 		usb_queue_reset_device(data->intf);
 	else
-		bt_dev_err(hdev, "Failed usb_autopm_get_interface with %d", err);
+		bt_dev_err(hdev, "Failed autopm_get_interface with %d", err);
 }
 
 static inline void btusb_free_frags(struct btusb_data *data)
@@ -1300,10 +1301,11 @@ static void btusb_isoc_tx_complete(struct urb *urb)
 }
 
 static int btusb_open(struct hci_dev *hdev)
+
 {
 	struct btusb_data *data = hci_get_drvdata(hdev);
 	int err;
-
+        printk("hci0:%s",__func__);
 	BT_DBG("%s", hdev->name);
 
 	err = usb_autopm_get_interface(data->intf);
@@ -1350,6 +1352,7 @@ static int btusb_open(struct hci_dev *hdev)
 	}
 
 done:
+	printk("hci0:%s releasing auto_pm",__func__);
 	usb_autopm_put_interface(data->intf);
 	return 0;
 
@@ -2441,9 +2444,12 @@ static int btusb_setup_intel_new(struct hci_dev *hdev)
 	 * case since that command is only available in bootloader mode.
 	 */
 	if (ver.fw_variant == 0x23) {
+		printk("hci0: %s:device is in operational mode",__func__);
 		clear_bit(BTUSB_BOOTLOADER, &data->flags);
 		btintel_check_bdaddr(hdev);
 		goto finish;
+	} else if(ver.fw_variant == 0x06) {
+		printk("hci0: %s:device is in bootloader mode",__func__);
 	}
 
 	/* If the device is not in bootloader mode, then the only possible
@@ -2532,9 +2538,12 @@ static int btusb_setup_intel_new(struct hci_dev *hdev)
 		err = -EBADF;
 		goto done;
 	}
+        err = usb_autopm_get_interface(data->intf);
+	if(err)
+		printk("hci0:%s failed to get autopm interface",__func__);
 
 	set_bit(BTUSB_DOWNLOADING, &data->flags);
-
+        
 	/* Start firmware downloading and get boot parameter */
 	err = btintel_download_firmware(hdev, fw, &boot_param);
 	if (err < 0) {
@@ -2588,7 +2597,8 @@ static int btusb_setup_intel_new(struct hci_dev *hdev)
 
 done:
 	release_firmware(fw);
-
+        printk("hci0:%s, releasing autopm",__func__);
+	usb_autopm_put_interface(data->intf);
 	if (err < 0)
 		return err;
 
@@ -2693,6 +2703,7 @@ static int btusb_shutdown_intel(struct hci_dev *hdev)
 	 * command to clear all ongoing activity including advertising,
 	 * scanning etc.
 	 */
+	printk("hci0: %s",__func__);
 	skb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);
 	if (IS_ERR(skb)) {
 		ret = PTR_ERR(skb);
@@ -4268,7 +4279,7 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	struct btusb_data *data = usb_get_intfdata(intf);
 
 	BT_DBG("intf %p", intf);
-
+        printk("hci0: %s:",__func__);
 	if (data->suspend_count++)
 		return 0;
 
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 007678799337..a70a0a68a54b 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -866,6 +866,7 @@ static int hci_sock_release(struct socket *sock)
 			 * case since it will have been cleared already when
 			 * opening the user channel.
 			 */
+			printk("hci0:%s, calling hci_dev_do_close in case of user channel close",__func__);
 			hci_dev_do_close(hdev);
 			hci_dev_clear_flag(hdev, HCI_USER_CHANNEL);
 			mgmt_index_added(hdev);
@@ -1087,6 +1088,7 @@ static int hci_sock_bind(struct socket *sock, struct sockaddr *addr,
 
 	switch (haddr.hci_channel) {
 	case HCI_CHANNEL_RAW:
+		printk("hci0:%s:hci channel raw",__func__);
 		if (hci_pi(sk)->hdev) {
 			err = -EALREADY;
 			goto done;
@@ -1134,6 +1136,8 @@ static int hci_sock_bind(struct socket *sock, struct sockaddr *addr,
 		break;
 
 	case HCI_CHANNEL_USER:
+
+		printk("hci0:%s:hci channel user",__func__);
 		if (hci_pi(sk)->hdev) {
 			err = -EALREADY;
 			goto done;
-- 
2.17.1

