From 7c021f10e56ba62cf81132252a6e56a084c93823 Mon Sep 17 00:00:00 2001
From: Bing Han <bing.han@intel.com>
Date: Mon, 14 Jun 2021 13:07:59 +0530
Subject: [PATCH] btusb: add prepare suspend blocker

Prepare suspend blocker is added to prevent system going to suspend
when BT firmware download is ongoing

Tracked-On: OAM-97127
Signed-off-by: Bing Han <bing.han@intel.com>
---
 drivers/bluetooth/btusb.c | 17 ++++++++++++++---
 drivers/usb/core/usb.c    | 28 +++++++++++++++++++++++++++-
 include/linux/usb.h       |  1 +
 3 files changed, 42 insertions(+), 4 deletions(-)

diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 9b284c422719..c813926e704d 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -517,6 +517,7 @@ static const struct dmi_system_id btusb_needs_reset_resume_table[] = {
 #define BTUSB_WAKEUP_AUTOSUSPEND	14
 #define BTUSB_USE_ALT3_FOR_WBS	15
 #define BTUSB_FIRMWARE_VERIFY_FAILED 16
+#define BTUSB_BLOCK_SUSPEND    17
 
 /* Per core spec 5, vol 4, part B, table 2.1,
  * list the hci packet payload sizes for various ALT settings.
@@ -2974,11 +2975,9 @@ static int btusb_setup_intel_new(struct hci_dev *hdev)
 	/* controller is already having an operational firmware */
 	if (ver.fw_variant == 0x23)
 		goto finish;
-
 	err = btusb_intel_boot(hdev, boot_param);
 	if (err)
 		return err;
-
 	clear_bit(BTUSB_BOOTLOADER, &data->flags);
 
 	err = btusb_setup_intel_new_get_fw_name(&ver, &params, ddcname,
@@ -3028,7 +3027,7 @@ static int btusb_setup_intel_new(struct hci_dev *hdev)
 	 * and thus no need to fail the setup.
 	 */
 	btintel_set_event_mask(hdev, false);
-
+	clear_bit(BTUSB_BLOCK_SUSPEND, &data->flags);
 	return 0;
 }
 
@@ -4926,6 +4925,7 @@ static int btusb_probe(struct usb_interface *intf,
 		data->recv_event = btusb_recv_event_intel;
 		data->recv_bulk = btusb_recv_bulk_intel;
 		set_bit(BTUSB_BOOTLOADER, &data->flags);
+		set_bit(BTUSB_BLOCK_SUSPEND, &data->flags);
 	} else if (id->driver_info & BTUSB_REALTEK) {
 		/* Allocate extra space for Realtek device */
 		priv_size += sizeof(struct btrealtek_data);
@@ -5289,6 +5289,16 @@ static void btusb_disconnect(struct usb_interface *intf)
 }
 
 #ifdef CONFIG_PM
+static int btusb_prepare(struct usb_interface *intf)
+{
+	struct btusb_data *data = usb_get_intfdata(intf);
+	if (test_bit(BTUSB_BLOCK_SUSPEND, &data->flags)) {
+		return -EBUSY;
+	}
+	return 0;
+}
+
+
 static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct btusb_data *data = usb_get_intfdata(intf);
@@ -5450,6 +5460,7 @@ static struct usb_driver btusb_driver = {
 	.probe		= btusb_probe,
 	.disconnect	= btusb_disconnect,
 #ifdef CONFIG_PM
+	.prepare        = btusb_prepare,
 	.suspend	= btusb_suspend,
 	.resume		= btusb_resume,
 #endif
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index a21adbe8fbf5..b31b1838ee89 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -527,7 +527,33 @@ static int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
 
 static int usb_dev_prepare(struct device *dev)
 {
-	return 0;		/* Implement eventually? */
+	struct usb_device *udev = to_usb_device(dev);
+	struct usb_interface *intf;
+	struct usb_driver *driver;
+	int status = 0;
+	int i = 0, n = 0;
+
+	if (udev->state == USB_STATE_NOTATTACHED)
+		return 0;
+
+	if (udev->actconfig) {
+		n = udev->actconfig->desc.bNumInterfaces;
+		dev_info(dev, "bNumInterfaces %d\n", n);
+		for (i = n - 1; i >= 0; --i) {
+			intf = udev->actconfig->interface[i];
+			if (intf->condition == USB_INTERFACE_UNBOUND)
+				continue;
+			driver = to_usb_driver(intf->dev.driver);
+			if (driver->prepare) {
+				dev_info(dev, "driver->prepare\n");
+				status = driver->prepare(intf);
+				dev_info(dev, "driver->prepare status: %d\n", status);
+				if (status)
+					return status;
+			}
+		}
+	}
+	return 0;
 }
 
 static void usb_dev_complete(struct device *dev)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 303fd47848fa..4575f3ffa954 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1211,6 +1211,7 @@ struct usb_driver {
 	int (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,
 			void *buf);
 
+	int (*prepare) (struct usb_interface *intf);
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
 	int (*reset_resume)(struct usb_interface *intf);
-- 
2.40.1

