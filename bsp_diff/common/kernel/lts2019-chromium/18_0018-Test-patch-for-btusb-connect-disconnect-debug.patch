From 4450998c76e6adf4869a0785781f369068bff0c2 Mon Sep 17 00:00:00 2001
From: Aiswarya Cyriac <aiswarya.cyriac@intel.com>
Date: Thu, 18 Mar 2021 22:01:26 +0530
Subject: [PATCH] Test patch for btusb connect disconnect debug

Signed-off-by: Aiswarya Cyriac <aiswarya.cyriac@intel.com>
---
 drivers/bluetooth/btusb.c | 27 +++++++++++++++++++++++----
 net/bluetooth/hci_core.c  |  7 +++++--
 net/bluetooth/hci_sock.c  |  2 +-
 3 files changed, 29 insertions(+), 7 deletions(-)

diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 33bb0a88d8a3..d3778d22d287 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -2383,7 +2383,7 @@ static int btusb_setup_intel_new(struct hci_dev *hdev)
 	 */
 	err = btintel_read_version(hdev, &ver);
 	if (err) {
-		bt_dev_err(hdev, "Intel Read version failed (%d)", err);
+		bt_dev_err(hdev, " %s:Intel Read version failed (%d)", __func__,err);
 		btintel_reset_to_bootloader(hdev);
 		return err;
 	}
@@ -2441,10 +2441,12 @@ static int btusb_setup_intel_new(struct hci_dev *hdev)
 	 * case since that command is only available in bootloader mode.
 	 */
 	if (ver.fw_variant == 0x23) {
+		printk("hci0: %s:device is in operational mode",__func__);
 		clear_bit(BTUSB_BOOTLOADER, &data->flags);
 		btintel_check_bdaddr(hdev);
 		goto finish;
-	}
+	} else if (ver.fw_variant == 0x06)
+		printk("hci0: %s: device is in bootloader mode",__func__);
 
 	/* If the device is not in bootloader mode, then the only possible
 	 * choice is to return an error and abort the device initialization.
@@ -2693,6 +2695,7 @@ static int btusb_shutdown_intel(struct hci_dev *hdev)
 	 * command to clear all ongoing activity including advertising,
 	 * scanning etc.
 	 */
+	printk("%s",__func__);
 	skb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);
 	if (IS_ERR(skb)) {
 		ret = PTR_ERR(skb);
@@ -3849,6 +3852,7 @@ static int btusb_recv_evt(struct btusb_data *data, struct sk_buff *skb)
 }
 
 static int btusb_probe(struct usb_interface *intf,
+
 		       const struct usb_device_id *id)
 {
 	struct usb_endpoint_descriptor *ep_desc;
@@ -4069,6 +4073,7 @@ static int btusb_probe(struct usb_interface *intf,
 		set_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);
 		set_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);
 		set_bit(HCI_QUIRK_NON_PERSISTENT_DIAG, &hdev->quirks);
+                set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);
 	}
 
 	if (id->driver_info & BTUSB_MARVELL)
@@ -4268,12 +4273,13 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 	struct btusb_data *data = usb_get_intfdata(intf);
 
 	BT_DBG("intf %p", intf);
-
+        printk("hci0: %s:",__func__);
 	if (data->suspend_count++)
 		return 0;
 
 	spin_lock_irq(&data->txlock);
 	if (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {
+		printk("hci0: %s: forced suspend",__func__);
 		set_bit(BTUSB_SUSPENDING, &data->flags);
 		spin_unlock_irq(&data->txlock);
 	} else {
@@ -4281,7 +4287,17 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 		data->suspend_count--;
 		return -EBUSY;
 	}
-
+        if(PMSG_IS_AUTO(message)){
+	
+		printk("hci0: %s: auto suspend",__func__);
+	}
+	if(test_bit(BTUSB_DOWNLOADING,&data->flags)&& PMSG_IS_AUTO(message)){
+	
+		spin_unlock_irq(&data->txlock);
+		data->suspend_count--;
+		printk("hci0 %s: Btusbfirmware download is happening while in autosuspend",__func__);
+		return -EBUSY;
+	}
 	cancel_work_sync(&data->work);
 
 	btusb_stop_traffic(data);
@@ -4350,6 +4366,7 @@ static int btusb_resume(struct usb_interface *intf)
 	if (--data->suspend_count)
 		return 0;
 
+         printk(" hci0: %s: resumed from susped",__func__);
 	/* Disable only if not already disabled (keep it balanced) */
 	if (test_and_clear_bit(BTUSB_OOB_WAKE_ENABLED, &data->flags)) {
 		disable_irq(data->oob_wake_irq);
@@ -4360,6 +4377,8 @@ static int btusb_resume(struct usb_interface *intf)
 		goto done;
 
 	if (test_bit(BTUSB_INTR_RUNNING, &data->flags)) {
+
+		printk("hci0: %s: btusb_intr_running",__func__);
 		err = btusb_submit_intr_urb(hdev, GFP_NOIO);
 		if (err < 0) {
 			clear_bit(BTUSB_INTR_RUNNING, &data->flags);
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index eeafed2efc0d..8d2efec09b70 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1693,6 +1693,7 @@ static void hci_pend_le_actions_clear(struct hci_dev *hdev)
 int hci_dev_do_close(struct hci_dev *hdev)
 {
 	bool auto_off;
+	printk("%s",__func__);
 
 	BT_DBG("%s %p", hdev->name, hdev);
 
@@ -1700,8 +1701,9 @@ int hci_dev_do_close(struct hci_dev *hdev)
 	    !hci_dev_test_flag(hdev, HCI_USER_CHANNEL) &&
 	    test_bit(HCI_UP, &hdev->flags)) {
 		/* Execute vendor specific shutdown routine */
-		if (hdev->shutdown)
-			hdev->shutdown(hdev);
+		if (hdev->shutdown){
+			printk("%s: calling shutdown",__func__);
+			hdev->shutdown(hdev);}
 	}
 
 	cancel_delayed_work(&hdev->power_off);
@@ -1832,6 +1834,7 @@ int hci_dev_close(__u16 dev)
 
 	if (hci_dev_test_flag(hdev, HCI_USER_CHANNEL)) {
 		err = -EBUSY;
+		printk("%s: HCI_USER_CHANNEL hence not calling shutdown",__func__);
 		goto done;
 	}
 
diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 007678799337..50aa052e9b95 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -462,7 +462,7 @@ static struct sk_buff *create_monitor_event(struct hci_dev *hdev, int event)
 		skb = bt_skb_alloc(0, GFP_ATOMIC);
 		if (!skb)
 			return NULL;
-
+                printk("%s:",__func__);
 		opcode = cpu_to_le16(HCI_MON_CLOSE_INDEX);
 		break;
 
-- 
2.17.1

