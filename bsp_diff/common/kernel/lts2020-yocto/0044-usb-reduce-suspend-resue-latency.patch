From cf82952a474ee46c15a423938aa4f8a2a9db649f Mon Sep 17 00:00:00 2001
From: Kaushlendra Kumar <kaushlendra.kumar@intel.com>
Date: Mon, 19 Jun 2023 16:44:06 +0530
Subject: [PATCH] usb: reduce suspend/resue latency

Signed-off-by: Kaushlendra Kumar <kaushlendra.kumar@intel.com>
---
 drivers/usb/common/common.c       |  8 ++++++++
 drivers/usb/core/hub.c            | 13 ++++++-------
 drivers/usb/core/usb.c            | 11 +++++++++++
 drivers/usb/host/ehci-hcd.c       |  2 +-
 drivers/usb/host/ehci-hub.c       |  4 ++--
 drivers/usb/host/fotg210-hcd.c    |  2 +-
 drivers/usb/host/isp116x-hcd.c    |  2 +-
 drivers/usb/host/isp1362-hcd.c    |  2 +-
 drivers/usb/host/ohci-hub.c       |  2 +-
 drivers/usb/host/oxu210hp-hcd.c   |  2 +-
 drivers/usb/host/r8a66597-hcd.c   |  2 +-
 drivers/usb/host/sl811-hcd.c      |  2 +-
 drivers/usb/host/uhci-hub.c       |  6 +++---
 drivers/usb/host/xhci-hub.c       |  6 +++---
 drivers/usb/host/xhci-ring.c      |  2 +-
 drivers/usb/isp1760/isp1760-hcd.c |  2 +-
 drivers/usb/musb/musb_core.c      |  4 ++--
 include/linux/usb.h               | 17 ++++++++++++++++-
 18 files changed, 61 insertions(+), 28 deletions(-)

diff --git a/drivers/usb/common/common.c b/drivers/usb/common/common.c
index 347fb3d3894a..56e72dfad14e 100644
--- a/drivers/usb/common/common.c
+++ b/drivers/usb/common/common.c
@@ -17,6 +17,14 @@
 #include <linux/of_platform.h>
 #include <linux/debugfs.h>
 #include "common.h"
+struct usb_timing_config usb_timing = {
+	.tdrsmdn = USB_TIMING_TDRSMDN_DEF,
+	.trsmrcy = USB_TIMING_TRSMRCY_DEF,
+	.trstrcy = USB_TIMING_TRSTRCY_DEF,
+	.tdrstr  = USB_TIMING_TDRSTR_DEF
+};
+
+EXPORT_SYMBOL_GPL(usb_timing);
 
 static const char *const ep_type_names[] = {
 	[USB_ENDPOINT_XFER_CONTROL] = "ctrl",
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 371e19e72d2c..63240a291c05 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2984,8 +2984,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 			usleep_range(10000, 12000);
 		else {
 			/* TRSTRCY = 10 ms; plus some extra */
-			reset_recovery_time = 10 + 40;
-
+			msleep(usb_timing.trstrcy);
 			/* Hub needs extra delay after resetting its port. */
 			if (hub->hdev->quirks & USB_QUIRK_HUB_SLOW_RESET)
 				reset_recovery_time += 100;
@@ -3591,10 +3590,10 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	if (status) {
 		dev_dbg(&port_dev->dev, "can't resume, status %d\n", status);
 	} else {
-		/* drive resume for USB_RESUME_TIMEOUT msec */
+		/* drive resume for TDRSMDN msec */
 		dev_dbg(&udev->dev, "usb %sresume\n",
 				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
-		msleep(USB_RESUME_TIMEOUT);
+		msleep(usb_timing.tdrsmdn);
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
@@ -3617,7 +3616,7 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 		}
 
 		/* TRSMRCY = 10 msec */
-		msleep(10);
+		msleep(usb_timing.trsmrcy);
 	}
 
 	if (udev->persist_enabled)
@@ -3690,7 +3689,7 @@ static int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,
 
 	if (udev) {
 		/* TRSMRCY = 10 msec */
-		msleep(10);
+		msleep(usb_timing.trsmrcy);
 
 		usb_unlock_port(port_dev);
 		ret = usb_remote_wakeup(udev);
@@ -4356,7 +4355,7 @@ static void hub_usb3_port_prepare_disable(struct usb_hub *hub,
 		ret = hub_set_port_link_state(hub, port_dev->portnum,
 					      USB_SS_PORT_LS_U0);
 		if (!ret) {
-			msleep(USB_RESUME_TIMEOUT);
+			msleep(usb_timing.tdrsmdn);
 			ret = usb_disable_remote_wakeup(udev);
 		}
 		if (ret)
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index db4de5367737..d5a76b72dcb6 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -72,6 +72,10 @@ MODULE_PARM_DESC(autosuspend, "default autosuspend delay");
 #define usb_autosuspend_delay		0
 #endif
 
+static bool timing_minimum;
+module_param(timing_minimum, bool, 0644);
+MODULE_PARM_DESC(timing_minimum, "Use USB 2.0 spec minimum delays");
+
 static bool match_endpoint(struct usb_endpoint_descriptor *epd,
 		struct usb_endpoint_descriptor **bulk_in,
 		struct usb_endpoint_descriptor **bulk_out,
@@ -1007,6 +1011,13 @@ static int __init usb_init(void)
 	}
 	usb_init_pool_max();
 
+	if (timing_minimum) {
+		usb_timing.tdrsmdn = USB_TIMING_TDRSMDN_MIN;
+		usb_timing.trsmrcy = USB_TIMING_TRSMRCY_MIN;
+		usb_timing.trstrcy = USB_TIMING_TRSTRCY_MIN;
+		usb_timing.tdrstr  = USB_TIMING_TDRSTR_MIN;
+	}
+
 	usb_debugfs_init();
 
 	usb_acpi_register();
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8aff19ff8e8f..2a4dde577815 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -831,7 +831,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 * PORT_STAT_C_SUSPEND to stop that signaling.
 			 */
 			ehci->reset_done[i] = jiffies +
-				msecs_to_jiffies(USB_RESUME_TIMEOUT);
+				msecs_to_jiffies(usb_timing.tdrsmdn);
 			set_bit(i, &ehci->resuming_ports);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			usb_hcd_start_port_resume(&hcd->self, i);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 9f9ab5ccea88..a7f2adb494d3 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -479,7 +479,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	 */
 	if (resume_needed) {
 		spin_unlock_irq(&ehci->lock);
-		msleep(USB_RESUME_TIMEOUT);
+		msleep(usb_timing.tdrsmdn);
 		spin_lock_irq(&ehci->lock);
 		if (ehci->shutdown)
 			goto shutdown;
@@ -963,7 +963,7 @@ int ehci_hub_control(
 			temp &= ~PORT_WAKE_BITS;
 			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
 			ehci->reset_done[wIndex] = jiffies
-					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);
+					+ msecs_to_jiffies(usb_timing.tdrsmdn);
 			set_bit(wIndex, &ehci->resuming_ports);
 			usb_hcd_start_port_resume(&hcd->self, wIndex);
 			break;
diff --git a/drivers/usb/host/fotg210-hcd.c b/drivers/usb/host/fotg210-hcd.c
index ff0b3457fd34..a78ad6551062 100644
--- a/drivers/usb/host/fotg210-hcd.c
+++ b/drivers/usb/host/fotg210-hcd.c
@@ -1518,7 +1518,7 @@ static int fotg210_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			/* resume signaling for 20 msec */
 			fotg210_writel(fotg210, temp | PORT_RESUME, status_reg);
 			fotg210->reset_done[wIndex] = jiffies
-					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);
+					+ msecs_to_jiffies(usb_timing.tdrsmdn);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &fotg210->port_c_suspend);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 3e5c54742bef..35bdeb9d1ef2 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1481,7 +1481,7 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 	spin_unlock_irq(&isp116x->lock);
 
 	hcd->state = HC_STATE_RESUMING;
-	msleep(USB_RESUME_TIMEOUT);
+	msleep(usb_timing.tdrsmdn);
 
 	/* Go operational */
 	spin_lock_irq(&isp116x->lock);
diff --git a/drivers/usb/host/isp1362-hcd.c b/drivers/usb/host/isp1362-hcd.c
index 2cecb36d241b..40a6762aa7ca 100644
--- a/drivers/usb/host/isp1362-hcd.c
+++ b/drivers/usb/host/isp1362-hcd.c
@@ -1898,7 +1898,7 @@ static int isp1362_bus_resume(struct usb_hcd *hcd)
 	isp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);
 	spin_unlock_irqrestore(&isp1362_hcd->lock, flags);
 	/* TRSMRCY */
-	msleep(10);
+	msleep(usb_timing.trsmrcy);
 
 	/* keep it alive for ~5x suspend + resume costs */
 	isp1362_hcd->next_statechange = jiffies + msecs_to_jiffies(250);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 44504c1751e0..c9c634d45016 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -257,7 +257,7 @@ __acquires(ohci->lock)
 
 	/* TRSMRCY */
 	if (!autostopped) {
-		msleep (10);
+		msleep(usb_timing.trsmrcy);
 		spin_lock_irq (&ohci->lock);
 	}
 	/* now ohci->lock is always held and irqs are always disabled */
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index 6df2881cd7b9..1481e9d92ff4 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -2920,7 +2920,7 @@ static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)
 			 * stop that signaling.
 			 */
 			oxu->reset_done[i] = jiffies +
-				msecs_to_jiffies(USB_RESUME_TIMEOUT);
+				msecs_to_jiffies(usb_timing.tdrsmdn);
 			oxu_dbg(oxu, "port %d remote wakeup\n", i + 1);
 			mod_timer(&hcd->rh_timer, oxu->reset_done[i]);
 		}
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 63719cdf6a4e..4a63ed7905cc 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -2290,7 +2290,7 @@ static int r8a66597_bus_resume(struct usb_hcd *hcd)
 		rh->port &= ~USB_PORT_STAT_SUSPEND;
 		rh->port |= USB_PORT_STAT_C_SUSPEND << 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
-		msleep(USB_RESUME_TIMEOUT);
+		msleep(usb_timing.tdrsmdn);
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
 	}
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 9465fce99c82..3a5a95e39230 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1260,7 +1260,7 @@ sl811h_hub_control(
 			sl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);
 
 			mod_timer(&sl811->timer, jiffies
-					+ msecs_to_jiffies(USB_RESUME_TIMEOUT));
+					+ msecs_to_jiffies(usb_timing.tdrsmdn));
 			break;
 		case USB_PORT_FEAT_POWER:
 			port_power(sl811, 0);
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 47106dd8ca7c..3fc0dc28adf5 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -167,7 +167,7 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 				/* Port received a wakeup request */
 				set_bit(port, &uhci->resuming_ports);
 				uhci->ports_timeout = jiffies +
-					msecs_to_jiffies(USB_RESUME_TIMEOUT);
+					msecs_to_jiffies(usb_timing.tdrsmdn);
 				usb_hcd_start_port_resume(
 						&uhci_to_hcd(uhci)->self, port);
 
@@ -340,7 +340,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 
 			/* USB v2.0 7.1.7.5 */
 			uhci->ports_timeout = jiffies +
-				msecs_to_jiffies(USB_RESUME_TIMEOUT);
+				msecs_to_jiffies(usb_timing.tdrsmdn);
 			break;
 		case USB_PORT_FEAT_POWER:
 			/* UHCI has no power switching */
@@ -383,7 +383,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 				else
 					/* USB v2.0 7.1.7.7 */
 					uhci->ports_timeout = jiffies +
-						msecs_to_jiffies(20);
+						msecs_to_jiffies(usb_timing.tdrsmdn);
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
index ecc65c6b011e..bfa1629319b6 100644
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -857,7 +857,7 @@ static int xhci_handle_usb2_port_link_resume(struct xhci_port *port,
 			 * start resume timing
 			 */
 			unsigned long timeout = jiffies +
-				msecs_to_jiffies(USB_RESUME_TIMEOUT);
+				msecs_to_jiffies(usb_timing.tdrsmdn);
 
 			set_bit(wIndex, &bus_state->resuming_ports);
 			bus_state->resume_done[wIndex] = timeout;
@@ -1475,7 +1475,7 @@ int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 				xhci_set_link_state(xhci, ports[wIndex],
 						    XDEV_RESUME);
 				spin_unlock_irqrestore(&xhci->lock, flags);
-				msleep(USB_RESUME_TIMEOUT);
+				msecs_to_jiffies(usb_timing.tdrsmdn);
 				spin_lock_irqsave(&xhci->lock, flags);
 				xhci_set_link_state(xhci, ports[wIndex],
 							XDEV_U0);
@@ -1847,7 +1847,7 @@ int xhci_bus_resume(struct usb_hcd *hcd)
 	if (hcd->speed < HCD_USB3) {
 		if (bus_state->bus_suspended) {
 			spin_unlock_irqrestore(&xhci->lock, flags);
-			msleep(USB_RESUME_TIMEOUT);
+			msecs_to_jiffies(usb_timing.tdrsmdn);
 			spin_lock_irqsave(&xhci->lock, flags);
 		}
 		for_each_set_bit(port_index, &bus_state->bus_suspended,
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 174731247666..dfc50a710740 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -1962,7 +1962,7 @@ static void handle_port_status(struct xhci_hcd *xhci,
 		} else if (!test_bit(hcd_portnum, &bus_state->resuming_ports)) {
 			xhci_dbg(xhci, "resume HS port %d\n", port_id);
 			bus_state->resume_done[hcd_portnum] = jiffies +
-				msecs_to_jiffies(USB_RESUME_TIMEOUT);
+				msecs_to_jiffies(usb_timing.tdrsmdn);
 			set_bit(hcd_portnum, &bus_state->resuming_ports);
 			/* Do the rest in GetPortStatus after resume time delay.
 			 * Avoid polling roothub status before that so that a
diff --git a/drivers/usb/isp1760/isp1760-hcd.c b/drivers/usb/isp1760/isp1760-hcd.c
index 33ae656c4b68..8d52dc91690d 100644
--- a/drivers/usb/isp1760/isp1760-hcd.c
+++ b/drivers/usb/isp1760/isp1760-hcd.c
@@ -1865,7 +1865,7 @@ static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,
 				reg_write32(hcd->regs, HC_PORTSC1,
 							temp | PORT_RESUME);
 				priv->reset_done = jiffies +
-					msecs_to_jiffies(USB_RESUME_TIMEOUT);
+					msecs_to_jiffies(usb_timing.tdrsmdn);
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 4c8f0112481f..ba162d6d5f47 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -677,12 +677,12 @@ static void musb_handle_intr_resume(struct musb *musb, u8 devctl)
 					(USB_PORT_STAT_C_SUSPEND << 16)
 					| MUSB_PORT_STAT_RESUME;
 			musb->rh_timer = jiffies
-				+ msecs_to_jiffies(USB_RESUME_TIMEOUT);
+				+ msecs_to_jiffies(usb_timing.tdrsmdn);
 			musb->xceiv->otg->state = OTG_STATE_A_HOST;
 			musb->is_active = 1;
 			musb_host_resume_root_hub(musb);
 			schedule_delayed_work(&musb->finish_resume_work,
-				msecs_to_jiffies(USB_RESUME_TIMEOUT));
+				msecs_to_jiffies(usb_timing.tdrsmdn);
 			break;
 		case OTG_STATE_B_WAIT_ACON:
 			musb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 9f8e9e3d759e..b6566a52febc 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -309,7 +309,22 @@ void usb_put_intf(struct usb_interface *intf);
  * should cope with both LPJ calibration errors and devices not following every
  * detail of the USB Specification.
  */
-#define USB_RESUME_TIMEOUT	40 /* ms */
+#define USB_TIMING_TDRSMDN_MIN 20
+#define USB_TIMING_TRSMRCY_MIN 10
+#define USB_TIMING_TRSTRCY_MIN 0
+#define USB_TIMING_TDRSTR_MIN  50
+#define USB_TIMING_TDRSMDN_DEF 40
+#define USB_TIMING_TRSMRCY_DEF 10
+#define USB_TIMING_TRSTRCY_DEF 50
+#define USB_TIMING_TDRSTR_DEF  50
+
+struct usb_timing_config {
+	unsigned int tdrsmdn; /* resume signal time   20ms - infinity */
+	unsigned int trsmrcy; /* resume recovery time  0ms - 10ms     */
+	unsigned int trstrcy; /* reset recovery time   0ms - infinity */
+	unsigned int tdrstr;  /* root hub port reset  50ms - infinity */
+};
+extern struct usb_timing_config usb_timing;
 
 /**
  * struct usb_interface_cache - long-term representation of a device interface
-- 
2.40.1

