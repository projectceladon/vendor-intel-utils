From dae13ddbc5e856486795316e4fc3d541fc0717c9 Mon Sep 17 00:00:00 2001
From: Vilas R K <vilas.r.k@intel.com>
Date: Wed, 16 Mar 2022 15:36:43 +0530
Subject: [PATCH] [VSOCK] Enable VirtIO Logs

Signed-off-by: Vilas R K <vilas.r.k@intel.com>
---
 drivers/virtio/virtio.c            | 10 +++++++++-
 drivers/virtio/virtio_balloon.c    |  1 +
 drivers/virtio/virtio_input.c      |  2 +-
 drivers/virtio/virtio_mem.c        |  1 +
 drivers/virtio/virtio_mmio.c       | 21 +++++++++++++++++++++
 drivers/virtio/virtio_pci_common.c |  2 +-
 drivers/virtio/virtio_ring.c       |  4 +++-
 7 files changed, 37 insertions(+), 4 deletions(-)

diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c
index e3f5057baa7d..de9eff884c7d 100644
--- a/drivers/virtio/virtio.c
+++ b/drivers/virtio/virtio.c
@@ -402,7 +402,7 @@ EXPORT_SYMBOL_GPL(unregister_virtio_device);
 int virtio_device_freeze(struct virtio_device *dev)
 {
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
-
+	printk(KERN_DEBUG "[VSOCK]: In %s %d \n",__FUNCTION__,__LINE__);
 	virtio_config_disable(dev);
 
 	dev->failed = dev->config->get_status(dev) & VIRTIO_CONFIG_S_FAILED;
@@ -419,6 +419,13 @@ int virtio_device_restore(struct virtio_device *dev)
 	struct virtio_driver *drv = drv_to_virtio(dev->dev.driver);
 	int ret;
 
+	/* Short path for stateful devices. Here we assume that if the device
+	 * does not have a freeze callback, its state was not changed when
+	 * suspended.
+	 */
+	if (drv && !drv->freeze)
+		goto on_config_enable;
+
 	/* We always start by resetting the device, in case a previous
 	 * driver messed it up. */
 	dev->config->reset(dev);
@@ -450,6 +457,7 @@ int virtio_device_restore(struct virtio_device *dev)
 	/* Finally, tell the device we're all set */
 	virtio_add_status(dev, VIRTIO_CONFIG_S_DRIVER_OK);
 
+on_config_enable:
 	virtio_config_enable(dev);
 
 	return 0;
diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c
index 8985fc2cea86..5629c7e9530b 100644
--- a/drivers/virtio/virtio_balloon.c
+++ b/drivers/virtio/virtio_balloon.c
@@ -1080,6 +1080,7 @@ static int virtballoon_freeze(struct virtio_device *vdev)
 {
 	struct virtio_balloon *vb = vdev->priv;
 
+	printk(KERN_DEBUG "[VSOCK]: In  %s %d \n",__FUNCTION__,__LINE__);
 	/*
 	 * The workqueue is already frozen by the PM core before this
 	 * function is called.
diff --git a/drivers/virtio/virtio_input.c b/drivers/virtio/virtio_input.c
index 427d58c771cb..9f50b8ae56ff 100644
--- a/drivers/virtio/virtio_input.c
+++ b/drivers/virtio/virtio_input.c
@@ -345,7 +345,7 @@ static int virtinput_freeze(struct virtio_device *vdev)
 {
 	struct virtio_input *vi = vdev->priv;
 	unsigned long flags;
-
+	printk(KERN_DEBUG "[VSOCK]: In %s %d \n",__FUNCTION__,__LINE__);
 	spin_lock_irqsave(&vi->lock, flags);
 	vi->ready = false;
 	spin_unlock_irqrestore(&vi->lock, flags);
diff --git a/drivers/virtio/virtio_mem.c b/drivers/virtio/virtio_mem.c
index 41bd84335b23..a41412633a9b 100644
--- a/drivers/virtio/virtio_mem.c
+++ b/drivers/virtio/virtio_mem.c
@@ -1912,6 +1912,7 @@ static int virtio_mem_freeze(struct virtio_device *vdev)
 	 * When restarting the VM, all memory is usually unplugged. Don't
 	 * allow to suspend/hibernate.
 	 */
+	printk(KERN_DEBUG "[VSOCK]: In %s %d \n",__FUNCTION__,__LINE__);
 	dev_err(&vdev->dev, "save/restore not supported.\n");
 	return -EPERM;
 }
diff --git a/drivers/virtio/virtio_mmio.c b/drivers/virtio/virtio_mmio.c
index 238383ff1064..de73bd63f6b6 100644
--- a/drivers/virtio/virtio_mmio.c
+++ b/drivers/virtio/virtio_mmio.c
@@ -763,6 +763,26 @@ static void vm_unregister_cmdline_devices(void)
 
 #endif
 
+#ifdef CONFIG_PM_SLEEP
+static int virtio_mmio_freeze(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct virtio_mmio_device *vm_dev = platform_get_drvdata(pdev);
+
+	return virtio_device_freeze(&vm_dev->vdev);
+}
+
+static int virtio_mmio_restore(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct virtio_mmio_device *vm_dev = platform_get_drvdata(pdev);
+
+	return virtio_device_restore(&vm_dev->vdev);
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(virtio_mmio_pm_ops, virtio_mmio_freeze, virtio_mmio_restore);
+
 /* Platform driver */
 
 static const struct of_device_id virtio_mmio_match[] = {
@@ -786,6 +806,7 @@ static struct platform_driver virtio_mmio_driver = {
 		.name	= "virtio-mmio",
 		.of_match_table	= virtio_mmio_match,
 		.acpi_match_table = ACPI_PTR(virtio_mmio_acpi_match),
+		.pm = &virtio_mmio_pm_ops,
 	},
 };
 
diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c
index b35bb2d57f62..a9aad36c4b85 100644
--- a/drivers/virtio/virtio_pci_common.c
+++ b/drivers/virtio/virtio_pci_common.c
@@ -462,7 +462,7 @@ static int virtio_pci_freeze(struct device *dev)
 	struct pci_dev *pci_dev = to_pci_dev(dev);
 	struct virtio_pci_device *vp_dev = pci_get_drvdata(pci_dev);
 	int ret;
-
+	printk(KERN_DEBUG "[VSOCK]: In %s %d \n",__FUNCTION__,__LINE__);
 	ret = virtio_device_freeze(&vp_dev->vdev);
 
 	if (!ret)
diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c
index 7b9fe9893a2d..ce325abfef5a 100644
--- a/drivers/virtio/virtio_ring.c
+++ b/drivers/virtio/virtio_ring.c
@@ -1124,8 +1124,10 @@ static inline int virtqueue_add_packed(struct virtqueue *_vq,
 	if (virtqueue_use_indirect(_vq, total_sg)) {
 		err = virtqueue_add_indirect_packed(vq, sgs, total_sg, out_sgs,
 						    in_sgs, data, gfp);
-		if (err != -ENOMEM)
+		if (err != -ENOMEM) {
+			END_USE(vq);
 			return err;
+		}
 
 		/* fall back on direct */
 	}
-- 
2.17.1

