From 863b429ca7dafecc4b8850ee55cf68d688605f86 Mon Sep 17 00:00:00 2001
From: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
Date: Mon, 5 Aug 2024 14:59:49 +0000
Subject: [PATCH] Remove bluetooth hidl hal

From A15, BT hal has to be aidl, so removing hidl implementation
of it.

Tracked-On: OAM-122186
Signed-off-by: Gowtham Anandha Babu <gowtham.anandha.babu@intel.com>
---
 bluetooth/Android.bp                          |  48 --
 bluetooth/LICENSE                             | 176 -------
 ...roid.hardware.bluetooth@1.0-service.vbt.rc |  15 -
 bluetooth/async_fd_watcher.cc                 | 193 --------
 bluetooth/async_fd_watcher.h                  |  67 ---
 bluetooth/bluetooth_address.cc                | 128 ------
 bluetooth/bluetooth_address.h                 |  61 ---
 bluetooth/bluetooth_hci.cc                    | 145 ------
 bluetooth/bluetooth_hci.h                     |  61 ---
 bluetooth/bt_vendor_lib.h                     | 435 ------------------
 bluetooth/h4_protocol.cc                      | 269 -----------
 bluetooth/h4_protocol.h                       |  71 ---
 bluetooth/hci_internals.h                     |  49 --
 bluetooth/hci_packetizer.cc                   | 117 -----
 bluetooth/hci_packetizer.h                    |  54 ---
 bluetooth/hci_protocol.cc                     |  58 ---
 bluetooth/hci_protocol.h                      |  49 --
 bluetooth/mct_protocol.cc                     |  70 ---
 bluetooth/mct_protocol.h                      |  56 ---
 bluetooth/service.cpp                         |  37 --
 bluetooth/vendor_interface.cc                 | 394 ----------------
 bluetooth/vendor_interface.h                  |  76 ---
 22 files changed, 2629 deletions(-)
 delete mode 100644 bluetooth/Android.bp
 delete mode 100644 bluetooth/LICENSE
 delete mode 100644 bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc
 delete mode 100644 bluetooth/async_fd_watcher.cc
 delete mode 100644 bluetooth/async_fd_watcher.h
 delete mode 100644 bluetooth/bluetooth_address.cc
 delete mode 100644 bluetooth/bluetooth_address.h
 delete mode 100644 bluetooth/bluetooth_hci.cc
 delete mode 100644 bluetooth/bluetooth_hci.h
 delete mode 100644 bluetooth/bt_vendor_lib.h
 delete mode 100644 bluetooth/h4_protocol.cc
 delete mode 100644 bluetooth/h4_protocol.h
 delete mode 100644 bluetooth/hci_internals.h
 delete mode 100644 bluetooth/hci_packetizer.cc
 delete mode 100644 bluetooth/hci_packetizer.h
 delete mode 100644 bluetooth/hci_protocol.cc
 delete mode 100644 bluetooth/hci_protocol.h
 delete mode 100644 bluetooth/mct_protocol.cc
 delete mode 100644 bluetooth/mct_protocol.h
 delete mode 100644 bluetooth/service.cpp
 delete mode 100644 bluetooth/vendor_interface.cc
 delete mode 100644 bluetooth/vendor_interface.h

diff --git a/bluetooth/Android.bp b/bluetooth/Android.bp
deleted file mode 100644
index ce79c85..0000000
--- a/bluetooth/Android.bp
+++ /dev/null
@@ -1,48 +0,0 @@
-//
-// Copyright (C) 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-cc_binary {
-    name: "android.hardware.bluetooth@1.0-service.vbt",
-    proprietary: true,
-    relative_install_path: "hw",
-    include_dirs: [
-        "packages/modules/Bluetooth/system/device/include",
-        "packages/modules/Bluetooth/system/stack/include"
-    ],
-    srcs: [
-        "async_fd_watcher.cc",
-        "bluetooth_hci.cc",
-        "bluetooth_address.cc",
-        "vendor_interface.cc",
-        "hci_packetizer.cc",
-        "hci_protocol.cc",
-        "h4_protocol.cc",
-        "mct_protocol.cc",
-        "service.cpp",
-    ],
-    shared_libs: [
-        "android.hardware.bluetooth@1.0",
-        "libbase",
-        "libcutils",
-        "libhardware",
-        "libhwbinder",
-        "libhidlbase",
-        "libhidltransport",
-        "liblog",
-        "libutils",
-        "libusb",
-    ],
-    init_rc: ["android.hardware.bluetooth@1.0-service.vbt.rc"],
-}
diff --git a/bluetooth/LICENSE b/bluetooth/LICENSE
deleted file mode 100644
index 1a9893b..0000000
--- a/bluetooth/LICENSE
+++ /dev/null
@@ -1,176 +0,0 @@
-                                Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
diff --git a/bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc b/bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc
deleted file mode 100644
index af765bf..0000000
--- a/bluetooth/android.hardware.bluetooth@1.0-service.vbt.rc
+++ /dev/null
@@ -1,15 +0,0 @@
-service vendor.bluetooth-1-0 /vendor/bin/hw/android.hardware.bluetooth@1.0-service.vbt
-    class hal
-    capabilities BLOCK_SUSPEND NET_ADMIN SYS_NICE
-    user bluetooth
-    group bluetooth
-    writepid /dev/stune/foreground/tasks
-
-on property:vts.native_server.on=1 && property:ro.build.type=userdebug
-    stop vendor.bluetooth-1-0
-on property:vts.native_server.on=1 && property:ro.build.type=eng
-    stop vendor.bluetooth-1-0
-on property:vts.native_server.on=0 && property:ro.build.type=userdebug
-    start vendor.bluetooth-1-0
-on property:vts.native_server.on=0 && property:ro.build.type=eng
-    start vendor.bluetooth-1-0
diff --git a/bluetooth/async_fd_watcher.cc b/bluetooth/async_fd_watcher.cc
deleted file mode 100644
index 76d10c0..0000000
--- a/bluetooth/async_fd_watcher.cc
+++ /dev/null
@@ -1,193 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#define LOG_TAG "android.hardware.bluetooth@1.0-service.vbt"
-
-#include "async_fd_watcher.h"
-
-#include <algorithm>
-#include <atomic>
-#include <condition_variable>
-#include <map>
-#include <mutex>
-#include <thread>
-#include <log/log.h>
-#include <vector>
-#include "fcntl.h"
-#include "sys/select.h"
-#include "unistd.h"
-
-static const int INVALID_FD = -1;
-
-static const int BT_RT_PRIORITY = 1;
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace async {
-
-int AsyncFdWatcher::WatchFdForNonBlockingReads(
-    int file_descriptor, const ReadCallback& on_read_fd_ready_callback) {
-  // Add file descriptor and callback
-  {
-    std::unique_lock<std::mutex> guard(internal_mutex_);
-    watched_fds_[file_descriptor] = on_read_fd_ready_callback;
-  }
-
-  // Start the thread if not started yet
-  return tryStartThread();
-}
-
-int AsyncFdWatcher::ConfigureTimeout(
-    const std::chrono::milliseconds timeout,
-    const TimeoutCallback& on_timeout_callback) {
-  // Add timeout and callback
-  {
-    std::unique_lock<std::mutex> guard(timeout_mutex_);
-    timeout_cb_ = on_timeout_callback;
-    timeout_ms_ = timeout;
-  }
-
-  notifyThread();
-  return 0;
-}
-
-void AsyncFdWatcher::StopWatchingFileDescriptors() { stopThread(); }
-
-AsyncFdWatcher::~AsyncFdWatcher() {}
-
-// Make sure to call this with at least one file descriptor ready to be
-// watched upon or the thread routine will return immediately
-int AsyncFdWatcher::tryStartThread() {
-  if (std::atomic_exchange(&running_, true)) return 0;
-
-  // Set up the communication channel
-  int pipe_fds[2];
-  if (pipe2(pipe_fds, O_NONBLOCK)) return -1;
-
-  notification_listen_fd_ = pipe_fds[0];
-  notification_write_fd_ = pipe_fds[1];
-
-  thread_ = std::thread([this]() { ThreadRoutine(); });
-  if (!thread_.joinable()) return -1;
-
-  return 0;
-}
-
-int AsyncFdWatcher::stopThread() {
-  if (!std::atomic_exchange(&running_, false)) return 0;
-
-  notifyThread();
-  if (std::this_thread::get_id() != thread_.get_id()) {
-    thread_.join();
-  }
-
-  {
-    std::unique_lock<std::mutex> guard(internal_mutex_);
-    watched_fds_.clear();
-  }
-
-  {
-    std::unique_lock<std::mutex> guard(timeout_mutex_);
-    timeout_cb_ = nullptr;
-  }
-
-  close(notification_listen_fd_);
-  close(notification_write_fd_);
-
-  return 0;
-}
-
-int AsyncFdWatcher::notifyThread() {
-  uint8_t buffer[] = {0};
-  if (TEMP_FAILURE_RETRY(write(notification_write_fd_, &buffer, 1)) < 0) {
-    return -1;
-  }
-  return 0;
-}
-
-void AsyncFdWatcher::ThreadRoutine() {
-  // Make watching thread RT.
-  struct sched_param rt_params;
-  rt_params.sched_priority = BT_RT_PRIORITY;
-  if (sched_setscheduler(gettid(), SCHED_FIFO, &rt_params)) {
-    ALOGE("%s unable to set SCHED_FIFO for pid %d, tid %d, error %s", __func__,
-          getpid(), gettid(), strerror(errno));
-  }
-
-  while (running_) {
-    fd_set read_fds;
-    FD_ZERO(&read_fds);
-    FD_SET(notification_listen_fd_, &read_fds);
-    int max_read_fd = INVALID_FD;
-    for (auto& it : watched_fds_) {
-      FD_SET(it.first, &read_fds);
-      max_read_fd = std::max(max_read_fd, it.first);
-    }
-
-    struct timeval timeout;
-    struct timeval* timeout_ptr = NULL;
-    if (timeout_ms_ > std::chrono::milliseconds(0)) {
-      timeout.tv_sec = timeout_ms_.count() / 1000;
-      timeout.tv_usec = (timeout_ms_.count() % 1000) * 1000;
-      timeout_ptr = &timeout;
-    }
-
-    // Wait until there is data available to read on some FD.
-    int nfds = std::max(notification_listen_fd_, max_read_fd);
-    int retval = select(nfds + 1, &read_fds, NULL, NULL, timeout_ptr);
-
-    // There was some error.
-    if (retval < 0) continue;
-
-    // Timeout.
-    if (retval == 0) {
-      // Allow the timeout callback to modify the timeout.
-      TimeoutCallback saved_cb;
-      {
-        std::unique_lock<std::mutex> guard(timeout_mutex_);
-        if (timeout_ms_ > std::chrono::milliseconds(0))
-          saved_cb = timeout_cb_;
-      }
-      if (saved_cb != nullptr)
-        saved_cb();
-      continue;
-    }
-
-    // Read data from the notification FD.
-    if (FD_ISSET(notification_listen_fd_, &read_fds)) {
-      char buffer[] = {0};
-      TEMP_FAILURE_RETRY(read(notification_listen_fd_, buffer, 1));
-      continue;
-    }
-
-    // Invoke the data ready callbacks if appropriate.
-    {
-      // Hold the mutex to make sure that the callbacks are still valid.
-      std::unique_lock<std::mutex> guard(internal_mutex_);
-      for (auto& it : watched_fds_) {
-        if (FD_ISSET(it.first, &read_fds)) {
-        it.second(it.first);
-        }
-      }
-    }
-  }
-}
-
-} // namespace async
-} // namespace bluetooth
-} // namespace hardware
-} // namespace android
diff --git a/bluetooth/async_fd_watcher.h b/bluetooth/async_fd_watcher.h
deleted file mode 100644
index 358cbc3..0000000
--- a/bluetooth/async_fd_watcher.h
+++ /dev/null
@@ -1,67 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <map>
-#include <mutex>
-#include <thread>
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace async {
-
-using ReadCallback = std::function<void(int)>;
-using TimeoutCallback = std::function<void(void)>;
-
-class AsyncFdWatcher {
- public:
-  AsyncFdWatcher() = default;
-  ~AsyncFdWatcher();
-
-  int WatchFdForNonBlockingReads(int file_descriptor,
-                                 const ReadCallback& on_read_fd_ready_callback);
-  int ConfigureTimeout(const std::chrono::milliseconds timeout,
-                       const TimeoutCallback& on_timeout_callback);
-  void StopWatchingFileDescriptors();
-
- private:
-  AsyncFdWatcher(const AsyncFdWatcher&) = delete;
-  AsyncFdWatcher& operator=(const AsyncFdWatcher&) = delete;
-
-  int tryStartThread();
-  int stopThread();
-  int notifyThread();
-  void ThreadRoutine();
-
-  std::atomic_bool running_{false};
-  std::thread thread_;
-  std::mutex internal_mutex_;
-  std::mutex timeout_mutex_;
-
-  std::map<int, ReadCallback> watched_fds_;
-  int notification_listen_fd_;
-  int notification_write_fd_;
-  TimeoutCallback timeout_cb_;
-  std::chrono::milliseconds timeout_ms_;
-};
-
-
-} // namespace async
-} // namespace bluetooth
-} // namespace hardware
-} // namespace android
diff --git a/bluetooth/bluetooth_address.cc b/bluetooth/bluetooth_address.cc
deleted file mode 100644
index fd53e78..0000000
--- a/bluetooth/bluetooth_address.cc
+++ /dev/null
@@ -1,128 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#include "bluetooth_address.h"
-
-#include <cutils/properties.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <utils/Log.h>
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace V1_0 {
-namespace implementation {
-
-void BluetoothAddress::bytes_to_string(const uint8_t* addr, char* addr_str) {
-  sprintf(addr_str, "%02x:%02x:%02x:%02x:%02x:%02x", addr[0], addr[1], addr[2],
-          addr[3], addr[4], addr[5]);
-}
-
-bool BluetoothAddress::string_to_bytes(const char* addr_str, uint8_t* addr) {
-  if (addr_str == NULL) return false;
-  if (strnlen(addr_str, kStringLength) != kStringLength) return false;
-  unsigned char trailing_char = '\0';
-
-  return (sscanf(addr_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx%1c",
-                 &addr[0], &addr[1], &addr[2], &addr[3], &addr[4], &addr[5],
-                 &trailing_char) == kBytes);
-}
-
-bool BluetoothAddress::get_local_address(uint8_t* local_addr) {
-  char property[PROPERTY_VALUE_MAX] = {0};
-  bool valid_bda = false;
-
-  // Get local bdaddr storage path from a system property.
-  if (property_get(PROPERTY_BT_BDADDR_PATH, property, NULL)) {
-    int addr_fd;
-
-    ALOGD("%s: Trying %s", __func__, property);
-
-    addr_fd = open(property, O_RDONLY);
-    if (addr_fd != -1) {
-      char address[kStringLength + 1] = {0};
-      int bytes_read = read(addr_fd, address, kStringLength);
-      if (bytes_read == -1) {
-        ALOGE("%s: Error reading address from %s: %s", __func__, property,
-              strerror(errno));
-      }
-      close(addr_fd);
-
-      // Null terminate the string.
-      address[kStringLength] = '\0';
-
-      // If the address is not all zeros, then use it.
-      const uint8_t zero_bdaddr[kBytes] = {0, 0, 0, 0, 0, 0};
-      if ((string_to_bytes(address, local_addr)) &&
-          (memcmp(local_addr, zero_bdaddr, kBytes) != 0)) {
-        valid_bda = true;
-        ALOGD("%s: Got Factory BDA %s", __func__, address);
-      } else {
-        ALOGE("%s: Got Invalid BDA '%s' from %s", __func__, address, property);
-      }
-    }
-  }
-
-  // No BDADDR found in the file. Look for BDA in a factory property.
-  if (!valid_bda && property_get(FACTORY_BDADDR_PROPERTY, property, NULL) &&
-      string_to_bytes(property, local_addr)) {
-    valid_bda = true;
-  }
-
-  // No factory BDADDR found. Look for a previously stored BDA.
-  if (!valid_bda && property_get(PERSIST_BDADDR_PROPERTY, property, NULL) &&
-      string_to_bytes(property, local_addr)) {
-    valid_bda = true;
-  }
-
-  /* Generate new BDA if necessary */
-  if (!valid_bda) {
-    char bdstr[kStringLength + 1];
-
-    /* No autogen BDA. Generate one now. */
-    local_addr[0] = 0x22;
-    local_addr[1] = 0x22;
-    local_addr[2] = (uint8_t)rand();
-    local_addr[3] = (uint8_t)rand();
-    local_addr[4] = (uint8_t)rand();
-    local_addr[5] = (uint8_t)rand();
-
-    /* Convert to ascii, and store as a persistent property */
-    bytes_to_string(local_addr, bdstr);
-
-    ALOGE("%s: No preset BDA! Generating BDA: %s for prop %s", __func__,
-          (char*)bdstr, PERSIST_BDADDR_PROPERTY);
-    ALOGE("%s: This is a bug in the platform!  Please fix!", __func__);
-
-    if (property_set(PERSIST_BDADDR_PROPERTY, (char*)bdstr) < 0) {
-      ALOGE("%s: Failed to set random BDA in prop %s", __func__,
-            PERSIST_BDADDR_PROPERTY);
-      valid_bda = false;
-    } else {
-      valid_bda = true;
-    }
-  }
-
-  return valid_bda;
-}
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/bluetooth_address.h b/bluetooth/bluetooth_address.h
deleted file mode 100644
index 94bf616..0000000
--- a/bluetooth/bluetooth_address.h
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <fcntl.h>
-
-#include <cstdint>
-#include <string>
-#include <vector>
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace V1_0 {
-namespace implementation {
-
-// The property key stores the storage location of Bluetooth Device Address
-static constexpr char PROPERTY_BT_BDADDR_PATH[] = "ro.bt.bdaddr_path";
-
-// Check for a legacy address stored as a property.
-static constexpr char PERSIST_BDADDR_PROPERTY[] =
-    "persist.service.bdroid.bdaddr";
-
-// If there is no valid bdaddr available from PROPERTY_BT_BDADDR_PATH and there
-// is no available persistent bdaddr available from PERSIST_BDADDR_PROPERTY,
-// use a factory set address.
-static constexpr char FACTORY_BDADDR_PROPERTY[] = "ro.boot.btmacaddr";
-
-// Encapsulate handling for Bluetooth Addresses:
-class BluetoothAddress {
- public:
-  // Conversion constants
-  static constexpr size_t kStringLength = sizeof("XX:XX:XX:XX:XX:XX") - 1;
-  static constexpr size_t kBytes = (kStringLength + 1) / 3;
-
-  static void bytes_to_string(const uint8_t* addr, char* addr_str);
-
-  static bool string_to_bytes(const char* addr_str, uint8_t* addr);
-
-  static bool get_local_address(uint8_t* addr);
-};
-
-} // namespace implementation
-} // namespace V1_0
-} // namespace bluetooth
-} // namespace hardware
-} // namespace android
diff --git a/bluetooth/bluetooth_hci.cc b/bluetooth/bluetooth_hci.cc
deleted file mode 100644
index f789310..0000000
--- a/bluetooth/bluetooth_hci.cc
+++ /dev/null
@@ -1,145 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#define LOG_TAG "android.hardware.bluetooth@1.0-service.vbt"
-#include "bluetooth_hci.h"
-
-#include <log/log.h>
-
-#include "vendor_interface.h"
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace V1_0 {
-namespace implementation {
-
-static const uint8_t HCI_DATA_TYPE_COMMAND = 1;
-static const uint8_t HCI_DATA_TYPE_ACL = 2;
-static const uint8_t HCI_DATA_TYPE_SCO = 3;
-
-class BluetoothDeathRecipient : public hidl_death_recipient {
- public:
-  BluetoothDeathRecipient(const sp<IBluetoothHci> hci) : mHci(hci) {}
-
-  virtual void serviceDied(
-      uint64_t /*cookie*/,
-      const wp<::android::hidl::base::V1_0::IBase>& /*who*/) {
-    ALOGE("BluetoothDeathRecipient::serviceDied - Bluetooth service died");
-    has_died_ = true;
-    mHci->close();
-  }
-  sp<IBluetoothHci> mHci;
-  bool getHasDied() const { return has_died_; }
-  void setHasDied(bool has_died) { has_died_ = has_died; }
-
- private:
-  bool has_died_;
-};
-
-BluetoothHci::BluetoothHci()
-    : death_recipient_(new BluetoothDeathRecipient(this)) {}
-
-Return<void> BluetoothHci::initialize(
-    const ::android::sp<IBluetoothHciCallbacks>& cb) {
-  ALOGI("BluetoothHci::initialize()");
-  if (cb == nullptr) {
-    ALOGE("cb == nullptr! -> Unable to call initializationComplete(ERR)");
-    return Void();
-  }
-
-  death_recipient_->setHasDied(false);
-  cb->linkToDeath(death_recipient_, 0);
-
-  bool rc = VendorInterface::Initialize(
-      [cb](bool status) {
-        auto hidl_status = cb->initializationComplete(
-            status ? Status::SUCCESS : Status::INITIALIZATION_ERROR);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call initializationComplete()");
-        }
-      },
-      [cb](const hidl_vec<uint8_t>& packet) {
-        auto hidl_status = cb->hciEventReceived(packet);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call hciEventReceived()");
-        }
-      },
-      [cb](const hidl_vec<uint8_t>& packet) {
-        auto hidl_status = cb->aclDataReceived(packet);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call aclDataReceived()");
-        }
-      },
-      [cb](const hidl_vec<uint8_t>& packet) {
-        auto hidl_status = cb->scoDataReceived(packet);
-        if (!hidl_status.isOk()) {
-          ALOGE("VendorInterface -> Unable to call scoDataReceived()");
-        }
-      });
-  if (!rc) {
-    auto hidl_status = cb->initializationComplete(Status::INITIALIZATION_ERROR);
-    if (!hidl_status.isOk()) {
-      ALOGE("VendorInterface -> Unable to call initializationComplete(ERR)");
-    }
-  }
-
-  unlink_cb_ = [cb](sp<BluetoothDeathRecipient>& death_recipient) {
-    if (death_recipient->getHasDied())
-      ALOGI("Skipping unlink call, service died.");
-    else
-      cb->unlinkToDeath(death_recipient);
-  };
-
-  return Void();
-}
-
-Return<void> BluetoothHci::close() {
-  ALOGI("BluetoothHci::close()");
-  unlink_cb_(death_recipient_);
-  VendorInterface::Shutdown();
-  return Void();
-}
-
-Return<void> BluetoothHci::sendHciCommand(const hidl_vec<uint8_t>& command) {
-  sendDataToController(HCI_DATA_TYPE_COMMAND, command);
-  return Void();
-}
-
-Return<void> BluetoothHci::sendAclData(const hidl_vec<uint8_t>& data) {
-  sendDataToController(HCI_DATA_TYPE_ACL, data);
-  return Void();
-}
-
-Return<void> BluetoothHci::sendScoData(const hidl_vec<uint8_t>& data) {
-  sendDataToController(HCI_DATA_TYPE_SCO, data);
-  return Void();
-}
-
-void BluetoothHci::sendDataToController(const uint8_t type,
-                                        const hidl_vec<uint8_t>& data) {
-  VendorInterface::get()->Send(type, data.data(), data.size());
-}
-
-IBluetoothHci* HIDL_FETCH_IBluetoothHci(const char* /* name */) {
-  return new BluetoothHci();
-}
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/bluetooth_hci.h b/bluetooth/bluetooth_hci.h
deleted file mode 100644
index e2797b1..0000000
--- a/bluetooth/bluetooth_hci.h
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#ifndef HIDL_GENERATED_android_hardware_bluetooth_V1_0_BluetoothHci_H_
-#define HIDL_GENERATED_android_hardware_bluetooth_V1_0_BluetoothHci_H_
-
-#include <android/hardware/bluetooth/1.0/IBluetoothHci.h>
-
-#include <hidl/MQDescriptor.h>
-
-#include <functional>
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace V1_0 {
-namespace implementation {
-
-using ::android::hardware::Return;
-using ::android::hardware::hidl_vec;
-
-class BluetoothDeathRecipient;
-
-class BluetoothHci : public IBluetoothHci {
- public:
-  BluetoothHci();
-  Return<void> initialize(
-      const ::android::sp<IBluetoothHciCallbacks>& cb) override;
-  Return<void> sendHciCommand(const hidl_vec<uint8_t>& packet) override;
-  Return<void> sendAclData(const hidl_vec<uint8_t>& data) override;
-  Return<void> sendScoData(const hidl_vec<uint8_t>& data) override;
-  Return<void> close() override;
-
- private:
-  void sendDataToController(const uint8_t type, const hidl_vec<uint8_t>& data);
-  ::android::sp<BluetoothDeathRecipient> death_recipient_;
-  std::function<void(sp<BluetoothDeathRecipient>&)> unlink_cb_;
-};
-
-extern "C" IBluetoothHci* HIDL_FETCH_IBluetoothHci(const char* name);
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
-
-#endif  // HIDL_GENERATED_android_hardware_bluetooth_V1_0_BluetoothHci_H_
diff --git a/bluetooth/bt_vendor_lib.h b/bluetooth/bt_vendor_lib.h
deleted file mode 100644
index c140e52..0000000
--- a/bluetooth/bt_vendor_lib.h
+++ /dev/null
@@ -1,435 +0,0 @@
-/******************************************************************************
- *
- *  Copyright (C) 2009-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-#ifndef BT_VENDOR_LIB_H
-#define BT_VENDOR_LIB_H
-
-#include <stdint.h>
-#include <sys/cdefs.h>
-#include <sys/types.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/** Struct types */
-
-/** Typedefs and defines */
-
-/** Vendor specific operations OPCODE */
-typedef enum {
-  /*  [operation]
-   *      Power on or off the BT Controller.
-   *  [input param]
-   *      A pointer to int type with content of bt_vendor_power_state_t.
-   *      Typecasting conversion: (int *) param.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      None.
-   */
-  BT_VND_OP_POWER_CTRL,
-
-  /*  [operation]
-   *      Perform any vendor specific initialization or configuration
-   *      on the BT Controller. This is called before stack initialization.
-   *  [input param]
-   *      None.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      Must call fwcfg_cb to notify the stack of the completion of vendor
-   *      specific initialization once it has been done.
-   */
-  BT_VND_OP_FW_CFG,
-
-  /*  [operation]
-   *      Perform any vendor specific SCO/PCM configuration on the BT
-   * Controller.
-   *      This is called after stack initialization.
-   *  [input param]
-   *      None.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      Must call scocfg_cb to notify the stack of the completion of vendor
-   *      specific SCO configuration once it has been done.
-   */
-  BT_VND_OP_SCO_CFG,
-
-  /*  [operation]
-   *      Open UART port on where the BT Controller is attached.
-   *      This is called before stack initialization.
-   *  [input param]
-   *      A pointer to int array type for open file descriptors.
-   *      The mapping of HCI channel to fd slot in the int array is given in
-   *      bt_vendor_hci_channels_t.
-   *      And, it requires the vendor lib to fill up the content before
-   * returning
-   *      the call.
-   *      Typecasting conversion: (int (*)[]) param.
-   *  [return]
-   *      Numbers of opened file descriptors.
-   *      Valid number:
-   *          1 - CMD/EVT/ACL-In/ACL-Out via the same fd (e.g. UART)
-   *          2 - CMD/EVT on one fd, and ACL-In/ACL-Out on the other fd
-   *          4 - CMD, EVT, ACL-In, ACL-Out are on their individual fd
-   *  [callback]
-   *      None.
-   */
-  BT_VND_OP_USERIAL_OPEN,
-
-  /*  [operation]
-   *      Close the previously opened UART port.
-   *  [input param]
-   *      None.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      None.
-   */
-  BT_VND_OP_USERIAL_CLOSE,
-
-  /*  [operation]
-   *      Get the LPM idle timeout in milliseconds.
-   *      The stack uses this information to launch a timer delay before it
-   *      attempts to de-assert LPM WAKE signal once downstream HCI packet
-   *      has been delivered.
-   *  [input param]
-   *      A pointer to uint32_t type which is passed in by the stack. And, it
-   *      requires the vendor lib to fill up the content before returning
-   *      the call.
-   *      Typecasting conversion: (uint32_t *) param.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      None.
-   */
-  BT_VND_OP_GET_LPM_IDLE_TIMEOUT,
-
-  /*  [operation]
-   *      Enable or disable LPM mode on BT Controller.
-   *  [input param]
-   *      A pointer to uint8_t type with content of bt_vendor_lpm_mode_t.
-   *      Typecasting conversion: (uint8_t *) param.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      Must call lpm_cb to notify the stack of the completion of LPM
-   *      disable/enable process once it has been done.
-   */
-  BT_VND_OP_LPM_SET_MODE,
-
-  /*  [operation]
-   *      Assert or Deassert LPM WAKE on BT Controller.
-   *  [input param]
-   *      A pointer to uint8_t type with content of bt_vendor_lpm_wake_state_t.
-   *      Typecasting conversion: (uint8_t *) param.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      None.
-   */
-  BT_VND_OP_LPM_WAKE_SET_STATE,
-
-  /*  [operation]
-   *      Perform any vendor specific commands related to audio state changes.
-   *  [input param]
-   *      a pointer to bt_vendor_op_audio_state_t indicating what audio state is
-   *      set.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      None.
-   */
-  BT_VND_OP_SET_AUDIO_STATE,
-
-  /*  [operation]
-   *      The epilog call to the vendor module so that it can perform any
-   *      vendor-specific processes (e.g. send a HCI_RESET to BT Controller)
-   *      before the caller calls for cleanup().
-   *  [input param]
-   *      None.
-   *  [return]
-   *      0 - default, don't care.
-   *  [callback]
-   *      Must call epilog_cb to notify the stack of the completion of vendor
-   *      specific epilog process once it has been done.
-   */
-  BT_VND_OP_EPILOG,
-
-  /*  [operation]
-   *      Call to the vendor module so that it can perform all vendor-specific
-   *      operations to start offloading a2dp media encode & tx.
-   *  [input param]
-   *      pointer to bt_vendor_op_a2dp_offload_start_t containing elements
-   *      required for VND FW to setup a2dp offload.
-   *  [return]
-   *      0  - default, dont care.
-   *  [callback]
-   *      Must call a2dp_offload_start_cb to notify the stack of the
-   *      completion of vendor specific setup process once it has been done.
-   */
-  BT_VND_OP_A2DP_OFFLOAD_START,
-
-  /*  [operation]
-   *      Call to the vendor module so that it can perform all vendor-specific
-   *      operations to suspend offloading a2dp media encode & tx.
-   *  [input param]
-   *      pointer to bt_vendor_op_a2dp_offload_t containing elements
-   *      required for VND FW to setup a2dp offload.
-   *  [return]
-   *      0  - default, dont care.
-   *  [callback]
-   *      Must call a2dp_offload_cb to notify the stack of the
-   *      completion of vendor specific setup process once it has been done.
-   */
-  BT_VND_OP_A2DP_OFFLOAD_STOP,
-
-} bt_vendor_opcode_t;
-
-/** Power on/off control states */
-typedef enum {
-  BT_VND_PWR_OFF,
-  BT_VND_PWR_ON,
-} bt_vendor_power_state_t;
-
-/** Define HCI channel identifier in the file descriptors array
-    used in BT_VND_OP_USERIAL_OPEN operation.
- */
-typedef enum {
-  CH_CMD,      // HCI Command channel
-  CH_EVT,      // HCI Event channel
-  CH_ACL_OUT,  // HCI ACL downstream channel
-  CH_ACL_IN,   // HCI ACL upstream channel
-
-  CH_MAX  // Total channels
-} bt_vendor_hci_channels_t;
-
-/** LPM disable/enable request */
-typedef enum {
-  BT_VND_LPM_DISABLE,
-  BT_VND_LPM_ENABLE,
-} bt_vendor_lpm_mode_t;
-
-/** LPM WAKE set state request */
-typedef enum {
-  BT_VND_LPM_WAKE_ASSERT,
-  BT_VND_LPM_WAKE_DEASSERT,
-} bt_vendor_lpm_wake_state_t;
-
-/** Callback result values */
-typedef enum {
-  BT_VND_OP_RESULT_SUCCESS,
-  BT_VND_OP_RESULT_FAIL,
-} bt_vendor_op_result_t;
-
-/** audio (SCO) state changes triggering VS commands for configuration */
-typedef struct {
-  uint16_t handle;
-  uint16_t peer_codec;
-  uint16_t state;
-} bt_vendor_op_audio_state_t;
-
-/*
- * Bluetooth Host/Controller Vendor callback structure.
- */
-
-/* vendor initialization/configuration callback */
-typedef void (*cfg_result_cb)(bt_vendor_op_result_t result);
-
-/* datapath buffer allocation callback (callout)
- *
- *  Vendor lib needs to request a buffer through the alloc callout function
- *  from HCI lib if the buffer is for constructing a HCI Command packet which
- *  will be sent through xmit_cb to BT Controller.
- *
- *  For each buffer allocation, the requested size needs to be big enough to
- *  accommodate the below header plus a complete HCI packet --
- *      typedef struct
- *      {
- *          uint16_t          event;
- *          uint16_t          len;
- *          uint16_t          offset;
- *          uint16_t          layer_specific;
- *      } HC_BT_HDR;
- *
- *  HCI lib returns a pointer to the buffer where Vendor lib should use to
- *  construct a HCI command packet as below format:
- *
- *  --------------------------------------------
- *  |  HC_BT_HDR  |  HCI command               |
- *  --------------------------------------------
- *  where
- *      HC_BT_HDR.event = 0x2000;
- *      HC_BT_HDR.len = Length of HCI command;
- *      HC_BT_HDR.offset = 0;
- *      HC_BT_HDR.layer_specific = 0;
- *
- *  For example, a HCI_RESET Command will be formed as
- *  ------------------------
- *  |  HC_BT_HDR  |03|0c|00|
- *  ------------------------
- *  with
- *      HC_BT_HDR.event = 0x2000;
- *      HC_BT_HDR.len = 3;
- *      HC_BT_HDR.offset = 0;
- *      HC_BT_HDR.layer_specific = 0;
- */
-typedef void* (*malloc_cb)(int size);
-
-/* datapath buffer deallocation callback (callout) */
-typedef void (*mdealloc_cb)(void* p_buf);
-
-/* define callback of the cmd_xmit_cb
- *
- *  The callback function which HCI lib will call with the return of command
- *  complete packet. Vendor lib is responsible for releasing the buffer passed
- *  in at the p_mem parameter by calling dealloc callout function.
- */
-typedef void (*tINT_CMD_CBACK)(void* p_mem);
-
-/* hci command packet transmit callback (callout)
- *
- *  Vendor lib calls xmit_cb callout function in order to send a HCI Command
- *  packet to BT Controller. The buffer carrying HCI Command packet content
- *  needs to be first allocated through the alloc callout function.
- *  HCI lib will release the buffer for Vendor lib once it has delivered the
- *  packet content to BT Controller.
- *
- *  Vendor lib needs also provide a callback function (p_cback) which HCI lib
- *  will call with the return of command complete packet.
- *
- *  The opcode parameter gives the HCI OpCode (combination of OGF and OCF) of
- *  HCI Command packet. For example, opcode = 0x0c03 for the HCI_RESET command
- *  packet.
- */
-typedef uint8_t (*cmd_xmit_cb)(uint16_t opcode, void* p_buf,
-                               tINT_CMD_CBACK p_cback);
-
-typedef void (*cfg_a2dp_cb)(bt_vendor_op_result_t result, bt_vendor_opcode_t op,
-                            uint8_t bta_av_handle);
-
-typedef struct {
-  /** set to sizeof(bt_vendor_callbacks_t) */
-  size_t size;
-
-  /*
-   * Callback and callout functions have implemented in HCI libray
-   * (libbt-hci.so).
-   */
-
-  /* notifies caller result of firmware configuration request */
-  cfg_result_cb fwcfg_cb;
-
-  /* notifies caller result of sco configuration request */
-  cfg_result_cb scocfg_cb;
-
-  /* notifies caller result of lpm enable/disable */
-  cfg_result_cb lpm_cb;
-
-  /* notifies the result of codec setting */
-  cfg_result_cb audio_state_cb;
-
-  /* buffer allocation request */
-  malloc_cb alloc;
-
-  /* buffer deallocation request */
-  mdealloc_cb dealloc;
-
-  /* hci command packet transmit request */
-  cmd_xmit_cb xmit_cb;
-
-  /* notifies caller completion of epilog process */
-  cfg_result_cb epilog_cb;
-
-  /* notifies status of a2dp offload cmd's */
-  cfg_a2dp_cb a2dp_offload_cb;
-} bt_vendor_callbacks_t;
-
-/** A2DP offload request */
-typedef struct {
-  uint8_t bta_av_handle;  /* BTA_AV Handle for callbacks */
-  uint16_t xmit_quota;    /* Total ACL quota for light stack */
-  uint16_t acl_data_size; /* Max ACL data size across HCI transport */
-  uint16_t stream_mtu;
-  uint16_t local_cid;
-  uint16_t remote_cid;
-  uint16_t lm_handle;
-  uint8_t is_flushable; /* true if flushable channel */
-  uint32_t stream_source;
-  uint8_t codec_info[10]; /* Codec capabilities array */
-} bt_vendor_op_a2dp_offload_t;
-
-/*
- * Bluetooth Host/Controller VENDOR Interface
- */
-typedef struct {
-  /** Set to sizeof(bt_vndor_interface_t) */
-  size_t size;
-
-  /*
-   * Functions need to be implemented in Vendor libray (libbt-vendor.so).
-   */
-
-  /**
-   * Caller will open the interface and pass in the callback routines
-   * to the implemenation of this interface.
-   */
-  int (*init)(const bt_vendor_callbacks_t* p_cb, unsigned char* local_bdaddr);
-
-  /**  Vendor specific operations */
-  int (*op)(bt_vendor_opcode_t opcode, void* param);
-
-  /** Closes the interface */
-  void (*cleanup)(void);
-} bt_vendor_interface_t;
-
-/*
- * External shared lib functions/data
- */
-
-/* Entry point of DLib --
- *      Vendor library needs to implement the body of bt_vendor_interface_t
- *      structure and uses the below name as the variable name. HCI library
- *      will use this symbol name to get address of the object through the
- *      dlsym call.
- */
-extern const bt_vendor_interface_t BLUETOOTH_VENDOR_LIB_INTERFACE;
-
-// MODIFICATION FOR NEW HAL/HIDL IMPLEMENTATION:
-// EXPOSE THE BT_HDR STRUCT HERE FOR THE VENDOR INTERFACE
-// ONLY, WITHOUT REQUIRING INCLUDES FROM system/bt OR OTHER
-// DIRECTORIES.
-// ONLY USED INSIDE transmit_cb.
-// DO NOT USE IN NEW HAL IMPLEMENTATIONS GOING FORWARD
-typedef struct
-{
-    uint16_t          event;
-    uint16_t          len;
-    uint16_t          offset;
-    uint16_t          layer_specific;
-    uint8_t           data[];
-} HC_BT_HDR;
-// /MODIFICATION
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* BT_VENDOR_LIB_H */
diff --git a/bluetooth/h4_protocol.cc b/bluetooth/h4_protocol.cc
deleted file mode 100644
index 1b29117..0000000
--- a/bluetooth/h4_protocol.cc
+++ /dev/null
@@ -1,269 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#include "h4_protocol.h"
-
-#define LOG_TAG "android.hardware.bluetooth-hci-h4"
-
-#include <sys/ioctl.h>
-#include <linux/usbdevice_fs.h>
-#include <asm/byteorder.h>
-#include <linux/usb/ch9.h>
-#include <libusb/libusb.h>
-
-#define HCI_COMMAND_COMPLETE_EVT 0x0E
-#define HCI_COMMAND_STATUS_EVT 0x0F
-#define HCI_ESCO_CONNECTION_COMP_EVT 0x2C
-#define HCI_RESET_SUPPORTED(x) ((x)[5] & 0x80)
-#define HCI_GRP_INFORMATIONAL_PARAMS (0x04 << 10)    /* 0x1000 */
-#define HCI_READ_LOCAL_SUPPORTED_CMDS (0x0002 | HCI_GRP_INFORMATIONAL_PARAMS)
-#define HCI_GRP_HOST_CONT_BASEBAND_CMDS (0x03 << 10) /* 0x0C00 */
-#define HCI_RESET (0x0003 | HCI_GRP_HOST_CONT_BASEBAND_CMDS)
-
-#define INTEL_VID 0x8087
-#define INTEL_PID_8265 0x0a2b // Windstorm peak
-#define INTEL_PID_3168 0x0aa7 //SandyPeak (SdP)
-#define INTEL_PID_9260 0x0025 // 9160/9260 (also known as ThunderPeak)
-#define INTEL_PID_9560 0x0aaa // 9460/9560 also know as Jefferson Peak (JfP)
-#define INTEL_PID_AX201 0x0026 // AX201 also know as Harrison Peak (HrP)
-#define INTEL_PID_AX211 0x0033 // AX211 also know as GarfieldPeak (Gfp)
-
-#include <errno.h>
-#include <fcntl.h>
-#include <log/log.h>
-#include <sys/uio.h>
-#include <unistd.h>
-#include <string.h>
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-size_t H4Protocol::Send(uint8_t type, const uint8_t* data, size_t length){
-    /* For HCI communication over USB dongle, multiple write results in
-     * response timeout as driver expect type + data at once to process
-     * the command, so using "writev"(for atomicity) here.
-     */
-    struct iovec iov[2];
-    ssize_t ret = 0;
-    iov[0].iov_base = &type;
-    iov[0].iov_len = sizeof(type);
-    iov[1].iov_base = (void *)data;
-    iov[1].iov_len = length;
-
-    ALOGV("%x %x %x", data[0],data[1],data[2]);
-    while (1) {
-        ret = TEMP_FAILURE_RETRY(writev(uart_fd_, iov, 2));
-        if (ret == -1) {
-            if (errno == EAGAIN) {
-                ALOGE("%s error writing to UART (%s)", __func__, strerror(errno));
-                continue;
-            }
-        } else if (ret == 0) {
-            ALOGE("%s zero bytes written - something went wrong...", __func__);
-            break;
-        }
-        break;
-    }
-    return ret;
-}
-
-bool H4Protocol::IsIntelController(uint16_t vid, uint16_t pid) {
-    if ((vid == INTEL_VID) && ((pid == INTEL_PID_8265) ||
-                                (pid == INTEL_PID_3168)||
-                                (pid == INTEL_PID_9260)||
-                                (pid == INTEL_PID_9560)||
-                                (pid == INTEL_PID_AX201)||
-                                (pid == INTEL_PID_AX211)))
-        return true;
-    else
-	return false;
-}
-
-int H4Protocol::GetUsbpath(void) {
-    size_t count, i;
-    int ret = 0, busnum, devnum;
-    struct libusb_device **dev_list = NULL;
-    struct libusb_context *ctx;
-    uint16_t vid = 0, pid = 0;
-    ALOGD(" Initializing GenericUSB (libusb-1.0)...\n");
-    ret = libusb_init(&ctx);
-    if (ret < 0) {
-        ALOGE("libusb failed to initialize: %d\n", ret);
-        return ret;
-    }
-    count = libusb_get_device_list(ctx, &dev_list);
-    if (count <= 0) {
-        ALOGE("Error getting USB device list: %s\n", strerror(count));
-        goto exit;
-    }
-    for (i = 0; i < count; ++i) {
-        struct libusb_device* dev = dev_list[i];
-        busnum = libusb_get_bus_number(dev);
-        devnum = libusb_get_device_address(dev);
-        struct libusb_device_descriptor descriptor;
-        ret = libusb_get_device_descriptor(dev, &descriptor);
-        if (ret < 0)  {
-            ALOGE("Error getting device descriptor %d ", ret);
-            goto exit;
-        }
-        vid = descriptor.idVendor;
-        pid = descriptor.idProduct;
-        if (H4Protocol::IsIntelController(vid, pid)) {
-            snprintf(dev_address, sizeof(dev_address), "/dev/bus/usb/%03d/%03d",
-                                                       busnum, devnum);
-            ALOGV("Value of BT device address = %s", dev_address);
-            goto exit;
-        }
-    }
-exit:
-    libusb_free_device_list(dev_list, count);
-    libusb_exit(ctx);
-    return ret;
-}
-
-int H4Protocol::SendHandle(void) {
-    int fd, ret = 0;
-    fd = open(dev_address,O_WRONLY|O_NONBLOCK);
-    if (fd < 0) {
-        ALOGE("Fail to open USB device %s, value of fd= %d", dev_address, fd);
-        return -1;
-    } else {
-        struct usbdevfs_ioctl   wrapper;
-        wrapper.ifno = 1;
-        wrapper.ioctl_code = USBDEVFS_IOCTL;
-        wrapper.data = sco_handle;
-        ret = ioctl(fd, USBDEVFS_IOCTL, &wrapper);
-        if (ret < 0)
-            ALOGE("Failed to send SCO handle err = %d", ret);
-        close(fd);
-        return ret;
-    }
-}
-
-void H4Protocol::OnPacketReady() {
-  int ret = 0;
-  switch (hci_packet_type_) {
-    case HCI_PACKET_TYPE_EVENT:
-      if (hci_packetizer_.GetPacket() != NULL) {
-          if ((hci_packetizer_.GetPacket())[0] == HCI_COMMAND_COMPLETE_EVT) {
-              unsigned int cmd, lsb, msb;
-              msb = hci_packetizer_.GetPacket()[4] ;
-              lsb = hci_packetizer_.GetPacket()[3];
-              cmd = msb << 8 | lsb ;
-              if (cmd == HCI_RESET) {
-                  event_cb_(hci_packetizer_.GetPacket());
-                  hci_packet_type_ = HCI_PACKET_TYPE_UNKNOWN;
-                  ret = H4Protocol::GetUsbpath();
-                  if (ret < 0)
-                      ALOGE("Failed to get the USB path for btusb-sound-card");
-                  break;
-              }
-          } else if ((hci_packetizer_.GetPacket())[0] == HCI_ESCO_CONNECTION_COMP_EVT) {
-              const unsigned char *handle = hci_packetizer_.GetPacket().data() + 3;
-              memcpy(sco_handle, handle, 2);
-              ALOGI("Value of SCO handle = %x, %x", handle[0], handle[1]);
-              ret = H4Protocol::SendHandle();
-              if (ret < 0)
-                  ALOGE("Failed to send SCO handle to btusb-sound-card driver");
-          }
-      }
-
-      event_cb_(hci_packetizer_.GetPacket());
-      break;
-    case HCI_PACKET_TYPE_ACL_DATA:
-      acl_cb_(hci_packetizer_.GetPacket());
-      break;
-    case HCI_PACKET_TYPE_SCO_DATA:
-      sco_cb_(hci_packetizer_.GetPacket());
-      break;
-    default:
-      LOG_ALWAYS_FATAL("%s: Unimplemented packet type %d", __func__,
-                       static_cast<int>(hci_packet_type_));
-  }
-  // Get ready for the next type byte.
-  hci_packet_type_ = HCI_PACKET_TYPE_UNKNOWN;
-}
-
-
-typedef struct
-{
-    uint8_t         type;
-    uint8_t         event;
-    uint8_t         len;
-    uint8_t         offset;
-    uint16_t        layer_specific;
-} BT_EVENT_HDR;
-
-void H4Protocol::OnDataReady(int fd) {
-    if (hci_packet_type_ == HCI_PACKET_TYPE_UNKNOWN) {
-        /*
-         * read full buffer. ACL max length is 2 bytes, and SCO max length is 2
-         * byte. so taking 64K as buffer length.
-         * Question : Why to read in single chunk rather than multiple reads,
-         * which can give parameter length arriving in response ?
-         * Answer: The multiple reads does not work with BT USB dongle. At least
-         * with Bluetooth 2.0 supported USB dongle. After first read, either
-         * firmware/kernel (do not know who is responsible - inputs ??) driver
-         * discard the whole message and successive read results in forever
-         * blocking loop. - Is there any other way to make it work with multiple
-         * reads, do not know yet (it can eliminate need of this function) ?
-         * Reading in single shot gives expected response.
-         */
-        const size_t max_plen = 64*1024;
-        hidl_vec<uint8_t> tpkt;
-        tpkt.resize(max_plen);
-        size_t bytes_read = TEMP_FAILURE_RETRY(read(fd, tpkt.data(), max_plen));
-        if (bytes_read == 0) {
-            // This is only expected if the UART got closed when shutting down.
-            ALOGE("%s: Unexpected EOF reading the packet type!", __func__);
-            sleep(5);  // Expect to be shut down within 5 seconds.
-            return;
-        } else if (bytes_read < 0) {
-            LOG_ALWAYS_FATAL("%s: Read packet type error: %s", __func__,
-                         strerror(errno));
-        }
-        hci_packet_type_ = static_cast<HciPacketType>(tpkt.data()[0]);
-        if (hci_packet_type_ != HCI_PACKET_TYPE_ACL_DATA &&
-            hci_packet_type_ != HCI_PACKET_TYPE_SCO_DATA &&
-            hci_packet_type_ != HCI_PACKET_TYPE_EVENT) {
-          LOG_ALWAYS_FATAL("%s: Unimplemented packet type %d", __func__,
-                           static_cast<int>(hci_packet_type_));
-        } else {
-            if(tpkt.data()[1] == HCI_COMMAND_COMPLETE_EVT) {
-                ALOGD("%s Command complete event ncmds = %d",
-                                                     __func__, tpkt.data()[3]);
-                tpkt.data()[3] = 1;
-		/* Disable Enhance setup synchronous connections*/
-                BT_EVENT_HDR* hdr  = (BT_EVENT_HDR*)(tpkt.data());
-                if( hdr->layer_specific == HCI_READ_LOCAL_SUPPORTED_CMDS)
-                        tpkt.data()[36] &= ~((uint8_t)0x1 << 3);
-
-            } else if (tpkt.data()[1] ==  HCI_COMMAND_STATUS_EVT) {
-                ALOGV("%s Command status event ncmd = %d", __func__, tpkt.data()[4]);
-                tpkt.data()[4] = 1;
-            }
-
-            hci_packetizer_.CbHciPacket(tpkt.data() + 1, bytes_read - 1);
-        }
-    }
-}
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/h4_protocol.h b/bluetooth/h4_protocol.h
deleted file mode 100644
index f67ae80..0000000
--- a/bluetooth/h4_protocol.h
+++ /dev/null
@@ -1,71 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <hidl/HidlSupport.h>
-
-#include "async_fd_watcher.h"
-#include "bt_vendor_lib.h"
-#include "hci_internals.h"
-#include "hci_protocol.h"
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-class H4Protocol : public HciProtocol {
- public:
-  H4Protocol(int fd, PacketReadCallback event_cb, PacketReadCallback acl_cb,
-             PacketReadCallback sco_cb)
-      : uart_fd_(fd),
-        event_cb_(event_cb),
-        acl_cb_(acl_cb),
-        sco_cb_(sco_cb),
-        hci_packetizer_([this]() { OnPacketReady(); }) {}
-
-  size_t Send(uint8_t type, const uint8_t* data, size_t length);
-
-  void OnPacketReady();
-
-  void OnDataReady(int fd);
-
-  bool IsIntelController(uint16_t vid, uint16_t pid);
-
-  int GetUsbpath(void);
-
-  int SendHandle(void);
-
- private:
-  int uart_fd_;
-
-  uint8_t sco_handle[2];
-
-  char dev_address[32];
-
-  PacketReadCallback event_cb_;
-  PacketReadCallback acl_cb_;
-  PacketReadCallback sco_cb_;
-
-  HciPacketType hci_packet_type_{HCI_PACKET_TYPE_UNKNOWN};
-  hci::HciPacketizer hci_packetizer_;
-};
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/hci_internals.h b/bluetooth/hci_internals.h
deleted file mode 100644
index 1e1f300..0000000
--- a/bluetooth/hci_internals.h
+++ /dev/null
@@ -1,49 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <stdlib.h>
-
-// HCI UART transport packet types (Volume 4, Part A, 2)
-enum HciPacketType {
-  HCI_PACKET_TYPE_UNKNOWN = 0,
-  HCI_PACKET_TYPE_COMMAND = 1,
-  HCI_PACKET_TYPE_ACL_DATA = 2,
-  HCI_PACKET_TYPE_SCO_DATA = 3,
-  HCI_PACKET_TYPE_EVENT = 4
-};
-
-// 2 bytes for opcode, 1 byte for parameter length (Volume 2, Part E, 5.4.1)
-const size_t HCI_COMMAND_PREAMBLE_SIZE = 3;
-const size_t HCI_LENGTH_OFFSET_CMD = 2;
-
-// 2 bytes for handle, 2 bytes for data length (Volume 2, Part E, 5.4.2)
-const size_t HCI_ACL_PREAMBLE_SIZE = 4;
-const size_t HCI_LENGTH_OFFSET_ACL = 2;
-
-// 2 bytes for handle, 1 byte for data length (Volume 2, Part E, 5.4.3)
-const size_t HCI_SCO_PREAMBLE_SIZE = 3;
-const size_t HCI_LENGTH_OFFSET_SCO = 2;
-
-// 1 byte for event code, 1 byte for parameter length (Volume 2, Part E, 5.4.4)
-const size_t HCI_EVENT_PREAMBLE_SIZE = 2;
-const size_t HCI_LENGTH_OFFSET_EVT = 1;
-
-const size_t HCI_PREAMBLE_SIZE_MAX = HCI_ACL_PREAMBLE_SIZE;
-
-// Event codes (Volume 2, Part E, 7.7.14)
-const uint8_t HCI_COMMAND_COMPLETE_EVENT = 0x0E;
diff --git a/bluetooth/hci_packetizer.cc b/bluetooth/hci_packetizer.cc
deleted file mode 100644
index 8c970c2..0000000
--- a/bluetooth/hci_packetizer.cc
+++ /dev/null
@@ -1,117 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#include "hci_packetizer.h"
-
-#define LOG_TAG "android.hardware.bluetooth.hci_packetizer"
-
-#include <dlfcn.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <utils/Log.h>
-
-namespace {
-
-const size_t preamble_size_for_type[] = {
-    0, HCI_COMMAND_PREAMBLE_SIZE, HCI_ACL_PREAMBLE_SIZE, HCI_SCO_PREAMBLE_SIZE,
-    HCI_EVENT_PREAMBLE_SIZE};
-const size_t packet_length_offset_for_type[] = {
-    0, HCI_LENGTH_OFFSET_CMD, HCI_LENGTH_OFFSET_ACL, HCI_LENGTH_OFFSET_SCO,
-    HCI_LENGTH_OFFSET_EVT};
-
-size_t HciGetPacketLengthForType(HciPacketType type, const uint8_t* preamble) {
-  size_t offset = packet_length_offset_for_type[type];
-  if (type != HCI_PACKET_TYPE_ACL_DATA) return preamble[offset];
-  return (((preamble[offset + 1]) << 8) | preamble[offset]);
-}
-
-}  // namespace
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-const hidl_vec<uint8_t>& HciPacketizer::GetPacket() const {
-  return packet_;
-}
-
-void HciPacketizer::CbHciPacket(uint8_t *data, size_t len) {
-    packet_.setToExternal(data, len);
-    packet_ready_cb_();
-}
-
-void HciPacketizer::OnDataReady(int fd, HciPacketType packet_type) {
-  switch (state_) {
-    case HCI_PREAMBLE: {
-      ssize_t bytes_read = TEMP_FAILURE_RETRY(
-          read(fd, preamble_ + bytes_read_,
-               preamble_size_for_type[packet_type] - bytes_read_));
-      if (bytes_read == 0) {
-        // This is only expected if the UART got closed when shutting down.
-        ALOGE("%s: Unexpected EOF reading the header!", __func__);
-        sleep(5);  // Expect to be shut down within 5 seconds.
-        return;
-      }
-      if (bytes_read < 0) {
-        LOG_ALWAYS_FATAL("%s: Read header error: %s", __func__,
-                         strerror(errno));
-      }
-      bytes_read_ += bytes_read;
-      if (bytes_read_ == preamble_size_for_type[packet_type]) {
-        size_t packet_length =
-            HciGetPacketLengthForType(packet_type, preamble_);
-        packet_.resize(preamble_size_for_type[packet_type] + packet_length);
-        memcpy(packet_.data(), preamble_, preamble_size_for_type[packet_type]);
-        bytes_remaining_ = packet_length;
-        state_ = HCI_PAYLOAD;
-        bytes_read_ = 0;
-      }
-      break;
-    }
-
-    case HCI_PAYLOAD: {
-      ssize_t bytes_read = TEMP_FAILURE_RETRY(read(
-          fd,
-          packet_.data() + preamble_size_for_type[packet_type] + bytes_read_,
-          bytes_remaining_));
-      if (bytes_read == 0) {
-        // This is only expected if the UART got closed when shutting down.
-        ALOGE("%s: Unexpected EOF reading the payload!", __func__);
-        sleep(5);  // Expect to be shut down within 5 seconds.
-        return;
-      }
-      if (bytes_read < 0) {
-        LOG_ALWAYS_FATAL("%s: Read payload error: %s", __func__,
-                         strerror(errno));
-      }
-      bytes_remaining_ -= bytes_read;
-      bytes_read_ += bytes_read;
-      if (bytes_remaining_ == 0) {
-        packet_ready_cb_();
-        state_ = HCI_PREAMBLE;
-        bytes_read_ = 0;
-      }
-      break;
-    }
-  }
-}
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/hci_packetizer.h b/bluetooth/hci_packetizer.h
deleted file mode 100644
index 06de70f..0000000
--- a/bluetooth/hci_packetizer.h
+++ /dev/null
@@ -1,54 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <functional>
-
-#include <hidl/HidlSupport.h>
-
-#include "hci_internals.h"
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-using ::android::hardware::hidl_vec;
-using HciPacketReadyCallback = std::function<void(void)>;
-
-class HciPacketizer {
- public:
-  HciPacketizer(HciPacketReadyCallback packet_cb)
-      : packet_ready_cb_(packet_cb){};
-  void OnDataReady(int fd, HciPacketType packet_type);
-  void CbHciPacket(uint8_t* data, size_t length);
-  const hidl_vec<uint8_t>& GetPacket() const;
-
- protected:
-  enum State { HCI_PREAMBLE, HCI_PAYLOAD };
-  State state_{HCI_PREAMBLE};
-  uint8_t preamble_[HCI_PREAMBLE_SIZE_MAX];
-  hidl_vec<uint8_t> packet_;
-  size_t bytes_remaining_{0};
-  size_t bytes_read_{0};
-  HciPacketReadyCallback packet_ready_cb_;
-};
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/hci_protocol.cc b/bluetooth/hci_protocol.cc
deleted file mode 100644
index bf94dfe..0000000
--- a/bluetooth/hci_protocol.cc
+++ /dev/null
@@ -1,58 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#include "hci_protocol.h"
-
-#define LOG_TAG "android.hardware.bluetooth-hci-hci_protocol"
-#include <assert.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <log/log.h>
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-size_t HciProtocol::WriteSafely(int fd, const uint8_t* data, size_t length) {
-  size_t transmitted_length = 0;
-  while (length > 0) {
-    ssize_t ret =
-        TEMP_FAILURE_RETRY(write(fd, data + transmitted_length, length));
-
-    if (ret == -1) {
-      if (errno == EAGAIN) continue;
-      ALOGE("%s error writing to UART (%s)", __func__, strerror(errno));
-      break;
-
-    } else if (ret == 0) {
-      // Nothing written :(
-      ALOGE("%s zero bytes written - something went wrong...", __func__);
-      break;
-    }
-
-    transmitted_length += ret;
-    length -= ret;
-  }
-
-  return transmitted_length;
-}
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/hci_protocol.h b/bluetooth/hci_protocol.h
deleted file mode 100644
index 6821107..0000000
--- a/bluetooth/hci_protocol.h
+++ /dev/null
@@ -1,49 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <hidl/HidlSupport.h>
-
-#include "bt_vendor_lib.h"
-#include "hci_internals.h"
-#include "hci_packetizer.h"
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-using ::android::hardware::hidl_vec;
-using PacketReadCallback = std::function<void(const hidl_vec<uint8_t>&)>;
-
-// Implementation of HCI protocol bits common to different transports
-class HciProtocol {
- public:
-  HciProtocol() = default;
-  virtual ~HciProtocol(){};
-
-  // Protocol-specific implementation of sending packets.
-  virtual size_t Send(uint8_t type, const uint8_t* data, size_t length) = 0;
-
- protected:
-  static size_t WriteSafely(int fd, const uint8_t* data, size_t length);
-};
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/mct_protocol.cc b/bluetooth/mct_protocol.cc
deleted file mode 100644
index 2a59187..0000000
--- a/bluetooth/mct_protocol.cc
+++ /dev/null
@@ -1,70 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#include "mct_protocol.h"
-
-#include <assert.h>
-
-#define LOG_TAG "android.hardware.bluetooth-hci-mct"
-#include <utils/Log.h>
-
-#include <fcntl.h>
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-MctProtocol::MctProtocol(int* fds, PacketReadCallback event_cb,
-                         PacketReadCallback acl_cb)
-    : event_cb_(event_cb),
-      acl_cb_(acl_cb),
-      event_packetizer_([this]() { OnEventPacketReady(); }),
-      acl_packetizer_([this]() { OnAclDataPacketReady(); }) {
-  for (int i = 0; i < CH_MAX; i++) {
-    uart_fds_[i] = fds[i];
-  }
-}
-
-size_t MctProtocol::Send(uint8_t type, const uint8_t* data, size_t length) {
-  if (type == HCI_PACKET_TYPE_COMMAND)
-    return WriteSafely(uart_fds_[CH_CMD], data, length);
-  if (type == HCI_PACKET_TYPE_ACL_DATA)
-    return WriteSafely(uart_fds_[CH_ACL_OUT], data, length);
-  LOG_ALWAYS_FATAL("%s: Unimplemented packet type = %d", __func__, type);
-  return 0;
-}
-
-void MctProtocol::OnEventPacketReady() {
-  event_cb_(event_packetizer_.GetPacket());
-}
-
-void MctProtocol::OnAclDataPacketReady() {
-  acl_cb_(acl_packetizer_.GetPacket());
-}
-
-void MctProtocol::OnEventDataReady(int fd) {
-  event_packetizer_.OnDataReady(fd, HCI_PACKET_TYPE_EVENT);
-}
-
-void MctProtocol::OnAclDataReady(int fd) {
-  acl_packetizer_.OnDataReady(fd, HCI_PACKET_TYPE_ACL_DATA);
-}
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/mct_protocol.h b/bluetooth/mct_protocol.h
deleted file mode 100644
index 6991746..0000000
--- a/bluetooth/mct_protocol.h
+++ /dev/null
@@ -1,56 +0,0 @@
-//
-// Copyright 2017 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <hidl/HidlSupport.h>
-
-#include "async_fd_watcher.h"
-#include "bt_vendor_lib.h"
-#include "hci_internals.h"
-#include "hci_protocol.h"
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace hci {
-
-class MctProtocol : public HciProtocol {
- public:
-  MctProtocol(int* fds, PacketReadCallback event_cb, PacketReadCallback acl_cb);
-
-  size_t Send(uint8_t type, const uint8_t* data, size_t length);
-
-  void OnEventPacketReady();
-  void OnAclDataPacketReady();
-
-  void OnEventDataReady(int fd);
-  void OnAclDataReady(int fd);
-
- private:
-  int uart_fds_[CH_MAX];
-
-  PacketReadCallback event_cb_;
-  PacketReadCallback acl_cb_;
-
-  hci::HciPacketizer event_packetizer_;
-  hci::HciPacketizer acl_packetizer_;
-};
-
-}  // namespace hci
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/service.cpp b/bluetooth/service.cpp
deleted file mode 100644
index a96552b..0000000
--- a/bluetooth/service.cpp
+++ /dev/null
@@ -1,37 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#define LOG_TAG "android.hardware.bluetooth@1.0-service.vbt"
-
-#include <android/hardware/bluetooth/1.0/IBluetoothHci.h>
-#include <hidl/HidlSupport.h>
-#include <hidl/HidlTransportSupport.h>
-
-
-#include "bluetooth_hci.h"
-
-using ::android::hardware::configureRpcThreadpool;
-using ::android::hardware::bluetooth::V1_0::IBluetoothHci;
-using ::android::hardware::bluetooth::V1_0::implementation::BluetoothHci;
-using ::android::hardware::joinRpcThreadpool;
-using ::android::sp;
-
-int main(int /* argc */, char** /* argv */) {
-  sp<IBluetoothHci> bluetooth = new BluetoothHci;
-  configureRpcThreadpool(1, true);
-  bluetooth->registerAsService();
-  joinRpcThreadpool();
-}
diff --git a/bluetooth/vendor_interface.cc b/bluetooth/vendor_interface.cc
deleted file mode 100644
index 1e0df7b..0000000
--- a/bluetooth/vendor_interface.cc
+++ /dev/null
@@ -1,394 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#include "vendor_interface.h"
-
-#define LOG_TAG "android.hardware.bluetooth@1.0-service.vbt"
-#include <cutils/properties.h>
-#include <utils/Log.h>
-
-#include <dlfcn.h>
-#include <fcntl.h>
-
-#include "bluetooth_address.h"
-#include "h4_protocol.h"
-#include "mct_protocol.h"
-
-typedef uint8_t UINT8;
-typedef uint16_t UINT16;
-
-#define STREAM_TO_UINT8(u8, p)   {u8 = (UINT8)(*(p)); (p) += 1;}
-#define STREAM_TO_UINT16(u16, p) {u16 = ((UINT16)(*(p)) + (((UINT16)(*((p) + 1))) << 8)); (p) += 2;}
-
-static const char* VENDOR_LIBRARY_NAME = "libbt-vendor.so";
-static const char* VENDOR_LIBRARY_SYMBOL_NAME =
-    "BLUETOOTH_VENDOR_LIB_INTERFACE";
-
-static const int INVALID_FD = -1;
-
-namespace {
-
-using android::hardware::bluetooth::V1_0::implementation::VendorInterface;
-using android::hardware::hidl_vec;
-
-struct {
-  tINT_CMD_CBACK cb;
-  uint16_t opcode;
-} internal_command;
-
-// True when LPM is not enabled yet or wake is not asserted.
-bool lpm_wake_deasserted;
-uint32_t lpm_timeout_ms;
-bool recent_activity_flag;
-
-VendorInterface* g_vendor_interface = nullptr;
-std::mutex wakeup_mutex_;
-
-HC_BT_HDR* WrapPacketAndCopy(uint16_t event, const hidl_vec<uint8_t>& data) {
-  size_t packet_size = data.size() + sizeof(HC_BT_HDR);
-  HC_BT_HDR* packet = reinterpret_cast<HC_BT_HDR*>(new uint8_t[packet_size]);
-  packet->offset = 0;
-  packet->len = data.size();
-  packet->layer_specific = 0;
-  packet->event = event;
-  // TODO(eisenbach): Avoid copy here; if BT_HDR->data can be ensured to
-  // be the only way the data is accessed, a pointer could be passed here...
-  memcpy(packet->data, data.data(), data.size());
-  return packet;
-}
-
-bool internal_command_event_match(const hidl_vec<uint8_t>& packet) {
-  uint8_t event_code = packet[0];
-  if (event_code != HCI_COMMAND_COMPLETE_EVENT) {
-    ALOGE("%s: Unhandled event type %02X", __func__, event_code);
-    return false;
-  }
-
-  size_t opcode_offset = HCI_EVENT_PREAMBLE_SIZE + 1;  // Skip num packets.
-
-  uint16_t opcode = packet[opcode_offset] | (packet[opcode_offset + 1] << 8);
-
-  ALOGV("%s internal_command.opcode = %04X opcode = %04x", __func__,
-        internal_command.opcode, opcode);
-  return opcode == internal_command.opcode;
-}
-
-uint8_t transmit_cb(uint16_t opcode, void* buffer, tINT_CMD_CBACK callback) {
-  ALOGV("%s opcode: 0x%04x, ptr: %p, cb: %p", __func__, opcode, buffer,
-        callback);
-  internal_command.cb = callback;
-  internal_command.opcode = opcode;
-  uint8_t type = HCI_PACKET_TYPE_COMMAND;
-  HC_BT_HDR* bt_hdr = reinterpret_cast<HC_BT_HDR*>(buffer);
-  VendorInterface::get()->Send(type, bt_hdr->data, bt_hdr->len);
-  delete[] reinterpret_cast<uint8_t*>(buffer);
-  return true;
-}
-
-void firmware_config_cb(bt_vendor_op_result_t result) {
-  ALOGV("%s result: %d", __func__, result);
-  VendorInterface::get()->OnFirmwareConfigured(result);
-}
-
-void sco_config_cb(bt_vendor_op_result_t result) {
-  ALOGD("%s result: %d", __func__, result);
-}
-
-void low_power_mode_cb(bt_vendor_op_result_t result) {
-  ALOGD("%s result: %d", __func__, result);
-}
-
-void sco_audiostate_cb(bt_vendor_op_result_t result) {
-  ALOGD("%s result: %d", __func__, result);
-}
-
-void* buffer_alloc_cb(int size) {
-  void* p = new uint8_t[size];
-  ALOGV("%s pts: %p, size: %d", __func__, p, size);
-  return p;
-}
-
-void buffer_free_cb(void* buffer) {
-  ALOGV("%s ptr: %p", __func__, buffer);
-  delete[] reinterpret_cast<uint8_t*>(buffer);
-}
-
-void epilog_cb(bt_vendor_op_result_t result) {
-  ALOGD("%s result: %d", __func__, result);
-}
-
-void a2dp_offload_cb(bt_vendor_op_result_t result, bt_vendor_opcode_t op,
-                     uint8_t av_handle) {
-  ALOGD("%s result: %d, op: %d, handle: %d", __func__, result, op, av_handle);
-}
-
-const bt_vendor_callbacks_t lib_callbacks = {
-    sizeof(lib_callbacks), firmware_config_cb, sco_config_cb,
-    low_power_mode_cb,     sco_audiostate_cb,  buffer_alloc_cb,
-    buffer_free_cb,        transmit_cb,        epilog_cb,
-    a2dp_offload_cb};
-
-}  // namespace
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace V1_0 {
-namespace implementation {
-
-class FirmwareStartupTimer {
- public:
-  FirmwareStartupTimer() : start_time_(std::chrono::steady_clock::now()) {}
-
-  ~FirmwareStartupTimer() {
-    std::chrono::duration<double> duration =
-        std::chrono::steady_clock::now() - start_time_;
-    double s = duration.count();
-    if (s == 0) return;
-    ALOGI("Firmware configured in %.3fs", s);
-  }
-
- private:
-  std::chrono::steady_clock::time_point start_time_;
-};
-
-bool VendorInterface::Initialize(
-    InitializeCompleteCallback initialize_complete_cb,
-    PacketReadCallback event_cb, PacketReadCallback acl_cb,
-    PacketReadCallback sco_cb) {
-  if (g_vendor_interface) {
-    ALOGE("%s: No previous Shutdown()?", __func__);
-    return false;
-  }
-  g_vendor_interface = new VendorInterface();
-  return g_vendor_interface->Open(initialize_complete_cb, event_cb, acl_cb,
-                                  sco_cb);
-}
-
-void VendorInterface::Shutdown() {
-  LOG_ALWAYS_FATAL_IF(!g_vendor_interface, "%s: No Vendor interface!",
-                      __func__);
-  g_vendor_interface->Close();
-  delete g_vendor_interface;
-  g_vendor_interface = nullptr;
-}
-
-VendorInterface* VendorInterface::get() { return g_vendor_interface; }
-
-bool VendorInterface::Open(InitializeCompleteCallback initialize_complete_cb,
-                           PacketReadCallback event_cb,
-                           PacketReadCallback acl_cb,
-                           PacketReadCallback sco_cb) {
-  initialize_complete_cb_ = initialize_complete_cb;
-
-  // Initialize vendor interface
-
-  lib_handle_ = dlopen(VENDOR_LIBRARY_NAME, RTLD_NOW);
-  if (!lib_handle_) {
-    ALOGE("%s unable to open %s (%s)", __func__, VENDOR_LIBRARY_NAME,
-          dlerror());
-    return false;
-  }
-
-  lib_interface_ = reinterpret_cast<bt_vendor_interface_t*>(
-      dlsym(lib_handle_, VENDOR_LIBRARY_SYMBOL_NAME));
-  if (!lib_interface_) {
-    ALOGE("%s unable to find symbol %s in %s (%s)", __func__,
-          VENDOR_LIBRARY_SYMBOL_NAME, VENDOR_LIBRARY_NAME, dlerror());
-    return false;
-  }
-
-  // Get the local BD address
-
-  uint8_t local_bda[BluetoothAddress::kBytes];
-  if (!BluetoothAddress::get_local_address(local_bda)) {
-    LOG_ALWAYS_FATAL("%s: No Bluetooth Address!", __func__);
-  }
-  int status = lib_interface_->init(&lib_callbacks, (unsigned char*)local_bda);
-  if (status) {
-    ALOGE("%s unable to initialize vendor library: %d", __func__, status);
-    return false;
-  }
-
-  ALOGD("%s vendor library loaded", __func__);
-
-  // Power on the controller
-
-  int power_state = BT_VND_PWR_ON;
-  lib_interface_->op(BT_VND_OP_POWER_CTRL, &power_state);
-
-  // Get the UART socket(s)
-
-  int fd_list[CH_MAX] = {0};
-  int fd_count = lib_interface_->op(BT_VND_OP_USERIAL_OPEN, &fd_list);
-
-  if (fd_count < 1 || fd_count > CH_MAX - 1) {
-    ALOGE("%s: fd_count %d is invalid!", __func__, fd_count);
-    return false;
-  }
-
-  for (int i = 0; i < fd_count; i++) {
-    if (fd_list[i] == INVALID_FD) {
-      ALOGE("%s: fd %d is invalid!", __func__, fd_list[i]);
-      return false;
-    }
-  }
-
-  event_cb_ = event_cb;
-  PacketReadCallback intercept_events = [this](const hidl_vec<uint8_t>& event) {
-    HandleIncomingEvent(event);
-  };
-
-  if (fd_count == 1) {
-    hci::H4Protocol* h4_hci =
-        new hci::H4Protocol(fd_list[0], intercept_events, acl_cb, sco_cb);
-    fd_watcher_.WatchFdForNonBlockingReads(
-        fd_list[0], [h4_hci](int fd) { h4_hci->OnDataReady(fd); });
-    hci_ = h4_hci;
-  } else {
-    hci::MctProtocol* mct_hci =
-        new hci::MctProtocol(fd_list, intercept_events, acl_cb);
-    fd_watcher_.WatchFdForNonBlockingReads(
-        fd_list[CH_EVT], [mct_hci](int fd) { mct_hci->OnEventDataReady(fd); });
-    fd_watcher_.WatchFdForNonBlockingReads(
-        fd_list[CH_ACL_IN],
-        [mct_hci](int fd) { mct_hci->OnAclDataReady(fd); });
-    hci_ = mct_hci;
-  }
-
-  // Initially, the power management is off.
-  lpm_wake_deasserted = true;
-
-  // Start configuring the firmware
-  firmware_startup_timer_ = new FirmwareStartupTimer();
-  lib_interface_->op(BT_VND_OP_FW_CFG, nullptr);
-
-  return true;
-}
-
-void VendorInterface::Close() {
-  // These callbacks may send HCI events (vendor-dependent), so make sure to
-  // StopWatching the file descriptor after this.
-  if (lib_interface_ != nullptr) {
-    bt_vendor_lpm_mode_t mode = BT_VND_LPM_DISABLE;
-    lib_interface_->op(BT_VND_OP_LPM_SET_MODE, &mode);
-  }
-
-  fd_watcher_.StopWatchingFileDescriptors();
-
-  if (hci_ != nullptr) {
-    delete hci_;
-    hci_ = nullptr;
-  }
-
-  if (lib_interface_ != nullptr) {
-    lib_interface_->op(BT_VND_OP_USERIAL_CLOSE, nullptr);
-
-    int power_state = BT_VND_PWR_OFF;
-    lib_interface_->op(BT_VND_OP_POWER_CTRL, &power_state);
-
-    lib_interface_->cleanup();
-  }
-
-  if (lib_handle_ != nullptr) {
-    dlclose(lib_handle_);
-    lib_handle_ = nullptr;
-  }
-
-  if (firmware_startup_timer_ != nullptr) {
-    delete firmware_startup_timer_;
-    firmware_startup_timer_ = nullptr;
-  }
-}
-
-size_t VendorInterface::Send(uint8_t type, const uint8_t* data, size_t length) {
-  std::unique_lock<std::mutex> lock(wakeup_mutex_);
-  recent_activity_flag = true;
-
-  if (lpm_wake_deasserted == true) {
-    // Restart the timer.
-    fd_watcher_.ConfigureTimeout(std::chrono::milliseconds(lpm_timeout_ms),
-                                 [this]() { OnTimeout(); });
-    // Assert wake.
-    lpm_wake_deasserted = false;
-    bt_vendor_lpm_wake_state_t wakeState = BT_VND_LPM_WAKE_ASSERT;
-    lib_interface_->op(BT_VND_OP_LPM_WAKE_SET_STATE, &wakeState);
-    ALOGV("%s: Sent wake before (%02x)", __func__, data[0] | (data[1] << 8));
-  }
-  return hci_->Send(type, data, length);
-}
-
-void VendorInterface::OnFirmwareConfigured(uint8_t result) {
-  ALOGD("%s result: %d", __func__, result);
-
-  if (firmware_startup_timer_ != nullptr) {
-    delete firmware_startup_timer_;
-    firmware_startup_timer_ = nullptr;
-  }
-
-  if (initialize_complete_cb_ != nullptr) {
-    initialize_complete_cb_(result == 0);
-    initialize_complete_cb_ = nullptr;
-  }
-
-  // Post load
-  lib_interface_->op(BT_VND_OP_SCO_CFG, NULL);
-  ALOGI("%s: SCO configuration initiated ", __func__);
-
-  lib_interface_->op(BT_VND_OP_GET_LPM_IDLE_TIMEOUT, &lpm_timeout_ms);
-  ALOGI("%s: lpm_timeout_ms %d", __func__, lpm_timeout_ms);
-
-  bt_vendor_lpm_mode_t mode = BT_VND_LPM_ENABLE;
-  lib_interface_->op(BT_VND_OP_LPM_SET_MODE, &mode);
-
-  ALOGD("%s Calling StartLowPowerWatchdog()", __func__);
-  fd_watcher_.ConfigureTimeout(std::chrono::milliseconds(lpm_timeout_ms),
-                               [this]() { OnTimeout(); });
-}
-
-void VendorInterface::OnTimeout() {
-  ALOGV("%s", __func__);
-  std::unique_lock<std::mutex> lock(wakeup_mutex_);
-  if (recent_activity_flag == false) {
-    lpm_wake_deasserted = true;
-    bt_vendor_lpm_wake_state_t wakeState = BT_VND_LPM_WAKE_DEASSERT;
-    lib_interface_->op(BT_VND_OP_LPM_WAKE_SET_STATE, &wakeState);
-    fd_watcher_.ConfigureTimeout(std::chrono::seconds(0), []() {
-      ALOGE("Zero timeout! Should never happen.");
-    });
-  }
-  recent_activity_flag = false;
-}
-
-void VendorInterface::HandleIncomingEvent(const hidl_vec<uint8_t>& hci_packet) {
-  if (internal_command.cb != nullptr &&
-      internal_command_event_match(hci_packet)) {
-    HC_BT_HDR* bt_hdr = WrapPacketAndCopy(HCI_PACKET_TYPE_EVENT, hci_packet);
-
-    // The callbacks can send new commands, so don't zero after calling.
-    tINT_CMD_CBACK saved_cb = internal_command.cb;
-    internal_command.cb = nullptr;
-    saved_cb(bt_hdr);
-  } else {
-    event_cb_(hci_packet);
-  }
-}
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
diff --git a/bluetooth/vendor_interface.h b/bluetooth/vendor_interface.h
deleted file mode 100644
index a401ee6..0000000
--- a/bluetooth/vendor_interface.h
+++ /dev/null
@@ -1,76 +0,0 @@
-//
-// Copyright 2016 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-
-#pragma once
-
-#include <hidl/HidlSupport.h>
-
-#include "async_fd_watcher.h"
-#include "bt_vendor_lib.h"
-#include "hci_protocol.h"
-
-namespace android {
-namespace hardware {
-namespace bluetooth {
-namespace V1_0 {
-namespace implementation {
-
-using ::android::hardware::hidl_vec;
-using InitializeCompleteCallback = std::function<void(bool success)>;
-using PacketReadCallback = std::function<void(const hidl_vec<uint8_t>&)>;
-
-class FirmwareStartupTimer;
-
-class VendorInterface {
- public:
-  static bool Initialize(InitializeCompleteCallback initialize_complete_cb,
-                         PacketReadCallback event_cb, PacketReadCallback acl_cb,
-                         PacketReadCallback sco_cb);
-  static void Shutdown();
-  static VendorInterface *get();
-
-  size_t Send(uint8_t type, const uint8_t *data, size_t length);
-
-  void OnFirmwareConfigured(uint8_t result);
-
- private:
-  virtual ~VendorInterface() = default;
-
-  bool Open(InitializeCompleteCallback initialize_complete_cb,
-            PacketReadCallback event_cb, PacketReadCallback acl_cb,
-            PacketReadCallback sco_cb);
-  void Close();
-
-  void OnTimeout();
-
-  void HandleIncomingEvent(const hidl_vec<uint8_t>& hci_packet);
-
-  void *lib_handle_;
-  bt_vendor_interface_t *lib_interface_;
-  async::AsyncFdWatcher fd_watcher_;
-  InitializeCompleteCallback initialize_complete_cb_;
-  hci::HciProtocol* hci_;
-
-  PacketReadCallback event_cb_;
-
-  FirmwareStartupTimer *firmware_startup_timer_;
-};
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace bluetooth
-}  // namespace hardware
-}  // namespace android
-- 
2.34.1

