From c80e8efcb8750508c1348b72af9cbec72aec33b2 Mon Sep 17 00:00:00 2001
From: HeYue <yue.he@intel.com>
Date: Tue, 13 Jun 2023 16:17:15 +0530
Subject: [PATCH] Support open up to two backend driver

Changes include:
- In virtio, gvt-d or softpipe only open one driver node.
- In KMSRO, need open two backend driver, limit virtio-gpu usage only for
scanout, other buffers (i.e. rendering target, texture and so on)
allocated via i915.
- Only alloc no tile buffer for sriov to avoid potential map fail on
tiled buffer.
- Remove BO_USE_SCANOUT if yuv format to support hardware codec in
SRIOV mode.

Tracked-On: OAM-100205
Signed-off-by: Dongwon Kim <dongwon.kim@intel.com>
Signed-off-by: HeYue <yue.he@intel.com>
---
 Android.bp                                  |   1 +
 cros_gralloc/cros_gralloc_driver.cc         | 274 +++++++++++++++++++-
 cros_gralloc/cros_gralloc_driver.h          |  11 +-
 cros_gralloc/cros_gralloc_handle.h          |   1 +
 cros_gralloc/gralloc4/CrosGralloc4Mapper.cc |   4 +-
 drv.c                                       |  47 +++-
 drv.h                                       |   4 +
 drv_helpers.c                               |   8 +
 drv_priv.h                                  |   9 +
 i915.c                                      |   4 +
 10 files changed, 338 insertions(+), 25 deletions(-)

diff --git a/Android.bp b/Android.bp
index 59656dc..f23d123 100644
--- a/Android.bp
+++ b/Android.bp
@@ -220,6 +220,7 @@ cc_library_shared {
         "-DDRV_I915",
         "-DUSE_GRALLOC1",
         "-Wno-cast-qual",
+        "-Wno-unused-function",
         "-DHAVE_MEMFD_CREATE",
     ],
     enabled: false,
diff --git a/cros_gralloc/cros_gralloc_driver.cc b/cros_gralloc/cros_gralloc_driver.cc
index 5b21f23..765bdc8 100644
--- a/cros_gralloc/cros_gralloc_driver.cc
+++ b/cros_gralloc/cros_gralloc_driver.cc
@@ -14,6 +14,7 @@
 #include <syscall.h>
 #include <xf86drm.h>
 
+#include "../drv_priv.h"
 #include "../util.h"
 
 #ifdef USE_GRALLOC1
@@ -157,22 +158,200 @@ static void drv_destroy_and_close(struct driver *drv)
 	close(fd);
 }
 
-cros_gralloc_driver::cros_gralloc_driver() : drv_(init_try_nodes(), drv_destroy_and_close)
+cros_gralloc_driver::cros_gralloc_driver()
 {
+	/*
+	 * Create a driver from render nodes first, then try card
+	 * nodes.
+	 *
+	 * TODO(gsingh): Enable render nodes on udl/evdi.
+	 */
+
+	char const *render_nodes_fmt = "%s/renderD%d";
+	uint32_t num_nodes = DRM_NUM_NODES;
+	uint32_t min_render_node = DRM_RENDER_NODE_START;
+	uint32_t max_render_node = (min_render_node + num_nodes);
+
+	const char *undesired[2] = { "vgem", nullptr };
+	uint32_t j;
+	char *node;
+	int fd;
+	drmVersionPtr version;
+	const int render_num = 10;
+	int node_fd[render_num];
+	char *node_name[render_num] = {};
+	int availabe_node = 0;
+	int virtio_node_idx = -1;
+	uint32_t gpu_grp_type = 0;
+
 	char buf[PROP_VALUE_MAX];
 	property_get("ro.product.device", buf, "unknown");
 	mt8183_camera_quirk_ = !strncmp(buf, "kukui", strlen("kukui"));
+
+#define TARGET_DEVICE_IDX_PROP  "ro.acg.rnode"
+	char prop_buf[PROPERTY_VALUE_MAX] = {"-1"};
+	property_get(TARGET_DEVICE_IDX_PROP, prop_buf, "-1");
+	if (strcmp(prop_buf, "-1")) {
+		drv_loge("Render name set by property is (%s)",prop_buf);
+		min_render_node = atoi(prop_buf)+128;
+		num_nodes = 1;
+		max_render_node = (min_render_node + num_nodes);
+	}
+
+	// destroy drivers if exist before re-initializing them
+	if (drv_kms_) {
+		int fd = drv_get_fd(drv_kms_);
+		drv_destroy(drv_kms_);
+		if (!is_kmsro_enabled()) {
+			drv_render_ = nullptr;
+		}
+		drv_kms_ = nullptr;
+		close(fd);
+	}
+
+	if (drv_render_) {
+		int fd = drv_get_fd(drv_render_);
+		drv_destroy(drv_render_);
+		drv_render_ = nullptr;
+		close(fd);
+	}
+
+	for (uint32_t i = min_render_node; i < max_render_node; i++) {
+		if (asprintf(&node, render_nodes_fmt, DRM_DIR_NAME, i) < 0)
+			continue;
+
+		fd = open(node, O_RDWR, 0);
+		free(node);
+		if (fd < 0)
+			continue;
+
+		version = drmGetVersion(fd);
+		if (!version) {
+			close(fd);
+			continue;
+		}
+
+		for (j = 0; j < ARRAY_SIZE(undesired); j++) {
+			if (undesired[j] && !strcmp(version->name, undesired[j])) {
+				drmFreeVersion(version);
+				close(fd);
+				break;
+			}
+		}
+
+		// hit any of undesired render node
+		if (j < ARRAY_SIZE(undesired))
+			continue;
+
+		if (!strcmp(version->name, "virtio_gpu")) {
+			virtio_node_idx = availabe_node;
+		}
+
+		node_fd[availabe_node] = fd;
+		int len = snprintf(NULL, 0, "%s", version->name);
+		node_name[availabe_node] = (char *)malloc(len + 1);
+		strcpy(node_name[availabe_node], version->name);
+		availabe_node++;
+
+		drmFreeVersion(version);
+	}
+
+	// open the first render node
+	if (availabe_node > 0) {
+		drv_render_ = drv_create(node_fd[0]);
+		if (!drv_render_) {
+			drv_loge("Failed to create driver for the 1st device\n");
+			close(node_fd[0]);
+		} else {
+			switch (availabe_node) {
+			// only have one render node, is GVT-d/BM/VirtIO
+			case 1:
+				if (drv_render_) {
+					drv_kms_ = drv_render_;
+				} else
+					break;
+				gpu_grp_type = (virtio_node_idx != -1)? ONE_GPU_VIRTIO: ONE_GPU_INTEL;
+				break;
+			// is SR-IOV or iGPU + dGPU
+			case 2:
+				if (virtio_node_idx != -1) {
+					drv_kms_ = drv_create(node_fd[virtio_node_idx]);
+					if (!drv_kms_) {
+						drv_loge("Failed to create driver for virtio device\n");
+						close(node_fd[virtio_node_idx]);
+						break;
+					}
+					gpu_grp_type = TWO_GPU_IGPU_VIRTIO;
+				} else {
+					close(node_fd[1]);
+					drv_kms_ = drv_render_;
+					gpu_grp_type = TWO_GPU_IGPU_DGPU;
+				}
+				break;
+			// is SR-IOV + dGPU
+			case 3:
+				if (!strcmp(node_name[1], "i915")) {
+					close(node_fd[1]);
+				}
+				if (virtio_node_idx != -1) {
+					drv_kms_ = drv_create(node_fd[virtio_node_idx]);
+					if (!drv_kms_) {
+						drv_loge("Failed to create driver for virtio device\n");
+						close(node_fd[virtio_node_idx]);
+						break;
+					}
+				}
+				gpu_grp_type = THREE_GPU_IGPU_VIRTIO_DGPU;
+				// TO-DO: the 3rd node is i915 or others.
+				break;
+			}
+
+			if (drv_render_) {
+				if (drv_init(drv_render_, gpu_grp_type)) {
+					drv_loge("Failed to init render driver\n");
+				}
+			}
+
+			if (drv_kms_ && (drv_kms_ != drv_render_)) {
+				if (drv_init(drv_kms_, gpu_grp_type)) {
+					drv_loge("Failed to init kms driver\n");
+				}
+			}
+		}
+	}
+
+	for (int i = 0; i < availabe_node; i++) {
+		free(node_name[i]);
+	}
 }
 
 cros_gralloc_driver::~cros_gralloc_driver()
 {
 	buffers_.clear();
 	handles_.clear();
+
+	if (drv_kms_) {
+		int fd = drv_get_fd(drv_kms_);
+		drv_destroy(drv_kms_);
+		if (!is_kmsro_enabled()) {
+			drv_render_ = nullptr;
+		}
+		drv_kms_ = nullptr;
+		close(fd);
+	}
+
+	if (drv_render_) {
+		int fd = drv_get_fd(drv_render_);
+		drv_destroy(drv_render_);
+		drv_render_ = nullptr;
+		close(fd);
+	}
+
 }
 
 bool cros_gralloc_driver::is_initialized()
 {
-	return drv_ != nullptr;
+	return (drv_render_ != nullptr || drv_kms_ != nullptr);
 }
 
 bool cros_gralloc_driver::get_resolved_format_and_use_flags(
@@ -183,6 +362,7 @@ bool cros_gralloc_driver::get_resolved_format_and_use_flags(
 	uint64_t resolved_use_flags;
 	struct combination *combo;
 
+	struct driver *drv = (descriptor->use_flags & BO_USE_SCANOUT) ? drv_kms_ : drv_render_;
 	if (mt8183_camera_quirk_ && (descriptor->use_flags & BO_USE_CAMERA_READ) &&
 	    !(descriptor->use_flags & BO_USE_SCANOUT) &&
 	    descriptor->drm_format == DRM_FORMAT_FLEX_IMPLEMENTATION_DEFINED) {
@@ -191,10 +371,27 @@ bool cros_gralloc_driver::get_resolved_format_and_use_flags(
 		return true;
 	}
 
-	drv_resolve_format_and_use_flags(drv_.get(), descriptor->drm_format, descriptor->use_flags,
+	drv_resolve_format_and_use_flags(drv, descriptor->drm_format, descriptor->use_flags,
 					 &resolved_format, &resolved_use_flags);
 
-	combo = drv_get_combination(drv_.get(), resolved_format, resolved_use_flags);
+	combo = drv_get_combination(drv, resolved_format, resolved_use_flags);
+	if (!combo && (descriptor->use_flags & BO_USE_SCANOUT)) {
+		if (is_kmsro_enabled()) {
+			/* if kmsro is enabled, it is scanout buffer and not used for video,
+			 * don't need remove scanout flag */
+			if (!IsSupportedYUVFormat(descriptor->droid_format)) {
+				combo = drv_get_combination(drv, resolved_format,
+					    (descriptor->use_flags) & (~BO_USE_SCANOUT));
+			} else {
+				drv = drv_render_;
+				resolved_use_flags &= ~BO_USE_SCANOUT;
+				combo = drv_get_combination(drv, resolved_format, descriptor->use_flags);
+			}
+		} else {
+			resolved_use_flags &= ~BO_USE_SCANOUT;
+			combo = drv_get_combination(drv, resolved_format, descriptor->use_flags);
+		}
+	}
 	if (!combo && (descriptor->droid_usage & GRALLOC_USAGE_HW_VIDEO_ENCODER) &&
 	    descriptor->droid_format != HAL_PIXEL_FORMAT_YCbCr_420_888) {
 		// Unmask BO_USE_HW_VIDEO_ENCODER for other formats. They are mostly
@@ -202,12 +399,12 @@ bool cros_gralloc_driver::get_resolved_format_and_use_flags(
 		// camera). YV12 is passed to the encoder component, but it is converted
 		// to YCbCr_420_888 before being passed to the hw encoder.
 		resolved_use_flags &= ~BO_USE_HW_VIDEO_ENCODER;
-		combo = drv_get_combination(drv_.get(), resolved_format, resolved_use_flags);
+		combo = drv_get_combination(drv, resolved_format, resolved_use_flags);
 	}
 	if (!combo && (descriptor->droid_usage & BUFFER_USAGE_FRONT_RENDERING_MASK)) {
 		resolved_use_flags &= ~BO_USE_FRONT_RENDERING;
 		resolved_use_flags |= BO_USE_LINEAR;
-		combo = drv_get_combination(drv_.get(), resolved_format, resolved_use_flags);
+		combo = drv_get_combination(drv, resolved_format, resolved_use_flags);
 	}
 	if (!combo)
 		return false;
@@ -221,7 +418,8 @@ bool cros_gralloc_driver::is_supported(const struct cros_gralloc_buffer_descript
 {
 	uint32_t resolved_format;
 	uint64_t resolved_use_flags;
-	uint32_t max_texture_size = drv_get_max_texture_2d_size(drv_.get());
+	struct driver *drv = (descriptor->use_flags & BO_USE_SCANOUT) ? drv_kms_ : drv_render_;
+	uint32_t max_texture_size = drv_get_max_texture_2d_size(drv);
 	if (!get_resolved_format_and_use_flags(descriptor, &resolved_format, &resolved_use_flags))
 		return false;
 
@@ -267,22 +465,50 @@ int32_t cros_gralloc_driver::allocate(const struct cros_gralloc_buffer_descripto
 	struct bo *bo;
 	struct cros_gralloc_handle *hnd;
 	std::unique_ptr<cros_gralloc_buffer> buffer;
+	bool from_kms = false;
+
+	struct driver *drv;
+
+	if ((descriptor->use_flags & BO_USE_SCANOUT)) {
+		from_kms = true;
+		drv = drv_kms_;
+	} else {
+		drv = drv_render_;
+	}
 
 	if (!get_resolved_format_and_use_flags(descriptor, &resolved_format, &resolved_use_flags)) {
 		ALOGE("Failed to resolve format and use_flags.");
 		return -EINVAL;
 	}
 
+	/*
+	 * TODO(b/79682290): ARC++ assumes NV12 is always linear and doesn't
+	 * send modifiers across Wayland protocol, so we or in the
+	 * BO_USE_LINEAR flag here. We need to fix ARC++ to allocate and work
+	 * with tiled buffers.
+	 */
+	if (resolved_format == DRM_FORMAT_NV12)
+		resolved_use_flags |= BO_USE_LINEAR;
+
+	/*
+	 * This unmask is a backup in the case DRM_FORMAT_FLEX_IMPLEMENTATION_DEFINED is resolved
+	 * to non-YUV formats.
+	 */
+	if (descriptor->drm_format == DRM_FORMAT_FLEX_IMPLEMENTATION_DEFINED &&
+	    (resolved_format == DRM_FORMAT_XBGR8888 || resolved_format == DRM_FORMAT_ABGR8888)) {
+		resolved_use_flags &= ~BO_USE_HW_VIDEO_ENCODER;
+	}
+
 #ifdef USE_GRALLOC1
 	if (descriptor->modifier == 0) {
-		bo = drv_bo_create(drv_.get(), descriptor->width, descriptor->height, resolved_format,
+		bo = drv_bo_create(drv, descriptor->width, descriptor->height, resolved_format,
 				   resolved_use_flags);
 	} else {
-		bo = drv_bo_create_with_modifiers(drv_.get(), descriptor->width, descriptor->height,
+		bo = drv_bo_create_with_modifiers(drv, descriptor->width, descriptor->height,
 						  resolved_format, &descriptor->modifier, 1);
 	}
 #else
-	bo = drv_bo_create(drv_.get(), descriptor->width, descriptor->height, resolved_format,
+	bo = drv_bo_create(drv, descriptor->width, descriptor->height, resolved_format,
 			   resolved_use_flags);
 #endif
 	if (!bo) {
@@ -316,6 +542,7 @@ int32_t cros_gralloc_driver::allocate(const struct cros_gralloc_buffer_descripto
 		hnd->fds[i] = -1;
 
 	hnd->num_planes = num_planes;
+	hnd->from_kms = from_kms;
 	for (size_t plane = 0; plane < num_planes; plane++) {
 		ret = drv_bo_get_plane_fd(bo, plane);
 		if (ret < 0)
@@ -401,6 +628,7 @@ destroy_bo:
 int32_t cros_gralloc_driver::retain(buffer_handle_t handle)
 {
 	std::lock_guard<std::mutex> lock(mutex_);
+	struct driver *drv;
 
 	auto hnd = cros_gralloc_convert_handle(handle);
 	if (!hnd) {
@@ -408,6 +636,8 @@ int32_t cros_gralloc_driver::retain(buffer_handle_t handle)
 		return -EINVAL;
 	}
 
+	drv = (hnd->from_kms) ? drv_kms_ : drv_render_;
+
 	auto hnd_it = handles_.find(hnd);
 	if (hnd_it != handles_.end()) {
 		// The underlying buffer (as multiple handles can refer to the same buffer)
@@ -449,7 +679,7 @@ int32_t cros_gralloc_driver::retain(buffer_handle_t handle)
 		memcpy(data.strides, hnd->strides, sizeof(data.strides));
 		memcpy(data.offsets, hnd->offsets, sizeof(data.offsets));
 
-		struct bo *bo = drv_bo_import(drv_.get(), &data);
+		struct bo *bo = drv_bo_import(drv, &data);
 		if (!bo)
 			return -EFAULT;
 
@@ -680,13 +910,20 @@ uint32_t cros_gralloc_driver::get_resolved_drm_format(uint32_t drm_format, uint6
 {
 	uint32_t resolved_format;
 	uint64_t resolved_use_flags;
+	struct driver *drv = (use_flags & BO_USE_SCANOUT) ? drv_kms_ : drv_render_;
 
-	drv_resolve_format_and_use_flags(drv_.get(), drm_format, use_flags, &resolved_format,
+	drv_resolve_format_and_use_flags(drv, drm_format, use_flags, &resolved_format,
 					 &resolved_use_flags);
 
 	return resolved_format;
 }
 
+uint32_t cros_gralloc_driver::get_resolved_common_drm_format(uint32_t drm_format)
+{
+	return drv_resolved_common_drm_format(drm_format);
+}
+
+
 cros_gralloc_buffer *cros_gralloc_driver::get_buffer(cros_gralloc_handle_t hnd)
 {
 	/* Assumes driver mutex is held. */
@@ -718,3 +955,16 @@ void cros_gralloc_driver::with_each_buffer(
 	for (const auto &pair : buffers_)
 		function(pair.second.get());
 }
+
+bool cros_gralloc_driver::IsSupportedYUVFormat(uint32_t droid_format)
+{
+	switch (droid_format) {
+	case HAL_PIXEL_FORMAT_YCbCr_420_888:
+	case HAL_PIXEL_FORMAT_YV12:
+	case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
+		return true;
+	default:
+		return i915_private_supported_yuv_format(droid_format);
+	}
+	return false;
+}
diff --git a/cros_gralloc/cros_gralloc_driver.h b/cros_gralloc/cros_gralloc_driver.h
index 182e8ce..28959a0 100644
--- a/cros_gralloc/cros_gralloc_driver.h
+++ b/cros_gralloc/cros_gralloc_driver.h
@@ -54,6 +54,13 @@ class cros_gralloc_driver
 	void with_buffer(cros_gralloc_handle_t hnd,
 			 const std::function<void(cros_gralloc_buffer *)> &function);
 	void with_each_buffer(const std::function<void(cros_gralloc_buffer *)> &function);
+	uint32_t get_resolved_common_drm_format(uint32_t drm_format);
+
+	bool is_kmsro_enabled()
+	{
+		return drv_kms_ != drv_render_;
+	};
+	bool IsSupportedYUVFormat(uint32_t droid_format);
 
       private:
 	cros_gralloc_driver();
@@ -71,8 +78,6 @@ class cros_gralloc_driver
 	BufferAllocator allocator_;
 #endif
 
-	std::unique_ptr<struct driver, void (*)(struct driver *)> drv_;
-
 	struct cros_gralloc_imported_handle_info {
 		/*
 		 * The underlying buffer for referred to by this handle (as multiple handles can
@@ -84,6 +89,8 @@ class cros_gralloc_driver
 		int32_t refcount = 1;
 	};
 
+	struct driver *drv_kms_;
+	struct driver *drv_render_;
 	std::mutex mutex_;
 	std::unordered_map<uint32_t, std::unique_ptr<cros_gralloc_buffer>> buffers_;
 	std::unordered_map<cros_gralloc_handle_t, cros_gralloc_imported_handle_info> handles_;
diff --git a/cros_gralloc/cros_gralloc_handle.h b/cros_gralloc/cros_gralloc_handle.h
index cdcd5dc..f24b4a2 100644
--- a/cros_gralloc/cros_gralloc_handle.h
+++ b/cros_gralloc/cros_gralloc_handle.h
@@ -26,6 +26,7 @@ struct cros_gralloc_handle : public native_handle_t {
 	uint32_t strides[DRV_MAX_PLANES];
 	uint32_t offsets[DRV_MAX_PLANES];
 	uint32_t sizes[DRV_MAX_PLANES];
+	bool from_kms;
 	uint32_t id;
 	uint32_t width;
 	uint32_t height;
diff --git a/cros_gralloc/gralloc4/CrosGralloc4Mapper.cc b/cros_gralloc/gralloc4/CrosGralloc4Mapper.cc
index 1f87e65..f216277 100644
--- a/cros_gralloc/gralloc4/CrosGralloc4Mapper.cc
+++ b/cros_gralloc/gralloc4/CrosGralloc4Mapper.cc
@@ -493,8 +493,8 @@ Return<void> CrosGralloc4Mapper::get(const cros_gralloc_buffer* crosBuffer,
         PixelFormat pixelFormat = static_cast<PixelFormat>(crosBuffer->get_android_format());
         status = android::gralloc4::encodePixelFormatRequested(pixelFormat, &encodedMetadata);
     } else if (metadataType == android::gralloc4::MetadataType_PixelFormatFourCC) {
-        status = android::gralloc4::encodePixelFormatFourCC(
-                drv_get_standard_fourcc(crosBuffer->get_format()), &encodedMetadata);
+        uint32_t format = mDriver->get_resolved_common_drm_format(crosBuffer->get_format());
+        status = android::gralloc4::encodePixelFormatFourCC(format, &encodedMetadata);
     } else if (metadataType == android::gralloc4::MetadataType_PixelFormatModifier) {
         status = android::gralloc4::encodePixelFormatModifier(crosBuffer->get_format_modifier(),
                                                               &encodedMetadata);
diff --git a/drv.c b/drv.c
index cbd7b4b..f55a4bb 100644
--- a/drv.c
+++ b/drv.c
@@ -24,6 +24,10 @@
 #include "drv_priv.h"
 #include "util.h"
 
+#ifdef USE_GRALLOC1
+#include "i915_private.h"
+#endif
+
 #ifdef DRV_AMDGPU
 extern const struct backend backend_amdgpu;
 #endif
@@ -106,7 +110,6 @@ static const struct backend *drv_get_backend(int fd)
 struct driver *drv_create(int fd)
 {
 	struct driver *drv;
-	int ret;
 
 	drv = (struct driver *)calloc(1, sizeof(*drv));
 
@@ -141,14 +144,6 @@ struct driver *drv_create(int fd)
 	if (!drv->combos)
 		goto free_mappings;
 
-	if (drv->backend->init) {
-		ret = drv->backend->init(drv);
-		if (ret) {
-			drv_array_destroy(drv->combos);
-			goto free_mappings;
-		}
-	}
-
 	return drv;
 
 free_mappings:
@@ -164,6 +159,20 @@ free_driver:
 	return NULL;
 }
 
+int drv_init(struct driver * drv, uint32_t grp_type)
+{
+	int ret = 0;
+	assert(drv);
+	assert(drv->backend);
+
+	drv->gpu_grp_type = grp_type;
+
+	if (drv->backend->init) {
+		ret = drv->backend->init(drv);
+	}
+	return ret;
+}
+
 void drv_destroy(struct driver *drv)
 {
 	if (drv->backend->close)
@@ -727,6 +736,26 @@ void drv_resolve_format_and_use_flags(struct driver *drv, uint32_t format, uint6
 						   out_use_flags);
 }
 
+uint32_t drv_resolved_common_drm_format(uint32_t format)
+{
+	uint32_t ret = format;
+	switch (format) {
+		case DRM_FORMAT_NV12_Y_TILED_INTEL:
+		case DRM_FORMAT_FLEX_YCbCr_420_888:
+		case DRM_FORMAT_FLEX_IMPLEMENTATION_DEFINED:
+			ret = DRM_FORMAT_NV12;
+			ALOGI("drv_resolved_common_drm_format: DRM_FORMAT_NV12");
+			break;
+		case DRM_FORMAT_YVU420_ANDROID:
+			ret = DRM_FORMAT_YVU420;
+			ALOGI("drv_resolved_common_drm_format: DRM_FORMAT_YVU420");
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+
 uint32_t drv_num_buffers_per_bo(struct bo *bo)
 {
 	uint32_t count = 0;
diff --git a/drv.h b/drv.h
index b824fc5..cb2da96 100644
--- a/drv.h
+++ b/drv.h
@@ -135,6 +135,8 @@ void drv_preload(bool load);
 
 struct driver *drv_create(int fd);
 
+int drv_init(struct driver * drv, uint32_t grp_type);
+
 void drv_destroy(struct driver *drv);
 
 int drv_get_fd(struct driver *drv);
@@ -204,6 +206,8 @@ void drv_resolve_format_and_use_flags(struct driver *drv, uint32_t format, uint6
 
 uint64_t drv_resolve_use_flags(struct driver *drv, uint32_t format, uint64_t use_flags);
 
+uint32_t drv_resolved_common_drm_format(uint32_t format);
+
 size_t drv_num_planes_from_format(uint32_t format);
 
 size_t drv_num_planes_from_modifier(struct driver *drv, uint32_t format, uint64_t modifier);
diff --git a/drv_helpers.c b/drv_helpers.c
index 4cc1966..f3e74b2 100644
--- a/drv_helpers.c
+++ b/drv_helpers.c
@@ -605,6 +605,14 @@ void drv_resolve_format_and_use_flags_helper(struct driver *drv, uint32_t format
 {
 	*out_format = format;
 	*out_use_flags = use_flags;
+#ifdef USE_GRALLOC1
+	uint32_t resolved_format;
+	if (i915_private_resolve_format(format, use_flags, &resolved_format)) {
+		*out_format = resolved_format;
+		return;
+	}
+#endif
+
 	switch (format) {
 	case DRM_FORMAT_FLEX_IMPLEMENTATION_DEFINED:
 		/* Common camera implementation defined format. */
diff --git a/drv_priv.h b/drv_priv.h
index a2ccdda..c6eadf4 100644
--- a/drv_priv.h
+++ b/drv_priv.h
@@ -60,12 +60,21 @@ struct combination {
 	uint64_t use_flags;
 };
 
+enum CIV_GPU_TYPE {
+	ONE_GPU_INTEL = 1,
+	ONE_GPU_VIRTIO,
+	TWO_GPU_IGPU_VIRTIO,
+	TWO_GPU_IGPU_DGPU,
+	THREE_GPU_IGPU_VIRTIO_DGPU
+};
+
 struct driver {
 	int fd;
 	const struct backend *backend;
 	void *priv;
 	pthread_mutex_t buffer_table_lock;
 	void *buffer_table;
+	uint32_t gpu_grp_type;  	// enum CIV_GPU_TYPE
 	pthread_mutex_t mappings_lock;
 	struct drv_array *mappings;
 	struct drv_array *combos;
diff --git a/i915.c b/i915.c
index e03369a..c41cbb8 100644
--- a/i915.c
+++ b/i915.c
@@ -290,6 +290,10 @@ static int i915_add_combinations(struct driver *drv)
 	if (i915->graphics_version == 12)
 		scanout_and_render = unset_flags(scanout_and_render, BO_USE_SCANOUT);
 #endif
+	// In sriov mode, MMAP_GTT will fail for tiled buffer.
+	if ((drv->gpu_grp_type == TWO_GPU_IGPU_VIRTIO) || (drv->gpu_grp_type == THREE_GPU_IGPU_VIRTIO_DGPU))
+		scanout_and_render =
+			unset_flags(scanout_and_render, BO_USE_SW_READ_RARELY | BO_USE_SW_WRITE_RARELY);
 
 	drv_add_combinations(drv, render_formats, ARRAY_SIZE(render_formats), &metadata_x_tiled,
 			     render_not_linear);
-- 
2.40.1

