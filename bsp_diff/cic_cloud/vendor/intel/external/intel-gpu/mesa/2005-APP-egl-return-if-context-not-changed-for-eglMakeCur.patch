From 08a67823278dda01b77b812170f35b6a7422b326 Mon Sep 17 00:00:00 2001
From: Shuo Gao <shuo.gao@intel.com>
Date: Tue, 31 Aug 2021 11:14:48 +0800
Subject: [APP] egl: return if context not changed for eglMakeCurrent

Issue:
This issue was exposed during test when VDS was killed suddenly,
eglMakeCurrent failed and frameworks would try to fallback to the
previous context, which is still the current context, and re-set the
same context cause a dead lock in dequeueBuffer.

Cause:
Sometimes set the same context again would cause a dead lock in
dequeueBuffer, since the buffer already acquired by it's consumer
and not released yet.

Solution:
Do nothing in eglMakeCurrent if context and surface not changed
to avoid this kind of issue.

Change-Id: I92a25a6cdbdda2a662c3abc326807d30adbe9149
Tracked-On: VVP0-3694
Signed-off-by: Shuo Gao <shuo.gao@intel.com>
Signed-off-by: Marc Mao <marc.mao@intel.com>
---
 src/egl/drivers/dri2/egl_dri2.c |  4 ++++
 src/egl/main/eglcontext.c       | 24 ++++++++++++++++++++++++
 src/egl/main/eglcontext.h       |  2 ++
 3 files changed, 30 insertions(+)

diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index b20f2468fb4..7af33c969da 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -1631,6 +1631,10 @@ dri2_make_current(_EGLDisplay *disp, _EGLSurface *dsurf,
    if (!dri2_dpy)
       return _eglError(EGL_NOT_INITIALIZED, "eglMakeCurrent");
 
+   /* Just return if context/draw/read not changed */
+   if (!_eglIsContextChanged(ctx, dsurf, rsurf))
+      return EGL_TRUE;
+
    /* make new bindings, set the EGL error otherwise */
    if (!_eglBindContext(ctx, dsurf, rsurf, &old_ctx, &old_dsurf, &old_rsurf))
       return EGL_FALSE;
diff --git a/src/egl/main/eglcontext.c b/src/egl/main/eglcontext.c
index bd6518f19e1..f74c8eccac2 100644
--- a/src/egl/main/eglcontext.c
+++ b/src/egl/main/eglcontext.c
@@ -830,6 +830,30 @@ _eglCheckMakeCurrent(_EGLContext *ctx, _EGLSurface *draw, _EGLSurface *read)
    return EGL_TRUE;
 }
 
+EGLBoolean
+_eglIsContextChanged(_EGLContext *ctx, _EGLSurface *draw, _EGLSurface *read)
+{
+   _EGLThreadInfo *t = _eglGetCurrentThread();
+   _EGLContext *old_ctx = NULL;
+   _EGLSurface *old_draw = NULL, *old_read = NULL;
+
+   if (t == NULL) return _eglError(EGL_BAD_ACCESS, "eglIsContextChanged");
+
+   old_ctx = t->CurrentContext;
+   if (old_ctx) {
+      old_draw = old_ctx->DrawSurface;
+      old_read = old_ctx->ReadSurface;
+   }
+
+   if (ctx == old_ctx && draw == old_draw && read == old_read) {
+      _eglLog(_EGL_DEBUG, "context not changed: ctx = 0x%p, draw = 0x%p, read = 0x%p", ctx, draw, read);
+      return EGL_FALSE;
+   }
+
+   //_eglLog(_EGL_DEBUG, "context changed: ctx = 0x%p => 0x%p, draw = 0x%p => 0x%p, read = 0x%p => 0x%p", old_ctx, ctx, old_draw, draw, old_read, read);
+
+   return EGL_TRUE;
+}
 
 /**
  * Bind the context to the current thread and given surfaces.  Return the
diff --git a/src/egl/main/eglcontext.h b/src/egl/main/eglcontext.h
index acfef4fe7c0..130b98ec9cd 100644
--- a/src/egl/main/eglcontext.h
+++ b/src/egl/main/eglcontext.h
@@ -75,6 +75,8 @@ _eglInitContext(_EGLContext *ctx, _EGLDisplay *disp,
 extern EGLBoolean
 _eglQueryContext(_EGLContext *ctx, EGLint attribute, EGLint *value);
 
+extern EGLBoolean
+_eglIsContextChanged(_EGLContext *ctx, _EGLSurface *draw, _EGLSurface *read);
 
 extern EGLBoolean
 _eglBindContext(_EGLContext *ctx, _EGLSurface *draw, _EGLSurface *read,
-- 
2.25.1

