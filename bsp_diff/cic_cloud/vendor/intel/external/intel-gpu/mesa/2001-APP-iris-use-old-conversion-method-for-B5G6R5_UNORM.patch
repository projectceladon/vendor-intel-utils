From d090a3ee9914c5d2e201d41968bb90e8fe70270e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Tapani=20P=C3=A4lli?= <tapani.palli@intel.com>
Date: Fri, 3 Jun 2022 10:49:50 +0300
Subject: [APP] iris: use old conversion method for B5G6R5_UNORM
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This adds back older version of clear color conversion as
"convert_565_clear_color". This can be used as a workaround
and to investigate how old and new algorithm deviate with
16bpp colors.

Tracked-On: OAM-100915
Signed-off-by: Tapani PÃ¤lli <tapani.palli@intel.com>
Change-Id: If471872876602267e1df262228911650e4ad5319
Signed-off-by: Marc Mao <marc.mao@intel.com>
---
 src/gallium/drivers/iris/iris_clear.c | 70 +++++++++++++++++++++++++++
 1 file changed, 70 insertions(+)

diff --git a/src/gallium/drivers/iris/iris_clear.c b/src/gallium/drivers/iris/iris_clear.c
index 253a04a2be0..a6671d94870 100644
--- a/src/gallium/drivers/iris/iris_clear.c
+++ b/src/gallium/drivers/iris/iris_clear.c
@@ -141,10 +141,80 @@ can_fast_clear_color(struct iris_context *ice,
    return true;
 }
 
+static union isl_color_value
+convert_565_clear_color(enum pipe_format format,
+                        const union pipe_color_union *color)
+{
+   /* pipe_color_union and isl_color_value are interchangeable */
+   union isl_color_value override_color = *(union isl_color_value *)color;
+
+   const struct util_format_description *desc =
+      util_format_description(format);
+   unsigned colormask = util_format_colormask(desc);
+
+   if (util_format_is_intensity(format) ||
+       util_format_is_luminance(format)) {
+      override_color.u32[1] = override_color.u32[0];
+      override_color.u32[2] = override_color.u32[0];
+      if (util_format_is_intensity(format))
+         override_color.u32[3] = override_color.u32[0];
+   } else {
+      for (int chan = 0; chan < 3; chan++) {
+         if (!(colormask & (1 << chan)))
+            override_color.u32[chan] = 0;
+      }
+   }
+
+   if (util_format_is_unorm(format)) {
+      for (int i = 0; i < 4; i++)
+         override_color.f32[i] = SATURATE(override_color.f32[i]);
+   } else if (util_format_is_snorm(format)) {
+      for (int i = 0; i < 4; i++)
+         override_color.f32[i] = CLAMP(override_color.f32[i], -1.0f, 1.0f);
+   } else if (util_format_is_pure_uint(format)) {
+      for (int i = 0; i < 4; i++) {
+         unsigned bits = util_format_get_component_bits(
+            format, UTIL_FORMAT_COLORSPACE_RGB, i);
+         if (bits < 32) {
+            uint32_t max = (1u << bits) - 1;
+            override_color.u32[i] = MIN2(override_color.u32[i], max);
+         }
+      }
+   } else if (util_format_is_pure_sint(format)) {
+      for (int i = 0; i < 4; i++) {
+         unsigned bits = util_format_get_component_bits(
+            format, UTIL_FORMAT_COLORSPACE_RGB, i);
+         if (bits > 0 && bits < 32) {
+            int32_t max = u_intN_max(bits);
+            int32_t min = u_intN_min(bits);
+            override_color.i32[i] = CLAMP(override_color.i32[i], min, max);
+         }
+      }
+   } else if (format == PIPE_FORMAT_R11G11B10_FLOAT ||
+              format == PIPE_FORMAT_R9G9B9E5_FLOAT) {
+      /* these packed float formats only store unsigned values */
+      for (int i = 0; i < 4; i++)
+         override_color.f32[i] = MAX2(override_color.f32[i], 0.0f);
+   }
+
+   if (!(colormask & 1 << 3)) {
+      if (util_format_is_pure_integer(format))
+         override_color.u32[3] = 1;
+      else
+         override_color.f32[3] = 1.0f;
+   }
+
+   return override_color;
+}
+
 static union isl_color_value
 convert_clear_color(enum pipe_format format,
                     const union pipe_color_union *color)
 {
+   /* In case of B5G6R5, use old old conversion method. */
+   if (format == PIPE_FORMAT_B5G6R5_UNORM)
+      return convert_565_clear_color(format, color);
+
    uint32_t pixel[4];
    util_format_pack_rgba(format, pixel, color, 1);
 
-- 
2.25.1

