From 9ded9151cde6577578db420bf2db80f5d4bca3ee Mon Sep 17 00:00:00 2001
From: Ratnesh Kumar Rai <ratnesh.kumar.rai@intel.com>
Date: Thu, 9 Feb 2023 10:48:29 +0530
Subject: [PATCH] Changes to integrate openvino 2022.3.0

- added Android.bp
- resolved compilation errors
- resolved rtti issues while compiling nnhal

Tracked-On: OAM-106595
Signed-off-by: Ratnesh Kumar Rai <ratnesh.kumar.rai@intel.com>
Signed-off-by: Jeevaka Prabu Badrappan <jeevaka.badrappan@intel.com>
---
 Android.bp                                    | 1362 +++++++++++++++++
 .../legacy/include/legacy/graph_transformer.h |    1 +
 .../common_optimizations/ric_fusion.hpp       |  142 ++
 src/common/transformations/src/itt.hpp        |    2 -
 .../transformations/src/ov_ops/augru_cell.cpp |    2 +-
 .../src/ov_ops/augru_sequence.cpp             |    2 +-
 .../ov_ops/generate_proposals_ie_internal.cpp |    2 +-
 .../src/ov_ops/multiclass_nms_ie_internal.cpp |    2 +-
 .../src/ov_ops/nms_ie_internal.cpp            |    2 +-
 .../common_optimizations/ric_fusion.cpp       |   52 +
 src/core/dev_api/meta_data.hpp                |    1 +
 src/core/include/ngraph/variant.hpp           |   10 +-
 src/core/include/openvino/core/any.hpp        |   84 +-
 .../openvino/core/attribute_adapter.hpp       |   18 +-
 src/core/include/openvino/op/constant.hpp     |    4 +-
 .../src/runtime/reference/jit_generator.cpp   |    6 +-
 .../src/runtime/reference/jit_generator.hpp   |    5 +-
 src/core/src/check.cpp                        |    2 +-
 src/core/src/op/asinh.cpp                     |    1 +
 src/core/src/runtime/blob_allocator.hpp       |    1 +
 src/frontends/common/src/utils.cpp            |    2 +-
 src/inference/include/ie/ie_precision.hpp     |   19 +
 .../src/cpp/ie_executable_network_base.hpp    |    2 +
 .../src/cpp/ie_infer_async_request_base.hpp   |    2 +
 src/inference/src/ie_rtti.cpp                 |  782 ++++++++++
 src/inference/src/ie_system_conf.cpp          |    5 +-
 src/plugins/auto/plugin.hpp                   |    2 +-
 .../cross-compiled/ANY/proposal_imp.cpp       |    1 +
 .../cross-compiled/AVX2/proposal_imp.cpp      |    1 +
 .../cross-compiled/proposal_imp_disp.cpp      |   41 +
 .../cross-compiled/proposal_imp_holder.txt    |   16 +
 .../intel_cpu/src/emitters/jit_emitter.hpp    |    1 +
 .../src/emitters/jit_load_store_emitters.hpp  |    2 +
 .../intel_cpu/src/nodes/embedding_bag_sum.h   |    2 +-
 src/plugins/intel_cpu/src/nodes/rdft.h        |    1 +
 src/plugins/intel_cpu/src/plugin.h            |    2 +-
 .../utils/shape_inference/shape_inference.hpp |    1 +
 .../shape_inference/shape_inference_cpu.hpp   |    5 +-
 38 files changed, 2555 insertions(+), 33 deletions(-)
 create mode 100644 Android.bp
 create mode 100644 src/inference/src/ie_rtti.cpp
 create mode 120000 src/plugins/intel_cpu/cross-compiled/ANY/proposal_imp.cpp
 create mode 120000 src/plugins/intel_cpu/cross-compiled/AVX2/proposal_imp.cpp
 create mode 100644 src/plugins/intel_cpu/cross-compiled/proposal_imp_disp.cpp
 create mode 100644 src/plugins/intel_cpu/cross-compiled/proposal_imp_holder.txt

diff --git a/Android.bp b/Android.bp
new file mode 100644
index 0000000000..cc94ac9844
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1,1362 @@
+//####################COMMON CFLAGS######################
+common_cflags = [
+    "-DANDROID",
+    "-D__ANDROID__",
+    "-Wsuggest-override",
+    "-fsigned-char",
+    "-fexceptions",
+    "-ffunction-sections",
+    "-fdata-sections",
+    "-fdiagnostics-show-option",
+    "-Wundef",
+    "-Wreturn-type",
+    "-Wunused-variable",
+    "-Wuninitialized",
+    "-Winit-self",
+    "-Wmaybe-uninitialized",
+    "-Wall",
+    "-Wmissing-declarations",
+    "-O3",
+    "-DNDEBUG",
+    "-Wformat",
+    "-Wformat-security",
+    "-D_FORTIFY_SOURCE=2",
+    "-fno-delete-null-pointer-checks",
+    "-fwrapv",
+    "-fstack-protector-strong",
+    "-fPIC",
+    "-fvisibility=hidden",
+    "-fvisibility-inlines-hidden",
+    "-pthread",
+    "-std=c++11",
+    "-frtti",
+]
+
+//#################################################
+
+cc_library_headers {
+    name: "libopenvino_headers",
+    vendor: true,
+    export_include_dirs: [
+        "src/core/include",
+        "src/core/src",
+        "src/core/builder/include",
+        "src/core/reference/include",
+        "src/common/util/include",
+        "src/core/shape_inference/include",
+        "src/core/dev_api",
+        "src/common/conditional_compilation/include",
+        "src/common/itt/include",
+        "src/inference/include",
+    ],
+}
+
+//#################################################
+
+cc_library_shared {
+
+    name: "libopenvino",
+    proprietary: true,
+    owner: "intel",
+    compile_multilib: "64",
+
+    srcs: [
+        "src/core/src/any.cpp",
+        "src/core/src/attribute_adapter.cpp",
+        "src/core/src/attribute_visitor.cpp",
+        "src/core/src/axis_set.cpp",
+        "src/core/src/axis_vector.cpp",
+        "src/core/src/check.cpp",
+        "src/core/src/coordinate.cpp",
+        "src/core/src/coordinate_diff.cpp",
+        "src/core/src/descriptor/input.cpp",
+        "src/core/src/descriptor/output.cpp",
+        "src/core/src/descriptor/tensor.cpp",
+        "src/core/src/dimension.cpp",
+        "src/core/src/distributed.cpp",
+        "src/core/src/env_util.cpp",
+        "src/core/src/extension.cpp",
+        "src/core/src/factory.cpp",
+        "src/core/src/file_util.cpp",
+        "src/core/src/graph_util.cpp",
+        "src/core/src/interval.cpp",
+        "src/core/src/layout.cpp",
+        "src/core/src/legacy_op_extension.cpp",
+        "src/core/src/log.cpp",
+        "src/core/src/model.cpp",
+        "src/core/src/ngraph.cpp",
+        "src/core/src/node.cpp",
+        "src/core/src/node_input.cpp",
+        "src/core/src/node_output.cpp",
+        "src/core/src/node_vector.cpp",
+        "src/core/src/op/abs.cpp",
+        "src/core/src/op/acos.cpp",
+        "src/core/src/op/acosh.cpp",
+        "src/core/src/op/adaptive_avg_pool.cpp",
+        "src/core/src/op/adaptive_max_pool.cpp",
+        "src/core/src/op/add.cpp",
+        "src/core/src/op/asin.cpp",
+        "src/core/src/op/asinh.cpp",
+        "src/core/src/op/assign.cpp",
+        "src/core/src/op/atan.cpp",
+        "src/core/src/op/atanh.cpp",
+        "src/core/src/op/avg_pool.cpp",
+        "src/core/src/op/batch_norm.cpp",
+        "src/core/src/op/batch_to_space.cpp",
+        "src/core/src/op/binary_convolution.cpp",
+        "src/core/src/op/broadcast.cpp",
+        "src/core/src/op/bucketize.cpp",
+        "src/core/src/op/ceiling.cpp",
+        "src/core/src/op/clamp.cpp",
+        "src/core/src/op/concat.cpp",
+        "src/core/src/op/constant.cpp",
+        "src/core/src/op/convert.cpp",
+        "src/core/src/op/convert_like.cpp",
+        "src/core/src/op/convolution.cpp",
+        "src/core/src/op/cos.cpp",
+        "src/core/src/op/cosh.cpp",
+        "src/core/src/op/ctc_greedy_decoder.cpp",
+        "src/core/src/op/ctc_greedy_decoder_seq_len.cpp",
+        "src/core/src/op/ctc_loss.cpp",
+        "src/core/src/op/cum_sum.cpp",
+        "src/core/src/op/deformable_convolution.cpp",
+        "src/core/src/op/deformable_psroi_pooling.cpp",
+        "src/core/src/op/depth_to_space.cpp",
+        "src/core/src/op/detection_output.cpp",
+        "src/core/src/op/dft.cpp",
+        "src/core/src/op/divide.cpp",
+        "src/core/src/op/einsum.cpp",
+        "src/core/src/op/elu.cpp",
+        "src/core/src/op/embedding_segments_sum.cpp",
+        "src/core/src/op/embeddingbag_offsets_sum.cpp",
+        "src/core/src/op/embeddingbag_packedsum.cpp",
+        "src/core/src/op/equal.cpp",
+        "src/core/src/op/erf.cpp",
+        "src/core/src/op/exp.cpp",
+        "src/core/src/op/experimental_detectron_detection_output.cpp",
+        "src/core/src/op/experimental_detectron_generate_proposals.cpp",
+        "src/core/src/op/experimental_detectron_prior_grid_generator.cpp",
+        "src/core/src/op/experimental_detectron_roi_feature.cpp",
+        "src/core/src/op/experimental_detectron_topkrois.cpp",
+        "src/core/src/op/extractimagepatches.cpp",
+        "src/core/src/op/eye.cpp",
+        "src/core/src/op/fake_quantize.cpp",
+        "src/core/src/op/floor.cpp",
+        "src/core/src/op/floor_mod.cpp",
+        "src/core/src/op/gather.cpp",
+        "src/core/src/op/gather_elements.cpp",
+        "src/core/src/op/gather_nd.cpp",
+        "src/core/src/op/gather_tree.cpp",
+        "src/core/src/op/gelu.cpp",
+        "src/core/src/op/generate_proposals.cpp",
+        "src/core/src/op/greater.cpp",
+        "src/core/src/op/greater_eq.cpp",
+        "src/core/src/op/grid_sample.cpp",
+        "src/core/src/op/grn.cpp",
+        "src/core/src/op/group_conv.cpp",
+        "src/core/src/op/gru_cell.cpp",
+        "src/core/src/op/gru_sequence.cpp",
+        "src/core/src/op/hard_sigmoid.cpp",
+        "src/core/src/op/hsigmoid.cpp",
+        "src/core/src/op/hswish.cpp",
+        "src/core/src/op/i420_to_bgr.cpp",
+        "src/core/src/op/i420_to_rgb.cpp",
+        "src/core/src/op/idft.cpp",
+        "src/core/src/op/if.cpp",
+        "src/core/src/op/interpolate.cpp",
+        "src/core/src/op/irdft.cpp",
+        "src/core/src/op/is_finite.cpp",
+        "src/core/src/op/is_inf.cpp",
+        "src/core/src/op/is_nan.cpp",
+        "src/core/src/op/less.cpp",
+        "src/core/src/op/less_eq.cpp",
+        "src/core/src/op/log.cpp",
+        "src/core/src/op/log_softmax.cpp",
+        "src/core/src/op/logical_and.cpp",
+        "src/core/src/op/logical_not.cpp",
+        "src/core/src/op/logical_or.cpp",
+        "src/core/src/op/loop.cpp",
+        "src/core/src/op/lrn.cpp",
+        "src/core/src/op/lstm_cell.cpp",
+        "src/core/src/op/lstm_sequence.cpp",
+        "src/core/src/op/matmul.cpp",
+        "src/core/src/op/matrix_nms.cpp",
+        "src/core/src/op/max_pool.cpp",
+        "src/core/src/op/maximum.cpp",
+        "src/core/src/op/minimum.cpp",
+        "src/core/src/op/mish.cpp",
+        "src/core/src/op/mod.cpp",
+        "src/core/src/op/multiclass_nms.cpp",
+        "src/core/src/op/multiply.cpp",
+        "src/core/src/op/mvn.cpp",
+        "src/core/src/op/negative.cpp",
+        "src/core/src/op/non_max_suppression.cpp",
+        "src/core/src/op/non_zero.cpp",
+        "src/core/src/op/normalize_l2.cpp",
+        "src/core/src/op/not_equal.cpp",
+        "src/core/src/op/nv12_to_bgr.cpp",
+        "src/core/src/op/nv12_to_rgb.cpp",
+        "src/core/src/op/one_hot.cpp",
+        "src/core/src/op/op.cpp",
+        "src/core/src/op/pad.cpp",
+        "src/core/src/op/parameter.cpp",
+        "src/core/src/op/power.cpp",
+        "src/core/src/op/prelu.cpp",
+        "src/core/src/op/prior_box.cpp",
+        "src/core/src/op/prior_box_clustered.cpp",
+        "src/core/src/op/proposal.cpp",
+        "src/core/src/op/psroi_pooling.cpp",
+        "src/core/src/op/random_uniform.cpp",
+        "src/core/src/op/range.cpp",
+        "src/core/src/op/rdft.cpp",
+        "src/core/src/op/read_value.cpp",
+        "src/core/src/op/reduce_l1.cpp",
+        "src/core/src/op/reduce_l2.cpp",
+        "src/core/src/op/reduce_logical_and.cpp",
+        "src/core/src/op/reduce_logical_or.cpp",
+        "src/core/src/op/reduce_max.cpp",
+        "src/core/src/op/reduce_mean.cpp",
+        "src/core/src/op/reduce_min.cpp",
+        "src/core/src/op/reduce_prod.cpp",
+        "src/core/src/op/reduce_sum.cpp",
+        "src/core/src/op/region_yolo.cpp",
+        "src/core/src/op/relu.cpp",
+        "src/core/src/op/reorg_yolo.cpp",
+        "src/core/src/op/reshape.cpp",
+        "src/core/src/op/result.cpp",
+        "src/core/src/op/reverse.cpp",
+        "src/core/src/op/reverse_sequence.cpp",
+        "src/core/src/op/rnn_cell.cpp",
+        "src/core/src/op/rnn_sequence.cpp",
+        "src/core/src/op/roi_align.cpp",
+        "src/core/src/op/roi_pooling.cpp",
+        "src/core/src/op/roll.cpp",
+        "src/core/src/op/round.cpp",
+        "src/core/src/op/scatter_elements_update.cpp",
+        "src/core/src/op/scatter_nd_update.cpp",
+        "src/core/src/op/scatter_update.cpp",
+        "src/core/src/op/select.cpp",
+        "src/core/src/op/selu.cpp",
+        "src/core/src/op/shape_of.cpp",
+        "src/core/src/op/shuffle_channels.cpp",
+        "src/core/src/op/sigmoid.cpp",
+        "src/core/src/op/sign.cpp",
+        "src/core/src/op/sin.cpp",
+        "src/core/src/op/sinh.cpp",
+        "src/core/src/op/sink.cpp",
+        "src/core/src/op/slice.cpp",
+        "src/core/src/op/softmax.cpp",
+        "src/core/src/op/softplus.cpp",
+        "src/core/src/op/softsign.cpp",
+        "src/core/src/op/space_to_batch.cpp",
+        "src/core/src/op/space_to_depth.cpp",
+        "src/core/src/op/split.cpp",
+        "src/core/src/op/sqrt.cpp",
+        "src/core/src/op/squared_difference.cpp",
+        "src/core/src/op/squeeze.cpp",
+        "src/core/src/op/strided_slice.cpp",
+        "src/core/src/op/subtract.cpp",
+        "src/core/src/op/swish.cpp",
+        "src/core/src/op/tan.cpp",
+        "src/core/src/op/tanh.cpp",
+        "src/core/src/op/tensor_iterator.cpp",
+        "src/core/src/op/tile.cpp",
+        "src/core/src/op/topk.cpp",
+        "src/core/src/op/transpose.cpp",
+        "src/core/src/op/type_relaxed.cpp",
+        "src/core/src/op/unique.cpp",
+        "src/core/src/op/unsqueeze.cpp",
+        "src/core/src/op/util/activation_functions.cpp",
+        "src/core/src/op/util/arithmetic_reduction.cpp",
+        "src/core/src/op/util/arithmetic_reductions_keep_dims.cpp",
+        "src/core/src/op/util/assign_base.cpp",
+        "src/core/src/op/util/attr_types.cpp",
+        "src/core/src/op/util/binary_elementwise_arithmetic.cpp",
+        "src/core/src/op/util/binary_elementwise_comparison.cpp",
+        "src/core/src/op/util/binary_elementwise_logical.cpp",
+        "src/core/src/op/util/broadcast_base.cpp",
+        "src/core/src/op/util/convert_color_i420_base.cpp",
+        "src/core/src/op/util/convert_color_nv12_base.cpp",
+        "src/core/src/op/util/deformable_convolution_base.cpp",
+        "src/core/src/op/util/detection_output_base.cpp",
+        "src/core/src/op/util/elementwise_args.cpp",
+        "src/core/src/op/util/embeddingbag_offsets_base.cpp",
+        "src/core/src/op/util/embeddingbag_packed_base.cpp",
+        "src/core/src/op/util/evaluate_helpers.cpp",
+        "src/core/src/op/util/fft_base.cpp",
+        "src/core/src/op/util/framework_node.cpp",
+        "src/core/src/op/util/gather_base.cpp",
+        "src/core/src/op/util/gather_nd_base.cpp",
+        "src/core/src/op/util/index_reduction.cpp",
+        "src/core/src/op/util/logical_reduction.cpp",
+        "src/core/src/op/util/logical_reduction_keep_dims.cpp",
+        "src/core/src/op/util/max_pool_base.cpp",
+        "src/core/src/op/util/multi_subgraph_base.cpp",
+        "src/core/src/op/util/multiclass_nms_base.cpp",
+        "src/core/src/op/util/op_types.cpp",
+        "src/core/src/op/util/precision_sensitive_attribute.cpp",
+        "src/core/src/op/util/read_value_base.cpp",
+        "src/core/src/op/util/recurrent_sequence.cpp",
+        "src/core/src/op/util/reduction_base.cpp",
+        "src/core/src/op/util/rnn_cell_base.cpp",
+        "src/core/src/op/util/scatter_base.cpp",
+        "src/core/src/op/util/scatter_nd_base.cpp",
+        "src/core/src/op/util/slice_plan.cpp",
+        "src/core/src/op/util/sub_graph_base.cpp",
+        "src/core/src/op/util/unary_elementwise_arithmetic.cpp",
+        "src/core/src/op/util/variable.cpp",
+        "src/core/src/op/variadic_split.cpp",
+        "src/core/src/op/xor.cpp",
+        "src/core/src/opsets/opset.cpp",
+        "src/core/src/partial_shape.cpp",
+        "src/core/src/pass/constant_folding.cpp",
+        "src/core/src/pass/convert_fp32_to_fp16.cpp",
+        "src/core/src/pass/graph_rewrite.cpp",
+        "src/core/src/pass/low_latency.cpp",
+        "src/core/src/pass/make_stateful.cpp",
+        "src/core/src/pass/manager.cpp",
+        "src/core/src/pass/pass.cpp",
+        "src/core/src/pass/pass_config.cpp",
+        "src/core/src/pass/perf_counters.cpp",
+        "src/core/src/pass/serialize.cpp",
+        "src/core/src/pass/validate.cpp",
+        "src/core/src/pass/visualize_tree.cpp",
+        "src/core/src/pattern/matcher.cpp",
+        "src/core/src/pattern/op/any.cpp",
+        "src/core/src/pattern/op/any_of.cpp",
+        "src/core/src/pattern/op/any_output.cpp",
+        "src/core/src/pattern/op/branch.cpp",
+        "src/core/src/pattern/op/capture.cpp",
+        "src/core/src/pattern/op/label.cpp",
+        "src/core/src/pattern/op/or.cpp",
+        "src/core/src/pattern/op/pattern.cpp",
+        "src/core/src/pattern/op/skip.cpp",
+        "src/core/src/pattern/op/true.cpp",
+        "src/core/src/pattern/op/wrap_type.cpp",
+        "src/core/src/preprocess/color_utils.cpp",
+        "src/core/src/preprocess/pre_post_process.cpp",
+        "src/core/src/preprocess/preprocess_impls.cpp",
+        "src/core/src/preprocess/preprocess_steps_impl.cpp",
+        "src/core/src/rt_info.cpp",
+        "src/core/src/runtime/aligned_buffer.cpp",
+        "src/core/src/runtime/allocator.cpp",
+        "src/core/src/runtime/host_tensor.cpp",
+        "src/core/src/runtime/ov_tensor.cpp",
+        "src/core/src/runtime/tensor.cpp",
+        "src/core/src/runtime_attribute.cpp",
+        "src/core/src/shape.cpp",
+        "src/core/src/shape_util.cpp",
+        "src/core/src/so_extension.cpp",
+        "src/core/src/specialize_function.cpp",
+        "src/core/src/strides.cpp",
+        "src/core/src/type.cpp",
+        "src/core/src/type/bfloat16.cpp",
+        "src/core/src/type/element_type.cpp",
+        "src/core/src/type/float16.cpp",
+        "src/core/src/util.cpp",
+        "src/core/src/validation_util.cpp",
+        "src/core/src/variant.cpp",
+        "src/core/src/version.cpp",
+        "src/frontends/common/src/extension/conversion.cpp",
+        "src/frontends/common/src/extension/decoder_transformation.cpp",
+        "src/frontends/common/src/extension/progress_reporter.cpp",
+        "src/frontends/common/src/extension/telemetry.cpp",
+        "src/frontends/common/src/frontend.cpp",
+        "src/frontends/common/src/input_model.cpp",
+        "src/frontends/common/src/manager.cpp",
+        "src/frontends/common/src/place.cpp",
+        "src/frontends/common/src/plugin_loader.cpp",
+        "src/frontends/common/src/utils.cpp",
+        "src/inference/src/file_utils.cpp",
+        "src/common/legacy/src/transformations/convert_opset1_to_legacy/convert_one_hot_to_one_hot_ie.cpp",
+        "src/common/legacy/src/transformations/convert_opset1_to_legacy/convert_nms_5_to_legacy.cpp",
+        "src/common/legacy/src/ngraph_ops/nms_ie.cpp",
+        "src/common/legacy/src/ngraph_ops/onehot_ie.cpp",
+        "src/inference/src/any_copy.cpp",
+        "src/inference/src/blob_factory.cpp",
+        "src/inference/src/blob_transform.cpp",
+        "src/inference/src/check_network_batchable.cpp",
+        "src/inference/src/cnn_network_ngraph_impl.cpp",
+        "src/inference/src/compilation_context.cpp",
+        "src/inference/src/cpp/ie_cnn_network.cpp",
+        "src/inference/src/cpp/ie_executable_network.cpp",
+        "src/inference/src/cpp/ie_extension.cpp",
+        "src/inference/src/cpp/ie_infer_request.cpp",
+        "src/inference/src/cpp/ie_remote_context.cpp",
+        "src/inference/src/cpp/ie_variable_state.cpp",
+        "src/inference/src/cpp_interfaces/interface/ie_iexecutable_network_internal.cpp",
+        "src/inference/src/cpp_interfaces/interface/ie_iinfer_request_internal.cpp",
+        "src/inference/src/cpp_interfaces/interface/ie_iplugin_internal.cpp",
+        "src/inference/src/cpp_interfaces/interface/ie_ivariable_state_internal.cpp",
+        "src/inference/src/ie_blob_common.cpp",
+        "src/inference/src/ie_cache_guard.cpp",
+        "src/inference/src/ie_common.cpp",
+        "src/inference/src/ie_compound_blob.cpp",
+        "src/inference/src/ie_core.cpp",
+        "src/inference/src/ie_data.cpp",
+        "src/inference/src/ie_layouts.cpp",
+        "src/inference/src/ie_memcpy.cpp",
+        "src/inference/src/ie_network_reader.cpp",
+        "src/inference/src/ie_ngraph_utils.cpp",
+        "src/inference/src/ie_remote_context.cpp",
+        "src/inference/src/ie_system_conf.cpp",
+        "src/inference/src/ie_transformations.cpp",
+        "src/inference/src/ie_version.cpp",
+        "src/inference/src/openvino_shutdown.cpp",
+        "src/inference/src/os/lin/lin_system_conf.cpp",
+        "src/inference/src/precision_utils.cpp",
+        "src/inference/src/remote_tensor.cpp",
+        "src/inference/src/shared_object_loader.cpp",
+        "src/inference/src/system_allocator.cpp",
+        "src/inference/src/threading/ie_cpu_streams_executor.cpp",
+        "src/inference/src/threading/ie_executor_manager.cpp",
+        "src/inference/src/threading/ie_istreams_executor.cpp",
+        "src/inference/src/threading/ie_itask_executor.cpp",
+        "src/inference/src/threading/ie_parallel_custom_arena.cpp",
+        "src/inference/src/threading/ie_tbb_streams_executor.cpp",
+        "src/inference/src/threading/ie_thread_affinity.cpp",
+        "src/inference/src/xml_parse_utils.cpp",
+        "src/inference/src/cpu_x86_sse42/blob_transform_sse42.cpp",
+        "src/common/transformations/src/ov_ops/augru_cell.cpp",
+        "src/common/transformations/src/ov_ops/augru_sequence.cpp",
+        "src/common/transformations/src/ov_ops/generate_proposals_ie_internal.cpp",
+        "src/common/transformations/src/ov_ops/multiclass_nms_ie_internal.cpp",
+        "src/common/transformations/src/ov_ops/nms_ie_internal.cpp",
+        "src/common/transformations/src/ov_ops/nms_static_shape_ie.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/add_fake_quantize_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/align_eltwise_input_ranks.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/augru_cell_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/batch_to_space_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/binarize_weights.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/broadcast_elementwise_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/change_placeholder_types.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/clamp_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/common_optimizations.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/compress_float_constants.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/concat_reduce_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/conv_mul_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/conv_to_binary_conv.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/convert_compression_only_to_legacy.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/convert_nms_gather_path_to_unsigned.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/convert_quantize_dequantize.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/depth_to_space_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/dilated_convolution_converter.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/dimension_tracking.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/disable_random_uniform_constant_folding.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/disable_shapeof_constant_folding.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/divide_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/division_by_zero_fp16_resolver.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/dropout_with_random_uniform_replacer.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/eliminate_duplicate_ti_inputs.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/eliminate_unsqueeze_gather.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/fold_subgraph_empty_inputs.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/fq_mul_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/fq_reshape_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/fused_names_cleanup.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/gelu_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/gru_cell_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/hsigmoid_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/hswish_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/interpolate_sequence_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/leaky_relu_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/lin_op_sequence_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/mark_precision_sensitive_divides.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/mark_precision_sensitive_subgraphs.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/matmul_const_transposes_extraction.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/matmul_multiply_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/mish_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/moc_legacy_transformations.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/moc_transformations.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/mul_conv_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/mul_fake_quantize_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/mvn_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/nearest_neighbor_upsampling_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/nop_elimination.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/normalize_l2_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/optimize_strided_slice.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/pad_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/prelu_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/pull_through_reduce.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/pull_transpose_through_fq.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/random_uniform_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/reduce_merge.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/reduce_reshape_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/relu_fake_quantize_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/remove_concat_zero_dim_input.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/remove_filtering_boxes_by_size.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/remove_multi_subgraph_op_dangling_params.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/reshape_prelu.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/reshape_sequence_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/ric_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/select_with_one_value_condition.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/sequence_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/shuffle_channels_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/simplify_shape_of_sub_graph.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/skip_gather_before_transpose_and_reshape.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/softmax_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/softplus_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/softplus_to_mish_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/space_to_batch_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/split_concat_pair_to_interpolate_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/split_squeeze_concat_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/strides_optimization.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/subtract_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/swish_fusion.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_reshape_elimination_for_matmul.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_sinking.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_sinking_binary.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_sinking_concat.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_sinking_split.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_sinking_unary.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_sinking_utils.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/transpose_to_reshape.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/weights_dequantize_to_fake_quantize.cpp",
+        "src/common/transformations/src/transformations/common_optimizations/wrap_interpolate_into_transposes.cpp",
+        "src/common/transformations/src/transformations/control_flow/unroll_if.cpp",
+        "src/common/transformations/src/transformations/control_flow/unroll_tensor_iterator.cpp",
+        "src/common/transformations/src/transformations/convert_precision.cpp",
+        "src/common/transformations/src/transformations/disable_decompression_convert_constant_folding.cpp",
+        "src/common/transformations/src/transformations/fix_rt_info.cpp",
+        "src/common/transformations/src/transformations/init_node_info.cpp",
+        "src/common/transformations/src/transformations/low_precision/mark_dequantization_subgraph.cpp",
+        "src/common/transformations/src/transformations/op_conversions/batch_norm_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/bidirectional_sequences_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_batch_to_space.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_broadcast3.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_broadcast_to_tiles.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_convertlike.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_deformable_conv_v8_to_v1.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_depth_to_space.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_divide.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_gather_0d.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_gather_downgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_gather_upgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_gelu.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_gp9_to_gp_ie_internal.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_interpolate1_to_interpolate4.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_matrix_nms_to_matrix_nms_ie.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_maxpool_downgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_maxpool_upgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_minimum_to_power_and_max.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_mod.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_multiclass_nms_to_multiclass_nms_ie.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_multiclass_nms_upgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_mvn1_to_mvn6.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_negative.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_nms9_to_nms_ie_internal.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_nms_to_nms_ie_internal.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_pad_to_group_conv.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_previous_nms_to_nms_5.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_previous_nms_to_nms_9.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_prior_box_v8_to_v0.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_reduce_to_pooling.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_reduce_to_reshape.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_roi_align_v3_to_v9.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_roi_align_v9_to_v3.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_scatter_elements_to_scatter.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_sequences_to_tensor_iterator.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_shapeof3.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_shuffle_channels3.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_slice_to_strided_slice.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_softmax_downgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_softmax_upgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_space_to_batch.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_space_to_depth.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_subtract.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_ti_to_sequences.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_topk3.cpp",
+        "src/common/transformations/src/transformations/op_conversions/convert_xor_to_logical_xor.cpp",
+        "src/common/transformations/src/transformations/op_conversions/detection_output_downgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/detection_output_upgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/einsum_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/eye_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/fq_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/gather_normalize_negative_indices.cpp",
+        "src/common/transformations/src/transformations/op_conversions/gelu7_downgrade.cpp",
+        "src/common/transformations/src/transformations/op_conversions/gru_cell_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/hsigmoid_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/hswish_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/log_softmax_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/lstm_cell_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/mvn6_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/normalize_l2_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/reduce_l1_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/reduce_l2_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/rnn_cell_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/simplify_ctc_greedy_decoder_seq_len.cpp",
+        "src/common/transformations/src/transformations/op_conversions/softmax_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/softplus_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/softsign_decomposition.cpp",
+        "src/common/transformations/src/transformations/op_conversions/unique_decomposition.cpp",
+        "src/common/transformations/src/transformations/opset_conversions/convert_opset2_to_opset1.cpp",
+        "src/common/transformations/src/transformations/opset_conversions/convert_opset3_to_opset2.cpp",
+        "src/common/transformations/src/transformations/resolve_names_collisions.cpp",
+        "src/common/transformations/src/transformations/rt_info/attributes.cpp",
+        "src/common/transformations/src/transformations/rt_info/decompression.cpp",
+        "src/common/transformations/src/transformations/rt_info/dequantization_node.cpp",
+        "src/common/transformations/src/transformations/rt_info/disable_fp16_compression.cpp",
+        "src/common/transformations/src/transformations/rt_info/fused_names_attribute.cpp",
+        "src/common/transformations/src/transformations/rt_info/nms_selected_indices.cpp",
+        "src/common/transformations/src/transformations/rt_info/nonconvertible_divide.cpp",
+        "src/common/transformations/src/transformations/rt_info/old_api_map_element_type_attribute.cpp",
+        "src/common/transformations/src/transformations/rt_info/old_api_map_order_attribute.cpp",
+        "src/common/transformations/src/transformations/rt_info/preprocessing_attribute.cpp",
+        "src/common/transformations/src/transformations/rt_info/primitives_priority_attribute.cpp",
+        "src/common/transformations/src/transformations/rt_info/strides_property.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/broadcast_const_range_replacement.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/lstm_states_broadcast.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/matmul_sr.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/mimic_set_batch_size.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/proposal_scales_stridedslice.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/reshape_sinking.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/reshape_to_1D.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/set_batch_size.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/shape_of_const_folding.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/smart_reshape.cpp",
+        "src/common/transformations/src/transformations/smart_reshape/strided_slice_squeeze.cpp",
+        "src/common/transformations/src/transformations/utils/utils.cpp",
+        "src/common/low_precision_transformations/src/add.cpp",
+        "src/common/low_precision_transformations/src/align_quantization_intervals.cpp",
+        "src/common/low_precision_transformations/src/align_quantization_parameters.cpp",
+        "src/common/low_precision_transformations/src/assign_and_read_value.cpp",
+        "src/common/low_precision_transformations/src/avg_pool.cpp",
+        "src/common/low_precision_transformations/src/base_matcher_pass.cpp",
+        "src/common/low_precision_transformations/src/clamp.cpp",
+        "src/common/low_precision_transformations/src/concat.cpp",
+        "src/common/low_precision_transformations/src/convert.cpp",
+        "src/common/low_precision_transformations/src/convert_subtract_constant.cpp",
+        "src/common/low_precision_transformations/src/convolution.cpp",
+        "src/common/low_precision_transformations/src/convolution_backprop_data.cpp",
+        "src/common/low_precision_transformations/src/depth_to_space.cpp",
+        "src/common/low_precision_transformations/src/eltwise_base_transformation.cpp",
+        "src/common/low_precision_transformations/src/fake_quantize.cpp",
+        "src/common/low_precision_transformations/src/fake_quantize_decomposition.cpp",
+        "src/common/low_precision_transformations/src/fake_quantize_dequantization.cpp",
+        "src/common/low_precision_transformations/src/fold_convert.cpp",
+        "src/common/low_precision_transformations/src/fold_fake_quantize.cpp",
+        "src/common/low_precision_transformations/src/fuse_convert.cpp",
+        "src/common/low_precision_transformations/src/fuse_multiply_to_fake_quantize.cpp",
+        "src/common/low_precision_transformations/src/fuse_subtract_to_fake_quantize.cpp",
+        "src/common/low_precision_transformations/src/group_convolution.cpp",
+        "src/common/low_precision_transformations/src/interpolate.cpp",
+        "src/common/low_precision_transformations/src/layer_transformation.cpp",
+        "src/common/low_precision_transformations/src/low_precision.cpp",
+        "src/common/low_precision_transformations/src/markup_avg_pool_precision_preserved.cpp",
+        "src/common/low_precision_transformations/src/markup_can_be_quantized.cpp",
+        "src/common/low_precision_transformations/src/markup_precisions.cpp",
+        "src/common/low_precision_transformations/src/markup_quantization_granularity.cpp",
+        "src/common/low_precision_transformations/src/mat_mul.cpp",
+        "src/common/low_precision_transformations/src/max_pool.cpp",
+        "src/common/low_precision_transformations/src/move_fake_quantize.cpp",
+        "src/common/low_precision_transformations/src/multiply.cpp",
+        "src/common/low_precision_transformations/src/multiply_to_group_convolution.cpp",
+        "src/common/low_precision_transformations/src/mvn.cpp",
+        "src/common/low_precision_transformations/src/network_helper.cpp",
+        "src/common/low_precision_transformations/src/normalize_l2.cpp",
+        "src/common/low_precision_transformations/src/pad.cpp",
+        "src/common/low_precision_transformations/src/prelu.cpp",
+        "src/common/low_precision_transformations/src/propagate_precisions.cpp",
+        "src/common/low_precision_transformations/src/pull_reshape_through_dequantization.cpp",
+        "src/common/low_precision_transformations/src/pull_transpose_through_dequantization.cpp",
+        "src/common/low_precision_transformations/src/quantization_details.cpp",
+        "src/common/low_precision_transformations/src/recurrent_cell.cpp",
+        "src/common/low_precision_transformations/src/reduce_base_transformation.cpp",
+        "src/common/low_precision_transformations/src/reduce_max.cpp",
+        "src/common/low_precision_transformations/src/reduce_mean.cpp",
+        "src/common/low_precision_transformations/src/reduce_min.cpp",
+        "src/common/low_precision_transformations/src/reduce_sum.cpp",
+        "src/common/low_precision_transformations/src/relu.cpp",
+        "src/common/low_precision_transformations/src/reshape.cpp",
+        "src/common/low_precision_transformations/src/rt_info/avg_pool_precision_preserved_attribute.cpp",
+        "src/common/low_precision_transformations/src/rt_info/intervals_alignment_attribute.cpp",
+        "src/common/low_precision_transformations/src/rt_info/precision_preserved_attribute.cpp",
+        "src/common/low_precision_transformations/src/rt_info/precisions_attribute.cpp",
+        "src/common/low_precision_transformations/src/rt_info/quantization_alignment_attribute.cpp",
+        "src/common/low_precision_transformations/src/rt_info/quantization_granularity_attribute.cpp",
+        "src/common/low_precision_transformations/src/rt_info/quantization_mode_attribute.cpp",
+        "src/common/low_precision_transformations/src/rt_info/skip_cleanup_attribute.cpp",
+        "src/common/low_precision_transformations/src/shuffle_channels.cpp",
+        "src/common/low_precision_transformations/src/split.cpp",
+        "src/common/low_precision_transformations/src/squeeze.cpp",
+        "src/common/low_precision_transformations/src/strided_slice.cpp",
+        "src/common/low_precision_transformations/src/subtract.cpp",
+        "src/common/low_precision_transformations/src/transformation_context.cpp",
+        "src/common/low_precision_transformations/src/transparent_base_transformation.cpp",
+        "src/common/low_precision_transformations/src/transpose.cpp",
+        "src/common/low_precision_transformations/src/unsqueeze.cpp",
+        "src/common/low_precision_transformations/src/variadic_split.cpp",
+        "src/common/low_precision_transformations/src/weightable_layer_transformation.cpp",
+        "src/inference/src/ie_rtti.cpp"
+    ],
+
+    local_include_dirs: [
+        "src/core/include",
+        "src/core/src",
+        "src/core/builder/include",
+        "src/core/reference/include",
+        "src/common/util/include",
+        "src/core/shape_inference/include",
+        "src/core/dev_api",
+        "src/frontends/common/src",
+        "src/frontends/common/include",
+        "src/frontends/common/src",
+        "src/inference",
+        "src/inference/dev_api",
+        "src/inference/include",
+        "src/inference/include/ie",
+        "src/inference/src",
+        "src/common/legacy/include",
+        "src/common/preprocessing",
+        "src/common/transformations/include",
+        "src/common/transformations/src",
+        "src/common/low_precision_transformations/include",
+        "src/common/conditional_compilation/include",
+        "src/common/itt/include",
+        "src/plugins/intel_cpu/src",
+        "src/common/snippets/include",
+    ],
+
+    header_libs: [
+        "libpugixml_headers",
+        "libtbb_headers",
+        "xbyak_headers"
+    ],
+
+    cflags: common_cflags + [
+        "-DENABLE_INTEL_CPU=1",
+        "-DIE_THREAD=IE_THREAD_TBB",
+        "-DTBB_PREVIEW_WAITING_FOR_WORKERS=1",
+        "-Dopenvino_EXPORTS",
+        "-DPROJECT_ROOT_DIR=\"vendor/intel/external/project-celadon/openvino\"",
+        "-DCI_BUILD_NUMBER=\"2022.3.0-9052-9752fafe8eb-HEAD\"",
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DFRONTEND_LIB_PREFIX=\"libopenvino_\"",
+        "-DFRONTEND_LIB_SUFFIX=\"_frontend.so\"",
+        "-DIMPLEMENT_OPENVINO_API",
+    ],
+
+    shared_libs: [
+        "liblog",
+        "libtbb",
+    ],
+
+    static_libs: [
+        "libngraph_reference",
+        "libngraph_builders",
+        "libitt",
+        "libov_shape_inference",
+        "libutil",
+        "libpugixml",
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_static {
+    name: "libngraph_builders",
+    proprietary: true,
+    compile_multilib: "64",
+
+    srcs: [
+        "src/core/builder/src/builder/autobroadcast.cpp",
+        "src/core/builder/src/builder/make_constant.cpp",
+        "src/core/builder/src/builder/norm.cpp",
+        "src/core/builder/src/builder/reduce_ops.cpp",
+        "src/core/builder/src/builder/reshape.cpp",
+        "src/core/builder/src/builder/split.cpp"
+    ],
+
+    local_include_dirs: [
+        "src/core/builder/include",
+        "src/core/include"
+    ],
+
+    cflags: common_cflags + [
+        "-DENABLE_INTEL_CPU=1",
+        "-DIN_OV_CORE_LIBRARY",
+        "-DIE_BUILD_POSTFIX=\"\""
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_static {
+    name: "libngraph_reference",
+    proprietary: true,
+    compile_multilib: "64",
+
+    srcs: [
+        "src/core/reference/src/coordinate_index.cpp",
+        "src/core/reference/src/coordinate_range.cpp",
+        "src/core/reference/src/coordinate_transform.cpp",
+        "src/core/reference/src/runtime/opt_kernel/reshape.cpp",
+        "src/core/reference/src/runtime/reference/broadcast.cpp",
+        "src/core/reference/src/runtime/reference/concat.cpp",
+        "src/core/reference/src/runtime/reference/convert.cpp",
+        "src/core/reference/src/runtime/reference/depth_to_space.cpp",
+        "src/core/reference/src/runtime/reference/einsum.cpp",
+        "src/core/reference/src/runtime/reference/experimental_detectron_detection_output.cpp",
+        "src/core/reference/src/runtime/reference/experimental_detectron_proposal_single_image.cpp",
+        "src/core/reference/src/runtime/reference/experimental_detectron_roi_feature_extractor.cpp",
+        "src/core/reference/src/runtime/reference/fft.cpp",
+        "src/core/reference/src/runtime/reference/function.cpp",
+        "src/core/reference/src/runtime/reference/gather_tree.cpp",
+        "src/core/reference/src/runtime/reference/generate_proposal.cpp",
+        "src/core/reference/src/runtime/reference/group_convolution.cpp",
+        "src/core/reference/src/runtime/reference/group_convolution_backprop_data.cpp",
+        "src/core/reference/src/runtime/reference/if.cpp",
+        "src/core/reference/src/runtime/reference/interpolate.cpp",
+        "src/core/reference/src/runtime/reference/irdft.cpp",
+        "src/core/reference/src/runtime/reference/jit_generator.cpp",
+        "src/core/reference/src/runtime/reference/loop.cpp",
+        "src/core/reference/src/runtime/reference/matmul.cpp",
+        "src/core/reference/src/runtime/reference/matrix_nms.cpp",
+        "src/core/reference/src/runtime/reference/multiclass_nms.cpp",
+        "src/core/reference/src/runtime/reference/non_max_suppression.cpp",
+        "src/core/reference/src/runtime/reference/pad.cpp",
+        "src/core/reference/src/runtime/reference/random_uniform.cpp",
+        "src/core/reference/src/runtime/reference/rdft.cpp",
+        "src/core/reference/src/runtime/reference/reorg_yolo.cpp",
+        "src/core/reference/src/runtime/reference/reshape.cpp",
+        "src/core/reference/src/runtime/reference/reverse.cpp",
+        "src/core/reference/src/runtime/reference/shuffle_channels.cpp",
+        "src/core/reference/src/runtime/reference/slice.cpp",
+        "src/core/reference/src/runtime/reference/space_to_depth.cpp",
+        "src/core/reference/src/runtime/reference/split.cpp",
+        "src/core/reference/src/runtime/reference/strided_slice.cpp",
+        "src/core/reference/src/runtime/reference/tensor_iterator.cpp",
+        "src/core/reference/src/runtime/reference/tile.cpp",
+        "src/core/reference/src/runtime/reference/transpose.cpp",
+        "src/core/reference/src/runtime/reference/utils/fft_common.cpp",
+        "src/core/reference/src/runtime/reference/utils/nms_common.cpp"
+    ],
+
+    local_include_dirs: [
+        "src/core/reference/include",
+        "src/core/include"
+    ],
+
+    header_libs: [
+        "xbyak_headers"
+    ],
+
+    cflags: common_cflags + [
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DENABLE_INTEL_CPU=1",
+        "-DIN_OV_CORE_LIBRARY",
+        "-DXBYAK64",
+        "-DXBYAK_NO_OP_NAMES",
+    ],
+
+    shared_libs: [
+        "liblog"
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_shared {
+
+    name: "libopenvino_ir_frontend",
+    proprietary: true,
+    owner: "intel",
+    compile_multilib: "64",
+
+    srcs: [
+        "src/frontends/ir/src/frontend.cpp",
+        "src/frontends/ir/src/input_model.cpp",
+        "src/frontends/ir/src/ir_deserializer.cpp",
+        "src/frontends/ir/src/os/lin/lin_mmap_object.cpp",
+        "src/frontends/ir/src/rt_info_deserializer.cpp",
+        "src/frontends/ir/src/utils.cpp",
+        "src/inference/src/ie_rtti.cpp"
+    ],
+
+    local_include_dirs: [
+        "src/frontends/ir/include",
+        "src/frontends/ir/src",
+        "src/frontends/ir/src",
+        "src/core/include",
+        "src/frontends/common/include",
+        "src/inference/include",
+        "src/inference/include/ie",
+        "src/common/transformations/include",
+        "src/core/dev_api",
+        "src/inference/dev_api",
+        "src/common/low_precision_transformations/include",
+        "src/common/preprocessing",
+        "src/common/itt/include",
+        "src/common/util/include",
+        "src/plugins/intel_cpu/src",
+        "src/common/snippets/include",
+    ],
+
+    header_libs: [
+        "libtbb_headers",
+        "libpugixml_headers"
+    ],
+
+    cflags: common_cflags + [
+        "-DENABLE_INTEL_CPU=1",
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DIE_THREAD=IE_THREAD_TBB",
+        "-DTBB_PREVIEW_WAITING_FOR_WORKERS=1",
+        "-Dopenvino_ir_frontend_EXPORTS",
+        "-DPROJECT_ROOT_DIR=\"vendor/intel/external/project-celadon/openvino\"",
+    ],
+
+    shared_libs: [
+        "liblog",
+        "libtbb",
+        "libopenvino",
+    ],
+
+    static_libs: [
+        "libitt",
+        "libpugixml",
+        "libutil",
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_headers {
+    name: "libopenvino_intel_cpu_plugin_headers",
+    vendor: true,
+    export_include_dirs: [
+        "src/plugins/intel_cpu/src",
+        "src/core/include",
+        "src/frontends/common/include",
+        "src/inference/include",
+        "src/inference/include/ie",
+        "src/common/transformations/include",
+        "src/core/dev_api",
+        "src/inference/dev_api",
+        "src/common/low_precision_transformations/include",
+        "src/common/preprocessing",
+        "src/common/itt/include",
+        "src/common/util/include",
+        "src/common/conditional_compilation/include",
+        "src/core/shape_inference/include",
+        "src/common/snippets/include"
+    ],
+}
+
+//#################################################
+
+cc_library_shared {
+
+    name: "libopenvino_intel_cpu_plugin",
+    proprietary: true,
+    owner: "intel",
+    compile_multilib: "64",
+
+    srcs: [
+        "src/plugins/intel_cpu/src/async_infer_request.cpp",
+        "src/plugins/intel_cpu/src/cache/multi_cache.cpp",
+        "src/plugins/intel_cpu/src/config.cpp",
+        "src/plugins/intel_cpu/src/cpu_memory.cpp",
+        "src/plugins/intel_cpu/src/cpu_shape.cpp",
+        "src/plugins/intel_cpu/src/cpu_types.cpp",
+        "src/plugins/intel_cpu/src/dnnl_descriptor.cpp",
+        "src/plugins/intel_cpu/src/dnnl_extension_utils.cpp",
+        "src/plugins/intel_cpu/src/dnnl_postops_composer.cpp",
+        "src/plugins/intel_cpu/src/edge.cpp",
+        "src/plugins/intel_cpu/src/emitters/cpu_generator.cpp",
+        "src/plugins/intel_cpu/src/emitters/jit_conversion_emitters.cpp",
+        "src/plugins/intel_cpu/src/emitters/jit_dnnl_emitters.cpp",
+        "src/plugins/intel_cpu/src/emitters/jit_eltwise_emitters.cpp",
+        "src/plugins/intel_cpu/src/emitters/jit_emitter.cpp",
+        "src/plugins/intel_cpu/src/emitters/jit_load_store_emitters.cpp",
+        "src/plugins/intel_cpu/src/emitters/jit_snippets_emitters.cpp",
+        "src/plugins/intel_cpu/src/exec_network.cpp",
+        "src/plugins/intel_cpu/src/extension.cpp",
+        "src/plugins/intel_cpu/src/extension_mngr.cpp",
+        "src/plugins/intel_cpu/src/graph.cpp",
+        "src/plugins/intel_cpu/src/graph_dumper.cpp",
+        "src/plugins/intel_cpu/src/graph_optimizer.cpp",
+        "src/plugins/intel_cpu/src/infer_request.cpp",
+        "src/plugins/intel_cpu/src/memory_desc/blocked_memory_desc.cpp",
+        "src/plugins/intel_cpu/src/memory_desc/cpu_blocked_memory_desc.cpp",
+        "src/plugins/intel_cpu/src/memory_desc/cpu_memory_desc_utils.cpp",
+        "src/plugins/intel_cpu/src/memory_desc/dnnl_blocked_memory_desc.cpp",
+        "src/plugins/intel_cpu/src/memory_desc/dnnl_memory_desc.cpp",
+        "src/plugins/intel_cpu/src/memory_state.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/align_matmul_input_ranks.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_broadcast_to_tiles.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_fq_rnn_to_quantized_rnn.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_matmul_to_fc.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_tile_to_seq_tiles.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_to_interaction.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_to_leaky_relu.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_to_power_static.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/convert_to_swish_cpu.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/fc_bias_fusion.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/mha_fusion.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/move_eltwise_up_data_movement.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/op/fully_connected.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/op/interaction.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/op/leaky_relu.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/op/mha.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/op/power_static.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/op/swish_cpu.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/reshape_fc_fusion.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/rnn_sequences_optimization.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/snippets_mark_skipped.cpp",
+        "src/plugins/intel_cpu/src/ngraph_transformations/swap_convert_transpose.cpp",
+        "src/plugins/intel_cpu/src/node.cpp",
+        "src/plugins/intel_cpu/src/nodes/adaptive_pooling.cpp",
+        "src/plugins/intel_cpu/src/nodes/batch_to_space.cpp",
+        "src/plugins/intel_cpu/src/nodes/bin_conv.cpp",
+        "src/plugins/intel_cpu/src/nodes/broadcast.cpp",
+        "src/plugins/intel_cpu/src/nodes/bucketize.cpp",
+        "src/plugins/intel_cpu/src/nodes/color_convert.cpp",
+        "src/plugins/intel_cpu/src/nodes/common/blocked_desc_creator.cpp",
+        "src/plugins/intel_cpu/src/nodes/common/cpu_convert.cpp",
+        "src/plugins/intel_cpu/src/nodes/common/dnnl_executor.cpp",
+        "src/plugins/intel_cpu/src/nodes/common/permute_kernel.cpp",
+        "src/plugins/intel_cpu/src/nodes/common/softmax.cpp",
+        "src/plugins/intel_cpu/src/nodes/common/tile_broadcast_utils.cpp",
+        "src/plugins/intel_cpu/src/nodes/concat.cpp",
+        "src/plugins/intel_cpu/src/nodes/conv.cpp",
+        "src/plugins/intel_cpu/src/nodes/convert.cpp",
+        "src/plugins/intel_cpu/src/nodes/ctc_greedy_decoder.cpp",
+        "src/plugins/intel_cpu/src/nodes/ctc_greedy_decoder_seq_len.cpp",
+        "src/plugins/intel_cpu/src/nodes/ctc_loss.cpp",
+        "src/plugins/intel_cpu/src/nodes/cum_sum.cpp",
+        "src/plugins/intel_cpu/src/nodes/deconv.cpp",
+        "src/plugins/intel_cpu/src/nodes/def_conv.cpp",
+        "src/plugins/intel_cpu/src/nodes/depth_to_space.cpp",
+        "src/plugins/intel_cpu/src/nodes/detection_output.cpp",
+        "src/plugins/intel_cpu/src/nodes/dft.cpp",
+        "src/plugins/intel_cpu/src/nodes/eltwise.cpp",
+        "src/plugins/intel_cpu/src/nodes/embedding_bag_offset_sum.cpp",
+        "src/plugins/intel_cpu/src/nodes/embedding_bag_packed_sum.cpp",
+        "src/plugins/intel_cpu/src/nodes/embedding_bag_sum.cpp",
+        "src/plugins/intel_cpu/src/nodes/embedding_segments_sum.cpp",
+        "src/plugins/intel_cpu/src/nodes/experimental_detectron_detection_output.cpp",
+        "src/plugins/intel_cpu/src/nodes/experimental_detectron_generate_proposals_single_image.cpp",
+        "src/plugins/intel_cpu/src/nodes/experimental_detectron_priorgridgenerator.cpp",
+        "src/plugins/intel_cpu/src/nodes/experimental_detectron_roifeatureextractor.cpp",
+        "src/plugins/intel_cpu/src/nodes/experimental_detectron_topkrois.cpp",
+        "src/plugins/intel_cpu/src/nodes/extract_image_patches.cpp",
+        "src/plugins/intel_cpu/src/nodes/eye.cpp",
+        "src/plugins/intel_cpu/src/nodes/fake_quantize.cpp",
+        "src/plugins/intel_cpu/src/nodes/fullyconnected.cpp",
+        "src/plugins/intel_cpu/src/nodes/gather.cpp",
+        "src/plugins/intel_cpu/src/nodes/gather_elements.cpp",
+        "src/plugins/intel_cpu/src/nodes/gather_nd.cpp",
+        "src/plugins/intel_cpu/src/nodes/gather_tree.cpp",
+        "src/plugins/intel_cpu/src/nodes/generate_proposals.cpp",
+        "src/plugins/intel_cpu/src/nodes/generic.cpp",
+        "src/plugins/intel_cpu/src/nodes/grid_sample.cpp",
+        "src/plugins/intel_cpu/src/nodes/grn.cpp",
+        "src/plugins/intel_cpu/src/nodes/if.cpp",
+        "src/plugins/intel_cpu/src/nodes/input.cpp",
+        "src/plugins/intel_cpu/src/nodes/interaction.cpp",
+        "src/plugins/intel_cpu/src/nodes/interpolate.cpp",
+        "src/plugins/intel_cpu/src/nodes/kernels/dft_uni_kernel.cpp",
+        "src/plugins/intel_cpu/src/nodes/kernels/gather_uni_kernel.cpp",
+        "src/plugins/intel_cpu/src/nodes/kernels/grid_sample.cpp",
+        "src/plugins/intel_cpu/src/nodes/kernels/jit_kernel_base.cpp",
+        "src/plugins/intel_cpu/src/nodes/kernels/rdft_kernel.cpp",
+        "src/plugins/intel_cpu/src/nodes/log_softmax.cpp",
+        "src/plugins/intel_cpu/src/nodes/lrn.cpp",
+        "src/plugins/intel_cpu/src/nodes/mathematics.cpp",
+        "src/plugins/intel_cpu/src/nodes/matmul.cpp",
+        "src/plugins/intel_cpu/src/nodes/matrix_nms.cpp",
+        "src/plugins/intel_cpu/src/nodes/memory.cpp",
+        "src/plugins/intel_cpu/src/nodes/mha.cpp",
+        "src/plugins/intel_cpu/src/nodes/multiclass_nms.cpp",
+        "src/plugins/intel_cpu/src/nodes/mvn.cpp",
+        "src/plugins/intel_cpu/src/nodes/non_max_suppression.cpp",
+        "src/plugins/intel_cpu/src/nodes/non_zero.cpp",
+        "src/plugins/intel_cpu/src/nodes/normalize.cpp",
+        "src/plugins/intel_cpu/src/nodes/one_hot.cpp",
+        "src/plugins/intel_cpu/src/nodes/pad.cpp",
+        "src/plugins/intel_cpu/src/nodes/pooling.cpp",
+        "src/plugins/intel_cpu/src/nodes/priorbox.cpp",
+        "src/plugins/intel_cpu/src/nodes/priorbox_clustered.cpp",
+        "src/plugins/intel_cpu/src/nodes/proposal.cpp",
+        "src/plugins/intel_cpu/src/nodes/psroi_pooling.cpp",
+        "src/plugins/intel_cpu/src/nodes/range.cpp",
+        "src/plugins/intel_cpu/src/nodes/rdft.cpp",
+        "src/plugins/intel_cpu/src/nodes/reduce.cpp",
+        "src/plugins/intel_cpu/src/nodes/reference.cpp",
+        "src/plugins/intel_cpu/src/nodes/region_yolo.cpp",
+        "src/plugins/intel_cpu/src/nodes/reorder.cpp",
+        "src/plugins/intel_cpu/src/nodes/reorg_yolo.cpp",
+        "src/plugins/intel_cpu/src/nodes/reshape.cpp",
+        "src/plugins/intel_cpu/src/nodes/reverse_sequence.cpp",
+        "src/plugins/intel_cpu/src/nodes/rnn.cpp",
+        "src/plugins/intel_cpu/src/nodes/roi_align.cpp",
+        "src/plugins/intel_cpu/src/nodes/roi_pooling.cpp",
+        "src/plugins/intel_cpu/src/nodes/roll.cpp",
+        "src/plugins/intel_cpu/src/nodes/scatter_update.cpp",
+        "src/plugins/intel_cpu/src/nodes/select.cpp",
+        "src/plugins/intel_cpu/src/nodes/shapeof.cpp",
+        "src/plugins/intel_cpu/src/nodes/shuffle_channels.cpp",
+        "src/plugins/intel_cpu/src/nodes/softmax.cpp",
+        "src/plugins/intel_cpu/src/nodes/space_to_batch.cpp",
+        "src/plugins/intel_cpu/src/nodes/space_to_depth.cpp",
+        "src/plugins/intel_cpu/src/nodes/split.cpp",
+        "src/plugins/intel_cpu/src/nodes/strided_slice.cpp",
+        "src/plugins/intel_cpu/src/nodes/subgraph.cpp",
+        "src/plugins/intel_cpu/src/nodes/tensoriterator.cpp",
+        "src/plugins/intel_cpu/src/nodes/tile.cpp",
+        "src/plugins/intel_cpu/src/nodes/topk.cpp",
+        "src/plugins/intel_cpu/src/nodes/transpose.cpp",
+        "src/plugins/intel_cpu/src/nodes/unique.cpp",
+        "src/plugins/intel_cpu/src/nodes_factory.cpp",
+        "src/plugins/intel_cpu/src/normalize_preprocess.cpp",
+        "src/plugins/intel_cpu/src/onednn/dnnl.cpp",
+        "src/plugins/intel_cpu/src/onednn/iml_type_mapper.cpp",
+        "src/plugins/intel_cpu/src/plugin.cpp",
+        "src/plugins/intel_cpu/src/primitive.cpp",
+        "src/plugins/intel_cpu/src/serialize.cpp",
+        "src/plugins/intel_cpu/src/snippets_transformations/fuse_load_store_and_convert.cpp",
+        "src/plugins/intel_cpu/src/snippets_transformations/op/load_convert.cpp",
+        "src/plugins/intel_cpu/src/snippets_transformations/op/store_convert.cpp",
+        "src/plugins/intel_cpu/src/utils/blob_dump.cpp",
+        "src/plugins/intel_cpu/src/utils/debug_capabilities.cpp",
+        "src/plugins/intel_cpu/src/utils/jit_kernel.cpp",
+        "src/plugins/intel_cpu/src/utils/node_dumper.cpp",
+        "src/plugins/intel_cpu/src/utils/rt_info/memory_formats_attribute.cpp",
+        "src/plugins/intel_cpu/src/utils/shape_inference/shape_inference.cpp",
+        "src/plugins/intel_cpu/src/utils/shape_inference/shape_inference_cpu.cpp",
+        "src/plugins/intel_cpu/src/utils/shape_inference/shape_inference_ngraph.cpp",
+        "src/plugins/intel_cpu/src/utils/shape_inference/static_dimension.cpp",
+        "src/plugins/intel_cpu/src/utils/shape_inference/static_shape.cpp",
+        "src/plugins/intel_cpu/src/utils/verbose.cpp",
+        "src/plugins/intel_cpu/src/weights_cache.cpp",
+        "src/plugins/intel_cpu/src/nodes/proposal_imp.cpp",
+        "src/inference/src/ie_rtti.cpp",
+    ],
+
+    header_libs: [
+        "libopenvino_intel_cpu_plugin_headers",
+        "libdnnl_headers",
+        "libtbb_headers",
+        "libpugixml_headers"
+    ],
+
+    local_include_dirs: [
+        "src/plugins/intel_cpu/src",
+        "src/plugins/intel_cpu/src/nodes",
+        "src/common/snippets/include",
+    ],
+
+    cflags: common_cflags + [
+        "-DENABLE_INTEL_CPU=1",
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DIE_THREAD=IE_THREAD_TBB",
+        "-DIMPLEMENT_INFERENCE_ENGINE_PLUGIN",
+        "-DIMPLEMENT_INFERENCE_EXTENSION_API",
+        "-DTBB_PREVIEW_WAITING_FOR_WORKERS=1",
+        "-Dopenvino_intel_cpu_plugin_EXPORTS",
+        "-DPROJECT_ROOT_DIR=\"vendor/intel/external/project-celadon/openvino\"",
+        "-DCI_BUILD_NUMBER=\"2022.3.0-9052-9752fafe8eb-HEAD\"",
+        "-DXARCH=ANY",
+    ],
+
+    shared_libs: [
+        "liblog",
+        "libtbb",
+        "libopenvino",
+    ],
+
+    static_libs: [
+        "libitt",
+        "libdnnl",
+        "libpugixml",
+        "libutil",
+        "libngraph_reference",
+        "libinference_engine_snippets",
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_static {
+    name: "libitt",
+    proprietary: true,
+    compile_multilib: "64",
+
+    srcs: [
+        "src/common/itt/src/itt.cpp"
+    ],
+
+    local_include_dirs: [
+        "src/common/itt/include",
+        "src/common/util/include"
+    ],
+
+    cflags: common_cflags + [
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DENABLE_INTEL_CPU=1"
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_static {
+    name: "libutil",
+    proprietary: true,
+    compile_multilib: "64",
+
+    srcs: [
+        "src/common/util/src/common_util.cpp",
+        "src/common/util/src/env_util.cpp",
+        "src/common/util/src/file_util.cpp",
+        "src/common/util/src/log.cpp",
+        "src/common/util/src/os/lin/lin_shared_object_loader.cpp"
+    ],
+
+    local_include_dirs: [
+        "src/common/util/include"
+    ],
+
+    cflags: common_cflags + [
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DENABLE_INTEL_CPU=1"
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_static {
+    name: "libov_shape_inference",
+    proprietary: true,
+    compile_multilib: "64",
+
+    srcs: [
+        "src/core/shape_inference/src/convolution_shape_inference.cpp"
+    ],
+
+    local_include_dirs: [
+        "src/core/shape_inference/include",
+        "src/core/include"
+    ],
+
+    cflags: common_cflags + [
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DENABLE_INTEL_CPU=1",
+        "-DIN_OV_CORE_LIBRARY"
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
+
+//#################################################
+
+cc_library_static {
+    name: "libinference_engine_snippets",
+    proprietary: true,
+    compile_multilib: "64",
+
+    srcs: [
+        "src/common/snippets/src/generator.cpp",
+        "src/common/snippets/src/op/broadcastload.cpp",
+        "src/common/snippets/src/op/broadcastmove.cpp",
+        "src/common/snippets/src/op/convert_saturation.cpp",
+        "src/common/snippets/src/op/convert_truncation.cpp",
+        "src/common/snippets/src/op/kernel.cpp",
+        "src/common/snippets/src/op/load.cpp",
+        "src/common/snippets/src/op/nop.cpp",
+        "src/common/snippets/src/op/powerstatic.cpp",
+        "src/common/snippets/src/op/scalar.cpp",
+        "src/common/snippets/src/op/store.cpp",
+        "src/common/snippets/src/op/subgraph.cpp",
+        "src/common/snippets/src/op/tile.cpp",
+        "src/common/snippets/src/op/tile_scheduler.cpp",
+        "src/common/snippets/src/pass/align_element_type.cpp",
+        "src/common/snippets/src/pass/assign_registers.cpp",
+        "src/common/snippets/src/pass/collapse_subgraph.cpp",
+        "src/common/snippets/src/pass/common_optimizations.cpp",
+        "src/common/snippets/src/pass/convert_constants.cpp",
+        "src/common/snippets/src/pass/convert_power_to_powerstatic.cpp",
+        "src/common/snippets/src/pass/fq_decomposition.cpp",
+        "src/common/snippets/src/pass/insert_load_store.cpp",
+        "src/common/snippets/src/pass/insert_movebroadcast.cpp",
+        "src/common/snippets/src/pass/load_movebroadcast_to_broadcastload.cpp",
+        "src/common/snippets/src/pass/transform_convert.cpp",
+        "src/common/snippets/src/pass/vector_to_scalar.cpp",
+        "src/common/snippets/src/utils.cpp",
+    ],
+
+    local_include_dirs: [
+        "src/common/snippets/include",
+        "src/core/include",
+        "src/frontends/common/include",
+        "src/inference/include",
+        "src/inference/include/ie",
+        "src/core/reference/include",
+        "src/common/transformations/include",
+        "src/core/dev_api",
+        "src/inference/dev_api",
+        "src/common/low_precision_transformations/include",
+        "src/common/preprocessing",
+        "src/common/itt/include",
+        "src/common/util/include",
+        "src/common/conditional_compilation/include",
+    ],
+
+    cflags: common_cflags + [
+        "-DENABLE_INTEL_CPU=1",
+        "-DIE_BUILD_POSTFIX=\"\"",
+        "-DIE_THREAD=IE_THREAD_TBB",
+        "-DTBB_PREVIEW_WAITING_FOR_WORKERS=1",
+    ],
+
+    rtti: true,
+
+    strip: {
+        none: true,
+    }
+}
diff --git a/src/common/legacy/include/legacy/graph_transformer.h b/src/common/legacy/include/legacy/graph_transformer.h
index d6964f5df1..20b74ccd9a 100644
--- a/src/common/legacy/include/legacy/graph_transformer.h
+++ b/src/common/legacy/include/legacy/graph_transformer.h
@@ -66,6 +66,7 @@ protected:
      * @brief TBD
      */
     void cleanup();
+    virtual ~ConstTransformer() = default;
 
 private:
     const details::caseless_set<std::string> shapeTaking = {"Reshape", "Resample", "Interp", "Squeeze", "Unsqueeze"};
diff --git a/src/common/transformations/include/transformations/common_optimizations/ric_fusion.hpp b/src/common/transformations/include/transformations/common_optimizations/ric_fusion.hpp
index 39509eba54..37d8e43c9c 100644
--- a/src/common/transformations/include/transformations/common_optimizations/ric_fusion.hpp
+++ b/src/common/transformations/include/transformations/common_optimizations/ric_fusion.hpp
@@ -17,6 +17,148 @@ class TRANSFORMATIONS_API ReverseInputChannelsFusion;
 }  // namespace pass
 }  // namespace ov
 
+namespace ov {
+namespace pass {
+namespace ric_attr {
+
+#ifdef __clang__
+// Attribute describes RIC type which we propagate.
+// Also, it contains callback which can expand this attribute to the real RIC sub-graph.
+// In addition, attribute has some functionality and properties for propagation.
+class Attribute {
+public:
+    Attribute(std::vector<int64_t> order, int64_t axis, bool is_final = false, bool is_initial = false)
+        : m_order(std::move(order)),
+          m_axis(axis),
+          m_is_final(is_final),
+          m_is_initial(is_initial) {
+        m_can_be_fused.emplace_back(std::make_shared<bool>(true));
+    }
+
+    // Method which is used to create a copy of attribute for further propagation.
+    // TODO: can be removed and replaced with regular copy but we need to get rid of
+    //       is_initial flag and use some other way to detect original RIC output.
+    Attribute propagate() const {
+        Attribute attr(m_order, m_axis);
+        attr.m_can_be_fused = m_can_be_fused;
+        return attr;
+    }
+
+    void set_is_final(bool is_final) {
+        m_is_final = is_final;
+    }
+
+    void set_can_be_fused(bool can_be_fused) {
+        std::for_each(m_can_be_fused.cbegin(),
+                      m_can_be_fused.cend(),
+                      [can_be_fused](const std::shared_ptr<bool>& state) {
+                          *state = can_be_fused;
+                      });
+    }
+
+#if 0
+    // Apply callback to materialize RIC inside graph
+    void materialize(Input<Node> input, const ov::NodeVector& nodes) const {
+        const auto& input_pshape = input.get_partial_shape();
+        const auto input_rank = input_pshape.rank();
+        if (input_rank.is_dynamic()) {
+            NGRAPH_DEBUG << "Axis calculated to materialize RIC on input: input rank is dynamic";
+            return;
+        }
+        const auto axis = get_axis();
+        // Despite of m_axis is signed integer this transformartion does not handle negative axes values
+        if (axis < 0 || axis >= static_cast<int64_t>(input_pshape.size())) {
+            NGRAPH_DEBUG << "Axis calculated to materialize RIC on input: " << input << " is out of range";
+            return;
+        }
+        const auto& axis_dim = input_pshape[axis];
+        if (axis_dim.is_dynamic()) {
+            NGRAPH_DEBUG << "Axis calculated to materialize RIC on input: " << input << " is dynamic";
+            return;
+        }
+        auto output = input.get_source_output();
+	// Handle case when the RIC order is default
+        auto order = get_order();
+        if (order.empty()) {
+            order.resize(axis_dim.get_length());
+            std::iota(order.rbegin(), order.rend(), 0);
+        }
+        auto gather = std::make_shared<opset8::Gather>(output, create_1d_const(order), create_1d_const({get_axis()}));
+        input.replace_source_output(gather);
+        ov::copy_runtime_info(nodes, gather);
+    }
+
+    bool can_be_fused() const {
+        return std::all_of(m_can_be_fused.cbegin(), m_can_be_fused.cend(), [](const std::shared_ptr<bool>& state) {
+            return *state;
+        });
+    }
+
+    // For cases when we propagate through operation with multiple inputs like Eltwise
+    // we have to merge RIC attrs from all inputs. To check that given attr be merged with
+    // current we check the order and axis which must be the same.
+    bool can_be_merged_with(const Attribute& other) {
+        return (m_order.empty() || other.m_order.empty() || m_order == other.m_order) && m_axis == other.m_axis;
+    }
+
+    // When merging two and more attrs for further propagation we have to keep can_be_fused references
+    // for cases when fusion is not possible, so we can update all related attrs.
+    void merge_with(const Attribute& other) {
+        m_can_be_fused.insert(m_can_be_fused.end(), other.m_can_be_fused.begin(), other.m_can_be_fused.end());
+    }
+#else
+    void materialize(Input<Node> input, const ov::NodeVector& nodes) const;
+    bool can_be_fused() const;
+    bool can_be_merged_with(const Attribute& other);
+    void merge_with(const Attribute& other);
+#endif
+    const std::vector<int64_t>& get_order() const {
+        return m_order;
+    }
+
+    void set_order(const std::vector<int64_t>& order) {
+        m_order = order;
+    }
+
+    int64_t get_axis() const {
+        return m_axis;
+    }
+
+    void set_axis(int64_t axis) {
+        m_axis = axis;
+    }
+
+    bool is_final() const {
+        return m_is_final;
+    }
+
+    bool is_initial() const {
+        return m_is_initial;
+    }
+
+private:
+    // empty order means that the order is default and must be n, n-1, ..., 0
+    // according to the dimension values specified by m_axis
+    std::vector<int64_t> m_order;
+    int64_t m_axis;
+
+    // Specifies whether RIC can be fused or not. vector is needed to keep references to other
+    // attributes that were participated during merge.
+    std::vector<std::shared_ptr<bool>> m_can_be_fused;
+
+    // true - means that current RIC attribute is final and can be materialized
+    // false - means that current RIC attribute is temporary and need only for propagation
+    bool m_is_final;
+
+    // true - means that current RIC attribute is an initial attribute and belongs to real RIC output
+    // false - means that current RIC attribute is temporary and need only for propagation
+    bool m_is_initial;
+};
+} // namespace ric_attr
+}  // namespace pass
+}  // namespace ov
+#endif
+
 /**
  * @ingroup ie_transformation_common_api
  * @brief ReverseInputChannelsFusion
diff --git a/src/common/transformations/src/itt.hpp b/src/common/transformations/src/itt.hpp
index cac45e8684..f32f738ec2 100644
--- a/src/common/transformations/src/itt.hpp
+++ b/src/common/transformations/src/itt.hpp
@@ -39,7 +39,5 @@ OV_CC_DOMAINS(internal_op);
 #define INTERNAL_OP_SCOPE(region) MATCHER_SCOPE_(internal_op, region)
 
 #else
-
 #define INTERNAL_OP_SCOPE(region)
-
 #endif
diff --git a/src/common/transformations/src/ov_ops/augru_cell.cpp b/src/common/transformations/src/ov_ops/augru_cell.cpp
index 06f2282894..bece53a61d 100644
--- a/src/common/transformations/src/ov_ops/augru_cell.cpp
+++ b/src/common/transformations/src/ov_ops/augru_cell.cpp
@@ -7,7 +7,7 @@
 #include <cmath>
 
 #include "augru_cell_shape_inference.hpp"
-#include "itt.hpp"
+#include "src/common/transformations/src/itt.hpp"
 
 using namespace std;
 
diff --git a/src/common/transformations/src/ov_ops/augru_sequence.cpp b/src/common/transformations/src/ov_ops/augru_sequence.cpp
index cb2dd01566..eacd4ce844 100644
--- a/src/common/transformations/src/ov_ops/augru_sequence.cpp
+++ b/src/common/transformations/src/ov_ops/augru_sequence.cpp
@@ -5,7 +5,7 @@
 #include "ov_ops/augru_sequence.hpp"
 
 #include "augru_sequence_shape_inference.hpp"
-#include "itt.hpp"
+#include "src/common/transformations/src/itt.hpp"
 #include "ngraph/op/util/recurrent_sequence.hpp"
 
 using namespace std;
diff --git a/src/common/transformations/src/ov_ops/generate_proposals_ie_internal.cpp b/src/common/transformations/src/ov_ops/generate_proposals_ie_internal.cpp
index 64a3964e27..e9b5bbbad9 100644
--- a/src/common/transformations/src/ov_ops/generate_proposals_ie_internal.cpp
+++ b/src/common/transformations/src/ov_ops/generate_proposals_ie_internal.cpp
@@ -7,7 +7,7 @@
 #include <memory>
 #include <openvino/opsets/opset9.hpp>
 
-#include "itt.hpp"
+#include "src/common/transformations/src/itt.hpp"
 
 using namespace std;
 using namespace ov;
diff --git a/src/common/transformations/src/ov_ops/multiclass_nms_ie_internal.cpp b/src/common/transformations/src/ov_ops/multiclass_nms_ie_internal.cpp
index 43c3dd7b09..3ae74d0156 100644
--- a/src/common/transformations/src/ov_ops/multiclass_nms_ie_internal.cpp
+++ b/src/common/transformations/src/ov_ops/multiclass_nms_ie_internal.cpp
@@ -5,7 +5,7 @@
 #include "ov_ops/multiclass_nms_ie_internal.hpp"
 
 #include "../../core/shape_inference/include/multiclass_nms_shape_inference.hpp"
-#include "itt.hpp"
+#include "src/common/transformations/src/itt.hpp"
 
 using namespace std;
 using namespace ov;
diff --git a/src/common/transformations/src/ov_ops/nms_ie_internal.cpp b/src/common/transformations/src/ov_ops/nms_ie_internal.cpp
index bb5883a6d9..9ce31647bd 100644
--- a/src/common/transformations/src/ov_ops/nms_ie_internal.cpp
+++ b/src/common/transformations/src/ov_ops/nms_ie_internal.cpp
@@ -7,7 +7,7 @@
 #include <memory>
 #include <openvino/opsets/opset5.hpp>
 
-#include "itt.hpp"
+#include "src/common/transformations/src/itt.hpp"
 
 using namespace std;
 using namespace ov;
diff --git a/src/common/transformations/src/transformations/common_optimizations/ric_fusion.cpp b/src/common/transformations/src/transformations/common_optimizations/ric_fusion.cpp
index 71da793aa1..7e01e86494 100644
--- a/src/common/transformations/src/transformations/common_optimizations/ric_fusion.cpp
+++ b/src/common/transformations/src/transformations/common_optimizations/ric_fusion.cpp
@@ -30,6 +30,7 @@ std::shared_ptr<opset8::Constant> create_1d_const(const std::vector<int64_t>& va
 }
 }  // namespace
 
+#ifndef __clang__
 // Attribute describes RIC type which we propagate.
 // Also, it contains callback which can expand this attribute to the real RIC sub-graph.
 // In addition, attribute has some functionality and properties for propagation.
@@ -156,7 +157,58 @@ private:
     // false - means that current RIC attribute is temporary and need only for propagation
     bool m_is_initial;
 };
+#else
+    // Apply callback to materialize RIC inside graph
+    void Attribute::materialize(Input<Node> input, const ov::NodeVector& nodes) const {
+        const auto& input_pshape = input.get_partial_shape();
+        const auto input_rank = input_pshape.rank();
+        if (input_rank.is_dynamic()) {
+            NGRAPH_DEBUG << "Axis calculated to materialize RIC on input: input rank is dynamic";
+            return;
+        }
+        const auto axis = get_axis();
+        // Despite of m_axis is signed integer this transformartion does not handle negative axes values
+        if (axis < 0 || axis >= static_cast<int64_t>(input_pshape.size())) {
+            NGRAPH_DEBUG << "Axis calculated to materialize RIC on input: " << input << " is out of range";
+            return;
+        }
+        const auto& axis_dim = input_pshape[axis];
+        if (axis_dim.is_dynamic()) {
+            NGRAPH_DEBUG << "Axis calculated to materialize RIC on input: " << input << " is dynamic";
+            return;
+        }
+        auto output = input.get_source_output();
+        // Handle case when the RIC order is default
+        auto order = get_order();
+        if (order.empty()) {
+            order.resize(axis_dim.get_length());
+            std::iota(order.rbegin(), order.rend(), 0);
+        }
+        auto gather = std::make_shared<opset8::Gather>(output, create_1d_const(order), create_1d_const({get_axis()}));
+        input.replace_source_output(gather);
+        ov::copy_runtime_info(nodes, gather);
+    }
+
+    bool Attribute::can_be_fused() const {
+        return std::all_of(m_can_be_fused.cbegin(), m_can_be_fused.cend(), [](const std::shared_ptr<bool>& state) {
+            return *state;
+        });
+    }
+
+    // For cases when we propagate through operation with multiple inputs like Eltwise
+    // we have to merge RIC attrs from all inputs. To check that given attr be merged with
+    // current we check the order and axis which must be the same.
+    bool Attribute::can_be_merged_with(const Attribute& other) {
+        return (m_order.empty() || other.m_order.empty() || m_order == other.m_order) && m_axis == other.m_axis;
+    }
+
+    // When merging two and more attrs for further propagation we have to keep can_be_fused references
+    // for cases when fusion is not possible, so we can update all related attrs.
+    void Attribute::merge_with(const Attribute& other) {
+        m_can_be_fused.insert(m_can_be_fused.end(), other.m_can_be_fused.begin(), other.m_can_be_fused.end());
+    }
 
+#endif
 namespace {
 
 template <typename T>
diff --git a/src/core/dev_api/meta_data.hpp b/src/core/dev_api/meta_data.hpp
index 1d3d63f1a1..73bcfc41b8 100644
--- a/src/core/dev_api/meta_data.hpp
+++ b/src/core/dev_api/meta_data.hpp
@@ -18,6 +18,7 @@ public:
      *
      * @return ov::AnyMap with meta information
      */
+    virtual ~Meta() = default;
     virtual operator ov::AnyMap&() = 0;
     /**
      * @brief Parses and returns meta information by request
diff --git a/src/core/include/ngraph/variant.hpp b/src/core/include/ngraph/variant.hpp
index 97c217ca1c..c6b105854f 100644
--- a/src/core/include/ngraph/variant.hpp
+++ b/src/core/include/ngraph/variant.hpp
@@ -19,10 +19,17 @@ using VariantTypeInfo = ov::DiscreteTypeInfo;
 
 using Variant = ov::RuntimeAttribute;
 
+#ifndef __clang__
+template <typename VT>
+class OPENVINO_DEPRECATED("Please use ov::Any to store VT directly") VariantImpl : public Variant {};
+
+template <typename VT>
+class OPENVINO_DEPRECATED("Please use ov::Any to store VT directly") VariantWrapper {};
+#else
 template <typename VT>
 class OPENVINO_DEPRECATED("Please use ov::Any to store VT directly") VariantImpl : public Variant {
 public:
-    OPENVINO_RTTI(typeid(VT).name());
+    //OPENVINO_RTTI(typeid(VT).name());
     using value_type = VT;
 
     VariantImpl() = default;
@@ -67,6 +74,7 @@ public:
     }
 };
 
+#endif // __clang__
 template <typename T>
 inline std::shared_ptr<Variant> make_variant(const T& p) {
     return std::static_pointer_cast<Variant>(std::make_shared<VariantWrapper<T>>(p));
diff --git a/src/core/include/openvino/core/any.hpp b/src/core/include/openvino/core/any.hpp
index 7f29e05813..11e53cccae 100644
--- a/src/core/include/openvino/core/any.hpp
+++ b/src/core/include/openvino/core/any.hpp
@@ -181,6 +181,12 @@ typename T::value_type from_string(const std::string& val, const T&) {
     return value;
 }
 
+#ifdef __clang__
+template <typename T>
+auto from_string(const std::string& val) ->
+    typename std::enable_if<!Readable<T>::value && !Istreamable<T>::value && !std::is_same<T, std::string>::value,
+                            T>::type;
+#else
 template <typename T>
 auto from_string(const std::string& val) ->
     typename std::enable_if<!Readable<T>::value && !Istreamable<T>::value && !std::is_same<T, std::string>::value,
@@ -189,6 +195,7 @@ auto from_string(const std::string& val) ->
                          " defined or ov::util::Read<T> class specialization, T: ",
                          typeid(T).name());
 }
+#endif
 
 template <typename T, typename A>
 struct Read<std::vector<T, A>, typename std::enable_if<std::is_default_constructible<T>::value>::type> {
@@ -290,6 +297,12 @@ auto to_string(const T& value) ->
     return ss.str();
 }
 
+#ifdef __clang__
+template <typename T>
+auto to_string(const T&) ->
+    typename std::enable_if<!Writable<T>::value && !Ostreamable<T>::value && !std::is_same<T, std::string>::value,
+                            std::string>::type;
+#else
 template <typename T>
 auto to_string(const T&) ->
     typename std::enable_if<!Writable<T>::value && !Ostreamable<T>::value && !std::is_same<T, std::string>::value,
@@ -298,6 +311,7 @@ auto to_string(const T&) ->
                          " defined or ov::util::Write<T> class specialization, T: ",
                          typeid(T).name());
 }
+#endif
 
 template <typename T, typename A>
 struct Write<std::vector<T, A>> {
@@ -410,12 +424,17 @@ class OPENVINO_API Any {
     template <typename>
     struct TupleToTypeIndex;
 
+#ifdef __clang__
+    template <typename... Args>
+    struct TupleToTypeIndex<std::tuple<Args...>>;
+#else
     template <typename... Args>
     struct TupleToTypeIndex<std::tuple<Args...>> {
         static std::vector<std::type_index> get() {
             return {typeid(Args)...};
         }
     };
+#endif
 
     static bool equal(std::type_index lhs, std::type_index rhs);
 
@@ -448,6 +467,12 @@ class OPENVINO_API Any {
 
         bool is(const std::type_info& other) const;
 
+#ifdef __clang__
+        template <class T> bool is() const;
+        template <class T> T& as() &;
+        template <class T> const T& as() const&;
+
+#else
         template <class T>
         bool is() const {
             return is(typeid(decay_t<T>));
@@ -464,6 +489,7 @@ class OPENVINO_API Any {
             type_check(typeid(decay_t<T>));
             return *static_cast<const decay_t<T>*>(addressof());
         }
+#endif
 
     protected:
         ~Base() = default;
@@ -471,6 +497,11 @@ class OPENVINO_API Any {
 
     template <class T, typename = void>
     struct Impl;
+
+#ifdef __clang__    
+    template <class T>
+    struct Impl<T, typename std::enable_if<std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value>::type>;
+#else    
     template <class T>
     struct Impl<T, typename std::enable_if<std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value>::type>
         : public Base {
@@ -498,6 +529,7 @@ class OPENVINO_API Any {
         }
 
         Impl(const T& runtime_attribute) : runtime_attribute{runtime_attribute} {}
+        virtual ~Impl() = default;
 
         const std::type_info& type_info() const override {
             return typeid(T);
@@ -506,7 +538,6 @@ class OPENVINO_API Any {
         std::vector<std::type_index> base_type_info() const override {
             return {typeid(std::shared_ptr<RuntimeAttribute>)};
         }
-
         const void* addressof() const override {
             return std::addressof(runtime_attribute);
         }
@@ -532,12 +563,16 @@ class OPENVINO_API Any {
 
         T runtime_attribute;
     };
+#endif
 
+#ifdef __clang__
+    template <class T>
+    struct Impl<T, typename std::enable_if<!std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value>::type>;
+#else
     template <class T>
     struct Impl<T, typename std::enable_if<!std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value>::type>
         : public Base {
         OPENVINO_RTTI(typeid(T).name());
-
         template <typename... Args>
         Impl(Args&&... args) : value(std::forward<Args>(args)...) {}
 
@@ -546,7 +581,6 @@ class OPENVINO_API Any {
         const std::type_info& type_info() const override {
             return typeid(T);
         }
-
         const void* addressof() const override {
             return std::addressof(value);
         }
@@ -560,13 +594,14 @@ class OPENVINO_API Any {
             typename std::enable_if<HasBaseMemberType<U>::value, std::true_type>::type = {}) {
             return TupleToTypeIndex<typename T::Base>::get();
         }
-        template <class U>
+
+	template <class U>
         static std::vector<std::type_index> base_type_info_impl(
             typename std::enable_if<!HasBaseMemberType<U>::value, std::false_type>::type = {}) {
             return {typeid(T)};
         }
 
-        std::vector<std::type_index> base_type_info() const override {
+	std::vector<std::type_index> base_type_info() const override {
             return base_type_info_impl<T>();
         }
 
@@ -609,7 +644,6 @@ class OPENVINO_API Any {
             U& value) {
             is >> value;
         }
-
         template <typename U>
         static typename std::enable_if<!util::Readable<U>::value && !util::Istreamable<U>::value>::type read_impl(
             std::istream&,
@@ -618,14 +652,13 @@ class OPENVINO_API Any {
                                  " defined or ov::util::Read<T> class specialization, T: ",
                                  typeid(T).name());
         }
-
         void read(std::istream& is) override {
             read_impl(is, value);
         }
 
         T value;
     };
-
+#endif
     friend class ::ov::RuntimeAttribute;
     friend struct ::InferenceEngine::InferencePlugin;
     friend class ::InferenceEngine::ExecutableNetwork;
@@ -675,11 +708,19 @@ public:
      * @tparam T Any type
      * @param value object
      */
+#ifdef __clang__
+    template <typename T,
+              typename std::enable_if<!std::is_same<decay_t<T>, Any>::value && !std::is_abstract<decay_t<T>>::value &&
+                                          !std::is_convertible<decay_t<T>, Base::Ptr>::value,
+                                      bool>::type = true>
+    Any(T&& value);
+#else
     template <typename T,
               typename std::enable_if<!std::is_same<decay_t<T>, Any>::value && !std::is_abstract<decay_t<T>>::value &&
                                           !std::is_convertible<decay_t<T>, Base::Ptr>::value,
                                       bool>::type = true>
     Any(T&& value) : _impl{std::make_shared<Impl<decay_t<T>>>(std::forward<T>(value))} {}
+#endif
 
     /**
      * @brief Constructor creates string any from char *
@@ -726,6 +767,9 @@ public:
      * @tparam T Type of value
      * @return true if type of value is correct. Return false if any is empty
      */
+#ifdef __clang__
+    template <class T> bool is() const;
+#else
     template <class T>
     bool is() const {
         if (_impl != nullptr) {
@@ -740,12 +784,32 @@ public:
         }
         return false;
     }
+#endif
 
     /**
      * Dynamic cast to specified type
      * @tparam T type
      * @return casted object
      */
+#ifdef __clang__
+    template <class T>
+    typename std::enable_if<std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value, T>::type& as();
+
+    template <class T>
+    typename std::enable_if<!std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value &&
+                                !std::is_same<T, std::string>::value && std::is_default_constructible<T>::value &&
+                                (util::Istreamable<T>::value || util::Readable<T>::value),
+                            T>::type& as();
+
+    template <class T>
+    typename std::enable_if<
+        !std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value && !std::is_same<T, std::string>::value &&
+            (!std::is_default_constructible<T>::value || (!util::Istreamable<T>::value && !util::Readable<T>::value)),
+        T>::type& as();
+
+    template <class T>
+    typename std::enable_if<std::is_same<T, std::string>::value, T>::type& as();
+#else
     template <class T>
     typename std::enable_if<std::is_convertible<T, std::shared_ptr<RuntimeAttribute>>::value, T>::type& as() {
         if (_impl == nullptr) {
@@ -849,7 +913,7 @@ public:
             return *static_cast<std::string*>(_temp->addressof());
         }
     }
-
+#endif
     /**
      * Dynamic cast to specified type
      * @tparam T type
@@ -1030,4 +1094,4 @@ std::shared_ptr<T> static_pointer_cast(const ::ov::Any& any) {
     return any.as<std::shared_ptr<T>>();
 }
 
-}  // namespace std
\ No newline at end of file
+}  // namespace std
diff --git a/src/core/include/openvino/core/attribute_adapter.hpp b/src/core/include/openvino/core/attribute_adapter.hpp
index 3383970d4c..4b17701aa6 100644
--- a/src/core/include/openvino/core/attribute_adapter.hpp
+++ b/src/core/include/openvino/core/attribute_adapter.hpp
@@ -56,6 +56,9 @@ public:
     virtual const VAT& get() = 0;
     /// Sets the value
     virtual void set(const VAT& value) = 0;
+#ifdef __clang__
+    void set_as_any(const ov::Any& x) override;
+#else
     void set_as_any(const ov::Any& x) override {
         const auto* data = x.addressof();
         OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
@@ -65,6 +68,7 @@ public:
             OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(VAT).name());
         }
     }
+#endif //__clang__
 };
 
 template <>
@@ -107,6 +111,9 @@ public:
         m_buffer_valid = false;
     }
 
+#ifdef __clang__
+    void set_as_any(const ov::Any& x) override;
+#else
     void set_as_any(const ov::Any& x) override {
         const auto* data = x.addressof();
         OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
@@ -122,7 +129,7 @@ public:
             OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(AT).name());
         }
     }
-
+#endif // __clang__
 protected:
     AT& m_ref;
     VAT m_buffer;
@@ -156,6 +163,9 @@ public:
         m_buffer_valid = false;
     }
 
+#ifdef __clang__
+    void set_as_any(const ov::Any& x) override;
+#else
     void set_as_any(const ov::Any& x) override {
         const auto* data = x.addressof();
         OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
@@ -171,6 +181,7 @@ public:
             OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(AT).name());
         }
     }
+#endif
     operator AT&() {
         return m_ref;
     }
@@ -203,6 +214,9 @@ public:
         return m_ref;
     }
 
+#ifdef __clang__
+    void set_as_any(const ov::Any& x) override;
+#else
     void set_as_any(const ov::Any& x) override {
         const auto* data = x.addressof();
         OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
@@ -217,7 +231,7 @@ public:
             OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(AT).name());
         }
     }
-
+#endif // __clang__
 protected:
     AT& m_ref;
 };
diff --git a/src/core/include/openvino/op/constant.hpp b/src/core/include/openvino/op/constant.hpp
index 23aed791cf..8f52c9193b 100644
--- a/src/core/include/openvino/op/constant.hpp
+++ b/src/core/include/openvino/op/constant.hpp
@@ -521,13 +521,13 @@ private:
         if (!std::is_same<T, StorageDataType>::value) {
             OPENVINO_ASSERT(!std::numeric_limits<T>::is_signed ||
                             std::numeric_limits<StorageDataType>::lowest() <= value);
-            OPENVINO_ASSERT(value <= std::numeric_limits<StorageDataType>::max());
+            OPENVINO_ASSERT(std::numeric_limits<StorageDataType>::max() >= value);
         }
 #if defined(_MSC_VER)
 #    pragma warning(pop)
 #endif
 #ifdef __clang__
-#    pragma GangC diagnostic pop
+#    pragma clang diagnostic pop
 #endif
 #ifdef __GNUC__
 #    pragma GCC diagnostic pop
diff --git a/src/core/reference/src/runtime/reference/jit_generator.cpp b/src/core/reference/src/runtime/reference/jit_generator.cpp
index d10404ff4a..a73268a8b5 100644
--- a/src/core/reference/src/runtime/reference/jit_generator.cpp
+++ b/src/core/reference/src/runtime/reference/jit_generator.cpp
@@ -3,9 +3,11 @@
 //
 
 #include "jit_generator.hpp"
-
+#ifdef __clang__
+#include <xbyak_util.h>
+#else
 #include <xbyak/xbyak_util.h>
-
+#endif
 #include "ngraph/type/float16.hpp"
 
 namespace ngraph {
diff --git a/src/core/reference/src/runtime/reference/jit_generator.hpp b/src/core/reference/src/runtime/reference/jit_generator.hpp
index ab2be540b1..dd5cf73274 100644
--- a/src/core/reference/src/runtime/reference/jit_generator.hpp
+++ b/src/core/reference/src/runtime/reference/jit_generator.hpp
@@ -9,8 +9,11 @@
 #endif
 
 #include <functional>
+#ifdef __clang__
+#include <xbyak.h>
+#else
 #include <xbyak/xbyak.h>
-
+#endif
 namespace ngraph
 {
     namespace runtime
diff --git a/src/core/src/check.cpp b/src/core/src/check.cpp
index ec864aa707..da99c2ec9a 100644
--- a/src/core/src/check.cpp
+++ b/src/core/src/check.cpp
@@ -12,7 +12,7 @@ std::string CheckFailure::make_what(const CheckLocInfo& check_loc_info,
     // Use relative path only for internal code
     auto getRelativePath = [](const std::string& path) -> std::string {
         // Path to local OpenVINO repository
-        static const std::string project_root(PROJECT_ROOT_DIR);
+        const std::string project_root(PROJECT_ROOT_DIR);
         // All internal paths start from project root
         if (path.find(project_root) != 0)
             return path;
diff --git a/src/core/src/op/asinh.cpp b/src/core/src/op/asinh.cpp
index 29bdcc3b89..4fa0de0b2c 100644
--- a/src/core/src/op/asinh.cpp
+++ b/src/core/src/op/asinh.cpp
@@ -15,6 +15,7 @@
 
 using namespace std;
 using namespace ngraph;
+using namespace ov::element;
 
 BWDCMP_RTTI_DEFINITION(ov::op::v3::Asinh);
 
diff --git a/src/core/src/runtime/blob_allocator.hpp b/src/core/src/runtime/blob_allocator.hpp
index acc6e51aa0..d640d77bd6 100644
--- a/src/core/src/runtime/blob_allocator.hpp
+++ b/src/core/src/runtime/blob_allocator.hpp
@@ -46,6 +46,7 @@ struct BlobAllocator : public IAllocator {
 
 namespace ov {
 struct BlobAllocator : public runtime::AllocatorImpl {
+    virtual ~BlobAllocator() = default;
     BlobAllocator(const std::shared_ptr<ie::IAllocator>& impl = std::make_shared<ie::SystemMemoryAllocator>())
         : _impl{impl} {}
 
diff --git a/src/frontends/common/src/utils.cpp b/src/frontends/common/src/utils.cpp
index c7376e2fa9..57b290be66 100644
--- a/src/frontends/common/src/utils.cpp
+++ b/src/frontends/common/src/utils.cpp
@@ -51,7 +51,7 @@ static std::string _get_frontend_library_path() {
     GetModuleFileNameA(hm, (LPSTR)ie_library_path, sizeof(ie_library_path));
     return ov::util::get_directory(std::string(ie_library_path));
 #    endif
-#elif defined(__APPLE__) || defined(__linux__)
+#elif defined(__APPLE__) || defined(__linux__) || defined(__ANDROID__)
     Dl_info info;
     dladdr(reinterpret_cast<void*>(ov::frontend::get_frontend_library_path), &info);
     return ov::util::get_directory(ov::util::get_absolute_file_path(std::string(info.dli_fname))).c_str();
diff --git a/src/inference/include/ie/ie_precision.hpp b/src/inference/include/ie/ie_precision.hpp
index c74c0e8348..14349da161 100644
--- a/src/inference/include/ie/ie_precision.hpp
+++ b/src/inference/include/ie/ie_precision.hpp
@@ -90,6 +90,24 @@ public:
         precisionInfo.value = CUSTOM;
     }
 
+#ifdef __clang__
+    /**
+     * @brief Creates custom precision with specific underlined type
+     * @param typeName A string name of precision
+     * @return Precision converted from string name
+     */
+    template <class T>
+    static INFERENCE_ENGINE_API_CPP(Precision) fromType(const char* typeName = nullptr);
+
+    /**
+     * @brief checks whether given storage class T can be used to store objects of current precision
+     * @param typeName A string name of precision
+     * @return `true` if `typeName` has underlaying storage type
+     */
+    template <class T>
+    INFERENCE_ENGINE_API_CPP(bool) hasStorageType(const char* typeName = nullptr) const noexcept;
+#else
+
     /**
      * @brief Creates custom precision with specific underlined type
      * @param typeName A string name of precision
@@ -142,6 +160,7 @@ public:
             return false;
         }
     }
+#endif // __clang__
 
     /**
      * @brief Equality operator with Precision object
diff --git a/src/inference/src/cpp/ie_executable_network_base.hpp b/src/inference/src/cpp/ie_executable_network_base.hpp
index 810958f40a..e14ea57a86 100644
--- a/src/inference/src/cpp/ie_executable_network_base.hpp
+++ b/src/inference/src/cpp/ie_executable_network_base.hpp
@@ -45,6 +45,8 @@ public:
         _impl = impl;
     }
 
+    virtual ~ExecutableNetworkBase() = default;
+
     StatusCode GetOutputsInfo(ConstOutputsDataMap& outs, ResponseDesc* resp) const noexcept override {
         TO_STATUS(outs = _impl->GetOutputsInfo());
     }
diff --git a/src/inference/src/cpp/ie_infer_async_request_base.hpp b/src/inference/src/cpp/ie_infer_async_request_base.hpp
index a5ed56aec5..f9fbdfa52b 100644
--- a/src/inference/src/cpp/ie_infer_async_request_base.hpp
+++ b/src/inference/src/cpp/ie_infer_async_request_base.hpp
@@ -101,6 +101,8 @@ public:
      */
     explicit InferRequestBase(std::shared_ptr<IInferRequestInternal> impl): _impl(impl) {}
 
+    virtual ~InferRequestBase() = default;
+
     StatusCode Infer(ResponseDesc* resp) noexcept override {
         OV_ITT_SCOPED_TASK(itt::domains::Plugin, "Infer");
         TO_STATUS(_impl->Infer());
diff --git a/src/inference/src/ie_rtti.cpp b/src/inference/src/ie_rtti.cpp
new file mode 100644
index 0000000000..6fb4cffb5f
--- /dev/null
+++ b/src/inference/src/ie_rtti.cpp
@@ -0,0 +1,782 @@
+// Copyright (C) 2018-2020 Intel Corporation
+// SPDX-License-Identifier: Apache-2.0
+//
+
+#include <string>
+#include <vector>
+#include <tuple>
+#include <memory>
+#include <map>
+
+#include <details/ie_exception.hpp>
+#include <ie_blob.h>
+#include <ie_parameter.hpp>
+#include <ie_iextension.h>
+#include <ie_extension.h>
+#include <ie_preprocess.hpp>
+#include <inference_engine.hpp>
+#include <ie_precision.hpp>
+#include <exec_graph_info.hpp>
+#include <ngraph/opsets/opset.hpp>
+#include "ie/ie_precision.hpp"
+#include "openvino/core/any.hpp"
+#include "meta_data.hpp"
+#include "ngraph/variant.hpp"
+#include "openvino/core/attribute_adapter.hpp"
+#include "openvino/op/util/variable_context.hpp"
+#include "openvino/op/binary_convolution.hpp"
+#include "openvino/op/depth_to_space.hpp"
+#include "openvino/op/gelu.hpp"
+#include "openvino/op/grid_sample.hpp"
+#include "openvino/op/util/multi_subgraph_base.hpp"
+#include "openvino/op/interpolate.hpp"
+#include "openvino/op/lstm_cell.hpp"
+#include "openvino/op/non_max_suppression.hpp"
+#include "openvino/op/matrix_nms.hpp"
+#include "openvino/op/mvn.hpp"
+#include "openvino/op/loop.hpp"
+#include "openvino/op/roi_align.hpp"
+#include "openvino/op/round.hpp"
+#include "openvino/op/space_to_depth.hpp"
+#include "openvino/op/reverse.hpp"
+#include "openvino/op/util/framework_node.hpp"
+#include "openvino/op/util/multiclass_nms_base.hpp"
+#include "openvino/op/util/attr_types.hpp"
+#include "openvino/runtime/properties.hpp"
+#include "transformations/rt_info/old_api_map_order_attribute.hpp"
+#include "transformations/rt_info/old_api_map_element_type_attribute.hpp"
+#include "openvino/op/util/precision_sensitive_attribute.hpp"
+#include "openvino/pass/constant_folding.hpp"
+#include "openvino/core/preprocess/preprocess_steps.hpp"
+#include "openvino/core/preprocess/input_tensor_info.hpp"
+#include "transformations/rt_info/old_api_map_element_type_attribute.hpp"
+#include "transformations/rt_info/decompression.hpp"
+#include "transformations/rt_info/primitives_priority_attribute.hpp"
+#include "transformations/rt_info/disable_fp16_compression.hpp"
+#include "transformations/rt_info/fused_names_attribute.hpp"
+#include "transformations/rt_info/nms_selected_indices.hpp"
+#include "transformations/rt_info/strides_property.hpp"
+#include "transformations/rt_info/preprocessing_attribute.hpp"
+#include "transformations/common_optimizations/fold_subgraph_empty_inputs.hpp"
+#include "transformations/common_optimizations/remove_concat_zero_dim_input.hpp"
+#include "low_precision/rt_info/precision_preserved_attribute.hpp"
+#include "low_precision/rt_info/quantization_alignment_attribute.hpp"
+#include "transformations/rt_info/dequantization_node.hpp"
+#include "transformations/rt_info/nonconvertible_divide.hpp"
+#include "transformations/rt_info/dequantization_node.hpp"
+#include "low_precision/rt_info/quantization_alignment_attribute.hpp"
+#include "low_precision/rt_info/avg_pool_precision_preserved_attribute.hpp"
+#include "low_precision/rt_info/intervals_alignment_attribute.hpp"
+#include "transformations/common_optimizations/ric_fusion.hpp"
+#include "low_precision/rt_info/precisions_attribute.hpp"
+#include "low_precision/rt_info/intervals_alignment_attribute.hpp"
+#include "low_precision/rt_info/quantization_granularity_attribute.hpp"
+#include "low_precision/rt_info/quantization_alignment_attribute.hpp"
+#include "low_precision/rt_info/skip_cleanup_attribute.hpp"
+#include "utils/rt_info/memory_formats_attribute.hpp"
+#include "ngraph_transformations/snippets_mark_skipped.hpp"
+#include "snippets/pass/collapse_subgraph.hpp"
+#if defined(ENABLE_GNA)
+#include <gna-api-types-xnn.h>
+#endif
+
+using namespace InferenceEngine;
+using namespace ov;
+using namespace ov::util;
+using namespace std;
+using namespace ngraph;
+
+//
+// any.hpp
+//
+#ifdef __clang__
+template <typename T>
+auto from_string(const std::string& val) ->
+    typename std::enable_if<!Readable<T>::value && !Istreamable<T>::value && !std::is_same<T, std::string>::value,
+                            T>::type {
+    OPENVINO_UNREACHABLE("Could read type without std::istream& operator>>(std::istream&, T)",
+                         " defined or ov::util::Read<T> class specialization, T: ",
+                         typeid(T).name());
+}
+
+template <typename T>
+auto to_string(const T&) ->
+    typename std::enable_if<!Writable<T>::value && !Ostreamable<T>::value && !std::is_same<T, std::string>::value,
+                            std::string>::type {
+    OPENVINO_UNREACHABLE("Could convert to string from type without std::ostream& operator>>(std::ostream&, const T&)",
+                         " defined or ov::util::Write<T> class specialization, T: ",
+                         typeid(T).name());
+}
+
+template <typename... Args>
+struct Any::TupleToTypeIndex<std::tuple<Args...>> {
+    static std::vector<std::type_index> get() {
+        return {typeid(Args)...};
+    }
+};
+
+template <class T>
+bool ov::Any::Base::is() const {
+    return is(typeid(decay_t<T>));
+}
+
+template <class T>
+T& ov::Any::Base::as() & {
+    type_check(typeid(decay_t<T>));
+    return *static_cast<decay_t<T>*>(addressof());
+}
+
+template <class T>
+const T& ov::Any::Base::as() const& {
+    type_check(typeid(decay_t<T>));
+    return *static_cast<const decay_t<T>*>(addressof());
+}
+
+template <class T>
+struct ov::Any::Impl<T, typename std::enable_if<std::is_convertible<T, std::shared_ptr<ov::RuntimeAttribute>>::value>::type>
+    : public ov::Any::Base {
+    const ov::DiscreteTypeInfo& get_type_info() const override {
+        return static_cast<ov::RuntimeAttribute*>(runtime_attribute.get())->get_type_info();
+    }
+    std::shared_ptr<ov::RuntimeAttribute> as_runtime_attribute() const override {
+        return std::static_pointer_cast<ov::RuntimeAttribute>(runtime_attribute);
+    }
+    bool is_copyable() const override {
+        return static_cast<ov::RuntimeAttribute*>(runtime_attribute.get())->is_copyable();
+    }
+    ov::Any init(const std::shared_ptr<Node>& node) override {
+        return static_cast<ov::RuntimeAttribute*>(runtime_attribute.get())->init(node);
+    }
+    ov::Any merge(const std::vector<std::shared_ptr<Node>>& nodes) override {
+        return static_cast<ov::RuntimeAttribute*>(runtime_attribute.get())->merge(nodes);
+    }
+    std::string to_string() override {
+        return static_cast<ov::RuntimeAttribute*>(runtime_attribute.get())->to_string();
+    }
+
+    bool visit_attributes(AttributeVisitor& visitor) override {
+        return static_cast<ov::RuntimeAttribute*>(runtime_attribute.get())->visit_attributes(visitor);
+    }
+
+    Impl(const T& runtime_attribute) : runtime_attribute{runtime_attribute} {}
+    virtual ~Impl() = default;
+
+    const std::type_info& type_info() const override {
+        return typeid(T);
+    }
+
+    std::vector<std::type_index> base_type_info() const override {
+        return {typeid(std::shared_ptr<ov::RuntimeAttribute>)};
+    }
+
+    const void* addressof() const override {
+        return std::addressof(runtime_attribute);
+    }
+
+    ov::Any::Base::Ptr copy() const override {
+        return std::make_shared<Impl<T>>(this->runtime_attribute);
+    }
+
+    bool equal(const Base& rhs) const override {
+        if (rhs.is<T>()) {
+            return equal_impl(this->runtime_attribute, rhs.as<T>());
+        }
+        return false;
+    }
+
+    void print(std::ostream& os) const override {
+        os << runtime_attribute->to_string();
+    }
+
+    void read(std::istream&) override {
+        OPENVINO_UNREACHABLE("Pointer to runtime attribute is not readable from std::istream");
+    }
+
+    T runtime_attribute;
+};
+
+template <class T>
+struct ov::Any::Impl<T, typename std::enable_if<!std::is_convertible<T, std::shared_ptr<ov::RuntimeAttribute>>::value>::type>
+    : public ov::Any::Base {
+    OPENVINO_RTTI(typeid(T).name());
+
+    template <typename... Args>
+    Impl(Args&&... args) : value(std::forward<Args>(args)...) {}
+
+    virtual ~Impl() = default;
+
+    const std::type_info& type_info() const override {
+        return typeid(T);
+    }
+
+    const void* addressof() const override {
+        return std::addressof(value);
+    }
+
+    ov::Any::Base::Ptr copy() const override {
+        return std::make_shared<Impl<T>>(this->value);
+    }
+
+    template <class U>
+    static std::vector<std::type_index> base_type_info_impl(
+        typename std::enable_if<HasBaseMemberType<U>::value, std::true_type>::type = {}) {
+        return TupleToTypeIndex<typename T::Base>::get();
+    }
+    template <class U>
+    static std::vector<std::type_index> base_type_info_impl(
+        typename std::enable_if<!HasBaseMemberType<U>::value, std::false_type>::type = {}) {
+        return {typeid(T)};
+    }
+
+    std::vector<std::type_index> base_type_info() const override {
+        return base_type_info_impl<T>();
+    }
+
+    bool equal(const Base& rhs) const override {
+        if (rhs.is<T>()) {
+            return equal_impl(this->value, rhs.as<T>());
+        }
+        return false;
+    }
+
+    template <typename U>
+    static typename std::enable_if<util::Writable<U>::value>::type print_impl(std::ostream& os, const U& value) {
+        util::Write<U>{}(os, value);
+    }
+
+    template <typename U>
+    static typename std::enable_if<!util::Writable<U>::value && util::Ostreamable<U>::value>::type print_impl(
+        std::ostream& os,
+        const U& value) {
+        os << value;
+    }
+
+    template <typename U>
+    static typename std::enable_if<!util::Writable<U>::value && !util::Ostreamable<U>::value>::type print_impl(
+        std::ostream&,
+        const U&) {}
+
+    void print(std::ostream& os) const override {
+        print_impl(os, value);
+    }
+
+    template <typename U>
+    static typename std::enable_if<util::Readable<U>::value>::type read_impl(std::istream& is, U& value) {
+        util::Read<U>{}(is, value);
+    }
+
+    template <typename U>
+    static typename std::enable_if<!util::Readable<U>::value && util::Istreamable<U>::value>::type read_impl(
+        std::istream& is,
+        U& value) {
+        is >> value;
+    }
+
+    template <typename U>
+    static typename std::enable_if<!util::Readable<U>::value && !util::Istreamable<U>::value>::type read_impl(
+        std::istream&,
+        U&) {
+        OPENVINO_UNREACHABLE("Could read type without std::istream& operator>>(std::istream&, T)",
+                                " defined or ov::util::Read<T> class specialization, T: ",
+                                typeid(T).name());
+    }
+
+    void read(std::istream& is) override {
+        read_impl(is, value);
+    }
+
+    T value;
+};
+
+template <typename T,
+              typename std::enable_if<!std::is_same<decay_t<T>, ov::Any>::value && !std::is_abstract<decay_t<T>>::value &&
+                                          !std::is_convertible<decay_t<T>, ov::Any::Base::Ptr>::value,
+                                      bool>::type>
+    Any::Any(T&& value) : _impl{std::make_shared<ov::Any::Impl<decay_t<T>>>(std::forward<T>(value))} {}
+
+template <class T>
+typename std::enable_if<std::is_convertible<T, std::shared_ptr<ov::RuntimeAttribute>>::value, T>::type& Any::as() {
+    if (_impl == nullptr) {
+        _temp = std::make_shared<ov::Any::Impl<decay_t<T>>>(T{});
+        return *static_cast<decay_t<T>*>(_temp->addressof());
+    } else {
+        if (_impl->is(typeid(decay_t<T>))) {
+            return *static_cast<decay_t<T>*>(_impl->addressof());
+        } else {
+            auto runtime_attribute = _impl->as_runtime_attribute();
+            if (runtime_attribute == nullptr) {
+                OPENVINO_UNREACHABLE("Any does not contains pointer to runtime_attribute. It contains ",
+                                        _impl->type_info().name());
+            }
+            auto vptr = std::dynamic_pointer_cast<typename T::element_type>(runtime_attribute);
+            if (vptr == nullptr && T::element_type::get_type_info_static() != runtime_attribute->get_type_info() &&
+                T::element_type::get_type_info_static() != ov::RuntimeAttribute::get_type_info_static()) {
+                OPENVINO_UNREACHABLE("Could not cast Any runtime_attribute to ",
+                                        typeid(T).name(),
+                                        " from ",
+                                        _impl->type_info().name(),
+                                        "; from ",
+                                        static_cast<std::string>(runtime_attribute->get_type_info()),
+                                        " to ",
+                                        static_cast<std::string>(T::element_type::get_type_info_static()));
+            }
+            _temp = std::make_shared<ov::Any::Impl<decay_t<T>>>(
+                std::static_pointer_cast<typename T::element_type>(runtime_attribute));
+            return *static_cast<decay_t<T>*>(_temp->addressof());
+        }
+    }
+}
+
+/**
+ * Dynamic cast to specified type
+ * @tparam T type
+ * @return casted object
+ */
+template <class T>
+typename std::enable_if<!std::is_convertible<T, std::shared_ptr<ov::RuntimeAttribute>>::value &&
+                            !std::is_same<T, std::string>::value && std::is_default_constructible<T>::value &&
+                            (ov::util::Istreamable<T>::value || ov::util::Readable<T>::value),
+                        T>::type&
+Any::as() {
+    impl_check();
+    if (_impl->is(typeid(decay_t<T>))) {
+        return *static_cast<decay_t<T>*>(_impl->addressof());
+    } else if (_impl->is(typeid(std::string))) {
+        _temp = std::make_shared<ov::Any::Impl<decay_t<T>>>();
+        _impl->read_to(*_temp);
+        return *static_cast<decay_t<T>*>(_temp->addressof());
+    }
+    for (const auto& type_index : _impl->base_type_info()) {
+        if (equal(type_index, typeid(decay_t<T>))) {
+            return *static_cast<decay_t<T>*>(_impl->addressof());
+        }
+    }
+    OPENVINO_UNREACHABLE("Bad cast from: ", _impl->type_info().name(), " to: ", typeid(T).name());
+}
+
+/**
+ * Dynamic cast to specified type
+ * @tparam T type
+ * @return casted object
+ */
+template <class T>
+typename std::enable_if<
+    !std::is_convertible<T, std::shared_ptr<ov::RuntimeAttribute>>::value && !std::is_same<T, std::string>::value &&
+        (!std::is_default_constructible<T>::value || (!ov::util::Istreamable<T>::value && !ov::util::Readable<T>::value)),
+    T>::type&
+Any::as() {
+    impl_check();
+    if (_impl->is(typeid(decay_t<T>))) {
+        return *static_cast<decay_t<T>*>(_impl->addressof());
+    }
+    for (const auto& type_index : _impl->base_type_info()) {
+        if (equal(type_index, typeid(decay_t<T>))) {
+            return *static_cast<decay_t<T>*>(_impl->addressof());
+        }
+    }
+    OPENVINO_UNREACHABLE("Bad cast from: ", _impl->type_info().name(), " to: ", typeid(T).name());
+}
+
+/**
+ * Dynamic cast to specified type
+ * @tparam T type
+ * @return casted object
+ */
+template <class T>
+typename std::enable_if<std::is_same<T, std::string>::value, T>::type& Any::as() {
+    if (_impl != nullptr) {
+        if (_impl->is(typeid(decay_t<T>))) {
+            return *static_cast<decay_t<T>*>(_impl->addressof());
+        } else {
+            _temp = std::make_shared<Impl<std::string>>();
+            _impl->read_to(*_temp);
+            return *static_cast<std::string*>(_temp->addressof());
+        }
+    } else {
+        _temp = std::make_shared<Impl<std::string>>();
+        return *static_cast<std::string*>(_temp->addressof());
+    }
+}
+
+template <class T>
+bool ov::Any::is() const {
+    if (_impl != nullptr) {
+        if (_impl->is(typeid(decay_t<T>))) {
+            return true;
+        }
+        for (const auto& type_index : _impl->base_type_info()) {
+            if (equal(type_index, typeid(decay_t<T>))) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+template ov::Any::Any(ov::PrecisionSensitive&&);
+template ov::Any::Any(bool&);
+template ov::Any::Any(ov::LayoutAttribute&&);
+template ov::Any::Any(std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > >&&);
+template ov::Any::Any(std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > >&);
+template ov::Any::Any(ov::op::util::VariableContext&&);
+template ov::Any::Any(ov::pass::DisableConstantFolding&&);
+template ov::Any::Any(long&&);
+template ov::Any::Any(ov::preprocess::TensorInfoMemoryType&&);
+template ov::Any::Any(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&);
+template ov::Any::Any(std::vector<ov::PropertyName, std::allocator<ov::PropertyName> >&&);
+template ov::Any::Any(long const&);
+template ov::Any::Any(std::basic_string<char, std::char_traits<char>, std::allocator<char> >&);
+template ov::Any::Any(std::basic_string<char, std::char_traits<char>, std::allocator<char> >&&);
+template ov::Any::Any(ov::Property<unsigned int, (ov::PropertyMutability)1> const&);
+template ov::Any::Any(bool&&);
+template ov::Any::Any(std::basic_istream<char, std::char_traits<char> >*&&);
+template ov::Any::Any(std::shared_ptr<ngraph::runtime::AlignedBuffer>&);
+template ov::Any::Any(ov::streams::Num&&);
+template ov::Any::Any(int&&);
+template ov::Any::Any(ov::Affinity&&);
+template ov::Any::Any(ov::OldApiMapElementType const&);
+template ov::Any::Any(ov::pass::DisableFoldSubgraphEmptyInputs&&);
+template ov::Any::Any(ov::pass::DisableRemoveConcatZeroDimInput&&);
+template ov::Any::Any(ov::PrimitivesPriority&&);
+template ov::Any::Any(ov::PrimitivesPriority&);
+template ov::Any::Any(ov::FusedNames&&);
+template ov::Any::Any(ov::DisableFP16Compression&&);
+template ov::Any::Any(ov::NmsSelectedIndices&&);
+template ov::Any::Any(ov::OldApiMapOrder&&);
+template ov::Any::Any(ov::OldApiMapElementType&&);
+template ov::Any::Any(ov::Decompression&&);
+template ov::Any::Any(ov::StridesPropagation&&);
+template ov::Any::Any(ov::PreprocessingAttribute&&);
+template ov::Any::Any(ov::pass::ric_attr::Attribute const&);
+template ov::Any::Any(ov::DequantizationNode&&);
+template ov::Any::Any(ov::NonconvertibleDivide&&);
+template ov::Any::Any(ngraph::IntervalsAlignmentAttribute const&);
+template ov::Any::Any(ngraph::QuantizationAlignmentAttribute const&);
+template ov::Any::Any(ngraph::AvgPoolPrecisionPreservedAttribute const&);
+template ov::Any::Any(ngraph::PrecisionPreservedAttribute const&);
+template ov::Any::Any(ngraph::PrecisionsAttribute&&);
+template ov::Any::Any(ngraph::PrecisionsAttribute const&);
+template ov::Any::Any(ngraph::PrecisionPreservedAttribute&&);
+template ov::Any::Any(ngraph::QuantizationGranularityAttribute&&);
+template ov::Any::Any(ngraph::IntervalsAlignmentAttribute&);
+template ov::Any::Any(ngraph::QuantizationAlignmentAttribute&&);
+template ov::Any::Any(ngraph::SkipCleanupAttribute&&);
+template ov::Any::Any(std::shared_ptr<ov::Meta>&);
+template ov::Any::Any(unsigned int&&);
+template ov::Any::Any(std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >&&);
+//template ov::Any::Any(std::vector<ov::PropertyName, std::allocator<ov::PropertyName> >&&);
+//template ov::Any::Any(ov::streams::Num&&);
+template ov::Any::Any(ov::element::Type&&);
+//template ov::Any::Any(ov::Affinity&&);
+template ov::Any::Any(ov::hint::PerformanceMode const&&);
+template ov::Any::Any(float const&);
+template ov::Any::Any(std::vector<float, std::allocator<float> > const&);
+template ov::Any::Any(std::tuple<unsigned int, unsigned int>&&);
+template ov::Any::Any(std::tuple<unsigned int, unsigned int, unsigned int>&&);
+template ov::Any::Any(long&);
+template ov::Any::Any(ov::intel_cpu::NodeFusingType&);
+template ov::Any::Any(std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > > const&);
+template ov::Any::Any(std::vector<unsigned long, std::allocator<unsigned long> >&);
+template ov::Any::Any(ngraph::snippets::pass::SnippetsNodeType&);
+
+template std::enable_if<((!(std::is_convertible<ov::op::util::VariableContext, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::op::util::VariableContext, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::op::util::VariableContext>::value)) || ((!(util::Istreamable<ov::op::util::VariableContext>::value)) && (!(util::Readable<ov::op::util::VariableContext>::value)))), ov::op::util::VariableContext>::type& ov::Any::as<ov::op::util::VariableContext>();
+
+template std::enable_if<std::is_same<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::type& ov::Any::as<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >();
+
+template std::enable_if<(((!(std::is_convertible<bool, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<bool, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<bool>::value)) && ((util::Istreamable<bool>::value) || (util::Readable<bool>::value)), bool>::type& ov::Any::as<bool>();
+
+template std::enable_if<(((!(std::is_convertible<long, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<long, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<long>::value)) && ((util::Istreamable<long>::value) || (util::Readable<long>::value)), long>::type& ov::Any::as<long>();
+
+template std::enable_if<((!(std::is_convertible<ov::RuntimeAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::RuntimeAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::RuntimeAttribute>::value)) || ((!(util::Istreamable<ov::RuntimeAttribute>::value)) && (!(util::Readable<ov::RuntimeAttribute>::value)))), ov::RuntimeAttribute>::type& ov::Any::as<ov::RuntimeAttribute>();
+
+template std::enable_if<((!(std::is_convertible<ov::LayoutAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::LayoutAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::LayoutAttribute>::value)) || ((!(util::Istreamable<ov::LayoutAttribute>::value)) && (!(util::Readable<ov::LayoutAttribute>::value)))), ov::LayoutAttribute>::type& ov::Any::as<ov::LayoutAttribute>();
+
+template std::enable_if<((!(std::is_convertible<std::shared_ptr<ov::Meta>, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::shared_ptr<ov::Meta>, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<std::shared_ptr<ov::Meta> >::value)) || ((!(util::Istreamable<std::shared_ptr<ov::Meta> >::value)) && (!(util::Readable<std::shared_ptr<ov::Meta> >::value)))), std::shared_ptr<ov::Meta> >::type& ov::Any::as<std::shared_ptr<ov::Meta> >();
+
+template std::enable_if<(((!(std::is_convertible<std::vector<ov::PropertyName, std::allocator<ov::PropertyName> >, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::vector<ov::PropertyName, std::allocator<ov::PropertyName> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<std::vector<ov::PropertyName, std::allocator<ov::PropertyName> > >::value)) && ((util::Istreamable<std::vector<ov::PropertyName, std::allocator<ov::PropertyName> > >::value) || (util::Readable<std::vector<ov::PropertyName, std::allocator<ov::PropertyName> > >::value)), std::vector<ov::PropertyName, std::allocator<ov::PropertyName> > >::type& ov::Any::as<std::vector<ov::PropertyName, std::allocator<ov::PropertyName> > >();
+
+template std::enable_if<(((!(std::is_convertible<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::value)) && ((util::Istreamable<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::value) || (util::Readable<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::value)), std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::type& ov::Any::as<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >();
+
+template std::enable_if<((!(std::is_convertible<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const>::value)) || ((!(util::Istreamable<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const>::value)) && (!(util::Readable<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const>::value)))), std::basic_string<char, std::char_traits<char>, std::allocator<char> > const>::type& ov::Any::as<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const>();
+
+template std::enable_if<(((!(std::is_convertible<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > >, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > > >::value)) && ((util::Istreamable<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > > >::value) || (util::Readable<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > > >::value)), std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > > >::type& ov::Any::as<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > > >();
+
+template std::enable_if<((!(std::is_convertible<ov::OldApiMapElementType, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::OldApiMapElementType, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::OldApiMapElementType>::value)) || ((!(util::Istreamable<ov::OldApiMapElementType>::value)) && (!(util::Readable<ov::OldApiMapElementType>::value)))), ov::OldApiMapElementType>::type& ov::Any::as<ov::OldApiMapElementType>();
+
+template std::enable_if<((!(std::is_convertible<ov::OldApiMapOrder, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::OldApiMapOrder, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::OldApiMapOrder>::value)) || ((!(util::Istreamable<ov::OldApiMapOrder>::value)) && (!(util::Readable<ov::OldApiMapOrder>::value)))), ov::OldApiMapOrder>::type& ov::Any::as<ov::OldApiMapOrder>();
+
+template bool ov::Any::is<std::vector<long, std::allocator<long> > >() const;
+template bool ov::Any::is<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >() const;
+template bool ov::Any::is<std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, ov::Any, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> > const, ov::Any> > > >() const;
+template bool ov::Any::is<std::shared_ptr<ov::Meta> >() const;
+template bool ov::Any::is<long>() const;
+template bool ov::Any::is<unsigned long>() const;
+template bool ov::Any::is<std::shared_ptr<ov::op::util::Variable> >() const;
+template bool ov::Any::is<ov::Shape>() const;
+template bool ov::Any::is<ov::Strides>() const;
+template bool ov::Any::is<bool>() const;
+template bool ov::Any::is<ov::op::PadType>() const;
+template bool ov::Any::is<ov::op::RoundingType>() const;
+template bool ov::Any::is<double>() const;
+template bool ov::Any::is<ov::CoordinateDiff>() const;
+template bool ov::Any::is<ov::op::v1::BinaryConvolution::BinaryConvolutionMode>() const;
+template bool ov::Any::is<float>() const;
+template bool ov::Any::is<ov::op::v0::DepthToSpace::DepthToSpaceMode>() const;
+template bool ov::Any::is<int>() const;
+template bool ov::Any::is<std::vector<float, std::allocator<float> > >() const;
+template bool ov::Any::is<ov::op::GeluApproximationMode>() const;
+template bool ov::Any::is<ov::op::v9::GridSample::InterpolationMode>() const;
+template bool ov::Any::is<ov::op::v9::GridSample::PaddingMode>() const;
+template bool ov::Any::is<ov::op::RecurrentSequenceDirection>() const;
+template bool ov::Any::is<std::shared_ptr<ov::Model> >() const;
+template bool ov::Any::is<std::vector<std::shared_ptr<ov::op::util::MultiSubGraphOp::InputDescription>, std::allocator<std::shared_ptr<ov::op::util::MultiSubGraphOp::InputDescription> > > >() const;
+template bool ov::Any::is<std::vector<std::shared_ptr<ov::op::util::MultiSubGraphOp::OutputDescription>, std::allocator<std::shared_ptr<ov::op::util::MultiSubGraphOp::OutputDescription> > > >() const;
+template bool ov::Any::is<std::vector<unsigned long, std::allocator<unsigned long> > >() const;
+template bool ov::Any::is<ov::op::v4::Interpolate::InterpolateMode>() const;
+template bool ov::Any::is<ov::op::v4::Interpolate::ShapeCalcMode>() const;
+template bool ov::Any::is<ov::op::v4::Interpolate::CoordinateTransformMode>() const;
+template bool ov::Any::is<ov::op::v4::Interpolate::NearestMode>() const;
+template bool ov::Any::is<ov::op::v5::Loop::SpecialBodyPorts>() const;
+template bool ov::Any::is<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >() const;
+template bool ov::Any::is<ov::op::LSTMWeightsFormat>() const;
+template bool ov::Any::is<ov::op::v8::MatrixNms::SortResultType>() const;
+template bool ov::Any::is<ov::op::v8::MatrixNms::DecayFunction>() const;
+template bool ov::Any::is<ov::op::MVNEpsMode>() const;
+template bool ov::Any::is<ov::op::v1::NonMaxSuppression::BoxEncodingType>() const;
+template bool ov::Any::is<ov::op::v3::NonMaxSuppression::BoxEncodingType>() const;
+template bool ov::Any::is<ov::op::v5::NonMaxSuppression::BoxEncodingType>() const;
+template bool ov::Any::is<ov::op::v9::NonMaxSuppression::BoxEncodingType>() const;
+template bool ov::Any::is<ov::op::EpsMode>() const;
+template bool ov::Any::is<ov::op::PadMode>() const;
+template bool ov::Any::is<ov::PartialShape>() const;
+template bool ov::Any::is<ov::op::v1::Reverse::Mode>() const;
+template bool ov::Any::is<ov::op::v3::ROIAlign::PoolingMode>() const;
+template bool ov::Any::is<ov::op::v9::ROIAlign::PoolingMode>() const;
+template bool ov::Any::is<ov::op::v9::ROIAlign::AlignedMode>() const;
+template bool ov::Any::is<ov::op::v5::Round::RoundMode>() const;
+template bool ov::Any::is<ov::op::v0::SpaceToDepth::SpaceToDepthMode>() const;
+template bool ov::Any::is<ov::op::TopKMode>() const;
+template bool ov::Any::is<ov::op::TopKSortType>() const;
+template bool ov::Any::is<ov::op::AutoBroadcastType>() const;
+template bool ov::Any::is<ov::op::BroadcastType>() const;
+template bool ov::Any::is<std::vector<int, std::allocator<int> > >() const;
+template bool ov::Any::is<ov::op::util::FrameworkNodeAttrs>() const;
+template bool ov::Any::is<ov::op::util::MulticlassNmsBase::SortResultType>() const;
+template bool ov::Any::is<ov::RuntimeAttribute>() const;
+template bool ov::Any::is<std::shared_ptr<ngraph::runtime::AlignedBuffer> >() const;
+template bool ov::Any::is<std::vector<ov::element::Type, std::allocator<ov::element::Type> > >() const;
+template bool ov::Any::is<std::shared_ptr<ngraph::VariantWrapper<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >() const;
+template bool ov::Any::is<ov::PrimitivesPriority>() const;
+template bool ov::Any::is<std::set<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >() const;
+template bool ov::Any::is<ov::intel_cpu::InputMemoryFormats>() const;
+template bool ov::Any::is<ov::intel_cpu::OutputMemoryFormats>() const;
+template bool ov::Any::is<ov::Dimension>() const;
+template bool ov::Any::is<std::basic_istream<char, std::char_traits<char> >*>() const;
+template bool ov::Any::is<std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*>() const;
+
+template std::enable_if<((!(std::is_convertible<ov::pass::ric_attr::Attribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::pass::ric_attr::Attribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::pass::ric_attr::Attribute>::value)) || ((!(util::Istreamable<ov::pass::ric_attr::Attribute>::value)) && (!(util::Readable<ov::pass::ric_attr::Attribute>::value)))), ov::pass::ric_attr::Attribute>::type& ov::Any::as<ov::pass::ric_attr::Attribute>();
+template std::enable_if<std::is_convertible<std::shared_ptr<ngraph::VariantWrapper<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >, std::shared_ptr<ov::RuntimeAttribute> >::value, std::shared_ptr<ngraph::VariantWrapper<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::type& ov::Any::as<std::shared_ptr<ngraph::VariantWrapper<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >();
+template std::enable_if<((!(std::is_convertible<ov::PrimitivesPriority, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::PrimitivesPriority, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::PrimitivesPriority>::value)) || ((!(util::Istreamable<ov::PrimitivesPriority>::value)) && (!(util::Readable<ov::PrimitivesPriority>::value)))), ov::PrimitivesPriority>::type& ov::Any::as<ov::PrimitivesPriority>();
+template std::enable_if<((!(std::is_convertible<ov::FusedNames, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::FusedNames, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::FusedNames>::value)) || ((!(util::Istreamable<ov::FusedNames>::value)) && (!(util::Readable<ov::FusedNames>::value)))), ov::FusedNames>::type& ov::Any::as<ov::FusedNames>();
+template std::enable_if<((!(std::is_convertible<ov::StridesPropagation, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::StridesPropagation, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::StridesPropagation>::value)) || ((!(util::Istreamable<ov::StridesPropagation>::value)) && (!(util::Readable<ov::StridesPropagation>::value)))), ov::StridesPropagation>::type& ov::Any::as<ov::StridesPropagation>();
+template std::enable_if<((!(std::is_convertible<ngraph::IntervalsAlignmentAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ngraph::IntervalsAlignmentAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ngraph::IntervalsAlignmentAttribute>::value)) || ((!(util::Istreamable<ngraph::IntervalsAlignmentAttribute>::value)) && (!(util::Readable<ngraph::IntervalsAlignmentAttribute>::value)))), ngraph::IntervalsAlignmentAttribute>::type& ov::Any::as<ngraph::IntervalsAlignmentAttribute>();
+template std::enable_if<((!(std::is_convertible<ngraph::QuantizationAlignmentAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ngraph::QuantizationAlignmentAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ngraph::QuantizationAlignmentAttribute>::value)) || ((!(util::Istreamable<ngraph::QuantizationAlignmentAttribute>::value)) && (!(util::Readable<ngraph::QuantizationAlignmentAttribute>::value)))), ngraph::QuantizationAlignmentAttribute>::type& ov::Any::as<ngraph::QuantizationAlignmentAttribute>();
+template std::enable_if<((!(std::is_convertible<ngraph::PrecisionsAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ngraph::PrecisionsAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ngraph::PrecisionsAttribute>::value)) || ((!(util::Istreamable<ngraph::PrecisionsAttribute>::value)) && (!(util::Readable<ngraph::PrecisionsAttribute>::value)))), ngraph::PrecisionsAttribute>::type& ov::Any::as<ngraph::PrecisionsAttribute>();
+template std::enable_if<((!(std::is_convertible<ngraph::QuantizationGranularityAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ngraph::QuantizationGranularityAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ngraph::QuantizationGranularityAttribute>::value)) || ((!(util::Istreamable<ngraph::QuantizationGranularityAttribute>::value)) && (!(util::Readable<ngraph::QuantizationGranularityAttribute>::value)))), ngraph::QuantizationGranularityAttribute>::type& ov::Any::as<ngraph::QuantizationGranularityAttribute>();
+template std::enable_if<((!(std::is_convertible<ngraph::AvgPoolPrecisionPreservedAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ngraph::AvgPoolPrecisionPreservedAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ngraph::AvgPoolPrecisionPreservedAttribute>::value)) || ((!(util::Istreamable<ngraph::AvgPoolPrecisionPreservedAttribute>::value)) && (!(util::Readable<ngraph::AvgPoolPrecisionPreservedAttribute>::value)))), ngraph::AvgPoolPrecisionPreservedAttribute>::type& ov::Any::as<ngraph::AvgPoolPrecisionPreservedAttribute>();
+template std::enable_if<((!(std::is_convertible<ngraph::PrecisionPreservedAttribute, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ngraph::PrecisionPreservedAttribute, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ngraph::PrecisionPreservedAttribute>::value)) || ((!(util::Istreamable<ngraph::PrecisionPreservedAttribute>::value)) && (!(util::Readable<ngraph::PrecisionPreservedAttribute>::value)))), ngraph::PrecisionPreservedAttribute>::type& ov::Any::as<ngraph::PrecisionPreservedAttribute>();
+template std::enable_if<((!(std::is_convertible<std::basic_istream<char, std::char_traits<char> >*, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::basic_istream<char, std::char_traits<char> >*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<std::basic_istream<char, std::char_traits<char> >*>::value)) || ((!(util::Istreamable<std::basic_istream<char, std::char_traits<char> >*>::value)) && (!(util::Readable<std::basic_istream<char, std::char_traits<char> >*>::value)))), std::basic_istream<char, std::char_traits<char> >*>::type& ov::Any::as<std::basic_istream<char, std::char_traits<char> >*>();
+template std::enable_if<((!(std::is_convertible<std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*>::value)) || ((!(util::Istreamable<std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*>::value)) && (!(util::Readable<std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*>::value)))), std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*>::type& ov::Any::as<std::basic_istringstream<char, std::char_traits<char>, std::allocator<char> >*>();
+template std::enable_if<((!(std::is_convertible<std::shared_ptr<ngraph::runtime::AlignedBuffer>, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::shared_ptr<ngraph::runtime::AlignedBuffer>, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<std::shared_ptr<ngraph::runtime::AlignedBuffer> >::value)) || ((!(util::Istreamable<std::shared_ptr<ngraph::runtime::AlignedBuffer> >::value)) && (!(util::Readable<std::shared_ptr<ngraph::runtime::AlignedBuffer> >::value)))), std::shared_ptr<ngraph::runtime::AlignedBuffer> >::type& ov::Any::as<std::shared_ptr<ngraph::runtime::AlignedBuffer> >();
+template std::enable_if<((!(std::is_convertible<ov::intel_cpu::NodeFusingType, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::intel_cpu::NodeFusingType, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::intel_cpu::NodeFusingType>::value)) || ((!(util::Istreamable<ov::intel_cpu::NodeFusingType>::value)) && (!(util::Readable<ov::intel_cpu::NodeFusingType>::value)))), ov::intel_cpu::NodeFusingType>::type& ov::Any::as<ov::intel_cpu::NodeFusingType>();
+template std::enable_if<(((!(std::is_convertible<float, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<float, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<float>::value)) && ((util::Istreamable<float>::value) || (util::Readable<float>::value)), float>::type& ov::Any::as<float>();
+template std::enable_if<(((!(std::is_convertible<std::vector<float, std::allocator<float> >, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::vector<float, std::allocator<float> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<std::vector<float, std::allocator<float> > >::value)) && ((util::Istreamable<std::vector<float, std::allocator<float> > >::value) || (util::Readable<std::vector<float, std::allocator<float> > >::value)), std::vector<float, std::allocator<float> > >::type& ov::Any::as<std::vector<float, std::allocator<float> > >();
+template std::enable_if<((!(std::is_convertible<ov::intel_cpu::InputMemoryFormats, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::intel_cpu::InputMemoryFormats, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::intel_cpu::InputMemoryFormats>::value)) || ((!(util::Istreamable<ov::intel_cpu::InputMemoryFormats>::value)) && (!(util::Readable<ov::intel_cpu::InputMemoryFormats>::value)))), ov::intel_cpu::InputMemoryFormats>::type& ov::Any::as<ov::intel_cpu::InputMemoryFormats>();
+template std::enable_if<((!(std::is_convertible<ov::intel_cpu::OutputMemoryFormats, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ov::intel_cpu::OutputMemoryFormats, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ov::intel_cpu::OutputMemoryFormats>::value)) || ((!(util::Istreamable<ov::intel_cpu::OutputMemoryFormats>::value)) && (!(util::Readable<ov::intel_cpu::OutputMemoryFormats>::value)))), ov::intel_cpu::OutputMemoryFormats>::type& ov::Any::as<ov::intel_cpu::OutputMemoryFormats>();
+template std::enable_if<(((!(std::is_convertible<std::vector<unsigned long, std::allocator<unsigned long> >, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<std::vector<unsigned long, std::allocator<unsigned long> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && (std::is_default_constructible<std::vector<unsigned long, std::allocator<unsigned long> > >::value)) && ((util::Istreamable<std::vector<unsigned long, std::allocator<unsigned long> > >::value) || (util::Readable<std::vector<unsigned long, std::allocator<unsigned long> > >::value)), std::vector<unsigned long, std::allocator<unsigned long> > >::type& ov::Any::as<std::vector<unsigned long, std::allocator<unsigned long> > >();
+template std::enable_if<((!(std::is_convertible<ngraph::snippets::pass::SnippetsNodeType, std::shared_ptr<ov::RuntimeAttribute> >::value)) && (!(std::is_same<ngraph::snippets::pass::SnippetsNodeType, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >::value))) && ((!(std::is_default_constructible<ngraph::snippets::pass::SnippetsNodeType>::value)) || ((!(util::Istreamable<ngraph::snippets::pass::SnippetsNodeType>::value)) && (!(util::Readable<ngraph::snippets::pass::SnippetsNodeType>::value)))), ngraph::snippets::pass::SnippetsNodeType>::type& ov::Any::as<ngraph::snippets::pass::SnippetsNodeType>();
+template bool ov::Any::Base::is<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >() const;
+
+template <class T>
+Precision Precision::fromType(const char* typeName) {
+    return Precision(8 * sizeof(T), typeName == nullptr ? typeid(T).name() : typeName);
+}
+
+template <class T>
+bool Precision::hasStorageType(const char* typeName) const noexcept {
+    try {
+#define CASE(x, y) \
+    case x:        \
+        return std::is_same<T, y>()
+#define CASE2(x, y1, y2) \
+    case x:              \
+        return std::is_same<T, y1>() || std::is_same<T, y2>()
+
+            switch (precisionInfo.value) {
+                CASE(FP32, float);
+                CASE(FP64, double);
+                CASE2(FP16, int16_t, uint16_t);
+                CASE2(BF16, int16_t, uint16_t);
+                CASE2(I4, int8_t, uint8_t);
+                CASE(I8, int8_t);
+                CASE(I16, int16_t);
+                CASE(I32, int32_t);
+                CASE(I64, int64_t);
+                CASE(U4, uint8_t);
+                CASE(U8, uint8_t);
+                CASE(U16, uint16_t);
+                CASE(U32, uint32_t);
+                CASE(U64, uint64_t);
+                CASE(BOOL, uint8_t);
+                CASE2(Q78, int16_t, uint16_t);
+                CASE2(BIN, int8_t, uint8_t);
+            default:
+                return areSameStrings(name(), typeName == nullptr ? typeid(T).name() : typeName);
+#undef CASE
+#undef CASE2
+            }
+    } catch (...) {
+        return false;
+    }
+}
+
+template Precision Precision::fromType<int>(const char* typeName);
+template Precision Precision::fromType<signed char>(const char* typeName);
+template Precision Precision::fromType<short>(const char* typeName);
+#if defined(ENABLE_GNA)
+template Precision Precision::fromType<_compound_bias_t>(const char* typeName);
+#endif // ENABLE_GNA
+template bool Precision::hasStorageType<float>(const char* typeName) const;
+template bool Precision::hasStorageType<int>(const char* typeName) const;
+template bool Precision::hasStorageType<unsigned char>(const char* typeName) const;
+template bool Precision::hasStorageType<short>(const char* typeName) const;
+template bool Precision::hasStorageType<unsigned short>(const char* typeName) const;
+template bool Precision::hasStorageType<signed char>(const char* typeName) const;
+template bool Precision::hasStorageType<long>(const char* typeName) const;
+template bool Precision::hasStorageType<unsigned long>(const char* typeName) const;
+template bool Precision::hasStorageType<unsigned int>(const char* typeName) const;
+template bool Precision::hasStorageType<double>(const char* typeName) const;
+#if defined(ENABLE_GNA)
+template bool Precision::hasStorageType<_compound_bias_t>(const char* typeName) const;
+#endif // ENABLE_GNA
+
+template <typename VAT>
+void ValueAccessor<VAT>::set_as_any(const ov::Any& x) {
+    const auto* data = x.addressof();
+    OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
+    if (x.is<VAT>()) {
+        set(*static_cast<const VAT*>(data));
+    } else {
+        OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(VAT).name());
+    }
+}
+
+template <typename AT, typename VAT>
+void IndirectScalarValueAccessor<AT, VAT>::set_as_any(const ov::Any& x) {
+    const auto* data = x.addressof();
+    OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
+    // Try to represent x as VAT or AT
+    if (x.is<VAT>()) {
+        set(*static_cast<const VAT*>(data));
+    } else if (x.is<AT>()) {
+        // Don't call set here avoiding unnecessary casts AT -> VAT -> AT,
+        // instead reimplement logic from set.
+        m_ref = *static_cast<const AT*>(data);
+        m_buffer_valid = false;
+    } else {
+        OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(AT).name());
+    }
+}
+
+template <typename AT, typename VAT>
+void IndirectVectorValueAccessor<AT, VAT>::set_as_any(const ov::Any& x) {
+    const auto* data = x.addressof();
+    OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
+    // Try to represent x as VAT or AT
+    if (x.is<VAT>()) {
+        set(*static_cast<const VAT*>(data));
+    } else if (x.is<AT>()) {
+        // Don't call set here avoiding unnecessary casts AT -> VAT -> AT,
+        // instead reimplement logic from set.
+        m_ref = *static_cast<const AT*>(data);
+        m_buffer_valid = false;
+    } else {
+        OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(AT).name());
+    }
+}
+
+template <typename AT>
+void EnumAttributeAdapterBase<AT>::set_as_any(const ov::Any& x) {
+    const auto* data = x.addressof();
+    OPENVINO_ASSERT(data != nullptr, "Data conversion is not possible. Empty data is provided.");
+    // Try to represent x as std::string or AT
+    if (x.is<std::string>()) {
+        set(x.as<std::string>());
+    } else if (x.is<AT>()) {
+        // Don't call set here avoiding unnecessary casts AT -> std::string -> AT,
+        // instead reimplement logic from set.
+        m_ref = *static_cast<const AT*>(data);
+    } else {
+        OPENVINO_UNREACHABLE("Bad cast from: ", x.type_info().name(), " to: ", typeid(AT).name());
+    }
+}
+
+template void ov::ValueAccessor<std::vector<long, std::allocator<long> > >::set_as_any(ov::Any const&);
+template void ov::IndirectScalarValueAccessor<unsigned long, long>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::shared_ptr<ov::op::util::Variable> >::set_as_any(ov::Any const&);
+template void ov::IndirectVectorValueAccessor<ov::Shape, std::vector<long, std::allocator<long> > >::set_as_any(ov::Any const&);
+template void ov::IndirectVectorValueAccessor<ov::Strides, std::vector<long, std::allocator<long> > >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<bool>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::PadType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::RoundingType>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<double>::set_as_any(ov::Any const&);
+template void ov::IndirectVectorValueAccessor<ov::CoordinateDiff, std::vector<long, std::allocator<long> > >::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v1::BinaryConvolution::BinaryConvolutionMode>::set_as_any(ov::Any const&);
+template void ov::IndirectScalarValueAccessor<float, double>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<long>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v0::DepthToSpace::DepthToSpaceMode>::set_as_any(ov::Any const&);
+template void ov::IndirectScalarValueAccessor<int, long>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::vector<float, std::allocator<float> > >::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::GeluApproximationMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v9::GridSample::InterpolationMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v9::GridSample::PaddingMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::RecurrentSequenceDirection>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::shared_ptr<ov::Model> >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::vector<std::shared_ptr<ov::op::util::MultiSubGraphOp::InputDescription>, std::allocator<std::shared_ptr<ov::op::util::MultiSubGraphOp::InputDescription> > > >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::vector<std::shared_ptr<ov::op::util::MultiSubGraphOp::OutputDescription>, std::allocator<std::shared_ptr<ov::op::util::MultiSubGraphOp::OutputDescription> > > >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::vector<unsigned long, std::allocator<unsigned long> > >::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v4::Interpolate::InterpolateMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v4::Interpolate::ShapeCalcMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v4::Interpolate::CoordinateTransformMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v4::Interpolate::NearestMode>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<ov::op::v5::Loop::SpecialBodyPorts>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::LSTMWeightsFormat>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v8::MatrixNms::SortResultType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v8::MatrixNms::DecayFunction>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::MVNEpsMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v1::NonMaxSuppression::BoxEncodingType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v3::NonMaxSuppression::BoxEncodingType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v5::NonMaxSuppression::BoxEncodingType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v9::NonMaxSuppression::BoxEncodingType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::EpsMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::PadMode>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<ov::PartialShape>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v1::Reverse::Mode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v3::ROIAlign::PoolingMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v9::ROIAlign::PoolingMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v9::ROIAlign::AlignedMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v5::Round::RoundMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::v0::SpaceToDepth::SpaceToDepthMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::TopKMode>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::TopKSortType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::AutoBroadcastType>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::BroadcastType>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::vector<int, std::allocator<int> > >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<ov::op::util::FrameworkNodeAttrs>::set_as_any(ov::Any const&);
+template void ov::EnumAttributeAdapterBase<ov::op::util::MulticlassNmsBase::SortResultType>::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::shared_ptr<ngraph::runtime::AlignedBuffer> >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::vector<ov::element::Type, std::allocator<ov::element::Type> > >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<std::set<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >::set_as_any(ov::Any const&);
+template void ov::ValueAccessor<ov::Dimension>::set_as_any(ov::Any const&);
+#endif  // __clang__
diff --git a/src/inference/src/ie_system_conf.cpp b/src/inference/src/ie_system_conf.cpp
index 4e6a42536e..c6bcca4732 100644
--- a/src/inference/src/ie_system_conf.cpp
+++ b/src/inference/src/ie_system_conf.cpp
@@ -12,8 +12,11 @@
 
 #define XBYAK_NO_OP_NAMES
 #define XBYAK_UNDEF_JNL
+#ifdef __clang__
+#include <xbyak_util.h>
+#else
 #include <xbyak/xbyak_util.h>
-
+#endif
 namespace InferenceEngine {
 
 static Xbyak::util::Cpu& get_cpu_info() {
diff --git a/src/plugins/auto/plugin.hpp b/src/plugins/auto/plugin.hpp
index 6d2f6f37cd..7e07729d5e 100644
--- a/src/plugins/auto/plugin.hpp
+++ b/src/plugins/auto/plugin.hpp
@@ -28,7 +28,7 @@ namespace MultiDevicePlugin {
 class MultiDeviceInferencePlugin : public InferenceEngine::IInferencePlugin {
 public:
     MultiDeviceInferencePlugin();
-    ~MultiDeviceInferencePlugin() = default;
+    virtual ~MultiDeviceInferencePlugin() = default;
 
     InferenceEngine::IExecutableNetworkInternal::Ptr LoadExeNetworkImpl(const InferenceEngine::CNNNetwork&        network,
                                                                        const std::map<std::string, std::string>& config) override;
diff --git a/src/plugins/intel_cpu/cross-compiled/ANY/proposal_imp.cpp b/src/plugins/intel_cpu/cross-compiled/ANY/proposal_imp.cpp
new file mode 120000
index 0000000000..b171875524
--- /dev/null
+++ b/src/plugins/intel_cpu/cross-compiled/ANY/proposal_imp.cpp
@@ -0,0 +1 @@
+/home/ratnesh/openvino_exp/ov_22.3/src/plugins/intel_cpu/src/nodes/proposal_imp.cpp
\ No newline at end of file
diff --git a/src/plugins/intel_cpu/cross-compiled/AVX2/proposal_imp.cpp b/src/plugins/intel_cpu/cross-compiled/AVX2/proposal_imp.cpp
new file mode 120000
index 0000000000..b171875524
--- /dev/null
+++ b/src/plugins/intel_cpu/cross-compiled/AVX2/proposal_imp.cpp
@@ -0,0 +1 @@
+/home/ratnesh/openvino_exp/ov_22.3/src/plugins/intel_cpu/src/nodes/proposal_imp.cpp
\ No newline at end of file
diff --git a/src/plugins/intel_cpu/cross-compiled/proposal_imp_disp.cpp b/src/plugins/intel_cpu/cross-compiled/proposal_imp_disp.cpp
new file mode 100644
index 0000000000..fb37eb6b99
--- /dev/null
+++ b/src/plugins/intel_cpu/cross-compiled/proposal_imp_disp.cpp
@@ -0,0 +1,41 @@
+
+//
+// Auto generated file by CMake macros cross_compiled_file()
+// !! do not modify it !!!
+//
+#include "/home/ratnesh/openvino_exp/ov_22.3/src/plugins/intel_cpu/src/nodes/proposal_imp.hpp"
+#include "ie_system_conf.h"
+
+namespace InferenceEngine {
+namespace Extensions {
+namespace Cpu {
+namespace AVX2 {
+    void proposal_exec(const float* input0, const float* input1,
+        std::vector<size_t> dims0, std::array<float, 4> img_info,
+        const float* anchors, int* roi_indices,
+        float* output0, float* output1, proposal_conf &conf); 
+}
+namespace ANY {
+    void proposal_exec(const float* input0, const float* input1,
+        std::vector<size_t> dims0, std::array<float, 4> img_info,
+        const float* anchors, int* roi_indices,
+        float* output0, float* output1, proposal_conf &conf); 
+}
+namespace XARCH {
+
+void proposal_exec(const float* input0, const float* input1,
+        std::vector<size_t> dims0, std::array<float, 4> img_info,
+        const float* anchors, int* roi_indices,
+        float* output0, float* output1, proposal_conf &conf) {
+    if (with_cpu_x86_avx2()) {
+        return AVX2::proposal_exec(input0, input1, dims0, img_info, anchors, roi_indices, output0, output1, conf);
+    }
+    if (true) {
+        return ANY::proposal_exec(input0, input1, dims0, img_info, anchors, roi_indices, output0, output1, conf);
+    }
+}
+
+}
+}  // namespace InferenceEngine
+}  // namespace Extensions
+}  // namespace Cpu
diff --git a/src/plugins/intel_cpu/cross-compiled/proposal_imp_holder.txt b/src/plugins/intel_cpu/cross-compiled/proposal_imp_holder.txt
new file mode 100644
index 0000000000..45c7dffd7f
--- /dev/null
+++ b/src/plugins/intel_cpu/cross-compiled/proposal_imp_holder.txt
@@ -0,0 +1,16 @@
+# Copyright (C) 2018-2022 Intel Corporation
+# SPDX-License-Identifier: Apache-2.0
+#
+
+# =================================================================
+#
+# This file is used to add dependency on option value. If the args
+# was changes the configure file will be updated. And the dependent
+# add_custom_command will rerun.
+#
+# Otherwise the changing of CMake options will not have affect on
+# generated file.
+#
+# =================================================================
+
+
diff --git a/src/plugins/intel_cpu/src/emitters/jit_emitter.hpp b/src/plugins/intel_cpu/src/emitters/jit_emitter.hpp
index 74fe712ddd..c04a4ea965 100644
--- a/src/plugins/intel_cpu/src/emitters/jit_emitter.hpp
+++ b/src/plugins/intel_cpu/src/emitters/jit_emitter.hpp
@@ -26,6 +26,7 @@ enum emitter_in_out_map {
 // structure for storage of emitter parameters to hash in map
 struct emitter_params {
     virtual size_t hash() const = 0;
+    virtual ~emitter_params() = default;
 };
 
 struct emitter_context {
diff --git a/src/plugins/intel_cpu/src/emitters/jit_load_store_emitters.hpp b/src/plugins/intel_cpu/src/emitters/jit_load_store_emitters.hpp
index 9e3f264433..aa6fe0263d 100644
--- a/src/plugins/intel_cpu/src/emitters/jit_load_store_emitters.hpp
+++ b/src/plugins/intel_cpu/src/emitters/jit_load_store_emitters.hpp
@@ -26,6 +26,7 @@ struct load_emitter_params : public emitter_params {
     int load_num_;
     bool is_fill_;
     std::string fill_value_;
+    virtual ~load_emitter_params() = default;
 };
 
 struct store_emitter_params : public emitter_params {
@@ -37,6 +38,7 @@ struct store_emitter_params : public emitter_params {
     Precision src_prc_;
     Precision dst_prc_;
     int store_num_;
+    virtual ~store_emitter_params() = default;
 };
 
 // Arithmetic modes for data type conversion in store_emitter
diff --git a/src/plugins/intel_cpu/src/nodes/embedding_bag_sum.h b/src/plugins/intel_cpu/src/nodes/embedding_bag_sum.h
index c7dca23766..1d43116ee0 100644
--- a/src/plugins/intel_cpu/src/nodes/embedding_bag_sum.h
+++ b/src/plugins/intel_cpu/src/nodes/embedding_bag_sum.h
@@ -26,7 +26,7 @@ public:
     void execute(const uint8_t* srcData, const uint8_t* weightsData, const InferenceEngine::Precision &srcPrc,
                  const InferenceEngine::SizeVector& inDims, const MemoryPtr& outMemory);
 
-    ~EmbeddingBagSum() = default;
+    virtual ~EmbeddingBagSum() = default;
 
 protected:
     virtual void initFromInputs() = 0;
diff --git a/src/plugins/intel_cpu/src/nodes/rdft.h b/src/plugins/intel_cpu/src/nodes/rdft.h
index da177dec66..61bf9e5f6a 100644
--- a/src/plugins/intel_cpu/src/nodes/rdft.h
+++ b/src/plugins/intel_cpu/src/nodes/rdft.h
@@ -27,6 +27,7 @@ struct RDFTExecutor {
         std::vector<std::vector<float>> generateTwiddles(const std::vector<int>& signalSizes,
                                                          const std::vector<size_t>& outputShape,
                                                          const std::vector<int>& axes);
+        virtual ~RDFTExecutor() = default;
 
     protected:
         bool isInverse;
diff --git a/src/plugins/intel_cpu/src/plugin.h b/src/plugins/intel_cpu/src/plugin.h
index fd09a57dee..fb5e93a9aa 100644
--- a/src/plugins/intel_cpu/src/plugin.h
+++ b/src/plugins/intel_cpu/src/plugin.h
@@ -21,7 +21,7 @@ namespace intel_cpu {
 class Engine : public InferenceEngine::IInferencePlugin {
 public:
     Engine();
-    ~Engine();
+    virtual ~Engine();
 
     std::shared_ptr<InferenceEngine::IExecutableNetworkInternal>
     LoadExeNetworkImpl(const InferenceEngine::CNNNetwork &network,
diff --git a/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference.hpp b/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference.hpp
index adeaec2717..e4a01ff509 100644
--- a/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference.hpp
+++ b/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference.hpp
@@ -29,6 +29,7 @@ public:
     virtual const ov::CoordinateDiff& get_pads_end() = 0;
 
     virtual const std::vector<int64_t>& get_input_ranks() = 0;
+    virtual ~IShapeInferCommon() = default;
 };
 
 std::shared_ptr<IShapeInferCommon> make_shape_inference(const std::shared_ptr<ngraph::Node>& op);
diff --git a/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference_cpu.hpp b/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference_cpu.hpp
index 710db869fc..4c95b987d2 100644
--- a/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference_cpu.hpp
+++ b/src/plugins/intel_cpu/src/utils/shape_inference/shape_inference_cpu.hpp
@@ -19,7 +19,7 @@ public:
     using port_mask_t = uint32_t;
 
 public:
-    ~IShapeInfer() = default;
+    virtual ~IShapeInfer() = default;
 
     /**
      * @brief This method actually performs all the necessary shape inference computations
@@ -63,6 +63,7 @@ public:
     const ov::CoordinateDiff& get_pads_end() override final { // NOLINT
         return m_emptyVec;
     }
+    virtual ~ShapeInferEmptyPads() = default;
 private:
     static const ov::CoordinateDiff m_emptyVec;
 };
@@ -75,7 +76,7 @@ constexpr IShapeInfer::port_mask_t FULL_PORT_MASK = 0xffffffff;
 
 class ShapeInferFactory {
 public:
-    ~ShapeInferFactory() = default;
+    virtual ~ShapeInferFactory() = default;
     virtual ShapeInferPtr makeShapeInfer() const = 0;
 };
 
-- 
2.17.1

