From c87900c15767c77303fba807c979d51ff9304f02 Mon Sep 17 00:00:00 2001
From: shivasku82 <shiva.kumara.rudrappa@intel.com>
Date: Wed, 2 Mar 2022 13:01:57 +0530
Subject: [PATCH] cache clone handle

Signed-off-by: shivasku82 <shiva.kumara.rudrappa@intel.com>
---
 include/VirtualFakeCamera3.h |  2 +-
 src/VirtualFakeCamera3.cpp   | 40 ++++++++++++++++++++++++++++++++----
 2 files changed, 37 insertions(+), 5 deletions(-)

diff --git a/include/VirtualFakeCamera3.h b/include/VirtualFakeCamera3.h
index c05c666..6ed4253 100644
--- a/include/VirtualFakeCamera3.h
+++ b/include/VirtualFakeCamera3.h
@@ -65,7 +65,7 @@ public:
                        std::atomic<socket::CameraSessionState> &state);
 #endif
     virtual ~VirtualFakeCamera3();
-
+buffer_handle_t GetBufferHandle(buffer_handle_t key);
     /****************************************************************************
 * VirtualCamera3 virtual overrides
      ***************************************************************************/
diff --git a/src/VirtualFakeCamera3.cpp b/src/VirtualFakeCamera3.cpp
index df4ccc5..00ef92a 100644
--- a/src/VirtualFakeCamera3.cpp
+++ b/src/VirtualFakeCamera3.cpp
@@ -54,6 +54,10 @@ buffer_handle_t bufferHandle;
 buffer_handle_t bufferHandle1;
 buffer_handle_t bufferHandle2;
 buffer_handle_t bufferHandle_3;
+struct bufferHandleMap {
+    buffer_handle_t bufferHandle;
+    buffer_handle_t key;
+}handleMap[20];
 namespace android {
 
 int32_t gSrcWidth;
@@ -141,6 +145,21 @@ VirtualFakeCamera3::VirtualFakeCamera3(int cameraId, struct hw_module_t *module,
     mJpegCompressor = NULL;
 }
 
+buffer_handle_t VirtualFakeCamera3::GetBufferHandle(buffer_handle_t key) {
+    for(size_t i = 0; i < 20; i++) {
+        if(handleMap[i].key  ==  key) {
+            //ALOGE("Shiva return existing pointer added index %d, and key %p",(int)i, key);
+            return handleMap[i].bufferHandle;
+        }
+        if(handleMap[i].key == NULL) {
+            handleMap[i].key = key;
+            handleMap[i].bufferHandle = native_handle_clone((buffer_handle_t )key);
+            //ALOGE("Shiva Newly added index %d, and key %p",(int)i, key);
+            return handleMap[i].bufferHandle;
+        }
+    }
+    return NULL;
+}
 VirtualFakeCamera3::~VirtualFakeCamera3() {
     for (size_t i = 0; i < CAMERA3_TEMPLATE_COUNT; i++) {
         if (mDefaultTemplates[i] != NULL) {
@@ -177,6 +196,10 @@ status_t VirtualFakeCamera3::openCamera(hw_device_t **device) {
     ALOGI(LOG_TAG "%s: E", __FUNCTION__);
     Mutex::Autolock l(mLock);
 
+for(size_t i = 0; i < 20; i++)
+{
+    handleMap[i].key = NULL;
+}
     return VirtualCamera3::openCamera(device);
 }
 
@@ -363,6 +386,11 @@ status_t VirtualFakeCamera3::closeCamera() {
     // stream. Need to be removed later once handle startPublication properly in
     // remote. If NO processCaptureRequest received between open and close then wait.
 
+for(size_t i = 0; i < 20; i++) {
+    if(   handleMap[i].key != NULL)
+        native_handle_close(handleMap[i].bufferHandle);
+    handleMap[i].key = NULL;
+}
     if (!mprocessCaptureRequestFlag) {
         ALOGV(LOG_TAG " %s: wait:..", __FUNCTION__);
         std::this_thread::sleep_for(2500ms);
@@ -1159,7 +1187,9 @@ status_t VirtualFakeCamera3::processCaptureRequest(camera3_capture_request *requ
             if (srcBuf.stream->format == HAL_PIXEL_FORMAT_YCbCr_420_888) {
                 if (destBuf.format == HAL_PIXEL_FORMAT_YCbCr_420_888) {
                     android_ycbcr ycbcr = android_ycbcr();
-                    bufferHandle2 = native_handle_clone(*(destBuf.buffer));
+		    //ALOGE("Shiva its HAL_PIXEL_FORMAT_YCbCr_420_888 ");
+            //        bufferHandle2 = native_handle_clone(*(destBuf.buffer));
+            bufferHandle2 = GetBufferHandle(*(destBuf.buffer));
 #ifdef GRALLOC_MAPPER4
                     res = GrallocModule::getInstance().importBuffer(bufferHandle2, &bufferHandle1);
                     //res = GrallocModule::getInstance().importBuffer(*(destBuf.buffer), &bufferHandle1);
@@ -1186,7 +1216,9 @@ status_t VirtualFakeCamera3::processCaptureRequest(camera3_capture_request *requ
                 }
             } else {
 #ifdef GRALLOC_MAPPER4
-                bufferHandle_3 = native_handle_clone(*(destBuf.buffer)); 
+
+           //     bufferHandle_3 = native_handle_clone(*(destBuf.buffer)); 
+            bufferHandle_3 = GetBufferHandle(*(destBuf.buffer));
                 res = GrallocModule::getInstance().importBuffer(bufferHandle_3, &bufferHandle);
                 //res = GrallocModule::getInstance().importBuffer(*(destBuf.buffer), &bufferHandle);
                 if (res!= OK) {
@@ -1234,14 +1266,14 @@ status_t VirtualFakeCamera3::processCaptureRequest(camera3_capture_request *requ
         if (srcBuf.stream->format == HAL_PIXEL_FORMAT_YCbCr_420_888)
         {
            GrallocModule::getInstance().unlock(bufferHandle2);
-            native_handle_close(bufferHandle2);
+  //          native_handle_close(bufferHandle2);
            //GrallocModule::getInstance().release_handle(bufferHandle1);
            //GrallocModule::getInstance().unlock(bufferHandle1);
         }
         else
         {
            GrallocModule::getInstance().unlock(bufferHandle_3);
-            native_handle_close(bufferHandle_3);
+    //        native_handle_close(bufferHandle_3);
            //GrallocModule::getInstance().release_handle(bufferHandle);
            // GrallocModule::getInstance().unlock(bufferHandle);
         }
-- 
2.17.1

