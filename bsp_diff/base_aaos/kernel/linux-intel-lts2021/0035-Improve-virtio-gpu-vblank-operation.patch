From a171c8537e907545aa292604dfcfa1159b3f3ce3 Mon Sep 17 00:00:00 2001
From: "Xue, Bosheng" <bosheng.xue@intel.com>
Date: Fri, 22 Mar 2024 03:25:28 +0800
Subject: [PATCH] Improve virtio gpu vblank operation

set vblank on/off during atomic enable/disable
add vblank_get to protect vblank event operation

Signed-off-by: Xue, Bosheng <bosheng.xue@intel.com>
---
 drivers/gpu/drm/virtio/virtgpu_display.c | 20 ++++++++++-----
 drivers/gpu/drm/virtio/virtgpu_drv.c     |  1 +
 drivers/gpu/drm/virtio/virtgpu_drv.h     |  1 +
 drivers/gpu/drm/virtio/virtgpu_vq.c      | 31 ++++++++++++++++++++++++
 4 files changed, 47 insertions(+), 6 deletions(-)

diff --git a/drivers/gpu/drm/virtio/virtgpu_display.c b/drivers/gpu/drm/virtio/virtgpu_display.c
index f7cf13ee2a0f..335f9963efc1 100644
--- a/drivers/gpu/drm/virtio/virtgpu_display.c
+++ b/drivers/gpu/drm/virtio/virtgpu_display.c
@@ -54,6 +54,7 @@ static int virtio_irq_enable_vblank(struct drm_crtc *crtc)
 	struct virtio_gpu_device *vgdev = dev->dev_private;
 	struct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);
 
+	DRM_ERROR("bosheng enable vblank\n");
 	virtio_gpu_vblank_poll_arm(vgdev->vblank[output->index].vblank.vq);
 	virtqueue_enable_cb(vgdev->vblank[output->index].vblank.vq);
 	return 0;
@@ -65,6 +66,9 @@ static void virtio_irq_disable_vblank(struct drm_crtc *crtc)
 	struct virtio_gpu_device *vgdev;
 	vgdev = dev->dev_private;
 	struct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);
+	DRM_ERROR("bosheng disable vblank\n");
+
+	virtio_gpu_vblank_drain(vgdev->vblank[output->index].vblank.vq);
 
 	virtqueue_disable_cb(vgdev->vblank[output->index].vblank.vq);
 }
@@ -122,6 +126,8 @@ static void virtio_gpu_crtc_mode_set_nofb(struct drm_crtc *crtc)
 static void virtio_gpu_crtc_atomic_enable(struct drm_crtc *crtc,
 					  struct drm_atomic_state *state)
 {
+	DRM_ERROR("bosheng atomic enable\n");
+	drm_crtc_vblank_on(crtc);
 }
 
 static void virtio_gpu_crtc_atomic_disable(struct drm_crtc *crtc,
@@ -130,7 +136,9 @@ static void virtio_gpu_crtc_atomic_disable(struct drm_crtc *crtc,
 	struct drm_device *dev = crtc->dev;
 	struct virtio_gpu_device *vgdev = dev->dev_private;
 	struct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);
+	DRM_ERROR("bosheng atomic disable\n");
 
+	drm_crtc_vblank_off(crtc);
 	virtio_gpu_cmd_set_scanout(vgdev, output->index, 0, 0, 0, 0, 0);
 	virtio_gpu_notify(vgdev);
 }
@@ -149,16 +157,16 @@ static void virtio_gpu_crtc_atomic_flush(struct drm_crtc *crtc,
 	struct virtio_gpu_output *output = drm_crtc_to_virtio_gpu_output(crtc);
 	struct drm_device *drm = crtc->dev;
 
-	spin_lock_irq(&drm->event_lock);
-
-
 	if (crtc->state->event) {
-		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_lock_irq(&drm->event_lock);
+		if (drm_crtc_vblank_get(crtc) != 0)
+			drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		else
+			drm_crtc_arm_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irq(&drm->event_lock);
 		crtc->state->event = NULL;
 	}
 
-	spin_unlock_irq(&drm->event_lock);
-
 	/*
 	 * virtio-gpu can't do modeset and plane update operations
 	 * independent from each other.  So the actual modeset happens
diff --git a/drivers/gpu/drm/virtio/virtgpu_drv.c b/drivers/gpu/drm/virtio/virtgpu_drv.c
index 10a84c241b6c..4f0e9c3aead7 100644
--- a/drivers/gpu/drm/virtio/virtgpu_drv.c
+++ b/drivers/gpu/drm/virtio/virtgpu_drv.c
@@ -171,6 +171,7 @@ static int virtgpu_freeze(struct virtio_device *vdev)
 	struct virtio_gpu_device *vgdev = dev->dev_private;
 	int error;
 
+	DRM_ERROR("start to freezen\n");
 	error = drm_mode_config_helper_suspend(dev);
 	if (error) {
 		DRM_ERROR("suspend error %d\n", error);
diff --git a/drivers/gpu/drm/virtio/virtgpu_drv.h b/drivers/gpu/drm/virtio/virtgpu_drv.h
index 8f95c04cde77..6e50286ab775 100644
--- a/drivers/gpu/drm/virtio/virtgpu_drv.h
+++ b/drivers/gpu/drm/virtio/virtgpu_drv.h
@@ -409,6 +409,7 @@ virtio_gpu_cmd_resource_create_3d(struct virtio_gpu_device *vgdev,
 void virtio_gpu_ctrl_ack(struct virtqueue *vq);
 void virtio_gpu_cursor_ack(struct virtqueue *vq);
 void virtio_gpu_vblank_ack(struct virtqueue *vq);
+void virtio_gpu_vblank_drain(struct virtqueue *vq);
 void virtio_gpu_vblank_poll_arm(struct virtqueue *vq);
 void virtio_gpu_fence_ack(struct virtqueue *vq);
 void virtio_gpu_dequeue_ctrl_func(struct work_struct *work);
diff --git a/drivers/gpu/drm/virtio/virtgpu_vq.c b/drivers/gpu/drm/virtio/virtgpu_vq.c
index e1b68dbe07ea..890ba26e4f82 100644
--- a/drivers/gpu/drm/virtio/virtgpu_vq.c
+++ b/drivers/gpu/drm/virtio/virtgpu_vq.c
@@ -116,6 +116,37 @@ void virtio_gpu_vblank_ack(struct virtqueue *vq)
 
 }
 
+void virtio_gpu_vblank_drain(struct virtqueue *vq)
+{
+	struct drm_device *dev = vq->vdev->priv;
+	struct virtio_gpu_device *vgdev = dev->dev_private;
+	unsigned long irqflags;
+	unsigned int len;
+	unsigned int *ret_value;
+	int target = 0;
+	int vblank = 0;
+
+	while((target < vgdev->num_vblankq) && (vgdev->vblank[target].vblank.vq != vq)) {
+		target++;
+	}
+
+	while(vblank == 0) {
+	spin_lock_irqsave(&vgdev->vblank[target].vblank.qlock, irqflags);
+	if((ret_value = virtqueue_get_buf(vgdev->vblank[target].vblank.vq, &len)) != NULL) {
+
+		virtgpu_irqqueue_buf(vgdev->vblank[target].vblank.vq, ret_value);
+		vblank++;
+	}
+
+	spin_unlock_irqrestore(&vgdev->vblank[target].vblank.qlock, irqflags);
+	if (vblank) {
+		DRM_ERROR("bosheng drain vblank %d \n", vblank);
+		drm_handle_vblank(dev, target);
+	}
+	}
+}
+
+
 void virtio_gpu_cursor_ack(struct virtqueue *vq)
 {
 	struct drm_device *dev = vq->vdev->priv;
-- 
2.34.1

