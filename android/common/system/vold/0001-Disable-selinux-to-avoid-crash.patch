From 93e1b4f39cc922b372dae3ffa90a1e92eb7c1135 Mon Sep 17 00:00:00 2001
From: Hongcheng Xie <hongcheng.xie@intel.com>
Date: Thu, 3 Sep 2020 10:24:59 +0800
Subject: [PATCH] Disable selinux to avoid crash

Change-Id: I99160e943e38071f89c697e946ac2e7da655aa44
Signed-off-by: Hongcheng Xie <hongcheng.xie@intel.com>
---
 MetadataCrypt.cpp        |  4 ++++
 Utils.cpp                | 12 +++++++++++-
 cryptfs.cpp              |  8 +++++++-
 vold_prepare_subdirs.cpp |  4 ++++
 4 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/MetadataCrypt.cpp b/MetadataCrypt.cpp
index ca2813d2..4e06d67a 100644
--- a/MetadataCrypt.cpp
+++ b/MetadataCrypt.cpp
@@ -93,17 +93,21 @@ static bool mount_via_fs_mgr(const char* mount_point, const char* blk_device) {
 
     // fs_mgr_do_mount runs fsck. Use setexeccon to run trusted
     // partitions in the fsck domain.
+#ifndef _DISALBE_SELINUX_
     if (setexeccon(android::vold::sFsckContext)) {
         PLOG(ERROR) << "Failed to setexeccon";
         return false;
     }
+#endif
     auto mount_rc = fs_mgr_do_mount(&fstab_default, const_cast<char*>(mount_point),
                                     const_cast<char*>(blk_device), nullptr,
                                     android::vold::cp_needsCheckpoint(), true);
+#ifndef _DISALBE_SELINUX_
     if (setexeccon(nullptr)) {
         PLOG(ERROR) << "Failed to clear setexeccon";
         return false;
     }
+#endif
     if (mount_rc != 0) {
         LOG(ERROR) << "fs_mgr_do_mount failed with rc " << mount_rc;
         return false;
diff --git a/Utils.cpp b/Utils.cpp
index a9b7440f..c685c37c 100644
--- a/Utils.cpp
+++ b/Utils.cpp
@@ -102,12 +102,14 @@ status_t CreateDeviceNode(const std::string& path, dev_t dev) {
     const char* cpath = path.c_str();
     status_t res = 0;
 
+#ifndef _DISALBE_SELINUX_
     char* secontext = nullptr;
     if (sehandle) {
         if (!selabel_lookup(sehandle, &secontext, cpath, S_IFBLK)) {
             setfscreatecon(secontext);
         }
     }
+#endif
 
     mode_t mode = 0660 | S_IFBLK;
     if (mknod(cpath, mode, dev) < 0) {
@@ -118,10 +120,12 @@ status_t CreateDeviceNode(const std::string& path, dev_t dev) {
         }
     }
 
+#ifndef _DISALBE_SELINUX_
     if (secontext) {
         setfscreatecon(nullptr);
         freecon(secontext);
     }
+#endif
 
     return res;
 }
@@ -420,19 +424,23 @@ status_t PrepareDir(const std::string& path, mode_t mode, uid_t uid, gid_t gid)
     std::lock_guard<std::mutex> lock(kSecurityLock);
     const char* cpath = path.c_str();
 
+#ifndef _DISALBE_SELINUX_
     char* secontext = nullptr;
     if (sehandle) {
         if (!selabel_lookup(sehandle, &secontext, cpath, S_IFDIR)) {
             setfscreatecon(secontext);
         }
     }
+#endif
 
     int res = fs_prepare_dir(cpath, mode, uid, gid);
 
+#ifndef _DISALBE_SELINUX_
     if (secontext) {
         setfscreatecon(nullptr);
         freecon(secontext);
     }
+#endif
 
     if (res == 0) {
         return OK;
@@ -679,13 +687,15 @@ status_t ForkExecvp(const std::vector<std::string>& args, std::vector<std::strin
 
     pid_t pid = fork();
     if (pid == 0) {
+#ifndef _DISALBE_SELINUX_
         if (context) {
             if (setexeccon(context)) {
                 LOG(ERROR) << "Failed to setexeccon in ForkExecvp";
                 abort();
             }
         }
-        pipe_read.reset();
+#endif
+	pipe_read.reset();
         if (dup2(pipe_write.get(), STDOUT_FILENO) == -1) {
             PLOG(ERROR) << "dup2 in ForkExecvp";
             _exit(EXIT_FAILURE);
diff --git a/cryptfs.cpp b/cryptfs.cpp
index 8b7ac0ab..b4cf00f4 100644
--- a/cryptfs.cpp
+++ b/cryptfs.cpp
@@ -1615,6 +1615,7 @@ static int cryptfs_restart_internal(int restart_main) {
         int retries = RETRY_MOUNT_ATTEMPTS;
         int mount_rc;
 
+#ifndef _DISALBE_SELINUX_
         /*
          * fs_mgr_do_mount runs fsck. Use setexeccon to run trusted
          * partitions in the fsck domain.
@@ -1623,6 +1624,7 @@ static int cryptfs_restart_internal(int restart_main) {
             SLOGE("Failed to setexeccon");
             return -1;
         }
+#endif
         bool needs_cp = android::vold::cp_needsCheckpoint();
         while ((mount_rc = fs_mgr_do_mount(&fstab_default, DATA_MNT_POINT, crypto_blkdev, 0,
                                            needs_cp, false)) != 0) {
@@ -1643,16 +1645,20 @@ static int cryptfs_restart_internal(int restart_main) {
                 cryptfs_set_corrupt();
                 cryptfs_trigger_restart_min_framework();
                 SLOGI("Started framework to offer wipe");
+#ifndef _DISALBE_SELINUX_
                 if (setexeccon(NULL)) {
                     SLOGE("Failed to setexeccon");
                 }
-                return -1;
+#endif
+		return -1;
             }
         }
+#ifndef _DISALBE_SELINUX_
         if (setexeccon(NULL)) {
             SLOGE("Failed to setexeccon");
             return -1;
         }
+#endif
 
         /* Create necessary paths on /data */
         prep_data_fs();
diff --git a/vold_prepare_subdirs.cpp b/vold_prepare_subdirs.cpp
index d624d73b..6c3daab0 100644
--- a/vold_prepare_subdirs.cpp
+++ b/vold_prepare_subdirs.cpp
@@ -56,6 +56,7 @@ static bool valid_uuid(const std::string& s) {
 
 static bool prepare_dir(struct selabel_handle* sehandle, mode_t mode, uid_t uid, gid_t gid,
                         const std::string& path) {
+#ifndef _DISALBE_SELINUX_
     auto clearfscreatecon = android::base::make_scope_guard([] { setfscreatecon(nullptr); });
     auto secontext = std::unique_ptr<char, void (*)(char*)>(nullptr, freecon);
     char* tmp_secontext;
@@ -71,9 +72,11 @@ static bool prepare_dir(struct selabel_handle* sehandle, mode_t mode, uid_t uid,
             return false;
         }
     }
+#endif
     if (fs_prepare_dir(path.c_str(), mode, uid, gid) != 0) {
         return false;
     }
+#ifndef _DISALBE_SELINUX_
     if (secontext) {
         char* tmp_oldsecontext = nullptr;
         if (lgetfilecon(path.c_str(), &tmp_oldsecontext) < 0) {
@@ -90,6 +93,7 @@ static bool prepare_dir(struct selabel_handle* sehandle, mode_t mode, uid_t uid,
             }
         }
     }
+#endif
     return true;
 }
 
-- 
2.17.1

