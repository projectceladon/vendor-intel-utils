From 1ba69ccb437ce8b06a44a4f91187029476ec3941 Mon Sep 17 00:00:00 2001
From: Hongcheng Xie <hongcheng.xie@intel.com>
Date: Thu, 3 Sep 2020 10:33:37 +0800
Subject: [PATCH 01/11] Disable selinux to avoid crash

Change-Id: I4db370f15e32fdd97e83148e2bdcb80b293dca63
Signed-off-by: Hongcheng Xie <hongcheng.xie@intel.com>
---
 adb/daemon/main.cpp       |  2 ++
 init/builtins.cpp         |  6 ++++--
 init/devices.cpp          |  6 ++++++
 init/init.cpp             |  4 ++++
 init/property_service.cpp | 19 ++++++++++++++++++-
 init/selinux.cpp          |  2 ++
 init/service.cpp          |  6 ++++++
 init/subcontext.cpp       |  2 ++
 init/util.cpp             | 14 ++++++++++++++
 9 files changed, 58 insertions(+), 3 deletions(-)

diff --git a/adb/daemon/main.cpp b/adb/daemon/main.cpp
index 658e24456..0083bb053 100644
--- a/adb/daemon/main.cpp
+++ b/adb/daemon/main.cpp
@@ -153,9 +153,11 @@ static void drop_privileges(int server_port) {
         minijail_enter(jail.get());
 
         if (root_seclabel != nullptr) {
+#ifndef _DISALBE_SELINUX_
             if (selinux_android_setcon(root_seclabel) < 0) {
                 LOG(FATAL) << "Could not set SELinux context";
             }
+#endif
         }
         std::string error;
         std::string local_name =
diff --git a/init/builtins.cpp b/init/builtins.cpp
index 0ac66f272..a5c9f5d8d 100644
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -784,20 +784,22 @@ static Result<void> do_trigger(const BuiltinArguments& args) {
 }
 
 static int MakeSymlink(const std::string& target, const std::string& linkpath) {
+#ifndef _DISALBE_SELINUX_
     std::string secontext;
     // Passing 0 for mode should work.
     if (SelabelLookupFileContext(linkpath, 0, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+#endif
     int rc = symlink(target.c_str(), linkpath.c_str());
 
+#ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
-
+#endif
     return rc;
 }
 
diff --git a/init/devices.cpp b/init/devices.cpp
index 9fbec641b..d715f955f 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -247,6 +247,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     mode |= (block ? S_IFBLK : S_IFCHR);
 
     std::string secontext;
+#ifndef _DISALBE_SELINUX_
     if (!SelabelLookupFileContextBestMatch(path, links, mode, &secontext)) {
         PLOG(ERROR) << "Device '" << path << "' not created; cannot find SELinux label";
         return;
@@ -254,6 +255,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     if (!secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
+#endif
 
     dev_t dev = makedev(major, minor);
     /* Temporarily change egid to avoid race condition setting the gid of the
@@ -268,6 +270,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     /* If the node already exists update its SELinux label to handle cases when
      * it was created with the wrong context during coldboot procedure. */
     if (mknod(path.c_str(), mode, dev) && (errno == EEXIST) && !secontext.empty()) {
+#ifndef _DISALBE_SELINUX_
         char* fcon = nullptr;
         int rc = lgetfilecon(path.c_str(), &fcon);
         if (rc < 0) {
@@ -282,6 +285,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
             PLOG(ERROR) << "Cannot set '" << secontext << "' SELinux label on '" << path
                         << "' device";
         }
+#endif
     }
 
 out:
@@ -290,9 +294,11 @@ out:
         PLOG(FATAL) << "setegid(AID_ROOT) failed";
     }
 
+#ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
+#endif
 }
 
 // replaces any unacceptable characters with '_', the
diff --git a/init/init.cpp b/init/init.cpp
index 29859c5f5..fc1b43fd1 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -673,9 +673,11 @@ static void RecordStageBoottimes(const boot_clock::time_point& second_stage_star
 
     SetProperty("ro.boottime.init.first_stage",
                 std::to_string(selinux_start_time_ns - first_stage_start_time_ns));
+#ifndef _DISALBE_SELINUX_
     SetProperty("ro.boottime.init.selinux",
                 std::to_string(second_stage_start_time.time_since_epoch().count() -
                                selinux_start_time_ns));
+#endif
 }
 
 void SendLoadPersistentPropertiesMessage() {
@@ -749,10 +751,12 @@ int SecondStageMain(int argc, char** argv) {
     // Mount extra filesystems required during second stage init
     MountExtraFilesystems();
 
+#ifndef _DISALBE_SELINUX_
     // Now set up SELinux for second stage.
     SelinuxSetupKernelLogging();
     SelabelInitialize();
     SelinuxRestoreContext();
+#endif
 
     Epoll epoll;
     if (auto result = epoll.Open(); !result.ok()) {
diff --git a/init/property_service.cpp b/init/property_service.cpp
index a89504e59..ce7413611 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -147,6 +147,7 @@ bool CanReadProperty(const std::string& source_context, const std::string& name)
 
 static bool CheckMacPerms(const std::string& name, const char* target_context,
                           const char* source_context, const ucred& cr) {
+#ifndef _DISALBE_SELINUX_
     if (!target_context || !source_context) {
         return false;
     }
@@ -158,7 +159,9 @@ static bool CheckMacPerms(const std::string& name, const char* target_context,
 
     bool has_access = (selinux_check_access(source_context, target_context, "property_service",
                                             "set", &audit_data) == 0);
-
+#else
+    bool has_access = true;
+#endif
     return has_access;
 }
 
@@ -290,12 +293,14 @@ class SocketConnection {
     }
 
     bool GetSourceContext(std::string* source_context) const {
+#ifndef _DISALBE_SELINUX_
         char* c_source_context = nullptr;
         if (getpeercon(socket_, &c_source_context) != 0) {
             return false;
         }
         *source_context = c_source_context;
         freecon(c_source_context);
+#endif
         return true;
     }
 
@@ -416,7 +421,11 @@ bool CheckControlPropertyPerms(const std::string& name, const std::string& value
         property_info_area->GetPropertyInfo(control_string_legacy.c_str(), &target_context_legacy,
                                             &type_legacy);
 
+#ifndef _DISALBE_SELINUX_
         if (CheckMacPerms(control_string_legacy, target_context_legacy, source_context.c_str(), cr)) {
+#else
+        if (CheckMacPerms(control_string_legacy, target_context_legacy, NULL, cr)) {
+#endif
             return true;
         }
     }
@@ -427,7 +436,11 @@ bool CheckControlPropertyPerms(const std::string& name, const std::string& value
     property_info_area->GetPropertyInfo(control_string_full.c_str(), &target_context_full,
                                         &type_full);
 
+#ifndef _DISALBE_SELINUX_
     return CheckMacPerms(control_string_full, target_context_full, source_context.c_str(), cr);
+#else
+    return CheckMacPerms(control_string_full, target_context_full, NULL, cr);
+#endif
 }
 
 // This returns one of the enum of PROP_SUCCESS or PROP_ERROR*.
@@ -452,7 +465,11 @@ uint32_t CheckPermissions(const std::string& name, const std::string& value,
     const char* type = nullptr;
     property_info_area->GetPropertyInfo(name.c_str(), &target_context, &type);
 
+#ifndef _DISALBE_SELINUX_
     if (!CheckMacPerms(name, target_context, source_context.c_str(), cr)) {
+#else
+    if (!CheckMacPerms(name, target_context, NULL, cr)) {
+#endif
         *error = "SELinux permission check failed";
         return PROP_ERROR_PERMISSION_DENIED;
     }
diff --git a/init/selinux.cpp b/init/selinux.cpp
index 5a0255acd..a765b06fb 100644
--- a/init/selinux.cpp
+++ b/init/selinux.cpp
@@ -681,6 +681,7 @@ int SetupSelinux(char** argv) {
 
     MountMissingSystemPartitions();
 
+#ifndef _DISALBE_SELINUX_
     // Set up SELinux, loading the SELinux policy.
     SelinuxSetupKernelLogging();
     SelinuxInitialize();
@@ -692,6 +693,7 @@ int SetupSelinux(char** argv) {
     if (selinux_android_restorecon("/system/bin/init", 0) == -1) {
         PLOG(FATAL) << "restorecon failed of /system/bin/init failed";
     }
+#endif
 
     setenv(kEnvSelinuxStartedAt, std::to_string(start_time.time_since_epoch().count()).c_str(), 1);
 
diff --git a/init/service.cpp b/init/service.cpp
index 69f944eb2..10cce9950 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -62,6 +62,7 @@ using android::base::WriteStringToFile;
 namespace android {
 namespace init {
 
+#ifndef _DISALBE_SELINUX_
 static Result<std::string> ComputeContextFromExecutable(const std::string& service_path) {
     std::string computed_context;
 
@@ -97,6 +98,7 @@ static Result<std::string> ComputeContextFromExecutable(const std::string& servi
     }
     return computed_context;
 }
+#endif
 
 static bool ExpandArgsAndExecv(const std::vector<std::string>& args, bool sigstop) {
     std::vector<std::string> expanded_args;
@@ -236,11 +238,13 @@ void Service::SetProcessAttributesAndCaps() {
         LOG(FATAL) << "cannot set attribute for " << name_ << ": " << result.error();
     }
 
+#ifndef _DISALBE_SELINUX_
     if (!seclabel_.empty()) {
         if (setexeccon(seclabel_.c_str()) < 0) {
             PLOG(FATAL) << "cannot setexeccon('" << seclabel_ << "') for " << name_;
         }
     }
+#endif
 
     if (capabilities_) {
         if (!SetCapsForExec(*capabilities_)) {
@@ -445,6 +449,7 @@ Result<void> Service::Start() {
     }
 
     std::string scon;
+#ifndef _DISALBE_SELINUX_
     if (!seclabel_.empty()) {
         scon = seclabel_;
     } else {
@@ -454,6 +459,7 @@ Result<void> Service::Start() {
         }
         scon = *result;
     }
+#endif
 
     if (!AreRuntimeApexesReady() && !pre_apexd_) {
         // If this service is started before the Runtime and ART APEXes get
diff --git a/init/subcontext.cpp b/init/subcontext.cpp
index f3dd53826..ccd998583 100644
--- a/init/subcontext.cpp
+++ b/init/subcontext.cpp
@@ -206,6 +206,7 @@ void Subcontext::Fork() {
             PLOG(FATAL) << "Could not dup child_fd";
         }
 
+#ifndef _DISALBE_SELINUX_
         // We don't switch contexts if we're running the unit tests.  We don't use std::optional,
         // since we still need a real context string to pass to the builtin functions.
         if (context_ != kTestContext) {
@@ -213,6 +214,7 @@ void Subcontext::Fork() {
                 PLOG(FATAL) << "Could not set execcon for '" << context_ << "'";
             }
         }
+#endif
 
         auto init_path = GetExecutablePath();
         auto child_fd_string = std::to_string(child_fd);
diff --git a/init/util.cpp b/init/util.cpp
index 255434a1b..786de2ea5 100644
--- a/init/util.cpp
+++ b/init/util.cpp
@@ -88,18 +88,22 @@ Result<uid_t> DecodeUid(const std::string& name) {
  */
 Result<int> CreateSocket(const std::string& name, int type, bool passcred, mode_t perm, uid_t uid,
                          gid_t gid, const std::string& socketcon) {
+#ifndef _DISALBE_SELINUX_
     if (!socketcon.empty()) {
         if (setsockcreatecon(socketcon.c_str()) == -1) {
             return ErrnoError() << "setsockcreatecon(\"" << socketcon << "\") failed";
         }
     }
+#endif
 
     android::base::unique_fd fd(socket(PF_UNIX, type, 0));
     if (fd < 0) {
         return ErrnoError() << "Failed to open socket '" << name << "'";
     }
 
+#ifndef _DISALBE_SELINUX_
     if (!socketcon.empty()) setsockcreatecon(nullptr);
+#endif
 
     struct sockaddr_un addr;
     memset(&addr, 0 , sizeof(addr));
@@ -125,9 +129,11 @@ Result<int> CreateSocket(const std::string& name, int type, bool passcred, mode_
     int ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));
     int savederrno = errno;
 
+#ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
+#endif
 
     auto guard = android::base::make_scope_guard([&addr] { unlink(addr.sun_path); });
 
@@ -177,18 +183,22 @@ Result<std::string> ReadFile(const std::string& path) {
 }
 
 static int OpenFile(const std::string& path, int flags, mode_t mode) {
+#ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
+#endif
 
     int rc = open(path.c_str(), flags, mode);
 
+#ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
+#endif
 
     return rc;
 }
@@ -247,18 +257,22 @@ void ImportKernelCmdline(const std::function<void(const std::string&, const std:
 }
 
 bool make_dir(const std::string& path, mode_t mode) {
+#ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
+#endif
 
     int rc = mkdir(path.c_str(), mode);
 
+#ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
+#endif
 
     return rc == 0;
 }
-- 
2.17.1

