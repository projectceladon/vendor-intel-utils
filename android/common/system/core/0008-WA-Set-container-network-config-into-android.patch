From 9fa1707b4dc915ccc9625b1ac2cdd300689367f8 Mon Sep 17 00:00:00 2001
From: Hongcheng Xie <hongcheng.xie@intel.com>
Date: Thu, 23 Jul 2020 13:33:41 +0800
Subject: [PATCH] [WA] Set container network config into android

Auto detect container network config and set them to android
ethernet config file.
Port the implementation from android-entry as workaround for
no network issue.

Change-Id: Iea907ca309e0d785325883b17c16cb59ab526725
Signed-off-by: Hongcheng Xie <hongcheng.xie@intel.com>
---
 init/init.cpp | 123 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 123 insertions(+)

diff --git a/init/init.cpp b/init/init.cpp
index 3a8b827ef..b477c5e91 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -619,6 +619,127 @@ static void HandlePropertyFd() {
     }
 }
 
+
+static void write_strlen(int len, FILE *file) {
+    unsigned char byte1 = 0xff & (len>>8);
+    unsigned char byte2 = 0xff & len;
+    fwrite(&byte1, 1, 1, file);
+    fwrite(&byte2, 1, 1, file);
+}
+
+static void update_ipconfig() {
+    int file_version = htonl(2);
+    int key_extra = -1;
+    const char *ip_assignment_key = "ipAssignment";
+    const char *link_address_key = "linkAddress";
+    const char *static_key = "STATIC";
+    const char *gateway_key = "gateway";
+    const char *dns_key = "dns";
+    const char *id_key = "id";
+    const char *eos = "eos";
+
+    char ipconfig_file_path[256];
+    char pod_ip[64];
+    char pod_dns_ip[64];
+    char pod_gateway_ip[64];
+
+    FILE *output;
+
+    struct stat sb;
+    if (!(stat("/data/misc/ethernet", &sb) == 0 && S_ISDIR(sb.st_mode))) {
+        LOG(ERROR) << "/data/misc/ethernet not existed, create it first..";
+        mkdir("/data/misc", 1771);
+        mkdir("/data/misc/ethernet", 0770);
+        if (chown("/data/misc", 1000, 9998) || chown("/data/misc/ethernet", 1000, 1000)) {
+            LOG(ERROR) << "chown for /data/misc error!";
+        }
+    }
+
+    strcpy(ipconfig_file_path, "/data/misc/ethernet/ipconfig.txt");
+    FILE *ipconfig_file = fopen(ipconfig_file_path, "w");
+    if (!ipconfig_file) {
+        LOG(ERROR) << "Failed to open ipconfig file: " << ipconfig_file_path;
+        return;
+    }
+
+    std::string cmd = "ifconfig eth0 | grep -E \"([0-9]{1,3}\\.){3}[0-9]{1,3}\" | sed \"s/^[ \t]*//g\" | cut -f2 -d \" \" | cut -f2 -d \":\" | tr -d \"\\n\"";
+    output = popen(cmd.c_str(), "r");
+    if (!output) {
+        LOG(ERROR) << "Failed to run popen";
+        pclose(output);
+    }
+
+    if (fgets(pod_ip, 64, output) == NULL) {
+        LOG(ERROR) << "Failed to copy ip address";
+    }
+    pclose(output);
+
+    cmd = "cat /etc/resolv.conf | grep \"nameserver\" -m1 | cut -f2 -d \" \" | tr -d \"\\n\"";
+    output = popen(cmd.c_str(), "r");
+    if (!output) {
+        LOG(ERROR) << "Failed to run popen";
+        pclose(output);
+    }
+
+    if (fgets(pod_dns_ip, 64, output) == NULL) {
+        LOG(ERROR) << "Failed to copy dns ip address";
+    }
+    pclose(output);
+
+    cmd = "ip route | grep \"default\" | cut -f3 -d \" \" | tr -d \"\\n\"";
+    output = popen(cmd.c_str(), "r");
+    if (!output) {
+        LOG(ERROR) << "Failed to run popen";
+        pclose(output);
+    }
+
+    if (fgets(pod_gateway_ip, 64, output) == NULL) {
+        LOG(ERROR) << "Failed to copy gateway address";
+    }
+    pclose(output);
+
+    fwrite(&file_version, sizeof(int), 1, ipconfig_file);
+
+    write_strlen(strlen(ip_assignment_key), ipconfig_file);
+    fwrite(ip_assignment_key, sizeof(char), strlen(ip_assignment_key), ipconfig_file);
+
+    write_strlen(strlen(static_key), ipconfig_file);
+    fwrite(static_key, sizeof(char), strlen(static_key), ipconfig_file);
+
+    write_strlen(strlen(link_address_key), ipconfig_file);
+    fwrite(link_address_key, sizeof(char), strlen(link_address_key), ipconfig_file);
+    write_strlen(strlen(pod_ip), ipconfig_file);
+    fwrite(pod_ip, sizeof(char), strlen(pod_ip), ipconfig_file);
+    key_extra = htonl(16);
+    fwrite(&key_extra, sizeof(int), 1, ipconfig_file);
+
+    write_strlen(strlen(gateway_key), ipconfig_file);
+    fwrite(gateway_key, sizeof(char), strlen(gateway_key), ipconfig_file);
+    key_extra = htonl(0);
+    fwrite(&key_extra, sizeof(int), 1, ipconfig_file);
+    key_extra = htonl(1);
+    fwrite(&key_extra, sizeof(int), 1, ipconfig_file);
+
+    write_strlen(strlen(pod_gateway_ip), ipconfig_file);
+    fwrite(pod_gateway_ip, sizeof(char), strlen(pod_gateway_ip), ipconfig_file);
+
+    write_strlen(strlen(dns_key), ipconfig_file);
+    fwrite(dns_key, sizeof(char), strlen(dns_key), ipconfig_file);
+    write_strlen(strlen(pod_dns_ip), ipconfig_file);
+    fwrite(pod_dns_ip, sizeof(char), strlen(pod_dns_ip), ipconfig_file);
+
+    write_strlen(strlen(id_key), ipconfig_file);
+    fwrite(id_key, sizeof(char), strlen(id_key), ipconfig_file);
+
+    key_extra = htonl(0);
+    fwrite(&key_extra, sizeof(int), 1, ipconfig_file);
+
+    write_strlen(strlen(eos), ipconfig_file);
+    fwrite(eos, sizeof(char), strlen(eos), ipconfig_file);
+
+    fclose(ipconfig_file);
+}
+
 int SecondStageMain(int argc, char** argv) {
     if (REBOOT_BOOTLOADER_ON_PANIC) {
         InstallRebootSignalHandlers();
@@ -772,6 +893,8 @@ int SecondStageMain(int argc, char** argv) {
     // Run all property triggers based on current state of the properties.
     am.QueueBuiltinAction(queue_property_triggers_action, "queue_property_triggers");
 
+    update_ipconfig();
+
     while (true) {
         // By default, sleep until something happens.
         auto epoll_timeout = std::optional<std::chrono::milliseconds>{};
-- 
2.17.1

