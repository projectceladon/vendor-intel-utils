From 431ae9ef22d6a110ee8570416a0068e571526991 Mon Sep 17 00:00:00 2001
From: Xie Chao <chao.xie@intel.com>
Date: Fri, 19 Jul 2019 11:20:39 +0800
Subject: [PATCH] Tmp patch to disable selinux, it should be reverted

Change-Id: I3490e5dd4648aa3e44784eab5cdb56cae477f3df
Tracked-On:
Signed-off-by: Xie Chao <chao.xie@intel.com>
Signed-off-by: Hongcheng Xie <hongcheng.xie@intel.com>
---
 ServiceManager.cpp | 24 ++++++++++++++++++++++++
 ServiceManager.h   |  2 ++
 2 files changed, 26 insertions(+)

diff --git a/ServiceManager.cpp b/ServiceManager.cpp
index 991dc36..8d7c693 100644
--- a/ServiceManager.cpp
+++ b/ServiceManager.cpp
@@ -265,9 +265,11 @@ Return<sp<IBase>> ServiceManager::get(const hidl_string& hidlFqName,
     const std::string fqName = hidlFqName;
     const std::string name = hidlName;
 
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canGet(fqName, getBinderCallingContext())) {
         return nullptr;
     }
+#endif
 
     HidlService* hidlService = lookup(fqName, name);
     if (hidlService == nullptr) {
@@ -306,10 +308,12 @@ Return<bool> ServiceManager::add(const hidl_string& name, const sp<IBase>& servi
 
     auto pidcon = getBinderCallingContext();
 
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canAdd(IBase::descriptor, pidcon)) {
         LOG(ERROR) << "Missing permissions to add IBase";
         return false;
     }
+#endif
 
     auto ret = service->interfaceChain([&](const auto &interfaceChain) {
         addSuccess = addImpl(name, service, interfaceChain, pidcon);
@@ -332,6 +336,7 @@ bool ServiceManager::addImpl(const std::string& name,
         return false;
     }
 
+#ifndef _DISALBE_SELINUX_
     // First, verify you're allowed to add() the whole interface hierarchy
     for(size_t i = 0; i < interfaceChain.size(); i++) {
         const std::string fqName = interfaceChain[i];
@@ -340,6 +345,7 @@ bool ServiceManager::addImpl(const std::string& name,
             return false;
         }
     }
+#endif
 
     // Detect duplicate registration
     if (interfaceChain.size() > 1) {
@@ -409,9 +415,11 @@ Return<ServiceManager::Transport> ServiceManager::getTransport(const hidl_string
                                                                const hidl_string& name) {
     using ::android::hardware::getTransport;
 
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canGet(fqName, getBinderCallingContext())) {
         return Transport::EMPTY;
     }
+#endif
 
     switch (getTransport(fqName, name)) {
         case vintf::Transport::HWBINDER:
@@ -425,10 +433,12 @@ Return<ServiceManager::Transport> ServiceManager::getTransport(const hidl_string
 }
 
 Return<void> ServiceManager::list(list_cb _hidl_cb) {
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canList(getBinderCallingContext())) {
         _hidl_cb({});
         return Void();
     }
+#endif
 
     hidl_vec<hidl_string> list;
 
@@ -446,10 +456,12 @@ Return<void> ServiceManager::list(list_cb _hidl_cb) {
 
 Return<void> ServiceManager::listByInterface(const hidl_string& fqName,
                                              listByInterface_cb _hidl_cb) {
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canGet(fqName, getBinderCallingContext())) {
         _hidl_cb({});
         return Void();
     }
+#endif
 
     auto ifaceIt = mServiceMap.find(fqName);
     if (ifaceIt == mServiceMap.end()) {
@@ -489,9 +501,11 @@ Return<bool> ServiceManager::registerForNotifications(const hidl_string& fqName,
         return false;
     }
 
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canGet(fqName, getBinderCallingContext())) {
         return false;
     }
+#endif
 
     PackageInterfaceMap &ifaceMap = mServiceMap[fqName];
 
@@ -571,9 +585,11 @@ Return<bool> ServiceManager::registerClientCallback(const hidl_string& hidlFqNam
 
     // only the server of the interface can register a client callback
     pid_t pid = IPCThreadState::self()->getCallingPid();
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canAdd(fqName, getBinderCallingContext())) {
         return false;
     }
+#endif
 
     HidlService* registered = lookup(fqName, name);
 
@@ -644,10 +660,12 @@ Return<bool> ServiceManager::addWithChain(const hidl_string& name,
 
 Return<void> ServiceManager::listManifestByInterface(const hidl_string& fqName,
                                                      listManifestByInterface_cb _hidl_cb) {
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canGet(fqName, getBinderCallingContext())) {
         _hidl_cb({});
         return Void();
     }
+#endif
 
     std::set<std::string> instances = getInstances(fqName);
     hidl_vec<hidl_string> ret(instances.begin(), instances.end());
@@ -666,9 +684,11 @@ Return<bool> ServiceManager::tryUnregister(const hidl_string& hidlFqName,
         return false;
     }
 
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canAdd(fqName, getBinderCallingContext())) {
         return false;
     }
+#endif
 
     HidlService* registered = lookup(fqName, name);
 
@@ -714,10 +734,12 @@ Return<bool> ServiceManager::tryUnregister(const hidl_string& hidlFqName,
 }
 
 Return<void> ServiceManager::debugDump(debugDump_cb _cb) {
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canList(getBinderCallingContext())) {
         _cb({});
         return Void();
     }
+#endif
 
     std::vector<IServiceManager::InstanceDebugInfo> list;
     forEachServiceEntry([&] (const HidlService *service) {
@@ -749,6 +771,7 @@ Return<void> ServiceManager::registerPassthroughClient(const hidl_string &fqName
         const hidl_string &name) {
     auto callingContext = getBinderCallingContext();
 
+#ifndef _DISALBE_SELINUX_
     if (!mAcl.canGet(fqName, callingContext)) {
         /* We guard this function with "get", because it's typically used in
          * the getService() path, albeit for a passthrough service in this
@@ -756,6 +779,7 @@ Return<void> ServiceManager::registerPassthroughClient(const hidl_string &fqName
          */
         return Void();
     }
+#endif
 
     PackageInterfaceMap &ifaceMap = mServiceMap[fqName];
 
diff --git a/ServiceManager.h b/ServiceManager.h
index 38bda57..ea644cc 100644
--- a/ServiceManager.h
+++ b/ServiceManager.h
@@ -143,7 +143,9 @@ private:
         std::vector<sp<IServiceNotification>> mPackageListeners{};
     };
 
+#ifndef _DISALBE_SELINUX_
     AccessControl mAcl;
+#endif
 
     /**
      * Access to this map doesn't need to be locked, since hwservicemanager
-- 
2.17.1

