From d7bce7dde6e3eea0dab95bebfbf77e50b9fcc3ee Mon Sep 17 00:00:00 2001
From: Hongcheng Xie <hongcheng.xie@intel.com>
Date: Tue, 28 Jul 2020 09:05:59 +0800
Subject: [PATCH] Disable selinux to avoid crash

Change-Id: I628f4376a1a377fa2ee9ccd97b0179209f6be2c2
Signed-off-by: Hongcheng Xie <hongcheng.xie@intel.com>
---
 cmds/installd/InstalldNativeService.cpp | 30 +++++++++++++++++++++++--
 cmds/servicemanager/Access.cpp          |  2 ++
 2 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/cmds/installd/InstalldNativeService.cpp b/cmds/installd/InstalldNativeService.cpp
index b9c1addf8..42084b60c 100644
--- a/cmds/installd/InstalldNativeService.cpp
+++ b/cmds/installd/InstalldNativeService.cpp
@@ -321,6 +321,12 @@ status_t InstalldNativeService::dump(int fd, const Vector<String16> & /* args */
 static int restorecon_app_data_lazy(const std::string& path, const std::string& seInfo, uid_t uid,
         bool existing) {
     int res = 0;
+#ifdef _DISALBE_SELINUX_
+    (void) path;
+    (void) seInfo;
+    (void) uid;
+    (void) existing;
+#else
     char* before = nullptr;
     char* after = nullptr;
 
@@ -360,6 +366,7 @@ fail:
 done:
     free(before);
     free(after);
+#endif
     return res;
 }
 
@@ -1198,10 +1205,12 @@ binder::Status InstalldNativeService::moveCompleteApp(const std::unique_ptr<std:
             goto fail;
         }
 
+#ifndef _DISALBE_SELINUX_
         if (selinux_android_restorecon(to_app_package_path.c_str(), SELINUX_ANDROID_RESTORECON_RECURSE) != 0) {
             res = error("Failed to restorecon " + to_app_package_path);
             goto fail;
         }
+#endif
     }
 
     // Copy private data for all known users
@@ -2458,10 +2467,12 @@ binder::Status InstalldNativeService::linkNativeLibraryDirectory(
         return error("Failed to stat " + _pkgdir);
     }
 
+#ifndef _DISALBE_SELINUX_
     char *con = nullptr;
     if (lgetfilecon(pkgdir, &con) < 0) {
         return error("Failed to lgetfilecon " + _pkgdir);
     }
+#endif
 
     if (chown(pkgdir, AID_INSTALL, AID_INSTALL) < 0) {
         res = error("Failed to chown " + _pkgdir);
@@ -2497,13 +2508,16 @@ binder::Status InstalldNativeService::linkNativeLibraryDirectory(
         goto out;
     }
 
+#ifndef _DISALBE_SELINUX_
     if (lsetfilecon(libsymlink, con) < 0) {
         res = error("Failed to lsetfilecon " + _libsymlink);
         goto out;
     }
-
+#endif
 out:
+#ifndef _DISALBE_SELINUX_
     free(con);
+#endif
     if (chmod(pkgdir, s.st_mode) < 0) {
         auto msg = "Failed to cleanup chmod " + _pkgdir;
         if (res.isOk()) {
@@ -2534,25 +2548,35 @@ binder::Status InstalldNativeService::restoreconAppData(const std::unique_ptr<st
     std::lock_guard<std::recursive_mutex> lock(mLock);
 
     binder::Status res = ok();
-
+#ifdef _DISALBE_SELINUX_
+    (void) appId;
+    (void) seInfo;
+#else
     // SELINUX_ANDROID_RESTORECON_DATADATA flag is set by libselinux. Not needed here.
     unsigned int seflags = SELINUX_ANDROID_RESTORECON_RECURSE;
+#endif
     const char* uuid_ = uuid ? uuid->c_str() : nullptr;
     const char* pkgName = packageName.c_str();
+#ifndef _DISALBE_SELINUX_
     const char* seinfo = seInfo.c_str();
 
     uid_t uid = multiuser_get_uid(userId, appId);
+#endif
     if (flags & FLAG_STORAGE_CE) {
         auto path = create_data_user_ce_package_path(uuid_, userId, pkgName);
+#ifndef _DISALBE_SELINUX_
         if (selinux_android_restorecon_pkgdir(path.c_str(), seinfo, uid, seflags) < 0) {
             res = error("restorecon failed for " + path);
         }
+#endif
     }
     if (flags & FLAG_STORAGE_DE) {
         auto path = create_data_user_de_package_path(uuid_, userId, pkgName);
+#ifndef _DISALBE_SELINUX_
         if (selinux_android_restorecon_pkgdir(path.c_str(), seinfo, uid, seflags) < 0) {
             res = error("restorecon failed for " + path);
         }
+#endif
     }
     return res;
 }
@@ -2573,9 +2597,11 @@ binder::Status InstalldNativeService::createOatDir(const std::string& oatDir,
     if (fs_prepare_dir(oat_dir, S_IRWXU | S_IRWXG | S_IXOTH, AID_SYSTEM, AID_INSTALL)) {
         return error("Failed to prepare " + oatDir);
     }
+#ifndef _DISALBE_SELINUX_
     if (selinux_android_restorecon(oat_dir, 0)) {
         return error("Failed to restorecon " + oatDir);
     }
+#endif
     snprintf(oat_instr_dir, PKG_PATH_MAX, "%s/%s", oat_dir, instruction_set);
     if (fs_prepare_dir(oat_instr_dir, S_IRWXU | S_IRWXG | S_IXOTH, AID_SYSTEM, AID_INSTALL)) {
         return error(StringPrintf("Failed to prepare %s", oat_instr_dir));
diff --git a/cmds/servicemanager/Access.cpp b/cmds/servicemanager/Access.cpp
index b7e520f2f..c4b537d82 100644
--- a/cmds/servicemanager/Access.cpp
+++ b/cmds/servicemanager/Access.cpp
@@ -88,9 +88,11 @@ Access::Access() {
     cb.func_log = kIsVendor ? selinux_vendor_log_callback : selinux_log_callback;
     selinux_set_callback(SELINUX_CB_LOG, cb);
 
+#ifndef _DISALBE_SELINUX_
     CHECK(selinux_status_open(true /*fallback*/) >= 0);
 
     CHECK(getcon(&mThisProcessContext) == 0);
+#endif
 }
 
 Access::~Access() {
-- 
2.17.1

