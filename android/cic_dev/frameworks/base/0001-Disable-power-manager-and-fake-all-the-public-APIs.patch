From 4cb29a6390aba8b6840e972810f3863ac701edf5 Mon Sep 17 00:00:00 2001
From: bxu10x <bingx.xu@intel.com>
Date: Wed, 23 Sep 2020 10:20:01 +0800
Subject: [PATCH] Disable power manager and fake all the public APIs

Change-Id: Ib65cd37655b411fffce768f3b3831f60fa032ea0
Signed-off-by: Tong Bo <bo.tong@intel.com>
Signed-off-by: bxu10x <bingx.xu@intel.com>
---
 core/java/android/os/PowerManager.java        | 82 +++++++++++++++++++
 .../server/power/PowerManagerService.java     | 20 +++++
 2 files changed, 102 insertions(+)

diff --git a/core/java/android/os/PowerManager.java b/core/java/android/os/PowerManager.java
index 9c258487447..a53090ff9e4 100644
--- a/core/java/android/os/PowerManager.java
+++ b/core/java/android/os/PowerManager.java
@@ -107,6 +107,7 @@ import java.lang.annotation.RetentionPolicy;
 @SystemService(Context.POWER_SERVICE)
 public final class PowerManager {
     private static final String TAG = "PowerManager";
+    private static final String ENABLE_POWER_PROPERTY = "enable.power";
 
     /* NOTE: Wake lock levels were previously defined as a bit field, except that only a few
      * combinations were actually supported so the bit field was removed.  This explains
@@ -610,6 +611,7 @@ public final class PowerManager {
     final Context mContext;
     final IPowerManager mService;
     final Handler mHandler;
+    final boolean mPowerManagerDisabled;
 
     IDeviceIdleController mIDeviceIdleController;
 
@@ -620,6 +622,10 @@ public final class PowerManager {
         mContext = context;
         mService = service;
         mHandler = handler;
+        mPowerManagerDisabled = !SystemProperties.getBoolean(ENABLE_POWER_PROPERTY, false);
+        if (mPowerManagerDisabled) {
+            Log.w(TAG, "PowerManager disabled, fake all the public APIs!");
+        }
     }
 
     /**
@@ -809,6 +815,9 @@ public final class PowerManager {
      */
     @Deprecated
     public void userActivity(long when, boolean noChangeLights) {
+        if (mPowerManagerDisabled) {
+               return;
+        }
         userActivity(when, USER_ACTIVITY_EVENT_OTHER,
                 noChangeLights ? USER_ACTIVITY_FLAG_NO_CHANGE_LIGHTS : 0);
     }
@@ -895,6 +904,9 @@ public final class PowerManager {
      * @hide Requires signature permission.
      */
     public void goToSleep(long time, int reason, int flags) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.goToSleep(time, reason, flags);
         } catch (RemoteException e) {
@@ -922,6 +934,9 @@ public final class PowerManager {
      * @removed Requires signature permission.
      */
     public void wakeUp(long time) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.wakeUp(time, "wakeUp", mContext.getOpPackageName());
         } catch (RemoteException e) {
@@ -933,6 +948,9 @@ public final class PowerManager {
      * @hide
      */
     public void wakeUp(long time, String reason) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.wakeUp(time, reason, mContext.getOpPackageName());
         } catch (RemoteException e) {
@@ -963,6 +981,9 @@ public final class PowerManager {
      */
     @TestApi
     public void nap(long time) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.nap(time);
         } catch (RemoteException e) {
@@ -986,6 +1007,9 @@ public final class PowerManager {
      * @hide Requires signature permission.
      */
     public void boostScreenBrightness(long time) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.boostScreenBrightness(time);
         } catch (RemoteException e) {
@@ -1014,6 +1038,9 @@ public final class PowerManager {
      * @return True if the specified wake lock level is supported.
      */
     public boolean isWakeLockLevelSupported(int level) {
+        if (mPowerManagerDisabled) {
+            return false;
+        }
         try {
             return mService.isWakeLockLevelSupported(level);
         } catch (RemoteException e) {
@@ -1078,6 +1105,9 @@ public final class PowerManager {
      * @see android.content.Intent#ACTION_SCREEN_OFF
      */
     public boolean isInteractive() {
+        if (mPowerManagerDisabled) {
+            return true;
+        }
         try {
             return mService.isInteractive();
         } catch (RemoteException e) {
@@ -1095,6 +1125,9 @@ public final class PowerManager {
      *               request special boot modes, or null.
      */
     public void reboot(String reason) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.reboot(false, reason, true);
         } catch (RemoteException e) {
@@ -1110,6 +1143,9 @@ public final class PowerManager {
      * @hide
      */
     public void rebootSafeMode() {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.rebootSafeMode(false, true);
         } catch (RemoteException e) {
@@ -1126,6 +1162,9 @@ public final class PowerManager {
      * @return Returns true if currently in low power mode, else false.
      */
     public boolean isPowerSaveMode() {
+        if (mPowerManagerDisabled) {
+            return false;
+        }
         try {
             return mService.isPowerSaveMode();
         } catch (RemoteException e) {
@@ -1143,6 +1182,9 @@ public final class PowerManager {
      * @hide
      */
     public boolean setPowerSaveMode(boolean mode) {
+        if (mPowerManagerDisabled) {
+            return false;
+        }
         try {
             return mService.setPowerSaveMode(mode);
         } catch (RemoteException e) {
@@ -1160,6 +1202,13 @@ public final class PowerManager {
      * @see PowerSaveState
      */
     public PowerSaveState getPowerSaveState(@ServiceType int serviceType) {
+        if (mPowerManagerDisabled) {
+            final PowerSaveState.Builder builder = new PowerSaveState.Builder()
+                                                       .setGlobalBatterySaverEnabled(false)
+                                                       .setGpsMode(0)
+                                                       .setBatterySaverEnabled(false);
+            return builder.build();
+        }
         try {
             return mService.getPowerSaveState(serviceType);
         } catch (RemoteException e) {
@@ -1198,6 +1247,9 @@ public final class PowerManager {
      * restrictions have been lifted.
      */
     public boolean isDeviceIdleMode() {
+        if (mPowerManagerDisabled) {
+            return false;
+        }
         try {
             return mService.isDeviceIdleMode();
         } catch (RemoteException e) {
@@ -1218,6 +1270,9 @@ public final class PowerManager {
      * @hide
      */
     public boolean isLightDeviceIdleMode() {
+        if (mPowerManagerDisabled) {
+            return false;
+        }
         try {
             return mService.isLightDeviceIdleMode();
         } catch (RemoteException e) {
@@ -1254,6 +1309,9 @@ public final class PowerManager {
      * @hide
      */
     public void shutdown(boolean confirm, String reason, boolean wait) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.shutdown(confirm, reason, wait);
         } catch (RemoteException e) {
@@ -1287,6 +1345,9 @@ public final class PowerManager {
      * @hide
      */
     public void setDozeAfterScreenOff(boolean dozeAfterScreenOf) {
+        if (mPowerManagerDisabled) {
+            return;
+        }
         try {
             mService.setDozeAfterScreenOff(dozeAfterScreenOf);
         } catch (RemoteException e) {
@@ -1303,6 +1364,9 @@ public final class PowerManager {
      */
     @ShutdownReason
     public int getLastShutdownReason() {
+        if (mPowerManagerDisabled) {
+            return PowerManager.SHUTDOWN_REASON_UNKNOWN;
+        }
         try {
             return mService.getLastShutdownReason();
         } catch (RemoteException e) {
@@ -1429,6 +1493,9 @@ public final class PowerManager {
 
         @Override
         protected void finalize() throws Throwable {
+            if(mPowerManagerDisabled){
+                return;
+            }
             synchronized (mToken) {
                 if (mHeld) {
                     Log.wtf(TAG, "WakeLock finalized while still held: " + mTag);
@@ -1456,6 +1523,9 @@ public final class PowerManager {
          * make the wake lock non-reference counted.
          */
         public void setReferenceCounted(boolean value) {
+            if(mPowerManagerDisabled){
+                return;
+            }
             synchronized (mToken) {
                 mRefCounted = value;
             }
@@ -1469,6 +1539,9 @@ public final class PowerManager {
          * </p>
          */
         public void acquire() {
+            if(mPowerManagerDisabled){
+                return;
+            }
             synchronized (mToken) {
                 acquireLocked();
             }
@@ -1538,6 +1611,9 @@ public final class PowerManager {
          * Passing 0 is equivalent to calling {@link #release()}.
          */
         public void release(int flags) {
+            if(mPowerManagerDisabled){
+                return;
+            }
             synchronized (mToken) {
                 if (mInternalCount > 0) {
                     // internal count must only be decreased if it is > 0 or state of
@@ -1571,6 +1647,9 @@ public final class PowerManager {
          * @return True if the wake lock is held.
          */
         public boolean isHeld() {
+            if(mPowerManagerDisabled){
+                return true;
+            }
             synchronized (mToken) {
                 return mHeld;
             }
@@ -1595,6 +1674,9 @@ public final class PowerManager {
          * @param ws The work source, or null if none.
          */
         public void setWorkSource(WorkSource ws) {
+            if(mPowerManagerDisabled){
+                return;
+            }
             synchronized (mToken) {
                 if (ws != null && ws.isEmpty()) {
                     ws = null;
diff --git a/services/core/java/com/android/server/power/PowerManagerService.java b/services/core/java/com/android/server/power/PowerManagerService.java
index 697801f7787..412dd583552 100644
--- a/services/core/java/com/android/server/power/PowerManagerService.java
+++ b/services/core/java/com/android/server/power/PowerManagerService.java
@@ -221,6 +221,7 @@ public final class PowerManagerService extends SystemService
 
     // Persistent property for last reboot reason
     private static final String LAST_REBOOT_PROPERTY = "persist.sys.boot.reason";
+    private static final String ENABLE_POWER_PROPERTY = "enable.power";
 
     private final Context mContext;
     private final ServiceThread mHandlerThread;
@@ -459,6 +460,8 @@ public final class PowerManagerService extends SystemService
     private int mScreenBrightnessSettingMaximum;
     private int mScreenBrightnessSettingDefault;
 
+    private boolean mPowerManagerDisabled;
+
     // The screen brightness setting, from 0 to 255.
     // Use -1 if no value has been set.
     private int mScreenBrightnessSetting;
@@ -664,6 +667,8 @@ public final class PowerManagerService extends SystemService
         mBatterySaverStateMachine = new BatterySaverStateMachine(
                 mLock, mContext, mBatterySaverController);
 
+        mPowerManagerDisabled = !SystemProperties.getBoolean(ENABLE_POWER_PROPERTY, false);
+
         synchronized (mLock) {
             mWakeLockSuspendBlocker = createSuspendBlockerLocked("PowerManagerService.WakeLocks");
             mDisplaySuspendBlocker = createSuspendBlockerLocked("PowerManagerService.Display");
@@ -1897,6 +1902,9 @@ public final class PowerManagerService extends SystemService
     }
 
     void checkForLongWakeLocks() {
+        if(mPowerManagerDisabled){
+            return;
+        }
         synchronized (mLock) {
             final long now = SystemClock.uptimeMillis();
             mNotifyLongDispatched = now;
@@ -2061,6 +2069,9 @@ public final class PowerManagerService extends SystemService
      * bit and calling update power state.  Wakefulness transitions are handled elsewhere.
      */
     private void handleUserActivityTimeout() { // runs on handler thread
+        if(mPowerManagerDisabled){
+            return;
+        }
         synchronized (mLock) {
             if (DEBUG_SPEW) {
                 Slog.d(TAG, "handleUserActivityTimeout");
@@ -2203,6 +2214,9 @@ public final class PowerManagerService extends SystemService
         // Handle preconditions.
         final boolean startDreaming;
         final int wakefulness;
+        if(mPowerManagerDisabled){
+            return;
+        }
         synchronized (mLock) {
             mSandmanScheduled = false;
             wakefulness = mWakefulness;
@@ -3067,6 +3081,9 @@ public final class PowerManagerService extends SystemService
      * bit and calling update power state.
      */
     private void handleScreenBrightnessBoostTimeout() { // runs on handler thread
+        if(mPowerManagerDisabled){
+             return;
+        }
         synchronized (mLock) {
             if (DEBUG_SPEW) {
                 Slog.d(TAG, "handleScreenBrightnessBoostTimeout");
@@ -4048,6 +4065,9 @@ public final class PowerManagerService extends SystemService
 
         @Override
         public void acquire() {
+            if(mPowerManagerDisabled){
+                return;
+            }
             synchronized (this) {
                 mReferenceCount += 1;
                 if (mReferenceCount == 1) {
-- 
2.17.1

