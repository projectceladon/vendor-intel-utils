From 4a6b545de55b9e9609b020c7aa06d602f60e796b Mon Sep 17 00:00:00 2001
From: Bin Yang <bin.y.yang@intel.com>
Date: Thu, 14 May 2020 21:02:21 +0530
Subject: [PATCH] [Disable SELINUX] Tmp patch to disable selinux, it should be
 reverted

Change-Id: Idf45cf80c06e9fe133f61684cc0487032619a484
Tracked-On: N/A
Signed-off-by: Bin Yang <bin.y.yang@intel.com>
---
 adb/daemon/main.cpp       |  3 ++-
 init/builtins.cpp         |  7 ++++---
 init/devices.cpp          |  8 ++++++--
 init/init.cpp             |  4 ++++
 init/log.cpp              |  3 ++-
 init/property_service.cpp | 20 ++++++++++++++++----
 init/service.cpp          |  9 +++++++--
 init/subcontext.cpp       |  4 ++--
 init/util.cpp             | 27 ++++++++++++++++-----------
 9 files changed, 59 insertions(+), 26 deletions(-)

diff --git a/adb/daemon/main.cpp b/adb/daemon/main.cpp
index 5adeb4446..bff407ea5 100644
--- a/adb/daemon/main.cpp
+++ b/adb/daemon/main.cpp
@@ -152,12 +152,13 @@ static void drop_privileges(int server_port) {
     } else {
         // minijail_enter() will abort if any priv-dropping step fails.
         minijail_enter(jail.get());
-
+        #ifndef _DISALBE_SELINUX_
         if (root_seclabel != nullptr) {
             if (selinux_android_setcon(root_seclabel) < 0) {
                 LOG(FATAL) << "Could not set SELinux context";
             }
         }
+		#endif
         std::string error;
         std::string local_name =
             android::base::StringPrintf("tcp:%d", server_port);
diff --git a/init/builtins.cpp b/init/builtins.cpp
index 8bd92ccdd..e9d124aa7 100644
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -643,20 +643,21 @@ static Result<Success> do_trigger(const BuiltinArguments& args) {
 }
 
 static int MakeSymlink(const std::string& target, const std::string& linkpath) {
+	#ifndef _DISALBE_SELINUX_
     std::string secontext;
     // Passing 0 for mode should work.
     if (SelabelLookupFileContext(linkpath, 0, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     int rc = symlink(target.c_str(), linkpath.c_str());
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
-
+    #endif
     return rc;
 }
 
diff --git a/init/devices.cpp b/init/devices.cpp
index 751918fb5..5329fecf1 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -227,6 +227,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     mode |= (block ? S_IFBLK : S_IFCHR);
 
     std::string secontext;
+	#ifndef _DISALBE_SELINUX_
     if (!SelabelLookupFileContextBestMatch(path, links, mode, &secontext)) {
         PLOG(ERROR) << "Device '" << path << "' not created; cannot find SELinux label";
         return;
@@ -234,7 +235,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     if (!secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     dev_t dev = makedev(major, minor);
     /* Temporarily change egid to avoid race condition setting the gid of the
      * device node. Unforunately changing the euid would prevent creation of
@@ -248,6 +249,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     /* If the node already exists update its SELinux label to handle cases when
      * it was created with the wrong context during coldboot procedure. */
     if (mknod(path.c_str(), mode, dev) && (errno == EEXIST) && !secontext.empty()) {
+		#ifndef _DISALBE_SELINUX_
         char* fcon = nullptr;
         int rc = lgetfilecon(path.c_str(), &fcon);
         if (rc < 0) {
@@ -262,6 +264,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
             PLOG(ERROR) << "Cannot set '" << secontext << "' SELinux label on '" << path
                         << "' device";
         }
+		#endif
     }
 
 out:
@@ -269,10 +272,11 @@ out:
     if (setegid(AID_ROOT)) {
         PLOG(FATAL) << "setegid(AID_ROOT) failed";
     }
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
+	#endif
 }
 
 // replaces any unacceptable characters with '_', the
diff --git a/init/init.cpp b/init/init.cpp
index 228f7965c..337c82fb3 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -622,9 +622,11 @@ int main(int argc, char** argv) {
         // Enable seccomp if global boot option was passed (otherwise it is enabled in zygote).
         global_seccomp();
 
+		#ifndef _DISALBE_SELINUX_
         // Set up SELinux, loading the SELinux policy.
         SelinuxSetupKernelLogging();
         SelinuxInitialize();
+		#endif
 
         // restore the context for rootfs when we are in the kernel domain
         // AIC does not use ramdisk and docker will drop xattrs when build image
@@ -690,7 +692,9 @@ int main(int argc, char** argv) {
 
     // Make the time that init started available for bootstat to log.
     property_set("ro.boottime.init", getenv("INIT_STARTED_AT"));
+	#ifndef _DISALBE_SELINUX_
     property_set("ro.boottime.init.selinux", getenv("INIT_SELINUX_TOOK"));
+	#endif
 
     // Set libavb version for Framework-only OTA match in Treble build.
     const char* avb_version = getenv("INIT_AVB_VERSION");
diff --git a/init/log.cpp b/init/log.cpp
index 6198fc25f..2fc179ee2 100644
--- a/init/log.cpp
+++ b/init/log.cpp
@@ -54,6 +54,7 @@ static void InitAborter(const char* abort_message) {
 
 void InitKernelLogging(char* argv[]) {
     // Make stdin/stdout/stderr all point to /dev/null.
+	#ifndef _DISALBE_SELINUX_
     int fd = open("/sys/fs/selinux/null", O_RDWR);
     if (fd == -1) {
         int saved_errno = errno;
@@ -65,7 +66,7 @@ void InitKernelLogging(char* argv[]) {
     dup2(fd, 1);
     dup2(fd, 2);
     if (fd > 2) close(fd);
-
+    #endif
     android::base::InitLogging(argv, &android::base::KernelLogger, InitAborter);
 }
 
diff --git a/init/property_service.cpp b/init/property_service.cpp
index 4172ba754..5598c0cc7 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -112,6 +112,7 @@ void property_init() {
 }
 static bool CheckMacPerms(const std::string& name, const char* target_context,
                           const char* source_context, const ucred& cr) {
+	#ifndef _DISALBE_SELINUX_
     if (!target_context || !source_context) {
         return false;
     }
@@ -123,7 +124,9 @@ static bool CheckMacPerms(const std::string& name, const char* target_context,
 
     bool has_access = (selinux_check_access(source_context, target_context, "property_service",
                                             "set", &audit_data) == 0);
-
+    #else
+		bool has_access = true;
+	#endif
     return has_access;
 }
 
@@ -316,12 +319,15 @@ class SocketConnection {
     int socket() { return socket_; }
 
     const ucred& cred() { return cred_; }
-
     std::string source_context() const {
+		#ifndef _DISALBE_SELINUX_
         char* source_context = nullptr;
         getpeercon(socket_, &source_context);
         std::string result = source_context;
         freecon(source_context);
+		#else
+			std::string result;
+		#endif
         return result;
     }
 
@@ -407,8 +413,11 @@ bool CheckControlPropertyPerms(const std::string& name, const std::string& value
         const char* type_legacy = nullptr;
         property_info_area->GetPropertyInfo(control_string_legacy.c_str(), &target_context_legacy,
                                             &type_legacy);
-
+        #ifndef _DISALBE_SELINUX_
         if (CheckMacPerms(control_string_legacy, target_context_legacy, source_context.c_str(), cr)) {
+		#else
+			if (CheckMacPerms(control_string_legacy, target_context_legacy, NULL, cr)) {
+		#endif
             return true;
         }
     }
@@ -444,8 +453,11 @@ uint32_t HandlePropertySet(const std::string& name, const std::string& value,
     const char* target_context = nullptr;
     const char* type = nullptr;
     property_info_area->GetPropertyInfo(name.c_str(), &target_context, &type);
-
+    #ifndef _DISALBE_SELINUX_
     if (!CheckMacPerms(name, target_context, source_context.c_str(), cr)) {
+	#else
+		if (!CheckMacPerms(name, target_context,  NULL , cr)) {
+	#endif
         *error = "SELinux permission check failed";
         return PROP_ERROR_PERMISSION_DENIED;
     }
diff --git a/init/service.cpp b/init/service.cpp
index 37d3a8807..93faf67fe 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -65,7 +65,7 @@ using android::base::WriteStringToFile;
 
 namespace android {
 namespace init {
-
+#ifndef _DISALBE_SELINUX_
 static Result<std::string> ComputeContextFromExecutable(const std::string& service_path) {
     std::string computed_context;
 
@@ -100,7 +100,9 @@ static Result<std::string> ComputeContextFromExecutable(const std::string& servi
         return Error() << "Could not get process context";
     }
     return computed_context;
+
 }
+#endif
 
 Result<Success> Service::SetUpMountNamespace() const {
     constexpr unsigned int kSafeFlags = MS_NODEV | MS_NOEXEC | MS_NOSUID;
@@ -309,11 +311,13 @@ void Service::SetProcessAttributes() {
             PLOG(FATAL) << "setuid failed for " << name_;
         }
     }
+	#ifndef _DISALBE_SELINUX_
     if (!seclabel_.empty()) {
         if (setexeccon(seclabel_.c_str()) < 0) {
             PLOG(FATAL) << "cannot setexeccon('" << seclabel_ << "') for " << name_;
         }
     }
+	#endif
     if (priority_ != 0) {
         if (setpriority(PRIO_PROCESS, 0, priority_) != 0) {
             PLOG(FATAL) << "setpriority failed for " << name_;
@@ -824,6 +828,7 @@ Result<Success> Service::Start() {
     }
 
     std::string scon;
+	#ifndef _DISALBE_SELINUX_
     if (!seclabel_.empty()) {
         scon = seclabel_;
     } else {
@@ -833,7 +838,7 @@ Result<Success> Service::Start() {
         }
         scon = *result;
     }
-
+    #endif
     LOG(INFO) << "starting service '" << name_ << "'...";
 
     pid_t pid = -1;
diff --git a/init/subcontext.cpp b/init/subcontext.cpp
index fdb46415d..f73d39fa0 100644
--- a/init/subcontext.cpp
+++ b/init/subcontext.cpp
@@ -243,11 +243,11 @@ void Subcontext::Fork() {
         if (child_fd < 0) {
             PLOG(FATAL) << "Could not dup child_fd";
         }
-
+        #ifndef _DISALBE_SELINUX_
         if (setexeccon(context_.c_str()) < 0) {
             PLOG(FATAL) << "Could not set execcon for '" << context_ << "'";
         }
-
+        #endif
         auto init_path = GetExecutablePath();
         auto child_fd_string = std::to_string(child_fd);
         const char* args[] = {init_path.c_str(), "subcontext", context_.c_str(),
diff --git a/init/util.cpp b/init/util.cpp
index 4455b2eb1..8355618bf 100644
--- a/init/util.cpp
+++ b/init/util.cpp
@@ -87,20 +87,23 @@ Result<uid_t> DecodeUid(const std::string& name) {
  */
 int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t uid, gid_t gid,
                  const char* socketcon) {
+	#ifndef _DISALBE_SELINUX_
     if (socketcon) {
         if (setsockcreatecon(socketcon) == -1) {
             PLOG(ERROR) << "setsockcreatecon(\"" << socketcon << "\") failed";
             return -1;
         }
     }
+	#endif
 
     android::base::unique_fd fd(socket(PF_UNIX, type, 0));
     if (fd < 0) {
         PLOG(ERROR) << "Failed to open socket '" << name << "'";
         return -1;
     }
-
+    #ifndef _DISALBE_SELINUX_
     if (socketcon) setsockcreatecon(NULL);
+	#endif
 
     struct sockaddr_un addr;
     memset(&addr, 0 , sizeof(addr));
@@ -112,12 +115,12 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
         PLOG(ERROR) << "Failed to unlink old socket '" << name << "'";
         return -1;
     }
-
+    #ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(addr.sun_path, S_IFSOCK, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     if (passcred) {
         int on = 1;
         if (setsockopt(fd, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on))) {
@@ -128,11 +131,11 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
 
     int ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));
     int savederrno = errno;
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
-
+    #endif
     if (ret) {
         errno = savederrno;
         PLOG(ERROR) << "Failed to bind socket '" << name << "'";
@@ -185,19 +188,20 @@ Result<std::string> ReadFile(const std::string& path) {
 }
 
 static int OpenFile(const std::string& path, int flags, mode_t mode) {
+	#ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     int rc = open(path.c_str(), flags, mode);
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
-
+    #endif
     return rc;
 }
 
@@ -256,19 +260,20 @@ void import_kernel_cmdline(bool in_qemu,
 }
 
 bool make_dir(const std::string& path, mode_t mode) {
+	#ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     int rc = mkdir(path.c_str(), mode);
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
-
+    #endif
     return rc == 0;
 }
 
-- 
2.17.1

