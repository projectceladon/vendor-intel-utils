From 9ca839dd1bf8730df9f323a5b9222e1f557538cb Mon Sep 17 00:00:00 2001
From: Bin Yang <bin.y.yang@intel.com>
Date: Tue, 26 May 2020 13:23:04 +0530
Subject: [PATCH] [Disable SELINUX] Tmp patch to disable selinux,

it should be reverted

Change-Id: I1a47eaa2afef86484823d36b3c03c6a668bfa082
Tracked-On: N/A
Signed-off-by: Bin Yang <bin.y.yang@intel.com>
---
 adb/daemon/main.cpp       |  3 ++-
 init/builtins.cpp         |  7 ++++---
 init/devices.cpp          |  8 ++++++--
 init/init.cpp             |  5 ++++-
 init/log.cpp              |  3 ++-
 init/property_service.cpp | 19 ++++++++++++++++---
 init/service.cpp          |  9 ++++++---
 init/subcontext.cpp       |  4 ++--
 init/util.cpp             | 28 ++++++++++++++++------------
 9 files changed, 58 insertions(+), 28 deletions(-)

diff --git a/adb/daemon/main.cpp b/adb/daemon/main.cpp
index 5adeb4446..3705be39b 100644
--- a/adb/daemon/main.cpp
+++ b/adb/daemon/main.cpp
@@ -152,12 +152,13 @@ static void drop_privileges(int server_port) {
     } else {
         // minijail_enter() will abort if any priv-dropping step fails.
         minijail_enter(jail.get());
-
+        #ifndef _DISALBE_SELINUX_
         if (root_seclabel != nullptr) {
             if (selinux_android_setcon(root_seclabel) < 0) {
                 LOG(FATAL) << "Could not set SELinux context";
             }
         }
+        #endif
         std::string error;
         std::string local_name =
             android::base::StringPrintf("tcp:%d", server_port);
diff --git a/init/builtins.cpp b/init/builtins.cpp
index 8bd92ccdd..991b035c1 100644
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -643,20 +643,21 @@ static Result<Success> do_trigger(const BuiltinArguments& args) {
 }
 
 static int MakeSymlink(const std::string& target, const std::string& linkpath) {
+    #ifndef _DISALBE_SELINUX_
     std::string secontext;
     // Passing 0 for mode should work.
     if (SelabelLookupFileContext(linkpath, 0, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     int rc = symlink(target.c_str(), linkpath.c_str());
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
-
+    #endif
     return rc;
 }
 
diff --git a/init/devices.cpp b/init/devices.cpp
index ada1e2870..0362efa31 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -226,6 +226,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     mode |= (block ? S_IFBLK : S_IFCHR);
 
     std::string secontext;
+    #ifndef _DISALBE_SELINUX_
     if (!SelabelLookupFileContextBestMatch(path, links, mode, &secontext)) {
         PLOG(ERROR) << "Device '" << path << "' not created; cannot find SELinux label";
         return;
@@ -233,7 +234,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     if (!secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     dev_t dev = makedev(major, minor);
     /* Temporarily change egid to avoid race condition setting the gid of the
      * device node. Unforunately changing the euid would prevent creation of
@@ -247,6 +248,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
     /* If the node already exists update its SELinux label to handle cases when
      * it was created with the wrong context during coldboot procedure. */
     if (mknod(path.c_str(), mode, dev) && (errno == EEXIST) && !secontext.empty()) {
+        #ifndef _DISALBE_SELINUX_
         char* fcon = nullptr;
         int rc = lgetfilecon(path.c_str(), &fcon);
         if (rc < 0) {
@@ -261,6 +263,7 @@ void DeviceHandler::MakeDevice(const std::string& path, bool block, int major, i
             PLOG(ERROR) << "Cannot set '" << secontext << "' SELinux label on '" << path
                         << "' device";
         }
+        #endif
     }
 
 out:
@@ -268,10 +271,11 @@ out:
     if (setegid(AID_ROOT)) {
         PLOG(FATAL) << "setegid(AID_ROOT) failed";
     }
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
+    #endif
 }
 
 // replaces any unacceptable characters with '_', the
diff --git a/init/init.cpp b/init/init.cpp
index 4fe115e92..dc99698cc 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -617,10 +617,11 @@ int main(int argc, char** argv) {
 
         // Enable seccomp if global boot option was passed (otherwise it is enabled in zygote).
         global_seccomp();
-
+        #ifndef _DISALBE_SELINUX_
         // Set up SELinux, loading the SELinux policy.
         SelinuxSetupKernelLogging();
         SelinuxInitialize();
+        #endif
 
         // We're in the kernel domain, so re-exec init to transition to the init domain now
         // that the SELinux policy has been loaded.
@@ -668,7 +669,9 @@ int main(int argc, char** argv) {
 
     // Make the time that init started available for bootstat to log.
     property_set("ro.boottime.init", getenv("INIT_STARTED_AT"));
+    #ifndef _DISALBE_SELINUX_
     property_set("ro.boottime.init.selinux", getenv("INIT_SELINUX_TOOK"));
+    #endif
 
     // Set libavb version for Framework-only OTA match in Treble build.
     const char* avb_version = getenv("INIT_AVB_VERSION");
diff --git a/init/log.cpp b/init/log.cpp
index 6198fc25f..c45bd766a 100644
--- a/init/log.cpp
+++ b/init/log.cpp
@@ -54,6 +54,7 @@ static void InitAborter(const char* abort_message) {
 
 void InitKernelLogging(char* argv[]) {
     // Make stdin/stdout/stderr all point to /dev/null.
+    #ifndef _DISALBE_SELINUX_
     int fd = open("/sys/fs/selinux/null", O_RDWR);
     if (fd == -1) {
         int saved_errno = errno;
@@ -65,7 +66,7 @@ void InitKernelLogging(char* argv[]) {
     dup2(fd, 1);
     dup2(fd, 2);
     if (fd > 2) close(fd);
-
+    #endif
     android::base::InitLogging(argv, &android::base::KernelLogger, InitAborter);
 }
 
diff --git a/init/property_service.cpp b/init/property_service.cpp
index 4172ba754..71e2e4d85 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -112,6 +112,7 @@ void property_init() {
 }
 static bool CheckMacPerms(const std::string& name, const char* target_context,
                           const char* source_context, const ucred& cr) {
+    #ifndef _DISALBE_SELINUX_
     if (!target_context || !source_context) {
         return false;
     }
@@ -123,7 +124,9 @@ static bool CheckMacPerms(const std::string& name, const char* target_context,
 
     bool has_access = (selinux_check_access(source_context, target_context, "property_service",
                                             "set", &audit_data) == 0);
-
+    #else
+        bool has_access = true;
+    #endif
     return has_access;
 }
 
@@ -318,10 +321,14 @@ class SocketConnection {
     const ucred& cred() { return cred_; }
 
     std::string source_context() const {
+        #ifndef _DISALBE_SELINUX_
         char* source_context = nullptr;
         getpeercon(socket_, &source_context);
         std::string result = source_context;
         freecon(source_context);
+        #else
+            std::string result;
+        #endif
         return result;
     }
 
@@ -407,8 +414,11 @@ bool CheckControlPropertyPerms(const std::string& name, const std::string& value
         const char* type_legacy = nullptr;
         property_info_area->GetPropertyInfo(control_string_legacy.c_str(), &target_context_legacy,
                                             &type_legacy);
-
+        #ifndef _DISALBE_SELINUX_
         if (CheckMacPerms(control_string_legacy, target_context_legacy, source_context.c_str(), cr)) {
+        #else
+            if (CheckMacPerms(control_string_legacy, target_context_legacy, NULL, cr)) {
+        #endif
             return true;
         }
     }
@@ -444,8 +454,11 @@ uint32_t HandlePropertySet(const std::string& name, const std::string& value,
     const char* target_context = nullptr;
     const char* type = nullptr;
     property_info_area->GetPropertyInfo(name.c_str(), &target_context, &type);
-
+    #ifndef _DISALBE_SELINUX_
     if (!CheckMacPerms(name, target_context, source_context.c_str(), cr)) {
+    #else
+        if (!CheckMacPerms(name, target_context,  NULL , cr)) {
+    #endif
         *error = "SELinux permission check failed";
         return PROP_ERROR_PERMISSION_DENIED;
     }
diff --git a/init/service.cpp b/init/service.cpp
index 37d3a8807..fc6d90691 100644
--- a/init/service.cpp
+++ b/init/service.cpp
@@ -65,7 +65,7 @@ using android::base::WriteStringToFile;
 
 namespace android {
 namespace init {
-
+#ifndef _DISALBE_SELINUX_
 static Result<std::string> ComputeContextFromExecutable(const std::string& service_path) {
     std::string computed_context;
 
@@ -101,7 +101,7 @@ static Result<std::string> ComputeContextFromExecutable(const std::string& servi
     }
     return computed_context;
 }
-
+#endif
 Result<Success> Service::SetUpMountNamespace() const {
     constexpr unsigned int kSafeFlags = MS_NODEV | MS_NOEXEC | MS_NOSUID;
 
@@ -309,11 +309,13 @@ void Service::SetProcessAttributes() {
             PLOG(FATAL) << "setuid failed for " << name_;
         }
     }
+    #ifndef _DISALBE_SELINUX_
     if (!seclabel_.empty()) {
         if (setexeccon(seclabel_.c_str()) < 0) {
             PLOG(FATAL) << "cannot setexeccon('" << seclabel_ << "') for " << name_;
         }
     }
+    #endif
     if (priority_ != 0) {
         if (setpriority(PRIO_PROCESS, 0, priority_) != 0) {
             PLOG(FATAL) << "setpriority failed for " << name_;
@@ -824,6 +826,7 @@ Result<Success> Service::Start() {
     }
 
     std::string scon;
+    #ifndef _DISALBE_SELINUX_
     if (!seclabel_.empty()) {
         scon = seclabel_;
     } else {
@@ -833,7 +836,7 @@ Result<Success> Service::Start() {
         }
         scon = *result;
     }
-
+    #endif
     LOG(INFO) << "starting service '" << name_ << "'...";
 
     pid_t pid = -1;
diff --git a/init/subcontext.cpp b/init/subcontext.cpp
index fdb46415d..f73d39fa0 100644
--- a/init/subcontext.cpp
+++ b/init/subcontext.cpp
@@ -243,11 +243,11 @@ void Subcontext::Fork() {
         if (child_fd < 0) {
             PLOG(FATAL) << "Could not dup child_fd";
         }
-
+        #ifndef _DISALBE_SELINUX_
         if (setexeccon(context_.c_str()) < 0) {
             PLOG(FATAL) << "Could not set execcon for '" << context_ << "'";
         }
-
+        #endif
         auto init_path = GetExecutablePath();
         auto child_fd_string = std::to_string(child_fd);
         const char* args[] = {init_path.c_str(), "subcontext", context_.c_str(),
diff --git a/init/util.cpp b/init/util.cpp
index 4455b2eb1..718b2077d 100644
--- a/init/util.cpp
+++ b/init/util.cpp
@@ -87,20 +87,22 @@ Result<uid_t> DecodeUid(const std::string& name) {
  */
 int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t uid, gid_t gid,
                  const char* socketcon) {
+    #ifndef _DISALBE_SELINUX_
     if (socketcon) {
         if (setsockcreatecon(socketcon) == -1) {
             PLOG(ERROR) << "setsockcreatecon(\"" << socketcon << "\") failed";
             return -1;
         }
     }
-
+    #endif
     android::base::unique_fd fd(socket(PF_UNIX, type, 0));
     if (fd < 0) {
         PLOG(ERROR) << "Failed to open socket '" << name << "'";
         return -1;
     }
-
+    #ifndef _DISALBE_SELINUX_
     if (socketcon) setsockcreatecon(NULL);
+    #endif
 
     struct sockaddr_un addr;
     memset(&addr, 0 , sizeof(addr));
@@ -112,12 +114,12 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
         PLOG(ERROR) << "Failed to unlink old socket '" << name << "'";
         return -1;
     }
-
+    #ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(addr.sun_path, S_IFSOCK, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     if (passcred) {
         int on = 1;
         if (setsockopt(fd, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on))) {
@@ -128,11 +130,11 @@ int CreateSocket(const char* name, int type, bool passcred, mode_t perm, uid_t u
 
     int ret = bind(fd, (struct sockaddr *) &addr, sizeof (addr));
     int savederrno = errno;
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         setfscreatecon(nullptr);
     }
-
+    #endif
     if (ret) {
         errno = savederrno;
         PLOG(ERROR) << "Failed to bind socket '" << name << "'";
@@ -185,19 +187,20 @@ Result<std::string> ReadFile(const std::string& path) {
 }
 
 static int OpenFile(const std::string& path, int flags, mode_t mode) {
+    #ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     int rc = open(path.c_str(), flags, mode);
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
-
+    #endif
     return rc;
 }
 
@@ -256,19 +259,20 @@ void import_kernel_cmdline(bool in_qemu,
 }
 
 bool make_dir(const std::string& path, mode_t mode) {
+    #ifndef _DISALBE_SELINUX_
     std::string secontext;
     if (SelabelLookupFileContext(path, mode, &secontext) && !secontext.empty()) {
         setfscreatecon(secontext.c_str());
     }
-
+    #endif
     int rc = mkdir(path.c_str(), mode);
-
+    #ifndef _DISALBE_SELINUX_
     if (!secontext.empty()) {
         int save_errno = errno;
         setfscreatecon(nullptr);
         errno = save_errno;
     }
-
+    #endif
     return rc == 0;
 }
 
-- 
2.17.1

