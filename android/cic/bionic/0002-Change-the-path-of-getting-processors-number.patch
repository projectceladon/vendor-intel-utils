From a5772447047332d429334969211e0d10e072a6d2 Mon Sep 17 00:00:00 2001
From: Zhiwei Li <zhiwei.li@intel.com>
Date: Fri, 5 Mar 2021 09:38:31 +0800
Subject: [PATCH] Change the path of getting processors number

Make get_nprocs_conf() and get_nprocs() return nprocs
in docker instead of host system. Path changed from
/sys/devices/system/cpu to /sys/fs/cgroup/cpuset

Change-Id: I5fd367ed406101f92fefea03848cc2f0bebbf9b8
Tracked-On: ACP-1514
Signed-off-by: Zhiwei Li <zhiwei.li@intel.com>
---
 libc/bionic/sysinfo.cpp | 25 ++-----------------------
 1 file changed, 2 insertions(+), 23 deletions(-)

diff --git a/libc/bionic/sysinfo.cpp b/libc/bionic/sysinfo.cpp
index 1d1070e2b..fbeb61170 100644
--- a/libc/bionic/sysinfo.cpp
+++ b/libc/bionic/sysinfo.cpp
@@ -36,34 +36,13 @@
 #include "private/get_cpu_count_from_string.h"
 #include "private/ScopedReaddir.h"
 
-static bool __matches_cpuN(const char* s) {
-  // The %c trick is to ensure that we have the anchored match "^cpu[0-9]+$".
-  unsigned cpu;
-  char dummy;
-  return (sscanf(s, "cpu%u%c", &cpu, &dummy) == 1);
-}
-
 int get_nprocs_conf() {
-  // On x86 kernels you can use /proc/cpuinfo for this, but on ARM kernels offline CPUs disappear
-  // from there. This method works on both.
-  ScopedReaddir reader("/sys/devices/system/cpu");
-  if (reader.IsBad()) {
-    return 1;
-  }
-
-  int result = 0;
-  dirent* entry;
-  while ((entry = reader.ReadEntry()) != nullptr) {
-    if (entry->d_type == DT_DIR && __matches_cpuN(entry->d_name)) {
-      ++result;
-    }
-  }
-  return result;
+  return get_nprocs();
 }
 
 int get_nprocs() {
   int cpu_count = 1;
-  FILE* fp = fopen("/sys/devices/system/cpu/online", "re");
+  FILE* fp = fopen("/sys/fs/cgroup/cpuset/cpuset.cpus", "re");
   if (fp != nullptr) {
     char* line = nullptr;
     size_t len = 0;
-- 
2.20.1.2.gb21ebb6

