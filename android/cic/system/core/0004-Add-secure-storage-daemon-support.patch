From dbac0dcbb3942fec90be1e2fbd663e7bff56de92 Mon Sep 17 00:00:00 2001
From: Huang Yang <yang.huang@intel.com>
Date: Tue, 25 Feb 2020 15:00:25 +0800
Subject: [PATCH 04/14] Add secure storage daemon support

Change-Id: I89924090c337fa487ffd91752be366ef29be6d39
Signed-off-by: Huang Yang <yang.huang@intel.com>
---
 trusty/storage/lib/Android.bp     |   6 +
 trusty/storage/proxy/Android.bp   |  13 +-
 trusty/storage/proxy/ipc.h        |   1 +
 trusty/storage/proxy/linux/rpmb.h | 134 ++++++++
 trusty/storage/proxy/proxy.c      | 269 ++++++++-------
 trusty/storage/proxy/rpmb-dev.c   | 182 ++++++++++
 trusty/storage/proxy/rpmb-dev.h   |  23 ++
 trusty/storage/proxy/rpmb-sim.c   | 699 ++++++++++++++++++++++++++++++++++++++
 trusty/storage/proxy/rpmb-sim.h   |  25 ++
 trusty/storage/proxy/rpmb.c       | 156 +++++----
 trusty/storage/proxy/rpmb.h       |   6 +-
 trusty/storage/proxy/storage.c    |  12 +-
 trusty/storage/proxy/storage.h    |   4 +
 trusty/storage/tests/Android.bp   |   1 +
 trusty/trusty-base.mk             |  28 --
 trusty/trusty-storage.mk          |  18 -
 16 files changed, 1336 insertions(+), 241 deletions(-)
 create mode 100644 trusty/storage/proxy/linux/rpmb.h
 create mode 100644 trusty/storage/proxy/rpmb-dev.c
 create mode 100644 trusty/storage/proxy/rpmb-dev.h
 create mode 100644 trusty/storage/proxy/rpmb-sim.c
 create mode 100644 trusty/storage/proxy/rpmb-sim.h
 delete mode 100644 trusty/trusty-base.mk
 delete mode 100644 trusty/trusty-storage.mk

diff --git a/trusty/storage/lib/Android.bp b/trusty/storage/lib/Android.bp
index 2fba17e..22ceab4 100644
--- a/trusty/storage/lib/Android.bp
+++ b/trusty/storage/lib/Android.bp
@@ -26,10 +26,16 @@ cc_library_static {
         "libtrusty",
         "libtrustystorageinterface",
     ],
+
     shared_libs: [
         "liblog",
     ],
 
+    header_libs: [
+        "liblog_headers",
+        "libcutils_headers",
+    ],
+
     cflags: [
         "-fvisibility=hidden",
         "-Wall",
diff --git a/trusty/storage/proxy/Android.bp b/trusty/storage/proxy/Android.bp
index b93facb..01371f9 100644
--- a/trusty/storage/proxy/Android.bp
+++ b/trusty/storage/proxy/Android.bp
@@ -21,18 +21,27 @@ cc_binary {
     srcs: [
         "ipc.c",
         "rpmb.c",
+        "rpmb-dev.c",
         "storage.c",
         "proxy.c",
+        "rpmb-sim.c",
     ],
 
-    shared_libs: ["liblog"],
-    header_libs: ["libcutils_headers"],
+    shared_libs: [
+        "liblog",
+        "libcrypto",
+    ],
 
     static_libs: [
         "libtrustystorageinterface",
         "libtrusty",
     ],
 
+    header_libs: [
+        "liblog_headers",
+        "libcutils_headers",
+    ],
+
     cflags: [
         "-Wall",
         "-Werror",
diff --git a/trusty/storage/proxy/ipc.h b/trusty/storage/proxy/ipc.h
index 2e366bb..994aa6a 100644
--- a/trusty/storage/proxy/ipc.h
+++ b/trusty/storage/proxy/ipc.h
@@ -17,6 +17,7 @@
 
 #include <stdint.h>
 #include <trusty/interface/storage.h>
+#include <unistd.h>
 
 int ipc_connect(const char *device, const char *service_name);
 void ipc_disconnect(void);
diff --git a/trusty/storage/proxy/linux/rpmb.h b/trusty/storage/proxy/linux/rpmb.h
new file mode 100644
index 0000000..98bf68c
--- /dev/null
+++ b/trusty/storage/proxy/linux/rpmb.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015-2016, Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_LINUX_RPMB_H_
+#define _UAPI_LINUX_RPMB_H_
+
+#include <linux/types.h>
+
+/**
+ * struct rpmb_frame - rpmb frame as defined by specs
+ *
+ * @stuff        : stuff bytes
+ * @key_mac      : The authentication key or the message authentication
+ *                 code (MAC) depending on the request/response type.
+ *                 The MAC will be delivered in the last (or the only)
+ *                 block of data.
+ * @data         : Data to be written or read by signed access.
+ * @nonce        : Random number generated by the host for the requests
+ *                 and copied to the response by the RPMB engine.
+ * @write_counter: Counter value for the total amount of the successful
+ *                 authenticated data write requests made by the host.
+ * @addr         : Address of the data to be programmed to or read
+ *                 from the RPMB. Address is the serial number of
+ *                 the accessed block (half sector 256B).
+ * @block_count  : Number of blocks (half sectors, 256B) requested to be
+ *                 read/programmed.
+ * @result       : Includes information about the status of the write counter
+ *                 (valid, expired) and result of the access made to the RPMB.
+ * @req_resp     : Defines the type of request and response to/from the memory.
+ */
+struct rpmb_frame {
+	__u8   stuff[196];
+	__u8   key_mac[32];
+	__u8   data[256];
+	__u8   nonce[16];
+	__be32 write_counter;
+	__be16 addr;
+	__be16 block_count;
+	__be16 result;
+	__be16 req_resp;
+} __attribute__((packed));
+
+#define RPMB_PROGRAM_KEY       0x1    /* Program RPMB Authentication Key */
+#define RPMB_GET_WRITE_COUNTER 0x2    /* Read RPMB write counter */
+#define RPMB_WRITE_DATA        0x3    /* Write data to RPMB partition */
+#define RPMB_READ_DATA         0x4    /* Read data from RPMB partition */
+#define RPMB_RESULT_READ       0x5    /* Read result request  (Internal) */
+
+#define RPMB_REQ2RESP(_OP) ((_OP) << 8)
+#define RPMB_RESP2REQ(_OP) ((_OP) >> 8)
+
+/* length of the part of the frame used for HMAC computation */
+#define hmac_data_len \
+	(sizeof(struct rpmb_frame) - offsetof(struct rpmb_frame, data))
+
+/**
+ * enum rpmb_op_result - rpmb operation results
+ *
+ * @RPMB_ERR_OK:       operation successful
+ * @RPMB_ERR_GENERAL:  general failure
+ * @RPMB_ERR_AUTH:     mac doesn't match or ac calculation failure
+ * @RPMB_ERR_COUNTER:  counter doesn't match or counter increment failure
+ * @RPMB_ERR_ADDRESS:  address out of range or wrong address alignment
+ * @RPMB_ERR_WRITE:    data, counter, or result write failure
+ * @RPMB_ERR_READ:     data, counter, or result read failure
+ * @RPMB_ERR_NO_KEY:   authentication key not yet programmed
+ *
+ * @RPMB_ERR_COUNTER_EXPIRED:  counter expired
+ */
+enum rpmb_op_result {
+	RPMB_ERR_OK      = 0x0000,
+	RPMB_ERR_GENERAL = 0x0001,
+	RPMB_ERR_AUTH    = 0x0002,
+	RPMB_ERR_COUNTER = 0x0003,
+	RPMB_ERR_ADDRESS = 0x0004,
+	RPMB_ERR_WRITE   = 0x0005,
+	RPMB_ERR_READ    = 0x0006,
+	RPMB_ERR_NO_KEY  = 0x0007,
+
+	RPMB_ERR_COUNTER_EXPIRED = 0x0080
+};
+
+#define RPMB_F_WRITE     (1UL << 0)
+#define RPMB_F_REL_WRITE (1UL << 1)
+
+/**
+ * struct rpmb_cmd: rpmb access command
+ *
+ * @flags:   command flags
+ *      0 - read command
+ *      1 - write commnad RPMB_F_WRITE
+ *      2 -  reliable write RPMB_F_REL_WRITE
+ * @nframes: number of rpmb frames in the command
+ * @frames_ptr:  a pointer to the list of rpmb frames
+ */
+struct rpmb_ioc_cmd {
+	__u32 flags;
+	__u32 nframes;
+	__aligned_u64 frames_ptr;
+};
+
+#define rpmb_ioc_cmd_set_frames(_cmd, _ptr) \
+	(_cmd).frames_ptr = (__aligned_u64)(intptr_t)(_ptr)
+
+#define rpmb_ioc_cmd_set(_cmd, _flags, _ptr, _n) do {         \
+	(_cmd).flags = (_flags);                              \
+	(_cmd).nframes = (_n);                                \
+	(_cmd).frames_ptr = (__u64)(intptr_t)(_ptr);  \
+} while (0)
+
+/**
+ * struct rpmb_ioc_seq_cmd - rpmb command sequence
+ *
+ * @num_of_cmds: number of commands
+ * @cmds: list of rpmb commands
+ */
+struct rpmb_ioc_seq_cmd {
+	__u64 num_of_cmds;
+	struct rpmb_ioc_cmd cmds[0];
+};
+
+#define RPMB_IOC_SEQ_CMD _IOWR(0xB5, 82, struct rpmb_ioc_seq_cmd)
+
+#endif /* _UAPI_LINUX_RPMB_H_ */
diff --git a/trusty/storage/proxy/proxy.c b/trusty/storage/proxy/proxy.c
index 41263e5..c105c66 100644
--- a/trusty/storage/proxy/proxy.c
+++ b/trusty/storage/proxy/proxy.c
@@ -17,90 +17,69 @@
 #include <getopt.h>
 #include <stdbool.h>
 #include <stdint.h>
-#include <string.h>
 #include <stdlib.h>
+#include <string.h>
 #include <sys/capability.h>
+#include <sys/sysmacros.h>
 #include <sys/prctl.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
+#include <linux/major.h>
+
 #include <cutils/android_filesystem_config.h>
 
 #include "ipc.h"
 #include "log.h"
 #include "rpmb.h"
+#include "rpmb-dev.h"
+#include "rpmb-sim.h"
 #include "storage.h"
 
 #define REQ_BUFFER_SIZE 4096
-static uint8_t req_buffer[REQ_BUFFER_SIZE + 1];
+/* /dev/block/mmcblk1p13 */
+#define RPMB_SIM_DEV_NAME       "/dev/block/by-name/teedata"
 
-static const char *ss_data_root;
-static const char *trusty_devname;
-static const char *rpmb_devname;
-static const char *ss_srv_name = STORAGE_DISK_PROXY_PORT;
-
-static const char *_sopts = "hp:d:r:";
-static const struct option _lopts[] =  {
-    {"help",       no_argument,       NULL, 'h'},
-    {"trusty_dev", required_argument, NULL, 'd'},
-    {"data_path",  required_argument, NULL, 'p'},
-    {"rpmb_dev",   required_argument, NULL, 'r'},
-    {0, 0, 0, 0}
-};
-
-static void show_usage_and_exit(int code)
-{
-    ALOGE("usage: storageproxyd -d <trusty_dev> -p <data_path> -r <rpmb_dev>\n");
-    exit(code);
-}
-
-static int drop_privs(void)
-{
-    struct __user_cap_header_struct capheader;
-    struct __user_cap_data_struct capdata[2];
-
-    if (prctl(PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0) {
-        return -1;
-    }
-
-    /*
-     * ensure we're running as the system user
-     */
-    if (setgid(AID_SYSTEM) != 0) {
-        return -1;
-    }
+static uint8_t req_buffer[REQ_BUFFER_SIZE + 1];
 
-    if (setuid(AID_SYSTEM) != 0) {
-        return -1;
-    }
+static unsigned int rpmb_sim;
 
-    /*
-     * drop all capabilities except SYS_RAWIO
-     */
-    memset(&capheader, 0, sizeof(capheader));
-    memset(&capdata, 0, sizeof(capdata));
-    capheader.version = _LINUX_CAPABILITY_VERSION_3;
-    capheader.pid = 0;
+static const char* ss_data_root;
+static const char* trusty_devname;
+static const char* rpmb_devname;
+static const char* ss_srv_name = STORAGE_DISK_PROXY_PORT;
 
-    capdata[CAP_TO_INDEX(CAP_SYS_RAWIO)].permitted = CAP_TO_MASK(CAP_SYS_RAWIO);
-    capdata[CAP_TO_INDEX(CAP_SYS_RAWIO)].effective = CAP_TO_MASK(CAP_SYS_RAWIO);
+static enum dev_type dev_type = MMC_RPMB;
 
-    if (capset(&capheader, &capdata[0]) < 0) {
-        return -1;
+static enum dev_type parse_dev_type(const char* dev_type_name) {
+    if (!strcmp(dev_type_name, "mmc")) {
+        return MMC_RPMB;
+    } else if (!strcmp(dev_type_name, "virt")) {
+        return VIRT_RPMB;
+    } else {
+        return UNKNOWN_RPMB;
     }
+}
 
-    /* no-execute for user, no access for group and other */
-    umask(S_IXUSR | S_IRWXG | S_IRWXO);
-
-    return 0;
+static const char* _sopts = "hp:d:r:t:";
+static const struct option _lopts[] = {{"help", no_argument, NULL, 'h'},
+                                       {"trusty_dev", required_argument, NULL, 'd'},
+                                       {"data_path", required_argument, NULL, 'p'},
+                                       {"rpmb_dev", required_argument, NULL, 'r'},
+                                       {"dev_type", required_argument, NULL, 't'},
+                                       {0, 0, 0, 0}};
+
+static void show_usage_and_exit(int code) {
+    ALOGE("usage: storageproxyd -d <trusty_dev> -p <data_path> -r <rpmb_dev> -t <dev_type>\n");
+    ALOGE("Available dev types: mmc, virt\n");
+    exit(code);
 }
 
-static int handle_req(struct storage_msg *msg, const void *req, size_t req_len)
-{
+static int handle_req(struct storage_msg* msg, const void* req, size_t req_len) {
     int rc;
 
-    if ((msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) &&
-        (msg->cmd != STORAGE_RPMB_SEND)) {
+    if ((msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) && (msg->cmd != STORAGE_RPMB_SEND)) {
         /*
          * handling post commit messages on non rpmb commands are not
          * implemented as there is no use case for this yet.
@@ -119,42 +98,45 @@ static int handle_req(struct storage_msg *msg, const void *req, size_t req_len)
     }
 
     switch (msg->cmd) {
-    case STORAGE_FILE_DELETE:
-        rc = storage_file_delete(msg, req, req_len);
-        break;
+        case STORAGE_FILE_DELETE:
+            rc = storage_file_delete(msg, req, req_len);
+            break;
 
-    case STORAGE_FILE_OPEN:
-        rc = storage_file_open(msg, req, req_len);
-        break;
+        case STORAGE_FILE_OPEN:
+            rc = storage_file_open(msg, req, req_len);
+            break;
 
-    case STORAGE_FILE_CLOSE:
-        rc = storage_file_close(msg, req, req_len);
-        break;
+        case STORAGE_FILE_CLOSE:
+            rc = storage_file_close(msg, req, req_len);
+            break;
 
-    case STORAGE_FILE_WRITE:
-        rc = storage_file_write(msg, req, req_len);
-        break;
+        case STORAGE_FILE_WRITE:
+            rc = storage_file_write(msg, req, req_len);
+            break;
 
-    case STORAGE_FILE_READ:
-        rc = storage_file_read(msg, req, req_len);
-        break;
+        case STORAGE_FILE_READ:
+            rc = storage_file_read(msg, req, req_len);
+            break;
 
-    case STORAGE_FILE_GET_SIZE:
-        rc = storage_file_get_size(msg, req, req_len);
-        break;
+        case STORAGE_FILE_GET_SIZE:
+            rc = storage_file_get_size(msg, req, req_len);
+            break;
 
-    case STORAGE_FILE_SET_SIZE:
-        rc = storage_file_set_size(msg, req, req_len);
-        break;
+        case STORAGE_FILE_SET_SIZE:
+            rc = storage_file_set_size(msg, req, req_len);
+            break;
 
-    case STORAGE_RPMB_SEND:
-        rc = rpmb_send(msg, req, req_len);
-        break;
+        case STORAGE_RPMB_SEND:
+            if (rpmb_sim)
+                rc = rpmb_sim_send(msg, req, req_len);
+            else
+                rc = rpmb_dev_send(msg, req, req_len);
+            break;
 
-    default:
-        ALOGE("unhandled command 0x%x\n", msg->cmd);
-        msg->result = STORAGE_ERR_UNIMPLEMENTED;
-        rc = 1;
+        default:
+            ALOGE("unhandled command 0x%x\n", msg->cmd);
+            msg->result = STORAGE_ERR_UNIMPLEMENTED;
+            rc = 1;
     }
 
     if (rc > 0) {
@@ -164,58 +146,58 @@ static int handle_req(struct storage_msg *msg, const void *req, size_t req_len)
     return rc;
 }
 
-static int proxy_loop(void)
-{
+static int proxy_loop(void) {
     ssize_t rc;
     struct storage_msg msg;
 
     /* enter main message handling loop */
     while (true) {
-
         /* get incoming message */
         rc = ipc_get_msg(&msg, req_buffer, REQ_BUFFER_SIZE);
-        if (rc < 0)
-            return rc;
+        if (rc < 0) return rc;
 
         /* handle request */
         req_buffer[rc] = 0; /* force zero termination */
         rc = handle_req(&msg, req_buffer, rc);
-        if (rc)
-            return rc;
+        if (rc) return rc;
     }
 
     return 0;
 }
 
-static void parse_args(int argc, char *argv[])
-{
+static void parse_args(int argc, char* argv[]) {
     int opt;
     int oidx = 0;
 
     while ((opt = getopt_long(argc, argv, _sopts, _lopts, &oidx)) != -1) {
         switch (opt) {
-
-        case 'd':
-            trusty_devname = strdup(optarg);
-            break;
-
-        case 'p':
-            ss_data_root = strdup(optarg);
-            break;
-
-        case 'r':
-            rpmb_devname = strdup(optarg);
-            break;
-
-        default:
-            ALOGE("unrecognized option (%c):\n", opt);
-            show_usage_and_exit(EXIT_FAILURE);
+            case 'd':
+                trusty_devname = strdup(optarg);
+                break;
+
+            case 'p':
+                ss_data_root = strdup(optarg);
+                break;
+
+            case 'r':
+                rpmb_devname = strdup(optarg);
+                break;
+
+            case 't':
+                dev_type = parse_dev_type(optarg);
+                if (dev_type == UNKNOWN_RPMB) {
+                    ALOGE("Unrecognized dev type: %s\n", optarg);
+                    show_usage_and_exit(EXIT_FAILURE);
+                }
+                break;
+
+            default:
+                ALOGE("unrecognized option (%c):\n", opt);
+                show_usage_and_exit(EXIT_FAILURE);
         }
     }
 
-    if (ss_data_root == NULL ||
-        trusty_devname == NULL ||
-        rpmb_devname == NULL) {
+    if (ss_data_root == NULL || trusty_devname == NULL || rpmb_devname == NULL) {
         ALOGE("missing required argument(s)\n");
         show_usage_and_exit(EXIT_FAILURE);
     }
@@ -226,38 +208,69 @@ static void parse_args(int argc, char *argv[])
     ALOGI("rpmb dev: %s\n", rpmb_devname);
 }
 
-int main(int argc, char *argv[])
+static int get_teedata_path(char* teedata_path)
 {
+    uint16_t i, j;
+
+    if (NULL == teedata_path)
+        return 0;
+
+    for (i=0; i<=15; i++)
+        for (j=0; j<=255; j++) {
+            sprintf(teedata_path, "/dev/block/pci/pci0000:00/0000:00:%02x.%x/by-name/teedata", j, i);
+            if (rpmb_sim_open(teedata_path) < 0)
+                continue;
+            ALOGI("teedata is found: %s\n", teedata_path);
+            return 1;
+    }
+
+    return 0;
+}
+
+int main(int argc, char* argv[]) {
     int rc;
+    char path[55];
+
+    if (!get_teedata_path(path)) {
+        ALOGE("storage no teedata found.\n");
+        rpmb_sim = 0;
+    }
+    else
+        rpmb_sim = is_use_sim_rpmb();
 
-    /* drop privileges */
-    if (drop_privs() < 0)
-        return EXIT_FAILURE;
+    if (rpmb_sim)
+        ALOGI("storage use simulation rpmb.\n");
+    else
+        ALOGI("storage use physical rpmb.\n");
 
     /* parse arguments */
     parse_args(argc, argv);
 
     /* initialize secure storage directory */
     rc = storage_init(ss_data_root);
-    if (rc < 0)
-        return EXIT_FAILURE;
+    if (rc < 0) return EXIT_FAILURE;
 
-    /* open rpmb device */
-    rc = rpmb_open(rpmb_devname);
-    if (rc < 0)
-        return EXIT_FAILURE;
+    if (!rpmb_sim) {
+        rpmb_sim_close();
+        rc = rpmb_dev_open(rpmb_devname);
+    }
+
+    if (rc < 0) return EXIT_FAILURE;
 
     /* connect to Trusty secure storage server */
     rc = ipc_connect(trusty_devname, ss_srv_name);
-    if (rc < 0)
-        return EXIT_FAILURE;
+    if (rc < 0) return EXIT_FAILURE;
 
     /* enter main loop */
     rc = proxy_loop();
     ALOGE("exiting proxy loop with status (%d)\n", rc);
 
     ipc_disconnect();
-    rpmb_close();
+
+    if (rpmb_sim)
+        rpmb_sim_close();
+    else
+        rpmb_dev_close();
 
     return (rc < 0) ? EXIT_FAILURE : EXIT_SUCCESS;
 }
diff --git a/trusty/storage/proxy/rpmb-dev.c b/trusty/storage/proxy/rpmb-dev.c
new file mode 100644
index 0000000..e116cac
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-dev.c
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+
+#include "linux/rpmb.h"
+
+#include "ipc.h"
+#include "log.h"
+#include "rpmb.h"
+#include "storage.h"
+
+#define RPMB_BLOCK_SIZE sizeof(struct rpmb_frame)
+
+static int rpmb_fd = -1;
+static uint8_t read_buf[4096];
+
+#ifdef RPMB_DEBUG
+
+static void print_buf(const char *prefix, const uint8_t *buf, size_t size)
+{
+    size_t i;
+
+    printf("%s @%p [%zu]", prefix, buf, size);
+    for (i = 0; i < size; i++) {
+        if (i && i % 32 == 0)
+            printf("\n%*s", (int) strlen(prefix), "");
+        printf(" %02x", buf[i]);
+    }
+    printf("\n");
+    fflush(stdout);
+}
+
+#endif /* RPMB_DEBUG */
+
+
+int rpmb_dev_send(struct storage_msg *msg, const void *r, size_t req_len)
+{
+    int rc;
+    uint32_t blocks;
+    struct {
+        struct rpmb_ioc_seq_cmd seq;
+        struct rpmb_ioc_cmd cmd[3];
+    } rpmb = {};
+    struct rpmb_ioc_cmd *cmd = rpmb.seq.cmds;
+    const struct storage_rpmb_send_req *req = r;
+
+    if (req_len < sizeof(*req)) {
+        ALOGW("malformed rpmb request: invalid length (%zu < %zu)\n",
+              req_len, sizeof(*req));
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    size_t expected_len = sizeof(*req) + req->reliable_write_size + req->write_size;
+    if (req_len != expected_len) {
+        ALOGW("malformed rpmb request: invalid length (%zu != %zu)\n",
+              req_len, expected_len);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    const uint8_t *write_buf = req->payload;
+    if (req->reliable_write_size) {
+        if ((req->reliable_write_size % RPMB_BLOCK_SIZE) != 0) {
+            ALOGW("invalid reliable write size %u\n", req->reliable_write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+
+        blocks = req->reliable_write_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, RPMB_F_WRITE | RPMB_F_REL_WRITE, write_buf, blocks);
+
+#ifdef RPMB_DEBUG
+        ALOGI("opcode: 0x%x, write_flag: 0x%x\n", cmd->opcode, cmd->write_flag);
+        //print_buf("request: ", write_buf, req->reliable_write_size);
+#endif
+        write_buf += req->reliable_write_size;
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    if (req->write_size) {
+        if ((req->write_size % RPMB_BLOCK_SIZE) != 0) {
+            ALOGW("invalid write size %u\n", req->write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+        blocks = req->write_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, RPMB_F_WRITE, write_buf, blocks);
+
+#ifdef RPMB_DEBUG
+        ALOGI("opcode: 0x%x, write_flag: 0x%x\n", cmd->opcode, cmd->write_flag);
+        print_buf("request: ", write_buf, req->write_size);
+#endif
+        write_buf += req->write_size;
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    if (req->read_size) {
+        if (req->read_size % RPMB_BLOCK_SIZE != 0 ||
+            req->read_size > sizeof(read_buf)) {
+            ALOGE("%s: invalid read size %u\n", __func__, req->read_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+        blocks = req->read_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, 0, read_buf, blocks);
+
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    rc = ioctl(rpmb_fd, RPMB_IOC_SEQ_CMD, &rpmb.seq);
+    if (rc < 0) {
+        ALOGE("%s: mmc ioctl failed: %d, %s\n", __func__, rc, strerror(errno));
+        msg->result = STORAGE_ERR_GENERIC;
+        goto err_response;
+    }
+#ifdef RPMB_DEBUG
+    if (req->read_size)
+        print_buf("response: ", read_buf, req->read_size);
+#endif
+
+    if (msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) {
+        /*
+         * Nothing todo for post msg commit request as RPMB_IOC_SEQ_CMD
+         * is fully synchronous in this implementation.
+         */
+    }
+
+    msg->result = STORAGE_NO_ERROR;
+    return ipc_respond(msg, read_buf, req->read_size);
+
+err_response:
+    return ipc_respond(msg, NULL, 0);
+}
+
+
+int rpmb_dev_open(const char *rpmb_devname)
+{
+    int rc;
+
+    rc = open(rpmb_devname, O_RDWR, 0);
+    if (rc < 0) {
+        ALOGE("unable (%d) to open rpmb device '%s': %s\n",
+              errno, rpmb_devname, strerror(errno));
+        return rc;
+    }
+    rpmb_fd = rc;
+    return 0;
+}
+
+void rpmb_dev_close(void)
+{
+    close(rpmb_fd);
+    rpmb_fd = -1;
+}
+
diff --git a/trusty/storage/proxy/rpmb-dev.h b/trusty/storage/proxy/rpmb-dev.h
new file mode 100644
index 0000000..4493695
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-dev.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <trusty/interface/storage.h>
+
+int rpmb_dev_open(const char *rpmb_devname);
+int rpmb_dev_send(struct storage_msg *msg, const void *r, size_t req_len);
+void rpmb_dev_close(void);
diff --git a/trusty/storage/proxy/rpmb-sim.c b/trusty/storage/proxy/rpmb-sim.c
new file mode 100644
index 0000000..b5147fd
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-sim.c
@@ -0,0 +1,699 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2017 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <fcntl.h>
+#include <inttypes.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <assert.h>
+
+#include <openssl/hmac.h>
+
+#include "ipc.h"
+#include "storage.h"
+#include "log.h"
+
+struct rpmb_packet {
+    uint8_t              pad[196];
+    uint8_t              key_mac[32];
+    uint8_t              data[256];
+    uint8_t              nonce[16];
+    uint32_t             write_counter;
+    uint16_t             address;
+    uint16_t             block_count;
+    uint16_t             result;
+    uint16_t             req_resp;
+};
+
+enum rpmb_request {
+    RPMB_REQ_PROGRAM_KEY                = 0x0001,
+    RPMB_REQ_GET_COUNTER                = 0x0002,
+    RPMB_REQ_DATA_WRITE                 = 0x0003,
+    RPMB_REQ_DATA_READ                  = 0x0004,
+    RPMB_REQ_RESULT_READ                = 0x0005,
+};
+
+enum rpmb_response {
+    RPMB_RESP_PROGRAM_KEY               = 0x0100,
+    RPMB_RESP_GET_COUNTER               = 0x0200,
+    RPMB_RESP_DATA_WRITE                = 0x0300,
+    RPMB_RESP_DATA_READ                 = 0x0400,
+};
+
+enum rpmb_result {
+    RPMB_RES_OK                         = 0x0000,
+    RPMB_RES_GENERAL_FAILURE            = 0x0001,
+    RPMB_RES_AUTH_FAILURE               = 0x0002,
+    RPMB_RES_COUNT_FAILURE              = 0x0003,
+    RPMB_RES_ADDR_FAILURE               = 0x0004,
+    RPMB_RES_WRITE_FAILURE              = 0x0005,
+    RPMB_RES_READ_FAILURE               = 0x0006,
+    RPMB_RES_NO_AUTH_KEY                = 0x0007,
+
+    RPMB_RES_WRITE_COUNTER_EXPIRED      = 0x0080,
+};
+
+
+#define RPMB_FRAME_SIZE  512
+
+static int rpmb_fd = -1;
+static uint8_t read_buf[4096];
+
+/*
+ * 0~6 is magic
+ * 7~38 is rpmb key
+ * 39~41 is write counter
+ */
+#define KEY_MAGIC		"key_sim"
+#define KEY_MAGIC_ADDR		0
+#define KEY_MAGIC_LENGTH	7
+
+#define KEY_ADDR		7
+#define KEY_LENGTH		32
+
+#define WRITER_COUNTER_ADDR	39
+
+/* teedata size is 32M. But here only 256K~4M are available to use. */
+#define TEEDATA_SIZE		(4*1024*1024) //4M
+#define TEEDATA_BLOCK_COUNT	(TEEDATA_SIZE/256)
+
+
+inline uint32_t swap32(uint32_t val)
+{
+	return ((val & (uint32_t)0x000000ffUL) << 24)
+		| ((val & (uint32_t)0x0000ff00UL) <<  8)
+		| ((val & (uint32_t)0x00ff0000UL) >>  8)
+		| ((val & (uint32_t)0xff000000UL) >> 24);
+}
+
+inline uint16_t swap16(uint16_t val)
+{
+	return ((val & (uint16_t)0x00ffU) << 8)
+		| ((val & (uint16_t)0xff00U) >> 8);
+}
+
+static inline int memcpy_s(void *dst, size_t dst_size, const void *src, size_t count)
+{
+    if (!dst || !src || dst_size < count)
+        return -1;
+
+    memcpy(dst, src, count);
+    return 0;
+}
+
+static int rpmb_sim_operations(const void *rel_write_data,
+                        size_t rel_write_size, const void *write_data,
+                        size_t write_size, void *read_buf, size_t read_size);
+
+/*
+ * Executes the RPMB request at @r, sends response to storage service.
+ *
+ * @msg:     address of storage message header
+ * @r:       address of storage message request
+ * @req_len: length of resp in bytes
+ */
+int rpmb_sim_send(struct storage_msg *msg, const void *r,
+                             size_t req_len)
+{
+    int rc;
+    size_t exp_len;
+    const void *write_data = NULL;
+    const void *rel_write_data = NULL;
+    const struct storage_rpmb_send_req *req = r;
+
+    if (req_len < sizeof(req)) {
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    exp_len = sizeof(*req) + req->reliable_write_size + req->write_size;
+    if (req_len != exp_len) {
+        ALOGE("%s: malformed rpmb request: invalid length (%zu != %zu)\n",
+                __func__, req_len, exp_len);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    if (req->reliable_write_size) {
+        if ((req->reliable_write_size % RPMB_FRAME_SIZE) != 0) {
+            ALOGE("%s: invalid reliable write size %u\n", __func__,
+                         req->reliable_write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+        rel_write_data = req->payload;
+    }
+
+    if (req->write_size) {
+        if ((req->write_size % RPMB_FRAME_SIZE) != 0) {
+            ALOGE("%s: invalid write size %u\n", __func__,
+                         req->write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+        write_data = req->payload + req->reliable_write_size;
+    }
+
+    if (req->read_size) {
+        if (req->read_size % RPMB_FRAME_SIZE != 0 ||
+            req->read_size > sizeof(read_buf)) {
+            ALOGE("%s: invalid read size %u\n", __func__,
+                         req->read_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+    }
+
+    /* execute rpmb command */
+    rc = rpmb_sim_operations(rel_write_data, req->reliable_write_size,
+                             write_data, req->write_size,
+                             read_buf, req->read_size);
+    if (rc) {
+        ALOGE("%s: rpmb_storage_send failed: %d\n", __func__, rc);
+        msg->result = STORAGE_ERR_GENERIC;
+        goto err_response;
+    }
+
+    if (msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) {
+        /*
+         * Nothing todo for post msg commit request as MMC_IOC_MULTI_CMD
+         * is fully synchronous in this implementation.
+         */
+    }
+
+    msg->result = STORAGE_NO_ERROR;
+    return ipc_respond(msg, read_buf, req->read_size);
+
+err_response:
+    return ipc_respond(msg, NULL, 0);
+}
+
+int rpmb_sim_open(const char *rpmb_devname)
+{
+    int rc;
+
+    rc = open(rpmb_devname, O_RDWR, 0);
+    if (rc < 0) {
+        return rc;
+    }
+    rpmb_fd = rc;
+    return 0;
+}
+
+void rpmb_sim_close(void)
+{
+    close(rpmb_fd);
+    rpmb_fd = -1;
+}
+
+static int fwrite_with_retry(int fd, const void *buf, size_t size, off_t offset)
+{
+    int rc;
+
+    rc = write_with_retry(fd, buf, size, offset);
+    if (rc < 0) {
+       ALOGE("%s write with retry failed.\n", __func__);
+       return rc;
+    }
+
+    rc = fsync(fd);
+    if (rc < 0) {
+        ALOGE("fsync for fd=%d failed: %s\n", fd, strerror(errno));
+        return rc;
+    }
+    return 0;
+}
+
+static int get_counter(uint32_t *counter)
+{
+    int rc = 0;
+
+    rc = read_with_retry(rpmb_fd, counter, sizeof(*counter), WRITER_COUNTER_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed.\n", __func__);
+        return -1;
+    }
+
+    swap32(*counter);
+
+    return 0;
+}
+
+static int set_counter(const uint32_t *counter)
+{
+    int rc = 0;
+    uint32_t cnt = *counter;
+
+    swap32(cnt);
+    rc = fwrite_with_retry(rpmb_fd, &cnt, sizeof(cnt), WRITER_COUNTER_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed.\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int is_key_programmed(void)
+{
+    int rc = 0;
+    uint8_t magic[KEY_MAGIC_LENGTH] = {0};
+
+    rc = read_with_retry(rpmb_fd, magic, KEY_MAGIC_LENGTH, KEY_MAGIC_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s read magic failed.\n", __func__);
+        return 0;
+    }
+
+    if (memcmp(KEY_MAGIC, magic, KEY_MAGIC_LENGTH))
+        return 0;
+
+    return 1;
+}
+
+int is_use_sim_rpmb(void)
+{
+    return is_key_programmed();
+}
+
+static int get_key(uint8_t *key)
+{
+    int rc = 0;
+
+    rc = read_with_retry(rpmb_fd, key, 32, KEY_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed.\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int program_key(const uint8_t *key)
+{
+    int rc = 0;
+
+    rc = fwrite_with_retry(rpmb_fd, key, 32, KEY_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed at set key.\n", __func__);
+        return -1;
+    }
+
+    rc = fwrite_with_retry(rpmb_fd, KEY_MAGIC, KEY_MAGIC_LENGTH, KEY_MAGIC_ADDR);
+    if (rc < 0)
+    {
+        ALOGE("%s failed at set magic.\n", __func__);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int rpmb_mac(uint8_t *key, const struct rpmb_packet *packet,
+                    int packet_count, uint8_t *mac)
+{
+    int i;
+    int hmac_ret;
+    unsigned int md_len;
+    HMAC_CTX hmac_ctx;
+
+    HMAC_CTX_init(&hmac_ctx);
+    hmac_ret = HMAC_Init_ex(&hmac_ctx, key, 32, EVP_sha256(), NULL);
+    if (!hmac_ret) {
+        ALOGE("HMAC_Init_ex failed\n");
+        goto err;
+    }
+
+    for (i = 0; i < packet_count; i++) {
+        hmac_ret = HMAC_Update(&hmac_ctx, packet[i].data, 284);
+        if (!hmac_ret) {
+            ALOGE("HMAC_Update failed\n");
+            goto err;
+        }
+    }
+
+    hmac_ret = HMAC_Final(&hmac_ctx, mac, &md_len);
+    if (md_len != 32) {
+        ALOGE("bad md_len %d != 32.\n", md_len);
+        exit(1);
+    }
+
+    if (!hmac_ret) {
+        ALOGE("HMAC_Final failed\n");
+        goto err;
+    }
+
+err:
+    HMAC_CTX_cleanup(&hmac_ctx);
+
+    return hmac_ret ? 0 : -1;
+}
+
+static int rpmb_program_key(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                            struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    int err = RPMB_RES_WRITE_FAILURE;
+    uint32_t counter = 0;
+
+    if (in_cnt == 0  || in_frame == NULL)
+        return -EINVAL;
+
+    if (is_key_programmed())
+        err = RPMB_RES_GENERAL_FAILURE;
+    else
+        ret = program_key(in_frame->key_mac);
+
+    if (ret)
+        goto out;
+
+    ret = set_counter(&counter);
+    if (ret)
+        goto out;
+
+    err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, out_cnt*sizeof(*out_frame));
+        out_frame->req_resp = swap16(RPMB_RESP_PROGRAM_KEY);
+        out_frame->result = swap16(err);
+    }
+
+    return ret;
+}
+
+static int rpmb_write(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                      struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    int err = RPMB_RES_WRITE_FAILURE;
+    uint32_t i;
+    uint8_t key[32];
+    uint8_t mac[32];
+    uint32_t counter;
+    uint16_t addr;
+    uint16_t block_count;
+    uint8_t data[256*in_cnt];
+
+    if (in_cnt == 0  || in_frame == NULL)
+        return -EINVAL;
+
+    if (in_frame[0].req_resp != swap16(RPMB_REQ_DATA_WRITE))
+        return -EINVAL;
+
+    if (in_cnt > 2) {
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    addr = swap16(in_frame[0].address);
+    block_count = swap16(in_frame[0].block_count);
+
+    if (addr >= TEEDATA_BLOCK_COUNT) {
+        err = RPMB_RES_ADDR_FAILURE;
+        goto out;
+    }
+
+    if (addr + block_count > TEEDATA_BLOCK_COUNT)
+        goto out;
+
+    if (block_count == 0 || block_count > in_cnt) {
+        ret = -EINVAL;
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    if (!is_key_programmed()) {
+        err = RPMB_RES_NO_AUTH_KEY;
+        goto out;
+    }
+
+    if (get_counter(&counter))
+        goto out;
+
+    if (counter == 0xFFFFFFFF) {
+        err = RPMB_RES_WRITE_COUNTER_EXPIRED;
+        goto out;
+    }
+
+    if (counter != swap32(in_frame[0].write_counter)) {
+        err = RPMB_RES_COUNT_FAILURE;
+        goto out;
+    }
+
+    if (get_key(key)) {
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    if (rpmb_mac(key, in_frame, in_cnt, mac)) {
+        err = RPMB_RES_GENERAL_FAILURE;
+        goto out;
+    }
+
+    if (memcmp(in_frame[in_cnt - 1].key_mac, mac, 32)) {
+        ALOGE("%s wrong mac.\n", __func__);
+        err = RPMB_RES_AUTH_FAILURE;
+        goto out;
+    }
+
+    for (i = 0; i < in_cnt; i++) {
+        ret = memcpy_s(data + i * 256, 256, in_frame[i].data, 256);
+        if(ret) {
+            err = RPMB_RES_GENERAL_FAILURE;
+            goto out;
+        }
+    }
+
+    if (fwrite_with_retry(rpmb_fd, data, sizeof(data), 256 * addr) < 0) {
+        ALOGE("%s fwrite_with_retry failed.\n", __func__);
+        goto out;
+    }
+
+    ++counter;
+    if (set_counter(&counter)) {
+        ALOGE("%s set_counter failed.\n", __func__);
+        goto out;
+    }
+
+    err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, out_cnt*sizeof(*out_frame));
+        out_frame->req_resp = swap16(RPMB_RESP_DATA_WRITE);
+        out_frame->result = swap16(err);
+        if (err == RPMB_RES_OK) {
+            out_frame->address = swap16(addr);
+            out_frame->write_counter = swap32(counter);
+            rpmb_mac(key, out_frame, 1, out_frame->key_mac);
+        }
+    }
+
+    return ret;
+}
+
+static int rpmb_read(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                     struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    uint32_t i;
+    int err = RPMB_RES_READ_FAILURE;
+    uint8_t key[32];
+    uint8_t mac[32];
+    uint16_t addr;
+    uint8_t data[256*out_cnt];
+
+    if (in_cnt != 1 || in_frame == NULL)
+        return -EINVAL;
+
+    if (in_frame->req_resp != swap16(RPMB_REQ_DATA_READ))
+        return -EINVAL;
+
+    addr = swap16(in_frame->address);
+
+    if (addr >= TEEDATA_BLOCK_COUNT) {
+        err = RPMB_RES_ADDR_FAILURE;
+        goto out;
+    }
+
+    if (addr + out_cnt > TEEDATA_BLOCK_COUNT)
+        goto out;
+
+    if (!is_key_programmed()) {
+        err = RPMB_RES_NO_AUTH_KEY;
+        goto out;
+    }
+
+    if (read_with_retry(rpmb_fd, data, sizeof(data), 256 * addr) < 0) {
+        ALOGE("%s read_with_retry failed.\n", __func__);
+        goto out;
+    }
+
+    err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, out_cnt*sizeof(*out_frame));
+        for (i = 0; i < out_cnt; i++) {
+            ret = memcpy_s(out_frame[i].nonce, sizeof(out_frame[i].nonce),
+                     in_frame[0].nonce, sizeof(in_frame[0].nonce));
+            if(ret) {
+                ALOGE("%s: %d: memcpy_s failed.\n", __func__, __LINE__);
+                return ret;
+            }
+            out_frame[i].req_resp = swap16(RPMB_RESP_DATA_READ);
+            out_frame[i].block_count = swap16(out_cnt);
+            out_frame[i].address = in_frame[0].address;
+            ret = memcpy_s(out_frame[i].data, 256, data+256*i, 256);
+            if(ret) {
+                ALOGE("%s: %d: memcpy_s failed.\n", __func__, __LINE__);
+                return ret;
+            }
+        }
+        if (get_key(key))
+            ALOGE("%s, get_key failed.\n", __func__);
+
+        out_frame[out_cnt - 1].result = swap16(err);
+        rpmb_mac(key, out_frame, out_cnt, mac);
+        ret = memcpy_s(out_frame[out_cnt - 1].key_mac, sizeof(out_frame[out_cnt - 1].key_mac),
+                 mac, sizeof(mac));
+        if(ret) {
+            ALOGE("%s: %d: memcpy_s failed.\n", __func__, __LINE__);
+            return ret;
+        }
+    }
+
+    return ret;
+}
+
+static int rpmb_get_counter(const struct rpmb_packet* in_frame, uint32_t in_cnt,
+                            struct rpmb_packet* out_frame, uint32_t out_cnt)
+{
+    int ret = 0;
+    int err = RPMB_RES_COUNT_FAILURE;
+    uint8_t key[32];
+    uint32_t counter;
+
+    if (in_cnt != 1 || in_frame == NULL)
+        return -EINVAL;
+
+    if (in_frame->req_resp != swap16(RPMB_REQ_GET_COUNTER))
+        return -EINVAL;
+
+    if (!is_key_programmed()) {
+        err = RPMB_RES_NO_AUTH_KEY;
+        goto out;
+    }
+
+    if (get_key(key))
+        goto out;
+
+    if (get_counter(&counter))
+        goto out;
+
+     err = RPMB_RES_OK;
+
+out:
+    if (out_frame) {
+        memset(out_frame, 0, sizeof(*out_frame)*out_cnt);
+        out_frame->result = swap16(err);
+        out_frame->req_resp = swap16(RPMB_RESP_GET_COUNTER);
+        ret = memcpy_s(out_frame->nonce, sizeof(out_frame->nonce),
+               in_frame[0].nonce, sizeof(in_frame[0].nonce));
+        if(ret){
+            ALOGE("%s: %d: memcpy_s failed.\n", __func__, __LINE__);
+            return ret;
+        }
+        if (err == RPMB_RES_OK) {
+            out_frame->write_counter = swap32(counter);
+            rpmb_mac(key, out_frame, out_cnt, out_frame->key_mac);
+        }
+    }
+
+    return ret;
+}
+
+/*
+ *                rel_write       write      read
+ * RPMB_READ          0             1        1~N
+ * RPMB_WRITE        1~N            1         1
+ * GET_COUNTER        0             1         1
+ * PROGRAM_KEY        1             1         1
+ */
+static int rpmb_sim_operations(const void *rel_write_data, size_t rel_write_size,
+                        const void *write_data, size_t write_size,
+                        void *read_buf, size_t read_size)
+{
+    int ret = -1;
+
+    if (rel_write_size) {
+        int nframe = rel_write_size/RPMB_FRAME_SIZE;
+        struct rpmb_packet rel_write_frame[nframe];
+        ret = memcpy_s(rel_write_frame, sizeof(rel_write_frame),
+                 rel_write_data, rel_write_size);
+        if(ret){
+            ALOGE("%s: %d: memcpy_s failed.\n", __func__, __LINE__);
+            return ret;
+        }
+        if (rel_write_frame[0].req_resp == swap16(RPMB_REQ_DATA_WRITE))  {
+            if (write_size/RPMB_FRAME_SIZE &&
+                   ((struct rpmb_packet*)write_data)->req_resp == swap16(RPMB_REQ_RESULT_READ))
+                ret = rpmb_write(rel_write_frame, nframe, read_buf, read_size/RPMB_FRAME_SIZE);
+            else
+                ret = rpmb_write(rel_write_frame, nframe, NULL, 0);
+        }
+        else if (rel_write_frame[0].req_resp == swap16(RPMB_REQ_PROGRAM_KEY)) {
+            if (write_size/RPMB_FRAME_SIZE &&
+                   ((struct rpmb_packet*)write_data)->req_resp == swap16(RPMB_REQ_RESULT_READ))
+                ret = rpmb_program_key(rel_write_frame, 1, read_buf, read_size/RPMB_FRAME_SIZE);
+            else
+                ret = rpmb_program_key(rel_write_frame, 1, NULL, 0);
+        }
+    }
+    else if (write_size) {
+        struct rpmb_packet write_frame[write_size/RPMB_FRAME_SIZE];
+        ret = memcpy_s(write_frame, sizeof(write_frame), write_data, write_size);
+        if(ret){
+            ALOGE("%s: %d: memcpy_s failed.\n", __func__, __LINE__);
+            return ret;
+        }
+        if (write_frame[0].req_resp == swap16(RPMB_REQ_DATA_READ)) {
+            ret = rpmb_read(write_frame, 1, read_buf, read_size/RPMB_FRAME_SIZE);
+        }
+        else if (write_frame[0].req_resp == swap16(RPMB_REQ_GET_COUNTER)) {
+            ret = rpmb_get_counter(write_frame, 1, read_buf, 1);
+        }
+    }
+
+    return ret;
+}
+
diff --git a/trusty/storage/proxy/rpmb-sim.h b/trusty/storage/proxy/rpmb-sim.h
new file mode 100644
index 0000000..68ac4cd
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-sim.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * Copyright (C) 2017 Intel Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <trusty/interface/storage.h>
+
+int rpmb_sim_open(const char *rpmb_devname);
+int rpmb_sim_send(struct storage_msg *msg, const void *r, size_t req_len);
+void rpmb_sim_close(void);
+int is_use_sim_rpmb(void);
diff --git a/trusty/storage/proxy/rpmb.c b/trusty/storage/proxy/rpmb.c
index 9c79105..b9d00e8 100644
--- a/trusty/storage/proxy/rpmb.c
+++ b/trusty/storage/proxy/rpmb.c
@@ -51,17 +51,16 @@
 
 static int rpmb_fd = -1;
 static uint8_t read_buf[4096];
+static enum dev_type dev_type = UNKNOWN_RPMB;
 
 #ifdef RPMB_DEBUG
 
-static void print_buf(const char *prefix, const uint8_t *buf, size_t size)
-{
+static void print_buf(const char* prefix, const uint8_t* buf, size_t size) {
     size_t i;
 
     printf("%s @%p [%zu]", prefix, buf, size);
     for (i = 0; i < size; i++) {
-        if (i && i % 32 == 0)
-            printf("\n%*s", (int) strlen(prefix), "");
+        if (i && i % 32 == 0) printf("\n%*s", (int)strlen(prefix), "");
         printf(" %02x", buf[i]);
     }
     printf("\n");
@@ -70,41 +69,16 @@ static void print_buf(const char *prefix, const uint8_t *buf, size_t size)
 
 #endif
 
-
-int rpmb_send(struct storage_msg *msg, const void *r, size_t req_len)
-{
-    int rc;
+static int send_mmc_rpmb_req(int mmc_fd, const struct storage_rpmb_send_req* req) {
     struct {
         struct mmc_ioc_multi_cmd multi;
         struct mmc_ioc_cmd cmd_buf[3];
     } mmc = {};
-    struct mmc_ioc_cmd *cmd = mmc.multi.cmds;
-    const struct storage_rpmb_send_req *req = r;
-
-    if (req_len < sizeof(*req)) {
-        ALOGW("malformed rpmb request: invalid length (%zu < %zu)\n",
-              req_len, sizeof(*req));
-        msg->result = STORAGE_ERR_NOT_VALID;
-        goto err_response;
-    }
-
-    size_t expected_len =
-            sizeof(*req) + req->reliable_write_size + req->write_size;
-    if (req_len != expected_len) {
-        ALOGW("malformed rpmb request: invalid length (%zu != %zu)\n",
-              req_len, expected_len);
-        msg->result = STORAGE_ERR_NOT_VALID;
-        goto err_response;
-    }
+    struct mmc_ioc_cmd* cmd = mmc.multi.cmds;
+    int rc;
 
-    const uint8_t *write_buf = req->payload;
+    const uint8_t* write_buf = req->payload;
     if (req->reliable_write_size) {
-        if ((req->reliable_write_size % MMC_BLOCK_SIZE) != 0) {
-            ALOGW("invalid reliable write size %u\n", req->reliable_write_size);
-            msg->result = STORAGE_ERR_NOT_VALID;
-            goto err_response;
-        }
-
         cmd->write_flag = MMC_WRITE_FLAG_RELW;
         cmd->opcode = MMC_WRITE_MULTIPLE_BLOCK;
         cmd->flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
@@ -121,12 +95,6 @@ int rpmb_send(struct storage_msg *msg, const void *r, size_t req_len)
     }
 
     if (req->write_size) {
-        if ((req->write_size % MMC_BLOCK_SIZE) != 0) {
-            ALOGW("invalid write size %u\n", req->write_size);
-            msg->result = STORAGE_ERR_NOT_VALID;
-            goto err_response;
-        }
-
         cmd->write_flag = MMC_WRITE_FLAG_W;
         cmd->opcode = MMC_WRITE_MULTIPLE_BLOCK;
         cmd->flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
@@ -143,17 +111,9 @@ int rpmb_send(struct storage_msg *msg, const void *r, size_t req_len)
     }
 
     if (req->read_size) {
-        if (req->read_size % MMC_BLOCK_SIZE != 0 ||
-            req->read_size > sizeof(read_buf)) {
-            ALOGE("%s: invalid read size %u\n", __func__, req->read_size);
-            msg->result = STORAGE_ERR_NOT_VALID;
-            goto err_response;
-        }
-
         cmd->write_flag = MMC_WRITE_FLAG_R;
         cmd->opcode = MMC_READ_MULTIPLE_BLOCK;
-        cmd->flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC,
-        cmd->blksz = MMC_BLOCK_SIZE;
+        cmd->flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC, cmd->blksz = MMC_BLOCK_SIZE;
         cmd->blocks = req->read_size / MMC_BLOCK_SIZE;
         mmc_ioc_cmd_set_data((*cmd), read_buf);
 #ifdef RPMB_DEBUG
@@ -163,15 +123,97 @@ int rpmb_send(struct storage_msg *msg, const void *r, size_t req_len)
         cmd++;
     }
 
-    rc = ioctl(rpmb_fd, MMC_IOC_MULTI_CMD, &mmc.multi);
+    rc = ioctl(mmc_fd, MMC_IOC_MULTI_CMD, &mmc.multi);
     if (rc < 0) {
         ALOGE("%s: mmc ioctl failed: %d, %s\n", __func__, rc, strerror(errno));
+    }
+    return rc;
+}
+
+static int send_virt_rpmb_req(int rpmb_fd, void* read_buf, size_t read_size, const void* payload,
+                              size_t payload_size) {
+    int rc;
+    uint16_t res_count = read_size / MMC_BLOCK_SIZE;
+    uint16_t cmd_count = payload_size / MMC_BLOCK_SIZE;
+    rc = write(rpmb_fd, &res_count, sizeof(res_count));
+    if (rc < 0) {
+        return rc;
+    }
+    rc = write(rpmb_fd, &cmd_count, sizeof(cmd_count));
+    if (rc < 0) {
+        return rc;
+    }
+    rc = write(rpmb_fd, payload, payload_size);
+    if (rc < 0) {
+        return rc;
+    }
+    rc = read(rpmb_fd, read_buf, read_size);
+    return rc;
+}
+
+int rpmb_send(struct storage_msg* msg, const void* r, size_t req_len) {
+    int rc;
+    const struct storage_rpmb_send_req* req = r;
+
+    if (req_len < sizeof(*req)) {
+        ALOGW("malformed rpmb request: invalid length (%zu < %zu)\n", req_len, sizeof(*req));
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    size_t expected_len = sizeof(*req) + req->reliable_write_size + req->write_size;
+    if (req_len != expected_len) {
+        ALOGW("malformed rpmb request: invalid length (%zu != %zu)\n", req_len, expected_len);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    if ((req->reliable_write_size % MMC_BLOCK_SIZE) != 0) {
+        ALOGW("invalid reliable write size %u\n", req->reliable_write_size);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    if ((req->write_size % MMC_BLOCK_SIZE) != 0) {
+        ALOGW("invalid write size %u\n", req->write_size);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    if (req->read_size % MMC_BLOCK_SIZE != 0 || req->read_size > sizeof(read_buf)) {
+        ALOGE("%s: invalid read size %u\n", __func__, req->read_size);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    if (dev_type == MMC_RPMB) {
+        rc = send_mmc_rpmb_req(rpmb_fd, req);
+        if (rc < 0) {
+            msg->result = STORAGE_ERR_GENERIC;
+            goto err_response;
+        }
+    } else if (dev_type == VIRT_RPMB) {
+        size_t payload_size = req->reliable_write_size + req->write_size;
+        rc = send_virt_rpmb_req(rpmb_fd, read_buf, req->read_size, req->payload, payload_size);
+        if (rc < 0) {
+            ALOGE("send_virt_rpmb_req failed: %d, %s\n", rc, strerror(errno));
+            msg->result = STORAGE_ERR_GENERIC;
+            goto err_response;
+        }
+        if ((uint32_t)rc != req->read_size) {
+            ALOGE("send_virt_rpmb_req got incomplete response: "
+                  "(size %d, expected %d)\n",
+                  rc, req->read_size);
+            msg->result = STORAGE_ERR_GENERIC;
+            goto err_response;
+        }
+    } else {
+        ALOGE("Unsupported dev_type\n");
         msg->result = STORAGE_ERR_GENERIC;
         goto err_response;
     }
 #ifdef RPMB_DEBUG
-    if (req->read_size)
-        print_buf("response: ", read_buf, req->read_size);
+    if (req->read_size) print_buf("response: ", read_buf, req->read_size);
 #endif
 
     if (msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) {
@@ -188,24 +230,20 @@ err_response:
     return ipc_respond(msg, NULL, 0);
 }
 
-
-int rpmb_open(const char *rpmb_devname)
-{
+int rpmb_open(const char* rpmb_devname, enum dev_type open_dev_type) {
     int rc;
+    dev_type = open_dev_type;
 
     rc = open(rpmb_devname, O_RDWR, 0);
     if (rc < 0) {
-        ALOGE("unable (%d) to open rpmb device '%s': %s\n",
-              errno, rpmb_devname, strerror(errno));
+        ALOGE("unable (%d) to open rpmb device '%s': %s\n", errno, rpmb_devname, strerror(errno));
         return rc;
     }
     rpmb_fd = rc;
     return 0;
 }
 
-void rpmb_close(void)
-{
+void rpmb_close(void) {
     close(rpmb_fd);
     rpmb_fd = -1;
 }
-
diff --git a/trusty/storage/proxy/rpmb.h b/trusty/storage/proxy/rpmb.h
index 85cff44..4c330c9 100644
--- a/trusty/storage/proxy/rpmb.h
+++ b/trusty/storage/proxy/rpmb.h
@@ -18,6 +18,8 @@
 #include <stdint.h>
 #include <trusty/interface/storage.h>
 
-int rpmb_open(const char *rpmb_devname);
-int rpmb_send(struct storage_msg *msg, const void *r, size_t req_len);
+enum dev_type { UNKNOWN_RPMB, MMC_RPMB, VIRT_RPMB };
+
+int rpmb_open(const char* rpmb_devname, enum dev_type dev_type);
+int rpmb_send(struct storage_msg* msg, const void* r, size_t req_len);
 void rpmb_close(void);
diff --git a/trusty/storage/proxy/storage.c b/trusty/storage/proxy/storage.c
index 5b83e21..4ba2ef7 100644
--- a/trusty/storage/proxy/storage.c
+++ b/trusty/storage/proxy/storage.c
@@ -123,7 +123,7 @@ static enum storage_err translate_errno(int error)
     return result;
 }
 
-static ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t offset)
+ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t offset)
 {
     ssize_t rc;
     const uint8_t *buf = buf_;
@@ -136,10 +136,11 @@ static ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t off
         buf += rc;
         offset += rc;
     }
+
     return 0;
 }
 
-static ssize_t read_with_retry(int fd, void *buf_, size_t size, off_t offset)
+ssize_t read_with_retry(int fd, void *buf_, size_t size, off_t offset)
 {
     ssize_t rc;
     size_t  rcnt = 0;
@@ -469,7 +470,9 @@ int storage_init(const char *dirname)
 {
     fs_state = SS_CLEAN;
     dir_state = SS_CLEAN;
-    for (uint i = 0; i < FD_TBL_SIZE; i++) {
+    uint i = 0;
+
+    for (i = 0; i < FD_TBL_SIZE; i++) {
         fd_state[i] = SS_UNUSED;  /* uninstalled */
     }
 
@@ -486,9 +489,10 @@ int storage_init(const char *dirname)
 int storage_sync_checkpoint(void)
 {
     int rc;
+    uint fd = 0;
 
     /* sync fd table and reset it to clean state first */
-    for (uint fd = 0; fd < FD_TBL_SIZE; fd++) {
+    for (fd = 0; fd < FD_TBL_SIZE; fd++) {
          if (fd_state[fd] == SS_DIRTY) {
              if (fs_state == SS_CLEAN) {
                  /* need to sync individual fd */
diff --git a/trusty/storage/proxy/storage.h b/trusty/storage/proxy/storage.h
index 5a670d4..4d659b1 100644
--- a/trusty/storage/proxy/storage.h
+++ b/trusty/storage/proxy/storage.h
@@ -43,3 +43,7 @@ int storage_init(const char *dirname);
 
 int storage_sync_checkpoint(void);
 
+ssize_t write_with_retry(int fd, const void *buf_, size_t size, off_t offset);
+
+ssize_t read_with_retry(int fd, void *buf_, size_t size, off_t offset);
+
diff --git a/trusty/storage/tests/Android.bp b/trusty/storage/tests/Android.bp
index 536c3ca..f631700 100644
--- a/trusty/storage/tests/Android.bp
+++ b/trusty/storage/tests/Android.bp
@@ -30,6 +30,7 @@ cc_test {
         "libtrustystorage",
         "libtrusty",
     ],
+
     shared_libs: [
         "liblog",
     ],
diff --git a/trusty/trusty-base.mk b/trusty/trusty-base.mk
deleted file mode 100644
index 9c3a7df..0000000
--- a/trusty/trusty-base.mk
+++ /dev/null
@@ -1,28 +0,0 @@
-#
-# Copyright (C) 2016 The Android Open-Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-#
-# This makefile should be included by devices that use Trusty TEE
-# to pull in the baseline set of Trusty specific modules.
-#
-
-PRODUCT_PACKAGES += \
-	keystore.trusty \
-	gatekeeper.trusty
-
-PRODUCT_PROPERTY_OVERRIDES += \
-	ro.hardware.keystore=trusty \
-	ro.hardware.gatekeeper=trusty
diff --git a/trusty/trusty-storage.mk b/trusty/trusty-storage.mk
deleted file mode 100644
index 3f26316..0000000
--- a/trusty/trusty-storage.mk
+++ /dev/null
@@ -1,18 +0,0 @@
-#
-# Copyright (C) 2015 The Android Open-Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-PRODUCT_PACKAGES += \
-	storageproxyd \
-- 
2.7.4

