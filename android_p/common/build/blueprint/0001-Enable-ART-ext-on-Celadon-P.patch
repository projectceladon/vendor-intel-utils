From 1c148522a8335a45d7ce84e00dc780e345f1fa8a Mon Sep 17 00:00:00 2001
From: reddyr3x <rakeshx.reddy@intel.com>
Date: Tue, 14 Aug 2018 11:16:12 +0530
Subject: [PATCH] Enable ART-ext on Celadon-P

Tracked-On: OAM-67515
Signed-off-by: yasoda <lab_aqa@intel.com>
---
 bootstrap.bash        |  8 +++++
 bootstrap/build.ninja |  2 +-
 bootstrap/command.go  | 94 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 102 insertions(+), 2 deletions(-)

diff --git a/bootstrap.bash b/bootstrap.bash
index 24f16c2..2006adb 100755
--- a/bootstrap.bash
+++ b/bootstrap.bash
@@ -101,10 +101,18 @@ EXTRA_ARGS="${EXTRA_ARGS} -l ${BLUEPRINT_LIST_FILE}"
 
 mkdir -p $BUILDDIR/.minibootstrap
 
+if [ ! -z "$VENDOR_ART_PATH" ] && [ "$VENDOR_ART_PATH" == "art" ] ; then
+    EXCLUDE_ART="art-extension/"
+
+else
+    EXCLUDE_ART="art/"
+fi
+
 echo "bootstrapBuildDir = $BUILDDIR" > $BUILDDIR/.minibootstrap/build.ninja
 echo "topFile = $SRCDIR/$TOPNAME" >> $BUILDDIR/.minibootstrap/build.ninja
 echo "extraArgs = $EXTRA_ARGS" >> $BUILDDIR/.minibootstrap/build.ninja
 echo "builddir = $NINJA_BUILDDIR" >> $BUILDDIR/.minibootstrap/build.ninja
+echo "excludeArt = $EXCLUDE_ART" >> $BUILDDIR/.minibootstrap/build.ninja
 echo "include $BLUEPRINTDIR/bootstrap/build.ninja" >> $BUILDDIR/.minibootstrap/build.ninja
 
 echo "BLUEPRINT_BOOTSTRAP_VERSION=2" > $BUILDDIR/.blueprint.bootstrap
diff --git a/bootstrap/build.ninja b/bootstrap/build.ninja
index b338843..bbeb46e 100644
--- a/bootstrap/build.ninja
+++ b/bootstrap/build.ninja
@@ -8,7 +8,7 @@
 ninja_required_version = 1.7.0
 
 rule build.ninja
-    command = ${builder} ${extraArgs} -b ${bootstrapBuildDir} -n ${builddir} -d ${out}.d -o ${out} ${in}
+    command = ${builder} ${extraArgs} -b ${bootstrapBuildDir} -n ${builddir} -d ${out}.d -o ${out} -e ${excludeArt} ${in}
     deps = gcc
     depfile = ${out}.d
     description = ${builder} ${out}
diff --git a/bootstrap/command.go b/bootstrap/command.go
index 04eb535..8e53d12 100644
--- a/bootstrap/command.go
+++ b/bootstrap/command.go
@@ -25,7 +25,9 @@ import (
 	"runtime/debug"
 	"runtime/pprof"
 	"runtime/trace"
-
+        "bufio"
+	"log"
+	"strings"
 	"github.com/google/blueprint"
 	"github.com/google/blueprint/deptools"
 )
@@ -44,6 +46,7 @@ var (
 	BuildDir      string
 	NinjaBuildDir string
 	SrcDir        string
+	excludeArt    string
 )
 
 func init() {
@@ -58,6 +61,7 @@ func init() {
 	flag.BoolVar(&noGC, "nogc", false, "turn off GC for debugging")
 	flag.BoolVar(&runGoTests, "t", false, "build and run go tests during bootstrap")
 	flag.StringVar(&moduleListFile, "l", "", "file that lists filepaths to parse")
+	flag.StringVar(&excludeArt, "e", "", "exclude art env string")
 }
 
 func Main(ctx *blueprint.Context, config interface{}, extraNinjaFileDeps ...string) {
@@ -97,6 +101,9 @@ func Main(ctx *blueprint.Context, config interface{}, extraNinjaFileDeps ...stri
 
 	SrcDir = filepath.Dir(flag.Arg(0))
 	if moduleListFile != "" {
+	        if excludeArt != "" {
+		   checkForVendorArt(moduleListFile,excludeArt)
+		}
 		ctx.SetModuleListFile(moduleListFile)
 		extraNinjaFileDeps = append(extraNinjaFileDeps, moduleListFile)
 	} else {
@@ -226,3 +233,88 @@ func fatalErrors(errs []error) {
 	}
 	os.Exit(1)
 }
+
+func checkForVendorArt(filepath string,exclude string) {
+    var f *os.File
+    f, err := os.OpenFile(filepath,
+                         os.O_RDWR,
+                         0666)
+    if err != nil {
+        log.Fatal(err)
+    }
+    defer f.Close()
+    if len(exclude) != 0 {
+       scanner := bufio.NewScanner(f)
+       nr := 1
+       count := 0
+       tmp:= 0
+       for scanner.Scan() {
+          if strings.Contains(scanner.Text(),exclude) {
+             if tmp == 0 {
+               tmp = nr
+             }
+            count++
+          }
+          nr++
+       }
+       if err := scanner.Err(); err != nil {
+          // Handle the error
+          log.Fatal(err)
+       }
+       if count != 0 {
+          if err := removeLines(filepath, tmp, count); err != nil {
+            log.Fatal(err)
+          }
+       }
+    }
+    return
+}
+
+func removeLines(filepath string, start, n int) (err error) {
+    var f *os.File
+    if f, err = os.OpenFile(filepath, os.O_RDWR, 0); err != nil {
+        return
+    }
+    defer func() {
+        if cErr := f.Close(); err == nil {
+            err = cErr
+        }
+    }()
+    var b []byte
+    if b, err = ioutil.ReadAll(f); err != nil {
+        return
+    }
+    cut, ok := skip(b, start-1)
+    if !ok {
+        return fmt.Errorf("less than %d lines", start)
+    }
+    if n == 0 {
+        return nil
+    }
+    tail, ok := skip(cut, n)
+    t := int64(len(b) - len(cut))
+    if err = f.Truncate(t); err != nil {
+        log.Fatal(err)
+    }
+    if len(tail) > 0 {
+        _, err = f.WriteAt(tail, t)
+    }
+    return
+}
+
+func skip(b []byte, n int) ([]byte, bool) {
+    for ; n > 0; n-- {
+       if len(b) == 0 {
+          return nil, false
+       }
+       x := bytes.IndexByte(b, '\n')
+       if x < 0 {
+          x = len(b)
+       } else {
+          x++
+       }
+       b = b[x:]
+    }
+    return b, true
+}
+
-- 
1.9.1

