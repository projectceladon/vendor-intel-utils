From 208ddb07f526ec6735f894ff2f72acd56ea17d09 Mon Sep 17 00:00:00 2001
From: Tomas Winkler <tomas.winkler@intel.com>
Date: Mon, 25 Jul 2016 18:37:13 +0300
Subject: [PATCH 02/17] Trusty: Enable storageproxyd daemon

Storageproxyd: add support for rpmb devices

Jira: None
Test: Device boots to home screen.
Change-Id: I7cd4cad467878ecb27245e323fc280877886f66e
Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
Signed-off-by: Huang, Yang <yang.huang@intel.com>
---
 trusty/storage/proxy/linux/rpmb.h | 152 +++++++++++++++++++++++++++++++
 trusty/storage/proxy/proxy.c      |  40 +++++++--
 trusty/storage/proxy/rpmb-dev.c   | 182 ++++++++++++++++++++++++++++++++++++++
 trusty/storage/proxy/rpmb-dev.h   |  23 +++++
 trusty/storage/proxy/storage.c    |   7 +-
 5 files changed, 396 insertions(+), 8 deletions(-)
 create mode 100644 trusty/storage/proxy/linux/rpmb.h
 create mode 100644 trusty/storage/proxy/rpmb-dev.c
 create mode 100644 trusty/storage/proxy/rpmb-dev.h

diff --git a/trusty/storage/proxy/linux/rpmb.h b/trusty/storage/proxy/linux/rpmb.h
new file mode 100644
index 0000000..a6fa78e
--- /dev/null
+++ b/trusty/storage/proxy/linux/rpmb.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2015-2016, Intel Corp.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI_LINUX_RPMB_H_
+#define _UAPI_LINUX_RPMB_H_
+
+#include <linux/types.h>
+
+/**
+ * struct rpmb_frame - rpmb frame as defined by specs
+ *
+ * @stuff        : stuff bytes
+ * @key_mac      : The authentication key or the message authentication
+ *                 code (MAC) depending on the request/response type.
+ *                 The MAC will be delivered in the last (or the only)
+ *                 block of data.
+ * @data         : Data to be written or read by signed access.
+ * @nonce        : Random number generated by the host for the requests
+ *                 and copied to the response by the RPMB engine.
+ * @write_counter: Counter value for the total amount of the successful
+ *                 authenticated data write requests made by the host.
+ * @addr         : Address of the data to be programmed to or read
+ *                 from the RPMB. Address is the serial number of
+ *                 the accessed block (half sector 256B).
+ * @block_count  : Number of blocks (half sectors, 256B) requested to be
+ *                 read/programmed.
+ * @result       : Includes information about the status of the write counter
+ *                 (valid, expired) and result of the access made to the RPMB.
+ * @req_resp     : Defines the type of request and response to/from the memory.
+ */
+struct rpmb_frame {
+	__u8   stuff[196];
+	__u8   key_mac[32];
+	__u8   data[256];
+	__u8   nonce[16];
+	__be32 write_counter;
+	__be16 addr;
+	__be16 block_count;
+	__be16 result;
+	__be16 req_resp;
+} __attribute__((packed));
+
+#define RPMB_PROGRAM_KEY       0x1    /* Program RPMB Authentication Key */
+#define RPMB_GET_WRITE_COUNTER 0x2    /* Read RPMB write counter */
+#define RPMB_WRITE_DATA        0x3    /* Write data to RPMB partition */
+#define RPMB_READ_DATA         0x4    /* Read data from RPMB partition */
+#define RPMB_RESULT_READ       0x5    /* Read result request  (Internal) */
+
+#define RPMB_REQ2RESP(_OP) ((_OP) << 8)
+#define RPMB_RESP2REQ(_OP) ((_OP) >> 8)
+
+/* length of the part of the frame used for HMAC computation */
+#define hmac_data_len \
+	(sizeof(struct rpmb_frame) - offsetof(struct rpmb_frame, data))
+
+/**
+ * enum rpmb_op_result - rpmb operation results
+ *
+ * @RPMB_ERR_OK:       operation successful
+ * @RPMB_ERR_GENERAL:  general failure
+ * @RPMB_ERR_AUTH:     mac doesn't match or ac calculation failure
+ * @RPMB_ERR_COUNTER:  counter doesn't match or counter increment failure
+ * @RPMB_ERR_ADDRESS:  address out of range or wrong address alignment
+ * @RPMB_ERR_WRITE:    data, counter, or result write failure
+ * @RPMB_ERR_READ:     data, counter, or result read failure
+ * @RPMB_ERR_NO_KEY:   authentication key not yet programmed
+ *
+ * @RPMB_ERR_COUNTER_EXPIRED:  counter expired
+ */
+enum rpmb_op_result {
+	RPMB_ERR_OK      = 0x0000,
+	RPMB_ERR_GENERAL = 0x0001,
+	RPMB_ERR_AUTH    = 0x0002,
+	RPMB_ERR_COUNTER = 0x0003,
+	RPMB_ERR_ADDRESS = 0x0004,
+	RPMB_ERR_WRITE   = 0x0005,
+	RPMB_ERR_READ    = 0x0006,
+	RPMB_ERR_NO_KEY  = 0x0007,
+
+	RPMB_ERR_COUNTER_EXPIRED = 0x0080
+};
+
+#define RPMB_F_WRITE     (1UL << 0)
+#define RPMB_F_REL_WRITE (1UL << 1)
+
+/**
+ * struct rpmb_cmd: rpmb access command
+ *
+ * @flags:   command flags
+ *      0 - read command
+ *      1 - write commnad RPMB_F_WRITE
+ *      2 -  reliable write RPMB_F_REL_WRITE
+ * @nframes: number of rpmb frames in the command
+ * @frames_ptr:  a pointer to the list of rpmb frames
+ */
+struct rpmb_ioc_cmd {
+	__u32 flags;
+	__u32 nframes;
+	__aligned_u64 frames_ptr;
+};
+
+#define rpmb_ioc_cmd_set_frames(_cmd, _ptr) \
+	(_cmd).frames_ptr = (__aligned_u64)(intptr_t)(_ptr)
+
+#define rpmb_ioc_cmd_set(_cmd, _flags, _ptr, _n) do {         \
+	(_cmd).flags = (_flags);                              \
+	(_cmd).nframes = (_n);                                \
+	(_cmd).frames_ptr = (__aligned_u64)(intptr_t)(_ptr);  \
+} while (0)
+
+/**
+ * struct rpmb_ioc_req_cmd - rpmb operation request command
+ *
+ * @req_type: request type:  must match the in frame req_resp
+ *            program key
+ *            get write counter
+ *            write data
+ *            read data
+ * @icmd: input command
+ * @ocmd: output/result command
+ */
+struct rpmb_ioc_req_cmd {
+	__u64 req_type;
+	struct rpmb_ioc_cmd icmd;
+	struct rpmb_ioc_cmd ocmd;
+};
+
+/**
+ * struct rpmb_ioc_seq_cmd - rpmb command sequence
+ *
+ * @num_of_cmds: number of commands
+ * @cmds: list of rpmb commands
+ */
+struct rpmb_ioc_seq_cmd {
+	__u64 num_of_cmds;
+	struct rpmb_ioc_cmd cmds[0];
+};
+
+#define RPMB_IOC_REQ_CMD _IOWR(0xB5, 0, struct rpmb_ioc_req_cmd)
+#define RPMB_IOC_SEQ_CMD _IOWR(0xB5, 1, struct rpmb_ioc_seq_cmd)
+
+#endif /* _UAPI_LINUX_RPMB_H_ */
diff --git a/trusty/storage/proxy/proxy.c b/trusty/storage/proxy/proxy.c
index 41263e5..679543a 100644
--- a/trusty/storage/proxy/proxy.c
+++ b/trusty/storage/proxy/proxy.c
@@ -21,14 +21,18 @@
 #include <stdlib.h>
 #include <sys/capability.h>
 #include <sys/prctl.h>
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
-#include <cutils/android_filesystem_config.h>
+#include <linux/major.h>
+
+#include <private/android_filesystem_config.h>
 
 #include "ipc.h"
 #include "log.h"
 #include "rpmb.h"
+#include "rpmb-dev.h"
 #include "storage.h"
 
 #define REQ_BUFFER_SIZE 4096
@@ -48,6 +52,8 @@ static const struct option _lopts[] =  {
     {0, 0, 0, 0}
 };
 
+static unsigned int rpmb_major;
+
 static void show_usage_and_exit(int code)
 {
     ALOGE("usage: storageproxyd -d <trusty_dev> -p <data_path> -r <rpmb_dev>\n");
@@ -148,7 +154,10 @@ static int handle_req(struct storage_msg *msg, const void *req, size_t req_len)
         break;
 
     case STORAGE_RPMB_SEND:
-        rc = rpmb_send(msg, req, req_len);
+        if (rpmb_major == MMC_BLOCK_MAJOR)
+            rc = rpmb_send(msg, req, req_len);
+        else
+            rc = rpmb_dev_send(msg, req, req_len);
         break;
 
     default:
@@ -229,10 +238,17 @@ static void parse_args(int argc, char *argv[])
 int main(int argc, char *argv[])
 {
     int rc;
-
-    /* drop privileges */
+    uint retry_cnt;
+    struct stat st;
+
+    /*service is enabled with system rather than root privelege,
+    so that drop_privs() is not required. This usage is more secure
+    than enableing with root preveledge and dropping redundant privs.
+    */
+    /* drop privileges
     if (drop_privs() < 0)
         return EXIT_FAILURE;
+    */
 
     /* parse arguments */
     parse_args(argc, argv);
@@ -243,7 +259,16 @@ int main(int argc, char *argv[])
         return EXIT_FAILURE;
 
     /* open rpmb device */
-    rc = rpmb_open(rpmb_devname);
+    rc = lstat(rpmb_devname, &st);
+    if (rc < 0)
+        return EXIT_FAILURE;
+    rpmb_major = major(st.st_dev);
+
+    if (rpmb_major == MMC_BLOCK_MAJOR)
+        rc = rpmb_open(rpmb_devname);
+    else
+        rc = rpmb_dev_open(rpmb_devname);
+
     if (rc < 0)
         return EXIT_FAILURE;
 
@@ -257,7 +282,10 @@ int main(int argc, char *argv[])
     ALOGE("exiting proxy loop with status (%d)\n", rc);
 
     ipc_disconnect();
-    rpmb_close();
+    if (rpmb_major == MMC_BLOCK_MAJOR)
+        rpmb_close();
+    else
+        rpmb_dev_close();
 
     return (rc < 0) ? EXIT_FAILURE : EXIT_SUCCESS;
 }
diff --git a/trusty/storage/proxy/rpmb-dev.c b/trusty/storage/proxy/rpmb-dev.c
new file mode 100644
index 0000000..e116cac
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-dev.c
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+
+#include "linux/rpmb.h"
+
+#include "ipc.h"
+#include "log.h"
+#include "rpmb.h"
+#include "storage.h"
+
+#define RPMB_BLOCK_SIZE sizeof(struct rpmb_frame)
+
+static int rpmb_fd = -1;
+static uint8_t read_buf[4096];
+
+#ifdef RPMB_DEBUG
+
+static void print_buf(const char *prefix, const uint8_t *buf, size_t size)
+{
+    size_t i;
+
+    printf("%s @%p [%zu]", prefix, buf, size);
+    for (i = 0; i < size; i++) {
+        if (i && i % 32 == 0)
+            printf("\n%*s", (int) strlen(prefix), "");
+        printf(" %02x", buf[i]);
+    }
+    printf("\n");
+    fflush(stdout);
+}
+
+#endif /* RPMB_DEBUG */
+
+
+int rpmb_dev_send(struct storage_msg *msg, const void *r, size_t req_len)
+{
+    int rc;
+    uint32_t blocks;
+    struct {
+        struct rpmb_ioc_seq_cmd seq;
+        struct rpmb_ioc_cmd cmd[3];
+    } rpmb = {};
+    struct rpmb_ioc_cmd *cmd = rpmb.seq.cmds;
+    const struct storage_rpmb_send_req *req = r;
+
+    if (req_len < sizeof(*req)) {
+        ALOGW("malformed rpmb request: invalid length (%zu < %zu)\n",
+              req_len, sizeof(*req));
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    size_t expected_len = sizeof(*req) + req->reliable_write_size + req->write_size;
+    if (req_len != expected_len) {
+        ALOGW("malformed rpmb request: invalid length (%zu != %zu)\n",
+              req_len, expected_len);
+        msg->result = STORAGE_ERR_NOT_VALID;
+        goto err_response;
+    }
+
+    const uint8_t *write_buf = req->payload;
+    if (req->reliable_write_size) {
+        if ((req->reliable_write_size % RPMB_BLOCK_SIZE) != 0) {
+            ALOGW("invalid reliable write size %u\n", req->reliable_write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+
+        blocks = req->reliable_write_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, RPMB_F_WRITE | RPMB_F_REL_WRITE, write_buf, blocks);
+
+#ifdef RPMB_DEBUG
+        ALOGI("opcode: 0x%x, write_flag: 0x%x\n", cmd->opcode, cmd->write_flag);
+        //print_buf("request: ", write_buf, req->reliable_write_size);
+#endif
+        write_buf += req->reliable_write_size;
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    if (req->write_size) {
+        if ((req->write_size % RPMB_BLOCK_SIZE) != 0) {
+            ALOGW("invalid write size %u\n", req->write_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+        blocks = req->write_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, RPMB_F_WRITE, write_buf, blocks);
+
+#ifdef RPMB_DEBUG
+        ALOGI("opcode: 0x%x, write_flag: 0x%x\n", cmd->opcode, cmd->write_flag);
+        print_buf("request: ", write_buf, req->write_size);
+#endif
+        write_buf += req->write_size;
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    if (req->read_size) {
+        if (req->read_size % RPMB_BLOCK_SIZE != 0 ||
+            req->read_size > sizeof(read_buf)) {
+            ALOGE("%s: invalid read size %u\n", __func__, req->read_size);
+            msg->result = STORAGE_ERR_NOT_VALID;
+            goto err_response;
+        }
+
+        blocks = req->read_size / RPMB_BLOCK_SIZE;
+        rpmb_ioc_cmd_set(*cmd, 0, read_buf, blocks);
+
+        rpmb.seq.num_of_cmds++;
+        cmd++;
+    }
+
+    rc = ioctl(rpmb_fd, RPMB_IOC_SEQ_CMD, &rpmb.seq);
+    if (rc < 0) {
+        ALOGE("%s: mmc ioctl failed: %d, %s\n", __func__, rc, strerror(errno));
+        msg->result = STORAGE_ERR_GENERIC;
+        goto err_response;
+    }
+#ifdef RPMB_DEBUG
+    if (req->read_size)
+        print_buf("response: ", read_buf, req->read_size);
+#endif
+
+    if (msg->flags & STORAGE_MSG_FLAG_POST_COMMIT) {
+        /*
+         * Nothing todo for post msg commit request as RPMB_IOC_SEQ_CMD
+         * is fully synchronous in this implementation.
+         */
+    }
+
+    msg->result = STORAGE_NO_ERROR;
+    return ipc_respond(msg, read_buf, req->read_size);
+
+err_response:
+    return ipc_respond(msg, NULL, 0);
+}
+
+
+int rpmb_dev_open(const char *rpmb_devname)
+{
+    int rc;
+
+    rc = open(rpmb_devname, O_RDWR, 0);
+    if (rc < 0) {
+        ALOGE("unable (%d) to open rpmb device '%s': %s\n",
+              errno, rpmb_devname, strerror(errno));
+        return rc;
+    }
+    rpmb_fd = rc;
+    return 0;
+}
+
+void rpmb_dev_close(void)
+{
+    close(rpmb_fd);
+    rpmb_fd = -1;
+}
+
diff --git a/trusty/storage/proxy/rpmb-dev.h b/trusty/storage/proxy/rpmb-dev.h
new file mode 100644
index 0000000..4493695
--- /dev/null
+++ b/trusty/storage/proxy/rpmb-dev.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <stdint.h>
+#include <trusty/interface/storage.h>
+
+int rpmb_dev_open(const char *rpmb_devname);
+int rpmb_dev_send(struct storage_msg *msg, const void *r, size_t req_len);
+void rpmb_dev_close(void);
diff --git a/trusty/storage/proxy/storage.c b/trusty/storage/proxy/storage.c
index c61e89d..05d004f 100644
--- a/trusty/storage/proxy/storage.c
+++ b/trusty/storage/proxy/storage.c
@@ -469,7 +469,9 @@ int storage_init(const char *dirname)
 {
     fs_state = SS_CLEAN;
     dir_state = SS_CLEAN;
-    for (uint i = 0; i < FD_TBL_SIZE; i++) {
+    uint i = 0;
+
+    for (i = 0; i < FD_TBL_SIZE; i++) {
         fd_state[i] = SS_UNUSED;  /* uninstalled */
     }
 
@@ -486,9 +488,10 @@ int storage_init(const char *dirname)
 int storage_sync_checkpoint(void)
 {
     int rc;
+    uint fd = 0;
 
     /* sync fd table and reset it to clean state first */
-    for (uint fd = 0; fd < FD_TBL_SIZE; fd++) {
+    for (fd = 0; fd < FD_TBL_SIZE; fd++) {
          if (fd_state[fd] == SS_DIRTY) {
              if (fs_state == SS_CLEAN) {
                  /* need to sync individual fd */
-- 
2.7.4

