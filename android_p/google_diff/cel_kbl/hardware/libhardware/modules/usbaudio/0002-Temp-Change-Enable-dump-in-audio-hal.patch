From d3db67ca4997a4bb8091f2bc4a5535b0b6c7b51e Mon Sep 17 00:00:00 2001
From: Karan Patidar <karan.patidar@intel.com>
Date: Tue, 2 Apr 2019 10:45:48 +0530
Subject: [PATCH] Temp Change : Enable dump in audio hal

Enabling call data dump for debugging.

Change-Id: I3019cd34cf744de93fed2966869f9c5f6f7ee713
Tracked-On:
Signed-off-by: Karan Patidar <karan.patidar@intel.com>
---
 modules/usbaudio/audio_hal.c | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/modules/usbaudio/audio_hal.c b/modules/usbaudio/audio_hal.c
index 668537cc..3fb2a6b3 100644
--- a/modules/usbaudio/audio_hal.c
+++ b/modules/usbaudio/audio_hal.c
@@ -15,7 +15,7 @@
  */
 
 #define LOG_TAG "modules.usbaudio.audio_hal"
-//#define LOG_NDEBUG 0
+#define LOG_NDEBUG 0
 
 #include <errno.h>
 #include <inttypes.h>
@@ -49,7 +49,7 @@
 #define AUDIO_PARAMETER_CARD         "card"
 #define AUDIO_PARAMETER_HFP_ENABLE   "hfp_enable"
 #define AUDIO_BT_DRIVER_NAME         "btaudiosource"
-//#define DEBUG_PCM_DUMP
+#define DEBUG_PCM_DUMP
 //#define DEBUG_DEVICE_INFO
 // BT-HFP ]
 
@@ -1510,6 +1510,10 @@ int looper(struct audio_device *adev, struct pcm_config *in_config, struct pcm_c
     size_t buf_size_out;
     size_t buf_size_remapped;
 
+    const alsa_device_profile *profile = in_proxy->profile;
+    ALOGW("%s : id %s card %d device %d direction %d pcm %p",__func__, id, profile->card, profile->device, profile->direction, &(in_proxy->pcm));
+    const alsa_device_profile *profile_out = out_proxy->profile;
+    ALOGW("%s : id %s card %d device %d direction %d pcm %p",__func__, id, profile_out->card, profile_out->device, profile_out->direction, &(out_proxy->pcm));
 #ifdef DEBUG_PCM_DUMP
     char dump_path[PATH_MAX] = {0};
     snprintf(dump_path, sizeof(dump_path), "/vendor/dump/loopback_read_%s.pcm", id);
@@ -1710,8 +1714,17 @@ static int adev_set_parameters(struct audio_hw_device *hw_dev, const char *kvpai
         ALOGD("%s : updated bt_card : %d",__func__, adev->btcard);
         pthread_mutex_lock(&adev->param_thread_lock);
         if (strcmp(value, "true") == 0){
+            /*check if previous execution of hfp_enable=true has not yet completed.
+            if(adev->usb_thread != 0 || adev->sco_thread != 0) {
+                ALOGE("%s : previous execution of hfp_enable has not yet completed.",__func__);
+                adev->terminate_sco_loopback = false;
+                pthread_mutex_unlock(&adev->param_thread_lock);
+                return 0;
+			}*/
             //Open and prepare pcm devices before the thread starts read and write.
-            int prep_status = prepare_loopback_parameters(adev);
+            int prep_status = -1;
+			prep_status = prepare_loopback_parameters(adev);
+			ALOGD("%s : prep_status : %d", __func__, prep_status);
             if(prep_status == 0){
                 adev->terminate_sco_loopback = false;
                 pthread_create(&adev->usb_thread, NULL, &run_usb_bt_loopback, adev);
-- 
2.20.1

