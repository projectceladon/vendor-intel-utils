From 05e3b88f17afb8814ba69e062c2b5ceb628d5686 Mon Sep 17 00:00:00 2001
From: anuvarsh <anuvarshini.bc@intel.com>
Date: Mon, 14 Oct 2019 14:22:49 +0530
Subject: [PATCH] Audio patch

Tracked-On:
Signed-off-by: anuvarsh <anuvarshini.bc@intel.com>
---
 media/libaudioprocessing/Android.mk           |  2 +-
 .../libaudioprocessing/AudioResamplerFirOps.h |  6 +++
 .../AudioResamplerFirProcessSSE.h             | 44 ++++++++++++++-----
 3 files changed, 40 insertions(+), 12 deletions(-)

diff --git a/media/libaudioprocessing/Android.mk b/media/libaudioprocessing/Android.mk
index da1ecc204..d2c314097 100644
--- a/media/libaudioprocessing/Android.mk
+++ b/media/libaudioprocessing/Android.mk
@@ -30,7 +30,7 @@ LOCAL_SHARED_LIBRARIES := \
 
 LOCAL_MODULE := libaudioprocessing
 
-LOCAL_CFLAGS := -Werror -Wall
+LOCAL_CFLAGS := -Werror -Wall -mavx2 -mfma
 
 # uncomment to disable NEON on architectures that actually do support NEON, for benchmarking
 #LOCAL_CFLAGS += -DUSE_NEON=false
diff --git a/media/libaudioprocessing/AudioResamplerFirOps.h b/media/libaudioprocessing/AudioResamplerFirOps.h
index 2e4cee3aa..f17b54775 100644
--- a/media/libaudioprocessing/AudioResamplerFirOps.h
+++ b/media/libaudioprocessing/AudioResamplerFirOps.h
@@ -39,6 +39,12 @@ namespace android {
 #if defined(__SSSE3__)  // Should be supported in x86 ABI for both 32 & 64-bit.
 #define USE_SSE (true)
 #include <tmmintrin.h>
+#if defined(__AVX2__)  // Should be supported in x86 ABI for both 32 & 64-bit.
+#define USE_AVX2 (true)
+#include <immintrin.h>
+#else
+#define USE_AVX2(false)
+#endif
 #else
 #define USE_SSE (false)
 #endif
diff --git a/media/libaudioprocessing/AudioResamplerFirProcessSSE.h b/media/libaudioprocessing/AudioResamplerFirProcessSSE.h
index 30233b5ae..7f4bd7ae5 100644
--- a/media/libaudioprocessing/AudioResamplerFirProcessSSE.h
+++ b/media/libaudioprocessing/AudioResamplerFirProcessSSE.h
@@ -79,12 +79,17 @@ static inline void ProcessSSEIntrinsic(float* out,
             // negCoef = interp * (negCoef - negCoef1) + negCoef1
             posCoef1 = _mm_sub_ps(posCoef1, posCoef);
             negCoef = _mm_sub_ps(negCoef, negCoef1);
-
+	
+	    #if USE_AVX2
+            posCoef = _mm_fmadd_ps(posCoef1, interp, posCoef);
+            negCoef = _mm_fmadd_ps(negCoef, interp, negCoef1);
+            #else	
             posCoef1 = _mm_mul_ps(posCoef1, interp);
             negCoef = _mm_mul_ps(negCoef, interp);
 
             posCoef = _mm_add_ps(posCoef1, posCoef);
             negCoef = _mm_add_ps(negCoef, negCoef1);
+	    #endif //USE_AVX2
         }
         switch (CHANNELS) {
         case 1: {
@@ -94,11 +99,16 @@ static inline void ProcessSSEIntrinsic(float* out,
             sN += 4;
 
             posSamp = _mm_shuffle_ps(posSamp, posSamp, 0x1B);
+	    #if USE_AVX2
+            accL = _mm_fmadd_ps(posSamp, posCoef, accL);
+            accL = _mm_fmadd_ps(negSamp, negCoef, accL);
+            #else	
             posSamp = _mm_mul_ps(posSamp, posCoef);
             negSamp = _mm_mul_ps(negSamp, negCoef);
 
             accL = _mm_add_ps(accL, posSamp);
             accL = _mm_add_ps(accL, negSamp);
+	    #endif	
         } break;
         case 2: {
             __m128 posSamp0 = _mm_loadu_ps(sP);
@@ -113,16 +123,24 @@ static inline void ProcessSSEIntrinsic(float* out,
             __m128 posSampR = _mm_shuffle_ps(posSamp1, posSamp0, 0x77);
             __m128 negSampL = _mm_shuffle_ps(negSamp0, negSamp1, 0x88);
             __m128 negSampR = _mm_shuffle_ps(negSamp0, negSamp1, 0xDD);
+	    
+	   #if USE_AVX2
+           accL = _mm_fmadd_ps(posSampL, posCoef, accL);
+           accR = _mm_fmadd_ps(posSampR, posCoef, accR);
+           accL = _mm_fmadd_ps(negSampL, negCoef, accL);
+           accR = _mm_fmadd_ps(negSampR, negCoef, accR);
+           #else
+           posSampL = _mm_mul_ps(posSampL, posCoef);
+           posSampR = _mm_mul_ps(posSampR, posCoef);
+           negSampL = _mm_mul_ps(negSampL, negCoef);
+           negSampR = _mm_mul_ps(negSampR, negCoef);
+
+           accL = _mm_add_ps(accL, posSampL);
+           accR = _mm_add_ps(accR, posSampR);
+           accL = _mm_add_ps(accL, negSampL);
+           accR = _mm_add_ps(accR, negSampR);
+           #endif	 	
 
-            posSampL = _mm_mul_ps(posSampL, posCoef);
-            posSampR = _mm_mul_ps(posSampR, posCoef);
-            negSampL = _mm_mul_ps(negSampL, negCoef);
-            negSampR = _mm_mul_ps(negSampR, negCoef);
-
-            accL = _mm_add_ps(accL, posSampL);
-            accR = _mm_add_ps(accR, posSampR);
-            accL = _mm_add_ps(accL, negSampL);
-            accR = _mm_add_ps(accR, negSampR);
         } break;
         }
     } while (count -= 4);
@@ -144,9 +162,13 @@ static inline void ProcessSSEIntrinsic(float* out,
         outAccum = _mm_hadd_ps(accL, accR);
         outAccum = _mm_hadd_ps(outAccum, outAccum);
     }
-
+    #if USE_AVX2
+    outSamp = _mm_fmadd_ps(outAccum, vLR,outSamp);
+    #else
     outAccum = _mm_mul_ps(outAccum, vLR);
     outSamp = _mm_add_ps(outSamp, outAccum);
+    #endif
+
     _mm_storel_pi(reinterpret_cast<__m64*>(out), outSamp);
 }
 
-- 
2.23.0

