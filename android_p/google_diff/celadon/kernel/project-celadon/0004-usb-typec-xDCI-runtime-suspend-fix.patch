From b1678a2c24d206aff60ed577c91f841fe487ce86 Mon Sep 17 00:00:00 2001
From: Abhilash K V <abhilash.k.v@intel.com>
Date: Thu, 22 Jun 2017 20:20:59 +0530
Subject: [PATCH 04/11] usb: typec: xDCI runtime suspend fix

Original patch puled from https://github.com/01org/ref-os-iot

b4ef7135dc0c4822e88264f23409bca771b05ef2 xDCI runtime suspend fix.

Wakeup xHCI PCI device for period of accessing DUAL_ROLE_CFG registers
when type-c cable is connected/disconnected. This is needed because
registers are located in xHCI MMIO address space and it requires xHCI
PCI primary bus to be powered on during the access.

Jira : None
Test : Basic USB sanity

Change-Id: I53931c0f23e66716741ebc3b0612e7630a7407c3
Signed-off-by: Nippula, Jari <jari.nippula@intel.com>
Signed-off-by: Vaibhav Agarwal <vaibhav.agarwal@intel.com>
Signed-off-by: Avinash Kumar <avinash3.kumar@intel.com>
Signed-off-by: Abhilash K V <abhilash.k.v@intel.com>
---
 drivers/usb/typec/typec_wcove.c | 23 +++++++++++++++++++++++
 1 file changed, 23 insertions(+)

diff --git a/drivers/usb/typec/typec_wcove.c b/drivers/usb/typec/typec_wcove.c
index e9c4e78..74607bb 100644
--- a/drivers/usb/typec/typec_wcove.c
+++ b/drivers/usb/typec/typec_wcove.c
@@ -15,6 +15,8 @@
 #include <linux/usb/typec.h>
 #include <linux/platform_device.h>
 #include <linux/mfd/intel_soc_pmic.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
 
 /* Register offsets */
 #define WCOVE_CHGRIRQ0		0x4e09
@@ -86,6 +88,7 @@ struct wcove_typec {
 	struct typec_port *port;
 	struct typec_capability cap;
 	struct typec_partner *partner;
+	struct pci_dev *xhci_dev;
 };
 
 enum wcove_typec_func {
@@ -108,6 +111,18 @@ enum wcove_typec_role {
 static guid_t guid = GUID_INIT(0x482383f0, 0x2876, 0x4e49,
 			       0x86, 0x85, 0xdb, 0x66, 0x21, 0x1a, 0xf0, 0x37);
 
+static int wcove_access_xhci(struct wcove_typec *wcove, bool enable)
+{
+	if (wcove->xhci_dev) {
+		if (enable) {
+			pm_runtime_get_sync(&wcove->xhci_dev->dev);
+		} else {
+			pm_runtime_put(&wcove->xhci_dev->dev);
+		}
+	}
+	return 0;
+}
+
 static int wcove_typec_func(struct wcove_typec *wcove,
 			    enum wcove_typec_func func, int param)
 {
@@ -205,7 +220,9 @@ static irqreturn_t wcove_typec_irq(int irq, void *data)
 				 WCOVE_ORIENTATION_NORMAL);
 
 		/* This makes sure the device controller is disconnected */
+                wcove_access_xhci(wcove, true);
 		wcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_HOST);
+                wcove_access_xhci(wcove, false);
 
 		/* Port to default role */
 		typec_set_data_role(wcove->port, TYPEC_DEVICE);
@@ -257,11 +274,15 @@ static irqreturn_t wcove_typec_irq(int irq, void *data)
 	}
 
 	if (role == TYPEC_SINK) {
+                wcove_access_xhci(wcove, true);
 		wcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_DEVICE);
+                wcove_access_xhci(wcove, false);
 		typec_set_data_role(wcove->port, TYPEC_DEVICE);
 		typec_set_pwr_role(wcove->port, TYPEC_SINK);
 	} else {
+                wcove_access_xhci(wcove, true);
 		wcove_typec_func(wcove, WCOVE_FUNC_ROLE, WCOVE_ROLE_HOST);
+                wcove_access_xhci(wcove, false);
 		typec_set_pwr_role(wcove->port, TYPEC_SOURCE);
 		typec_set_data_role(wcove->port, TYPEC_HOST);
 	}
@@ -342,6 +363,8 @@ static int wcove_typec_probe(struct platform_device *pdev)
 	regmap_write(wcove->regmap, USBC_IRQMASK2, val & ~USBC_IRQMASK2_ALL);
 
 	platform_set_drvdata(pdev, wcove);
+
+	wcove->xhci_dev = pci_get_class(PCI_CLASS_SERIAL_USB_XHCI, NULL);
 	return 0;
 }
 
-- 
1.9.1

