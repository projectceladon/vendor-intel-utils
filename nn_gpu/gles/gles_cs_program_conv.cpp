#include "gles_cs_program_manager.h"

namespace android {
namespace hardware {
namespace neuralnetworks {
namespace V1_0 {
namespace implementation {

static const char toChn4[] =
"layout(binding = 0) readonly buffer Input0{\n"
"    float data[];\n"
"} src;\n"
"layout(binding = 1) writeonly buffer Output{\n"
"    float data[];\n"
"} dst;\n"
"layout(local_size_x = LOCAL_SZ_X, local_size_y = 1, local_size_z = 1) in;\n"
"uniform uint numItems;\n"
"void main()\n"
"{\n"
"    int id = int(gl_WorkGroupID.x * gl_WorkGroupSize.x) * FETCH_PER_WI + int(gl_LocalInvocationID.x);\n"
"    for (int i = 0; i < FETCH_PER_WI && uint(id) < numItems; i++)\n"
"    {\n"
"        int out_id = id / 3 * 4 + id % 3;\n"
"        dst.data[out_id] = src.data[id];\n"
"        id += int(gl_WorkGroupSize.x);\n"
"    }\n"
"}\n"
;

static const char gemmShader4_4_chn3[] =
"#if defined(ACTIVATION_RELU)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(999999999.0))\n"
"#elif defined(ACTIVATION_RELU1)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(-1.0), vec4(1.0))\n"
"#elif defined(ACTIVATION_RELU6)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(6.0))\n"
"#else\n"
"#define ACTIVATION_FUNCTION(x)  (x)\n"
"#endif\n"
"layout(binding = 0) readonly buffer Input0{\n"
"    float data[];\n"
"} src0;\n"
"layout(binding = 1) readonly buffer Input1 {\n"
"    vec4 data[];\n"
"} bias;\n"
"layout(binding = 2) readonly buffer Input3{\n"
"    float data[];\n"
"} src1;\n"
"layout(binding = 3) writeonly buffer Output{\n"
"    vec4 data[];\n"
"} out0;\n"
"layout(local_size_x = LOCAL_SZ_X, local_size_y = LOCAL_SZ_Y, local_size_z = LOCAL_SZ_Z) in;\n"
"#define VEC_SIZE 4\n"
"#define BLOCK_H 4\n"
"#define BLOCK_W 4\n"
"#define K_STRIDE 4\n"
"#define TAIL_K (K % K_STRIDE)\n"
"#define LOAD_FLOAT(a)  ""    filter_x = (idx / src0_depth) % FILTER_W;  ""    filter_y = (idx / src0_depth) / FILTER_W;  ""    src0_x = org_x + filter_x;  ""    src0_y = org_y + filter_y;  ""    src0_z = idx % src0_depth;  ""    idx++;  ""    if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)  ""    {  ""      a = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];  ""    }\n"
"#define A_ROW1_B_COL4(y, a, ax, ay, az, aw, dotx, doty, dotz, dotw)  ""            dst_x = (out_y + y) % OUT_W;  ""            dst_y = (out_y + y) / OUT_W;  ""            org_y = dst_y * STRIDE_H - PAD_H; ""            org_x = dst_x * STRIDE_W - PAD_W; ""            idx = i; ""            LOAD_FLOAT(ax);  ""            LOAD_FLOAT(ay);  ""            LOAD_FLOAT(az);  ""            LOAD_FLOAT(aw);  ""            dotx += dot(bcol0, a); ""            doty += dot(bcol1, a); ""            dotz += dot(bcol2, a); ""            dotw += dot(bcol3, a);\n"
"#define A_ROW1_B_COL4_TAIL1(y, a, ax, ay, az, aw, dotx, doty, dotz, dotw)  ""            dst_x = (out_y + y) % OUT_W;  ""            dst_y = (out_y + y) / OUT_W;  ""            org_y = dst_y * STRIDE_H - PAD_H; ""            org_x = dst_x * STRIDE_W - PAD_W; ""            idx = i; ""            LOAD_FLOAT(ax);  ""            dotx += dot(bcol0, a); ""            doty += dot(bcol1, a); ""            dotz += dot(bcol2, a); ""            dotw += dot(bcol3, a);\n"
"#define A_ROW1_B_COL4_TAIL2(y, a, ax, ay, az, aw, dotx, doty, dotz, dotw)  ""            dst_x = (out_y + y) % OUT_W;  ""            dst_y = (out_y + y) / OUT_W;  ""            org_y = dst_y * STRIDE_H - PAD_H; ""            org_x = dst_x * STRIDE_W - PAD_W; ""            idx = i; ""            LOAD_FLOAT(ax);  ""            LOAD_FLOAT(ay);  ""            dotx += dot(bcol0, a); ""            doty += dot(bcol1, a); ""            dotz += dot(bcol2, a); ""            dotw += dot(bcol3, a);\n"
"#define A_ROW1_B_COL4_TAIL3(y, a, ax, ay, az, aw, dotx, doty, dotz, dotw)  ""            dst_x = (out_y + y) % OUT_W;  ""            dst_y = (out_y + y) / OUT_W;  ""            org_y = dst_y * STRIDE_H - PAD_H; ""            org_x = dst_x * STRIDE_W - PAD_W; ""            idx = i; ""            LOAD_FLOAT(ax);  ""            LOAD_FLOAT(ay);  ""            LOAD_FLOAT(az);  ""            dotx += dot(bcol0, a); ""            doty += dot(bcol1, a); ""            dotz += dot(bcol2, a); ""            dotw += dot(bcol3, a);\n"
"void main()\n"
"{\n"
"    int gx = int(gl_GlobalInvocationID.x);\n"
"    int gy = int(gl_GlobalInvocationID.y);\n"
"    int gz = int(gl_GlobalInvocationID.z);\n"
"    int out_x = BLOCK_W * gx;\n"
"    int out_y = BLOCK_H * gy;\n"
"    int input_batch_offset  = gz * IN_H * IN_W * CHANNELS;\n"
"    int output_batch_offset = gz * M * N / VEC_SIZE;\n"
"    if (out_x < N && gy < M / BLOCK_H)\n"
"    {\n"
"        int width0 = K;\n"
"        int width1 = N / VEC_SIZE;\n"
"        int src0_depth = CHANNELS;\n"
"        int src1_read0_offset = out_x * width0;\n"
"        vec4 dot0 = vec4(0.f);\n"
"        vec4 dot1 = vec4(0.f);\n"
"        vec4 dot2 = vec4(0.f);\n"
"        vec4 dot3 = vec4(0.f);\n"
"        int i = 0;\n"
"        do\n"
"        {\n"
"            vec4 a0 = vec4(0.f);\n"
"            vec4 a1 = vec4(0.f);\n"
"            vec4 a2 = vec4(0.f);\n"
"            vec4 a3 = vec4(0.f);\n"
"            vec4 bcol0;\n"
"            vec4 bcol1;\n"
"            vec4 bcol2;\n"
"            vec4 bcol3;\n"
"            bcol0.x = src1.data[src1_read0_offset];\n"
"            bcol0.y = src1.data[src1_read0_offset + 1];\n"
"            bcol0.z = src1.data[src1_read0_offset + 2];\n"
"            bcol0.w = src1.data[src1_read0_offset + 3];\n"
"            src1_read0_offset += width0;\n"
"            bcol1.x = src1.data[src1_read0_offset];\n"
"            bcol1.y = src1.data[src1_read0_offset + 1];\n"
"            bcol1.z = src1.data[src1_read0_offset + 2];\n"
"            bcol1.w = src1.data[src1_read0_offset + 3];\n"
"            src1_read0_offset += width0;\n"
"            bcol2.x = src1.data[src1_read0_offset];\n"
"            bcol2.y = src1.data[src1_read0_offset + 1];\n"
"            bcol2.z = src1.data[src1_read0_offset + 2];\n"
"            bcol2.w = src1.data[src1_read0_offset + 3];\n"
"            src1_read0_offset += width0;\n"
"            bcol3.x = src1.data[src1_read0_offset];\n"
"            bcol3.y = src1.data[src1_read0_offset + 1];\n"
"            bcol3.z = src1.data[src1_read0_offset + 2];\n"
"            bcol3.w = src1.data[src1_read0_offset + 3];\n"
"            src1_read0_offset += width0;\n"
"            src1_read0_offset += K_STRIDE - BLOCK_W * width0;\n"
"            int filter_x, filter_y;\n"
"            int src0_x, src0_y, src0_z;\n"
"            int dst_x, dst_y;\n"
"            int org_x, org_y;\n"
"            int idx;\n"
"            A_ROW1_B_COL4(0, a0, a0.x, a0.y, a0.z, a0.w, dot0.x, dot0.y, dot0.z, dot0.w);\n"
"            A_ROW1_B_COL4(1, a1, a1.x, a1.y, a1.z, a1.w, dot1.x, dot1.y, dot1.z, dot1.w);\n"
"            A_ROW1_B_COL4(2, a2, a2.x, a2.y, a2.z, a2.w, dot2.x, dot2.y, dot2.z, dot2.w);\n"
"            A_ROW1_B_COL4(3, a3, a3.x, a3.y, a3.z, a3.w, dot3.x, dot3.y, dot3.z, dot3.w);\n"
"            i += K_STRIDE;\n"
"        }\n"
"        while( i < width0 - TAIL_K);\n"
"#if TAIL_K > 0\n"
"        {\n"
"            vec4 a0 = vec4(0.f);\n"
"            vec4 a1 = vec4(0.f);\n"
"            vec4 a2 = vec4(0.f);\n"
"            vec4 a3 = vec4(0.f);\n"
"            vec4 bcol0 = vec4(0.f);\n"
"            vec4 bcol1 = vec4(0.f);\n"
"            vec4 bcol2 = vec4(0.f);\n"
"            vec4 bcol3 = vec4(0.f);\n"
"            bcol0.x = src1.data[src1_read0_offset];\n"
"#if TAIL_K > 1\n"
"            bcol0.y = src1.data[src1_read0_offset + 1];\n"
"#endif\n"
"#if TAIL_K > 2\n"
"            bcol0.z = src1.data[src1_read0_offset + 2];\n"
"#endif\n"
"            src1_read0_offset += width0;\n"
"            bcol1.x = src1.data[src1_read0_offset];\n"
"#if TAIL_K > 1\n"
"            bcol1.y = src1.data[src1_read0_offset + 1];\n"
"#endif\n"
"#if TAIL_K > 2\n"
"            bcol1.z = src1.data[src1_read0_offset + 2];\n"
"#endif\n"
"            src1_read0_offset += width0;\n"
"            bcol2.x = src1.data[src1_read0_offset];\n"
"#if TAIL_K > 1\n"
"            bcol2.y = src1.data[src1_read0_offset + 1];\n"
"#endif\n"
"#if TAIL_K > 2\n"
"            bcol2.z = src1.data[src1_read0_offset + 2];\n"
"#endif\n"
"            src1_read0_offset += width0;\n"
"            bcol3.x = src1.data[src1_read0_offset];\n"
"#if TAIL_K > 1\n"
"            bcol3.y = src1.data[src1_read0_offset + 1];\n"
"#endif\n"
"#if TAIL_K > 2\n"
"            bcol3.z = src1.data[src1_read0_offset + 2];\n"
"#endif\n"
"            int filter_x, filter_y;\n"
"            int src0_x, src0_y, src0_z;\n"
"            int dst_x, dst_y;\n"
"            int org_x, org_y;\n"
"            int idx;\n"
"            i = width0 - TAIL_K;\n"
"#if TAIL_K == 1\n"
"            A_ROW1_B_COL4_TAIL1(0, a0, a0.x, a0.y, a0.z, a0.w, dot0.x, dot0.y, dot0.z, dot0.w);\n"
"            A_ROW1_B_COL4_TAIL1(1, a1, a1.x, a1.y, a1.z, a1.w, dot1.x, dot1.y, dot1.z, dot1.w);\n"
"            A_ROW1_B_COL4_TAIL1(2, a2, a2.x, a2.y, a2.z, a2.w, dot2.x, dot2.y, dot2.z, dot2.w);\n"
"            A_ROW1_B_COL4_TAIL1(3, a3, a3.x, a3.y, a3.z, a3.w, dot3.x, dot3.y, dot3.z, dot3.w);\n"
"#elif TAIL_K == 2\n"
"            A_ROW1_B_COL4_TAIL2(0, a0, a0.x, a0.y, a0.z, a0.w, dot0.x, dot0.y, dot0.z, dot0.w);\n"
"            A_ROW1_B_COL4_TAIL2(1, a1, a1.x, a1.y, a1.z, a1.w, dot1.x, dot1.y, dot1.z, dot1.w);\n"
"            A_ROW1_B_COL4_TAIL2(2, a2, a2.x, a2.y, a2.z, a2.w, dot2.x, dot2.y, dot2.z, dot2.w);\n"
"            A_ROW1_B_COL4_TAIL2(3, a3, a3.x, a3.y, a3.z, a3.w, dot3.x, dot3.y, dot3.z, dot3.w);\n"
"#else\n"
"            A_ROW1_B_COL4_TAIL3(0, a0, a0.x, a0.y, a0.z, a0.w, dot0.x, dot0.y, dot0.z, dot0.w);\n"
"            A_ROW1_B_COL4_TAIL3(1, a1, a1.x, a1.y, a1.z, a1.w, dot1.x, dot1.y, dot1.z, dot1.w);\n"
"            A_ROW1_B_COL4_TAIL3(2, a2, a2.x, a2.y, a2.z, a2.w, dot2.x, dot2.y, dot2.z, dot2.w);\n"
"            A_ROW1_B_COL4_TAIL3(3, a3, a3.x, a3.y, a3.z, a3.w, dot3.x, dot3.y, dot3.z, dot3.w);\n"
"#endif\n"
"        }\n"
"#endif\n"
"        vec4 bias_val = bias.data[int(gl_GlobalInvocationID.x)];\n"
"        dot0 += bias_val; \n"
"        dot1 += bias_val; \n"
"        dot2 += bias_val; \n"
"        dot3 += bias_val; \n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + gx] = ACTIVATION_FUNCTION(dot0);\n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + gx] = ACTIVATION_FUNCTION(dot1);\n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + gx] = ACTIVATION_FUNCTION(dot2);\n"
"        out0.data[output_batch_offset + (out_y + 3) * width1 + gx] = ACTIVATION_FUNCTION(dot3);\n"
"    }\n"
"}\n"
;

static const char gemmShader4_8_generic[] =
"#if defined(ACTIVATION_RELU)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(999999999.0))\n"
"#elif defined(ACTIVATION_RELU1)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(-1.0), vec4(1.0))\n"
"#elif defined(ACTIVATION_RELU6)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(6.0))\n"
"#else\n"
"#define ACTIVATION_FUNCTION(x)  (x)\n"
"#endif\n"
"layout(binding = 0) readonly buffer Input0{\n"
"    vec4 data[];\n"
"} src0;\n"
"layout(binding = 1) readonly buffer Input1 {\n"
"    vec4 data[];\n"
"} bias;\n"
"layout(binding = 2) readonly buffer Input3{\n"
"    vec4 data[];\n"
"} src1;\n"
"layout(binding = 3) writeonly buffer Output{\n"
"    vec4 data[];\n"
"} out0;\n"
"layout(local_size_x = LOCAL_SZ_X, local_size_y = LOCAL_SZ_Y, local_size_z = LOCAL_SZ_Z) in;\n"
"#define VEC_SIZE 4\n"
"#define BLOCK_H 4\n"
"#define BLOCK_W 8\n"
"void main()\n"
"{\n"
"    int gx = int(gl_GlobalInvocationID.x);\n"
"    int gy = int(gl_GlobalInvocationID.y);\n"
"    int gz = int(gl_GlobalInvocationID.z);\n"
"    int out_x = BLOCK_W * gx;\n"
"    int out_y = BLOCK_H * gy;\n"
"    int input_batch_offset  = gz * IN_H * IN_W * CHANNELS / VEC_SIZE;\n"
"    int output_batch_offset = gz * M * N / VEC_SIZE;\n"
"    if (out_x < N && gy < M / BLOCK_H)\n"
"    {\n"
"        int width0 = K / VEC_SIZE;\n"
"        int width1 = N / VEC_SIZE;\n"
"        int src0_depth = CHANNELS / VEC_SIZE;\n"
"        int src1_read0_offset = out_x * width0;\n"
"        vec4 dot0 = vec4(0.f);\n"
"        vec4 dot1 = vec4(0.f);\n"
"        vec4 dot2 = vec4(0.f);\n"
"        vec4 dot3 = vec4(0.f);\n"
"        vec4 dot01 = vec4(0.f);\n"
"        vec4 dot11 = vec4(0.f);\n"
"        vec4 dot21 = vec4(0.f);\n"
"        vec4 dot31 = vec4(0.f);\n"
"        int i = 0;\n"
"        do\n"
"        {\n"
"            vec4 a0 = vec4(0.f);\n"
"            vec4 a1 = vec4(0.f);\n"
"            vec4 a2 = vec4(0.f);\n"
"            vec4 a3 = vec4(0.f);\n"
"            vec4 brow0  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow1  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow2  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow3  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow01 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow11 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow21 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow31 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            src1_read0_offset += 1 - BLOCK_W * width0;\n"
"            int dst_x = out_y % OUT_W;\n"
"            int dst_y = out_y / OUT_W;\n"
"            int org_y = dst_y * STRIDE_H - PAD_H;\n"
"            int org_x = dst_x * STRIDE_W - PAD_W;\n"
"            int src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            int src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            int src0_z = i % src0_depth;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a0 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot0.x += dot(brow0, a0);\n"
"            dot0.y += dot(brow1, a0);\n"
"            dot0.z += dot(brow2, a0);\n"
"            dot0.w += dot(brow3, a0);\n"
"            dot01.x += dot(brow01, a0);\n"
"            dot01.y += dot(brow11, a0);\n"
"            dot01.z += dot(brow21, a0);\n"
"            dot01.w += dot(brow31, a0);\n"
"            dst_x = (out_y + 1) % OUT_W;\n"
"            dst_y = (out_y + 1) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a1 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot1.x += dot(brow0, a1);\n"
"            dot1.y += dot(brow1, a1);\n"
"            dot1.z += dot(brow2, a1);\n"
"            dot1.w += dot(brow3, a1);\n"
"            dot11.x += dot(brow01, a1);\n"
"            dot11.y += dot(brow11, a1);\n"
"            dot11.z += dot(brow21, a1);\n"
"            dot11.w += dot(brow31, a1);\n"
"            dst_x = (out_y + 2) % OUT_W;\n"
"            dst_y = (out_y + 2) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a2 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot2.x += dot(brow0, a2);\n"
"            dot2.y += dot(brow1, a2);\n"
"            dot2.z += dot(brow2, a2);\n"
"            dot2.w += dot(brow3, a2);\n"
"            dot21.x += dot(brow01, a2);\n"
"            dot21.y += dot(brow11, a2);\n"
"            dot21.z += dot(brow21, a2);\n"
"            dot21.w += dot(brow31, a2);\n"
"            dst_x = (out_y + 3) % OUT_W;\n"
"            dst_y = (out_y + 3) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a3 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot3.x += dot(brow0, a3);\n"
"            dot3.y += dot(brow1, a3);\n"
"            dot3.z += dot(brow2, a3);\n"
"            dot3.w += dot(brow3, a3);\n"
"            dot31.x += dot(brow01, a3);\n"
"            dot31.y += dot(brow11, a3);\n"
"            dot31.z += dot(brow21, a3);\n"
"            dot31.w += dot(brow31, a3);\n"
"            i++;\n"
"        }\n"
"        while( i < width0 );\n"
"        vec4 bias_val = bias.data[2 * int(gl_GlobalInvocationID.x)];\n"
"        dot0 += bias_val; \n"
"        dot1 += bias_val; \n"
"        dot2 += bias_val; \n"
"        dot3 += bias_val; \n"
"        bias_val = bias.data[2 * int(gl_GlobalInvocationID.x) + 1];\n"
"        dot01 += bias_val; \n"
"        dot11 += bias_val; \n"
"        dot21 += bias_val; \n"
"        dot31 += bias_val; \n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + 2 * gx] = ACTIVATION_FUNCTION(dot0);\n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + 2 * gx] = ACTIVATION_FUNCTION(dot1);\n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + 2 * gx] = ACTIVATION_FUNCTION(dot2);\n"
"        out0.data[output_batch_offset + (out_y + 3) * width1 + 2 * gx] = ACTIVATION_FUNCTION(dot3);\n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + 2 * gx + 1] = ACTIVATION_FUNCTION(dot01);\n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + 2 * gx + 1] = ACTIVATION_FUNCTION(dot11);\n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + 2 * gx + 1] = ACTIVATION_FUNCTION(dot21);\n"
"        out0.data[output_batch_offset + (out_y + 3) * width1 + 2 * gx + 1] = ACTIVATION_FUNCTION(dot31);\n"
"    }\n"
"#if TAIL_M > 0\n"
"    else if (out_x < N && out_y < M)\n"
"    {\n"
"        int width0 = K / VEC_SIZE;\n"
"        int width1 = N / VEC_SIZE;\n"
"        int src0_depth = CHANNELS / VEC_SIZE;\n"
"        int src1_read0_offset = out_x * width0;\n"
"        vec4 dot0 = vec4(0.f);\n"
"        vec4 dot01 = vec4(0.f);\n"
"#if TAIL_M > 1\n"
"        vec4 dot1 = vec4(0.f);\n"
"        vec4 dot11 = vec4(0.f);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"        vec4 dot2 = vec4(0.f);\n"
"        vec4 dot21 = vec4(0.f);\n"
"#endif\n"
"        int i = 0;\n"
"        do\n"
"        {\n"
"            vec4 a0 = vec4(0.f);\n"
"#if TAIL_M > 1\n"
"            vec4 a1 = vec4(0.f);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"            vec4 a2 = vec4(0.f);\n"
"#endif\n"
"            vec4 brow0  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow1  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow2  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow3  = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow01 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow11 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow21 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            vec4 brow31 = src1.data[src1_read0_offset]; src1_read0_offset += width0;\n"
"            src1_read0_offset += 1 - BLOCK_W * width0;\n"
"            int dst_x = out_y % OUT_W;\n"
"            int dst_y = out_y / OUT_W;\n"
"            int org_y = dst_y * STRIDE_H - PAD_H;\n"
"            int org_x = dst_x * STRIDE_W - PAD_W;\n"
"            int src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            int src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            int src0_z = i % src0_depth;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a0 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot0.x += dot(brow0, a0);\n"
"            dot0.y += dot(brow1, a0);\n"
"            dot0.z += dot(brow2, a0);\n"
"            dot0.w += dot(brow3, a0);\n"
"            dot01.x += dot(brow01, a0);\n"
"            dot01.y += dot(brow11, a0);\n"
"            dot01.z += dot(brow21, a0);\n"
"            dot01.w += dot(brow31, a0);\n"
"#if TAIL_M > 1\n"
"            dst_x = (out_y + 1) % OUT_W;\n"
"            dst_y = (out_y + 1) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a1 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot1.x += dot(brow0, a1);\n"
"            dot1.y += dot(brow1, a1);\n"
"            dot1.z += dot(brow2, a1);\n"
"            dot1.w += dot(brow3, a1);\n"
"            dot11.x += dot(brow01, a1);\n"
"            dot11.y += dot(brow11, a1);\n"
"            dot11.z += dot(brow21, a1);\n"
"            dot11.w += dot(brow31, a1);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"            dst_x = (out_y + 2) % OUT_W;\n"
"            dst_y = (out_y + 2) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a2 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot2.x += dot(brow0, a2);\n"
"            dot2.y += dot(brow1, a2);\n"
"            dot2.z += dot(brow2, a2);\n"
"            dot2.w += dot(brow3, a2);\n"
"            dot21.x += dot(brow01, a2);\n"
"            dot21.y += dot(brow11, a2);\n"
"            dot21.z += dot(brow21, a2);\n"
"            dot21.w += dot(brow31, a2);\n"
"#endif\n"
"            i++;\n"
"        }\n"
"        while( i < width0 );\n"
"        vec4 bias_val = bias.data[2 * int(gl_GlobalInvocationID.x)];\n"
"        vec4 bias_val2 = bias.data[2 * int(gl_GlobalInvocationID.x) + 1];\n"
"        dot0 += bias_val; \n"
"        dot01 += bias_val2; \n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + 2 * gx] = ACTIVATION_FUNCTION(dot0);\n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + 2 * gx + 1] = ACTIVATION_FUNCTION(dot01);\n"
"#if TAIL_M > 1\n"
"        dot1 += bias_val; \n"
"        dot11 += bias_val2; \n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + gx] = ACTIVATION_FUNCTION(dot1);\n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + 2 * gx + 1] = ACTIVATION_FUNCTION(dot11);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"        dot2 += bias_val; \n"
"        dot21 += bias_val2; \n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + gx] = ACTIVATION_FUNCTION(dot2);\n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + 2 * gx + 1] = ACTIVATION_FUNCTION(dot21);\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
;
    
static const char gemmShader4_4_generic[] =
"#if defined(ACTIVATION_RELU)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(999999999.0))\n"
"#elif defined(ACTIVATION_RELU1)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(-1.0), vec4(1.0))\n"
"#elif defined(ACTIVATION_RELU6)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(6.0))\n"
"#else\n"
"#define ACTIVATION_FUNCTION(x)  (x)\n"
"#endif\n"
"layout(binding = 0) readonly buffer Input0{\n"
"    vec4 data[];\n"
"} src0;\n"
"layout(binding = 1) readonly buffer Input1 {\n"
"    vec4 data[];\n"
"} bias;\n"
"layout(binding = 2) readonly buffer Input3{\n"
"    vec4 data[];\n"
"} src1;\n"
"layout(binding = 3) writeonly buffer Output{\n"
"    vec4 data[];\n"
"} out0;\n"
"layout(local_size_x = LOCAL_SZ_X, local_size_y = LOCAL_SZ_Y, local_size_z = LOCAL_SZ_Z) in;\n"
"#define VEC_SIZE 4\n"
"#define BLOCK_H 4\n"
"#define BLOCK_W 4\n"
"void main()\n"
"{\n"
"    int gx = int(gl_GlobalInvocationID.x);\n"
"    int gy = int(gl_GlobalInvocationID.y);\n"
"    int gz = int(gl_GlobalInvocationID.z);\n"
"    int out_x = BLOCK_W * gx;\n"
"    int out_y = BLOCK_H * gy;\n"
"    int input_batch_offset  = gz * IN_H * IN_W * CHANNELS / VEC_SIZE;\n"
"    int output_batch_offset = gz * M * N / VEC_SIZE;\n"
"    if (out_x < N && gy < M / BLOCK_H)\n"
"    {\n"
"        int width0 = K / VEC_SIZE;\n"
"        int width1 = N / VEC_SIZE;\n"
"        int src0_depth = CHANNELS / VEC_SIZE;\n"
"        int src1_read0_offset = out_x * width0;\n"
"        vec4 dot0 = vec4(0.f);\n"
"        vec4 dot1 = vec4(0.f);\n"
"        vec4 dot2 = vec4(0.f);\n"
"        vec4 dot3 = vec4(0.f);\n"
"        int i = 0;\n"
"        do\n"
"        {\n"
"            vec4 a0 = vec4(0.f);\n"
"            vec4 a1 = vec4(0.f);\n"
"            vec4 a2 = vec4(0.f);\n"
"            vec4 a3 = vec4(0.f);\n"
"            vec4 brow0 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow1 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow2 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow3 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            src1_read0_offset += 1 - BLOCK_W * width0;\n"
"            int dst_x = out_y % OUT_W;\n"
"            int dst_y = out_y / OUT_W;\n"
"            int org_y = dst_y * STRIDE_H - PAD_H;\n"
"            int org_x = dst_x * STRIDE_W - PAD_W;\n"
"            int src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            int src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            int src0_z = i % src0_depth;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a0 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot0.x += dot(brow0, a0);\n"
"            dot0.y += dot(brow1, a0);\n"
"            dot0.z += dot(brow2, a0);\n"
"            dot0.w += dot(brow3, a0);\n"
"            dst_x = (out_y + 1) % OUT_W;\n"
"            dst_y = (out_y + 1) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a1 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot1.x += dot(brow0, a1);\n"
"            dot1.y += dot(brow1, a1);\n"
"            dot1.z += dot(brow2, a1);\n"
"            dot1.w += dot(brow3, a1);\n"
"            dst_x = (out_y + 2) % OUT_W;\n"
"            dst_y = (out_y + 2) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a2 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot2.x += dot(brow0, a2);\n"
"            dot2.y += dot(brow1, a2);\n"
"            dot2.z += dot(brow2, a2);\n"
"            dot2.w += dot(brow3, a2);\n"
"            dst_x = (out_y + 3) % OUT_W;\n"
"            dst_y = (out_y + 3) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a3 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot3.x += dot(brow0, a3);\n"
"            dot3.y += dot(brow1, a3);\n"
"            dot3.z += dot(brow2, a3);\n"
"            dot3.w += dot(brow3, a3);\n"
"            i++;\n"
"        }\n"
"        while( i < width0 );\n"
"        vec4 bias_val = bias.data[int(gl_GlobalInvocationID.x)];\n"
"        dot0 += bias_val; \n"
"        dot1 += bias_val; \n"
"        dot2 += bias_val; \n"
"        dot3 += bias_val; \n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + gx] = ACTIVATION_FUNCTION(dot0);\n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + gx] = ACTIVATION_FUNCTION(dot1);\n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + gx] = ACTIVATION_FUNCTION(dot2);\n"
"        out0.data[output_batch_offset + (out_y + 3) * width1 + gx] = ACTIVATION_FUNCTION(dot3);\n"
"    }\n"
"#if TAIL_M > 0\n"
"    else if (out_x < N && out_y < M)\n"
"    {\n"
"        int width0 = K / VEC_SIZE;\n"
"        int width1 = N / VEC_SIZE;\n"
"        int src0_depth = CHANNELS / VEC_SIZE;\n"
"        int src1_read0_offset = out_x * width0;\n"
"        vec4 dot0 = vec4(0.f);\n"
"#if TAIL_M > 1\n"
"        vec4 dot1 = vec4(0.f);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"        vec4 dot2 = vec4(0.f);\n"
"#endif\n"
"        int i = 0;\n"
"        do\n"
"        {\n"
"            vec4 a0 = vec4(0.f);\n"
"#if TAIL_M > 1\n"
"            vec4 a1 = vec4(0.f);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"            vec4 a2 = vec4(0.f);\n"
"#endif\n"
"            vec4 brow0 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow1 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow2 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow3 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            src1_read0_offset += 1 - BLOCK_W * width0;\n"
"            int dst_x = out_y % OUT_W;\n"
"            int dst_y = out_y / OUT_W;\n"
"            int org_y = dst_y * STRIDE_H - PAD_H;\n"
"            int org_x = dst_x * STRIDE_W - PAD_W;\n"
"            int src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            int src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            int src0_z = i % src0_depth;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a0 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot0.x += dot(brow0, a0);\n"
"            dot0.y += dot(brow1, a0);\n"
"            dot0.z += dot(brow2, a0);\n"
"            dot0.w += dot(brow3, a0);\n"
"#if TAIL_M > 1\n"
"            dst_x = (out_y + 1) % OUT_W;\n"
"            dst_y = (out_y + 1) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a1 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot1.x += dot(brow0, a1);\n"
"            dot1.y += dot(brow1, a1);\n"
"            dot1.z += dot(brow2, a1);\n"
"            dot1.w += dot(brow3, a1);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"            dst_x = (out_y + 2) % OUT_W;\n"
"            dst_y = (out_y + 2) / OUT_W;\n"
"            org_y = dst_y * STRIDE_H - PAD_H;\n"
"            org_x = dst_x * STRIDE_W - PAD_W;\n"
"            src0_x = org_x + (i / src0_depth) % FILTER_W;\n"
"            src0_y = org_y + (i / src0_depth) / FILTER_W;\n"
"            if(src0_y >= 0 && src0_y < IN_H && src0_x >= 0 && src0_x < IN_W)\n"
"            {\n"
"                a2 = src0.data[input_batch_offset + src0_y * (IN_W * src0_depth) + src0_x * src0_depth + src0_z];\n"
"            }\n"
"            dot2.x += dot(brow0, a2);\n"
"            dot2.y += dot(brow1, a2);\n"
"            dot2.z += dot(brow2, a2);\n"
"            dot2.w += dot(brow3, a2);\n"
"#endif\n"
"            i++;\n"
"        }\n"
"        while( i < width0 );\n"
"        vec4 bias_val = bias.data[int(gl_GlobalInvocationID.x)];\n"
"        dot0 += bias_val; \n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + gx] = ACTIVATION_FUNCTION(dot0);\n"
"#if TAIL_M > 1\n"
"        dot1 += bias_val; \n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + gx] = ACTIVATION_FUNCTION(dot1);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"        dot2 += bias_val; \n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + gx] = ACTIVATION_FUNCTION(dot2);\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
;

static const char gemmShader4_4_no_img2col[] =
"#if defined(ACTIVATION_RELU)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(999999999.0))\n"
"#elif defined(ACTIVATION_RELU1)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(-1.0), vec4(1.0))\n"
"#elif defined(ACTIVATION_RELU6)\n"
"#define ACTIVATION_FUNCTION(x)  clamp(x, vec4(0.0), vec4(6.0))\n"
"#else\n"
"#define ACTIVATION_FUNCTION(x)  (x)\n"
"#endif\n"
"layout(binding = 0) readonly buffer Input0{\n"
"    vec4 data[];\n"
"} src0;\n"
"layout(binding = 1) readonly buffer Input1 {\n"
"    vec4 data[];\n"
"} bias;\n"
"layout(binding = 2) readonly buffer Input3{\n"
"    vec4 data[];\n"
"} src1;\n"
"layout(binding = 3) writeonly buffer Output{\n"
"    vec4 data[];\n"
"} out0;\n"
"layout(local_size_x = LOCAL_SZ_X, local_size_y = LOCAL_SZ_Y, local_size_z = LOCAL_SZ_Z) in;\n"
"#define VEC_SIZE 4\n"
"#define BLOCK_H 4\n"
"#define BLOCK_W 4\n"
"void main()\n"
"{\n"
"    int x = int(gl_GlobalInvocationID.x);\n"
"    int y = int(gl_GlobalInvocationID.y);\n"
"    int gz = int(gl_GlobalInvocationID.z);\n"
"    int out_x = BLOCK_W * int(gl_GlobalInvocationID.x);\n"
"    int out_y = BLOCK_H * int(gl_GlobalInvocationID.y);\n"
"    int input_batch_offset  = gz * IN_H * IN_W * CHANNELS / VEC_SIZE;\n"
"    int output_batch_offset = gz * M * N / VEC_SIZE;\n"
"    if (out_x < N && y < M / BLOCK_H)\n"
"    {\n"
"        int width0 = K / VEC_SIZE;\n"
"        int width1 = N / VEC_SIZE;\n"
"        int src0_read0_offset = input_batch_offset + BLOCK_H * int(gl_GlobalInvocationID.y) * width0;\n"
"        int src1_read0_offset = BLOCK_W * int(gl_GlobalInvocationID.x) * width0;\n"
"        vec4 dot0 = vec4(0.f);\n"
"        vec4 dot1 = vec4(0.f);\n"
"        vec4 dot2 = vec4(0.f);\n"
"        vec4 dot3 = vec4(0.f);\n"
"        int i = 0;\n"
"        do\n"
"        {\n"
"            vec4 brow0 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow1 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow2 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow3 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            src1_read0_offset += 1 - BLOCK_W * width0;\n"
"            vec4 a0 = src0.data[src0_read0_offset + i + 0 * width0];\n"
"            dot0.x += dot(brow0, a0);\n"
"            dot0.y += dot(brow1, a0);\n"
"            dot0.z += dot(brow2, a0);\n"
"            dot0.w += dot(brow3, a0);\n"
"            vec4 a1 = src0.data[src0_read0_offset + i + 1 * width0];\n"
"            dot1.x += dot(brow0, a1);\n"
"            dot1.y += dot(brow1, a1);\n"
"            dot1.z += dot(brow2, a1);\n"
"            dot1.w += dot(brow3, a1);\n"
"            vec4 a2 = src0.data[src0_read0_offset + i + 2 * width0];\n"
"            dot2.x += dot(brow0, a2);\n"
"            dot2.y += dot(brow1, a2);\n"
"            dot2.z += dot(brow2, a2);\n"
"            dot2.w += dot(brow3, a2);\n"
"            vec4 a3 = src0.data[src0_read0_offset + i + 3 * width0];\n"
"            dot3.x += dot(brow0, a3);\n"
"            dot3.y += dot(brow1, a3);\n"
"            dot3.z += dot(brow2, a3);\n"
"            dot3.w += dot(brow3, a3);\n"
"            i++;\n"
"        }\n"
"        while( i < width0 );\n"
"        vec4 bias_val = bias.data[int(gl_GlobalInvocationID.x)];\n"
"        dot0 += bias_val; \n"
"        dot1 += bias_val; \n"
"        dot2 += bias_val; \n"
"        dot3 += bias_val; \n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + int(gl_GlobalInvocationID.x)] = ACTIVATION_FUNCTION(dot0);\n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + int(gl_GlobalInvocationID.x)] = ACTIVATION_FUNCTION(dot1);\n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + int(gl_GlobalInvocationID.x)] = ACTIVATION_FUNCTION(dot2);\n"
"        out0.data[output_batch_offset + (out_y + 3) * width1 + int(gl_GlobalInvocationID.x)] = ACTIVATION_FUNCTION(dot3);\n"
"    }\n"
"#if TAIL_M > 0\n"
"    else if (out_x < N && out_y < M)\n"
"    {\n"
"        int width0 = K / VEC_SIZE;\n"
"        int width1 = N / VEC_SIZE;\n"
"        int src0_read0_offset = input_batch_offset + out_y * width0;\n"
"        int src1_read0_offset = out_x * width0;\n"
"        vec4 dot0 = vec4(0.f);\n"
"#if TAIL_M > 1\n"
"        vec4 dot1 = vec4(0.f);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"        vec4 dot2 = vec4(0.f);\n"
"#endif\n"
"        int i = 0;\n"
"        do\n"
"        {\n"
"            vec4 brow0 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow1 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow2 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            vec4 brow3 = src1.data[src1_read0_offset];   src1_read0_offset += width0;\n"
"            src1_read0_offset += 1 - BLOCK_W * width0;\n"
"            vec4 a0 = src0.data[src0_read0_offset + i + 0 * width0];\n"
"            dot0.x += dot(brow0, a0);\n"
"            dot0.y += dot(brow1, a0);\n"
"            dot0.z += dot(brow2, a0);\n"
"            dot0.w += dot(brow3, a0);\n"
"#if TAIL_M > 1\n"
"            vec4 a1 = src0.data[src0_read0_offset + i + 1 * width0];\n"
"            dot1.x += dot(brow0, a1);\n"
"            dot1.y += dot(brow1, a1);\n"
"            dot1.z += dot(brow2, a1);\n"
"            dot1.w += dot(brow3, a1);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"            vec4 a2 = src0.data[src0_read0_offset + i + 2 * width0];\n"
"            dot2.x += dot(brow0, a2);\n"
"            dot2.y += dot(brow1, a2);\n"
"            dot2.z += dot(brow2, a2);\n"
"            dot2.w += dot(brow3, a2);\n"
"#endif\n"
"            i++;\n"
"        }\n"
"        while( i < width0 );\n"
"        vec4 bias_val = bias.data[int(gl_GlobalInvocationID.x)];\n"
"        dot0 += bias_val; \n"
"#if TAIL_M > 1\n"
"        dot1 += bias_val; \n"
"#endif\n"
"#if TAIL_M > 2\n"
"        dot2 += bias_val; \n"
"#endif\n"
"        out0.data[output_batch_offset + (out_y + 0) * width1 + int(gl_GlobalInvocationID.x)] = ACTIVATION_FUNCTION(dot0);\n"
"#if TAIL_M > 1\n"
"        out0.data[output_batch_offset + (out_y + 1) * width1 + int(gl_GlobalInvocationID.x)] = ACTIVATION_FUNCTION(dot1);\n"
"#endif\n"
"#if TAIL_M > 2\n"
"        out0.data[output_batch_offset + (out_y + 2) * width1 + int(gl_GlobalInvocationID.x)] = ACTIVATION_FUNCTION(dot2);\n"
"#endif\n"
"    }\n"
"#endif\n"
"}\n"
;

static const char gemmShader1[] =
"#ifdef ACTIVATION_RELU\n"
"#define ACTIVATION_FUNCTION(x)  ((x) < 0.f ? 0.f : (x))\n"
"#elif defined (ACTIVATION_RELU1)\n"
"#define ACTIVATION_FUNCTION(x)  ((x) > 1.f ? 1.f : (x) < -1.f ? -1.f : (x))\n"
"#elif defined (ACTIVATION_RELU6)\n"
"#define ACTIVATION_FUNCTION(x)  ((x) > 6.f ? 6.f : (x) < 0.f ? 0.f : (x))\n"
"#else\n"
"#define ACTIVATION_FUNCTION(x)  (x)\n"
"#endif\n"
"layout(binding = 0) readonly buffer Input0{\n"
"    vec4 data[];\n"
"} src0;\n"
"layout(binding = 1) readonly buffer Input1 {\n"
"    float data[];\n"
"} bias;\n"
"layout(binding = 2) readonly buffer Input3{\n"
"    vec4 data[];\n"
"} src1;\n"
"layout(binding = 3) writeonly buffer Output{\n"
"    float data[];\n"
"} out0;\n"
"layout(local_size_x = LOCAL_SZ_X, local_size_y = LOCAL_SZ_Y, local_size_z = LOCAL_SZ_Z) in;\n"
"#define VEC_SIZE 4\n"
"void main()\n"
"{\n"
"    int gx = int(gl_GlobalInvocationID.x);\n"
"    int gy = int(gl_GlobalInvocationID.y);\n"
"    int gz = int(gl_GlobalInvocationID.z);\n"
"    float sum = 0.0f;\n"
"    if (gx < N && gy < M && gz < BATCH)\n"
"    {\n"
"        int image_offset  = gz * IN_H * IN_W * CHANNELS / VEC_SIZE;\n"
"        int output_offset = gz * M * N;\n"
"        for (int i = 0; i < K / VEC_SIZE; i++)\n"
"        {\n"
"            sum += dot(src0.data[image_offset + gy * K / VEC_SIZE + i], src1.data[gx * K / VEC_SIZE + i]);\n"
"        }\n"
"        sum += bias.data[gx];\n"
"        out0.data[output_offset + gy * N + gx] = ACTIVATION_FUNCTION(sum);\n"
"    }\n"
"}\n"
;

static const char convShader[] =
"#ifdef ACTIVATION_RELU\n"
"#define ACTIVATION_FUNCTION(x)  ((x) < 0.f ? 0.f : (x))\n"
"#elif defined (ACTIVATION_RELU1)\n"
"#define ACTIVATION_FUNCTION(x)  ((x) > 1.f ? 1.f : (x) < -1.f ? -1.f : (x))\n"
"#elif defined (ACTIVATION_RELU6)\n"
"#define ACTIVATION_FUNCTION(x)  ((x) > 6.f ? 6.f : (x) < 0.f ? 0.f : (x))\n"
"#else\n"
"#define ACTIVATION_FUNCTION(x)  (x)\n"
"#endif\n"
"layout(binding = 0) readonly buffer Input0{\n"
"    float data[];\n"
"} image_data;\n"
"layout(binding = 1) readonly buffer Input1 {\n"
"    float data[];\n"
"} bias;\n"
"layout(binding = 2) readonly buffer Input3{\n"
"    float data[];\n"
"} kernel_data;\n"
"layout(binding = 3) writeonly buffer Output{\n"
"    float data[];\n"
"} convolved_image;\n"
"layout(local_size_x = LOCAL_SZ_X, local_size_y = LOCAL_SZ_Y, local_size_z = LOCAL_SZ_Z) in;\n"
"void main()\n"
"{\n"
"    int gx = int(gl_GlobalInvocationID.x);\n"
"    int gy = int(gl_GlobalInvocationID.y);\n"
"    int gz = int(gl_GlobalInvocationID.z);\n"
"    if(gx < N && gy < M && gz < BATCH)\n"
"    {\n"
"        float sum = 0.0f;\n"
"        int output_y = gy / OUT_W;\n"
"        int output_x = gy % OUT_W;\n"
"        int org_y = output_y * STRIDE_H - PAD_H;\n"
"        int org_x = output_x * STRIDE_W - PAD_W;\n"
"        int kernel_dataPtrFloat = gx * K;\n"
"        int image_offset  = gz * IN_H * IN_W * CHANNELS;\n"
"        int output_offset = gz * M * N;\n"
"        int image_dataPtrFloat = image_offset + (org_y * IN_W + org_x) * CHANNELS;\n"
"        for(int y = 0; y < FILTER_H; y++)\n"
"        {\n"
"            for(int x = 0; x < FILTER_W; x++)\n"
"            {\n"
"                if(org_y + y >= 0 && org_y + y < IN_H && org_x + x >= 0 && org_x + x < IN_W)\n"
"                {\n"
"                    for(int c = 0; c < CHANNELS; c++)\n"
"                    {\n"
"                        sum += image_data.data[image_dataPtrFloat + c] * kernel_data.data[kernel_dataPtrFloat + c];\n"
"                    }\n"
"                }\n"
"                image_dataPtrFloat += CHANNELS;\n"
"                kernel_dataPtrFloat += CHANNELS;\n"
"            }\n"
"            image_dataPtrFloat += IN_W * CHANNELS - CHANNELS * FILTER_W;\n"
"        }\n"
"        int offset = output_offset + gy * N + gx;\n"
"        convolved_image.data[offset] = ACTIVATION_FUNCTION(sum + bias.data[gx]);\n"
"    }\n"
"}\n"
;

void GlesCsProgramManager::getProgNameCONV_2D(const void* progKey, std::string& name)
{
    const GlesCsProgramKeyConv* key = reinterpret_cast<const GlesCsProgramKeyConv*>(progKey);
    ASSERT(key->opType == OperationType::CONV_2D);

    std::stringstream ss;
    if (key->shaderType == CONV_SHADER_TYPE_CHN3_TO_CHN4)
    {
        ss  << "chn3_to_chn4_converter";
    }
    else
    {
        ss  << "optype"   << (int)key->opType << "_"
            << "batch"    << key->convParam.batch << "_"
            << "in"      << key->convParam.inH  << "_"    << key->convParam.inW  << "_" << key->convParam.inC << "_"
            << "out"     << key->convParam.outH << "_"    << key->convParam.outW << "_" << key->convParam.outC << "_"
            << "filter"  << key->convParam.filterH << "_" << key->convParam.filterW << "_"
            << "pad"     << key->convParam.padH    << "_" << key->convParam.padW << "_"
            << "stride"  << key->convParam.strideH << "_" << key->convParam.strideW << "_"
            << "activation" << key->convParam.activation << "_"
            << "bias"  << key->convParam.hasBias << "_"
            << "type"  << key->shaderType << "_"
            << "lsz"   << key->localSizeX << "_" << key->localSizeY  << "_" << key->localSizeZ << "_"
            << "block" << key->blockWidth << "_" << key->blockHeight << "_" << key->blockDepth << "";
    }

    name = ss.str();
}

void GlesCsProgramManager::getShaderSourceCONV_2D(const void* basicKey, std::string& src)
{
    const GlesCsProgramKeyConv* key = reinterpret_cast<const GlesCsProgramKeyConv*>(basicKey);
    ASSERT(key->opType == OperationType::CONV_2D);

    std::stringstream ss;
    if (key->shaderType == CONV_SHADER_TYPE_CHN3_TO_CHN4)
    {
        ss << "#version 320 es\n";
        ss << "#define FETCH_PER_WI " << key->blockWidth << "\n";
        ss << "#define LOCAL_SZ_X " << key->localSizeX << "\n";
    }
    else
    {
        int M = key->convParam.outH * key->convParam.outW;
        int K = key->convParam.filterH * key->convParam.filterW * key->convParam.inC;
        int N = key->convParam.outC;

        ss << "#version 320 es\n";
        ss << "#define LOCAL_SZ_X " << key->localSizeX << "\n";
        ss << "#define LOCAL_SZ_Y " << key->localSizeY << "\n";
        ss << "#define LOCAL_SZ_Z " << key->localSizeZ << "\n";
        ss << "#define IN_H " << key->convParam.inH << "\n";
        ss << "#define IN_W " << key->convParam.inW << "\n";
        ss << "#define OUT_W " << key->convParam.outW << "\n";
        ss << "#define STRIDE_H " << key->convParam.strideH << "\n";
        ss << "#define STRIDE_W " << key->convParam.strideW << "\n";
        ss << "#define PAD_H " << key->convParam.padH << "\n";
        ss << "#define PAD_W " << key->convParam.padW << "\n";
        ss << "#define FILTER_W " << key->convParam.filterW << "\n";
        ss << "#define CHANNELS " << key->convParam.inC << "\n";
        ss << "#define BATCH " << key->convParam.batch << "\n";
        ss << "#define M " << M << "\n";
        ss << "#define K " << K << "\n";
        ss << "#define N " << N << "\n";

        if (key->shaderType == CONV_SHADER_TYPE_BASIC)
        {
            ss << "#define FILTER_H " << key->convParam.filterH << "\n";
        }

        if (key->shaderType == CONV_SHADER_TYPE_GEMM_4_4_NO_IMG2COL ||
            key->shaderType == CONV_SHADER_TYPE_GEMM_4_4_GENERIC ||
            key->shaderType == CONV_SHADER_TYPE_GEMM_4_8_GENERIC)
        {
            ss << "#define TAIL_M " << M % 4 << "\n";
        }

        switch (key->convParam.activation)
        {
            case kRelu6:
                ss << "#define ACTIVATION_RELU6\n";
                break;
            case kRelu1:
                ss << "#define ACTIVATION_RELU1\n";
                break;
            case kRelu:
                ss << "#define ACTIVATION_RELU\n";
                break;
            case kNone:
                break;
            default:
                NOT_REACH_HERE;
                break;
        }
    }

    switch (key->shaderType)
    {
        case CONV_SHADER_TYPE_BASIC:
            ss << convShader;
            break;
        case CONV_SHADER_TYPE_GEMM1:
            ss << gemmShader1;
            break;
        case CONV_SHADER_TYPE_GEMM_4_4_NO_IMG2COL:
            ss << gemmShader4_4_no_img2col;
            break;
        case CONV_SHADER_TYPE_GEMM_4_4_GENERIC:
            ss << gemmShader4_4_generic;
            break;
        case CONV_SHADER_TYPE_GEMM_4_8_GENERIC:
            ss << gemmShader4_8_generic;
            break;
        case CONV_SHADER_TYPE_GEMM_4_4_CHN3:
            ss << gemmShader4_4_chn3;
            break;
        case CONV_SHADER_TYPE_CHN3_TO_CHN4:
            ss << toChn4;
            break;
        default:
            NOT_REACH_HERE;
            break;
    }

    src = ss.str();
}

}  // namespace implementation
}  // namespace V1_0
}  // namespace neuralnetworks
}  // namespace hardware
}  // namespace android
